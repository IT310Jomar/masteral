import {
  require_vue
} from "./chunk-LHRJEHJL.js";
import "./chunk-VM65JGXE.js";
import {
  __commonJS
} from "./chunk-S5KM4IGW.js";

// node_modules/vue3-pdf-app/dist/vue3-pdf-app.umd.js
var require_vue3_pdf_app_umd = __commonJS({
  "node_modules/vue3-pdf-app/dist/vue3-pdf-app.umd.js"(exports, module) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory(require_vue());
      else if (typeof define === "function" && define.amd)
        define([], factory);
      else if (typeof exports === "object")
        exports["vue3-pdf-app"] = factory(require_vue());
      else
        root["vue3-pdf-app"] = factory(root["Vue"]);
    })(typeof self !== "undefined" ? self : exports, function(__WEBPACK_EXTERNAL_MODULE__7203__) {
      return function() {
        var __webpack_modules__ = {
          9662: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var isCallable = __webpack_require__2(614);
            var tryToString = __webpack_require__2(6330);
            var $TypeError = TypeError;
            module2.exports = function(argument) {
              if (isCallable(argument))
                return argument;
              throw $TypeError(tryToString(argument) + " is not a function");
            };
          },
          6077: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var isCallable = __webpack_require__2(614);
            var $String = String;
            var $TypeError = TypeError;
            module2.exports = function(argument) {
              if (typeof argument == "object" || isCallable(argument))
                return argument;
              throw $TypeError("Can't set " + $String(argument) + " as a prototype");
            };
          },
          5787: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var isPrototypeOf = __webpack_require__2(7976);
            var $TypeError = TypeError;
            module2.exports = function(it, Prototype) {
              if (isPrototypeOf(Prototype, it))
                return it;
              throw $TypeError("Incorrect invocation");
            };
          },
          9670: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var isObject = __webpack_require__2(111);
            var $String = String;
            var $TypeError = TypeError;
            module2.exports = function(argument) {
              if (isObject(argument))
                return argument;
              throw $TypeError($String(argument) + " is not an object");
            };
          },
          3013: function(module2) {
            module2.exports = typeof ArrayBuffer != "undefined" && typeof DataView != "undefined";
          },
          260: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            "use strict";
            var NATIVE_ARRAY_BUFFER = __webpack_require__2(3013);
            var DESCRIPTORS = __webpack_require__2(9781);
            var global = __webpack_require__2(7854);
            var isCallable = __webpack_require__2(614);
            var isObject = __webpack_require__2(111);
            var hasOwn = __webpack_require__2(2597);
            var classof = __webpack_require__2(648);
            var tryToString = __webpack_require__2(6330);
            var createNonEnumerableProperty = __webpack_require__2(8880);
            var defineBuiltIn = __webpack_require__2(8052);
            var defineProperty = __webpack_require__2(3070).f;
            var isPrototypeOf = __webpack_require__2(7976);
            var getPrototypeOf = __webpack_require__2(9518);
            var setPrototypeOf = __webpack_require__2(7674);
            var wellKnownSymbol = __webpack_require__2(5112);
            var uid = __webpack_require__2(9711);
            var InternalStateModule = __webpack_require__2(9909);
            var enforceInternalState = InternalStateModule.enforce;
            var getInternalState = InternalStateModule.get;
            var Int8Array2 = global.Int8Array;
            var Int8ArrayPrototype = Int8Array2 && Int8Array2.prototype;
            var Uint8ClampedArray2 = global.Uint8ClampedArray;
            var Uint8ClampedArrayPrototype = Uint8ClampedArray2 && Uint8ClampedArray2.prototype;
            var TypedArray = Int8Array2 && getPrototypeOf(Int8Array2);
            var TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);
            var ObjectPrototype = Object.prototype;
            var TypeError2 = global.TypeError;
            var TO_STRING_TAG = wellKnownSymbol("toStringTag");
            var TYPED_ARRAY_TAG = uid("TYPED_ARRAY_TAG");
            var TYPED_ARRAY_CONSTRUCTOR = "TypedArrayConstructor";
            var NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf && classof(global.opera) !== "Opera";
            var TYPED_ARRAY_TAG_REQUIRED = false;
            var NAME, Constructor, Prototype;
            var TypedArrayConstructorsList = {
              Int8Array: 1,
              Uint8Array: 1,
              Uint8ClampedArray: 1,
              Int16Array: 2,
              Uint16Array: 2,
              Int32Array: 4,
              Uint32Array: 4,
              Float32Array: 4,
              Float64Array: 8
            };
            var BigIntArrayConstructorsList = {
              BigInt64Array: 8,
              BigUint64Array: 8
            };
            var isView = function isView2(it) {
              if (!isObject(it))
                return false;
              var klass = classof(it);
              return klass === "DataView" || hasOwn(TypedArrayConstructorsList, klass) || hasOwn(BigIntArrayConstructorsList, klass);
            };
            var getTypedArrayConstructor = function(it) {
              var proto = getPrototypeOf(it);
              if (!isObject(proto))
                return;
              var state = getInternalState(proto);
              return state && hasOwn(state, TYPED_ARRAY_CONSTRUCTOR) ? state[TYPED_ARRAY_CONSTRUCTOR] : getTypedArrayConstructor(proto);
            };
            var isTypedArray = function(it) {
              if (!isObject(it))
                return false;
              var klass = classof(it);
              return hasOwn(TypedArrayConstructorsList, klass) || hasOwn(BigIntArrayConstructorsList, klass);
            };
            var aTypedArray = function(it) {
              if (isTypedArray(it))
                return it;
              throw TypeError2("Target is not a typed array");
            };
            var aTypedArrayConstructor = function(C) {
              if (isCallable(C) && (!setPrototypeOf || isPrototypeOf(TypedArray, C)))
                return C;
              throw TypeError2(tryToString(C) + " is not a typed array constructor");
            };
            var exportTypedArrayMethod = function(KEY, property, forced, options) {
              if (!DESCRIPTORS)
                return;
              if (forced)
                for (var ARRAY in TypedArrayConstructorsList) {
                  var TypedArrayConstructor = global[ARRAY];
                  if (TypedArrayConstructor && hasOwn(TypedArrayConstructor.prototype, KEY))
                    try {
                      delete TypedArrayConstructor.prototype[KEY];
                    } catch (error) {
                      try {
                        TypedArrayConstructor.prototype[KEY] = property;
                      } catch (error2) {
                      }
                    }
                }
              if (!TypedArrayPrototype[KEY] || forced) {
                defineBuiltIn(TypedArrayPrototype, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property, options);
              }
            };
            var exportTypedArrayStaticMethod = function(KEY, property, forced) {
              var ARRAY, TypedArrayConstructor;
              if (!DESCRIPTORS)
                return;
              if (setPrototypeOf) {
                if (forced)
                  for (ARRAY in TypedArrayConstructorsList) {
                    TypedArrayConstructor = global[ARRAY];
                    if (TypedArrayConstructor && hasOwn(TypedArrayConstructor, KEY))
                      try {
                        delete TypedArrayConstructor[KEY];
                      } catch (error) {
                      }
                  }
                if (!TypedArray[KEY] || forced) {
                  try {
                    return defineBuiltIn(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && TypedArray[KEY] || property);
                  } catch (error) {
                  }
                } else
                  return;
              }
              for (ARRAY in TypedArrayConstructorsList) {
                TypedArrayConstructor = global[ARRAY];
                if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
                  defineBuiltIn(TypedArrayConstructor, KEY, property);
                }
              }
            };
            for (NAME in TypedArrayConstructorsList) {
              Constructor = global[NAME];
              Prototype = Constructor && Constructor.prototype;
              if (Prototype)
                enforceInternalState(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
              else
                NATIVE_ARRAY_BUFFER_VIEWS = false;
            }
            for (NAME in BigIntArrayConstructorsList) {
              Constructor = global[NAME];
              Prototype = Constructor && Constructor.prototype;
              if (Prototype)
                enforceInternalState(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
            }
            if (!NATIVE_ARRAY_BUFFER_VIEWS || !isCallable(TypedArray) || TypedArray === Function.prototype) {
              TypedArray = function TypedArray2() {
                throw TypeError2("Incorrect invocation");
              };
              if (NATIVE_ARRAY_BUFFER_VIEWS)
                for (NAME in TypedArrayConstructorsList) {
                  if (global[NAME])
                    setPrototypeOf(global[NAME], TypedArray);
                }
            }
            if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {
              TypedArrayPrototype = TypedArray.prototype;
              if (NATIVE_ARRAY_BUFFER_VIEWS)
                for (NAME in TypedArrayConstructorsList) {
                  if (global[NAME])
                    setPrototypeOf(global[NAME].prototype, TypedArrayPrototype);
                }
            }
            if (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
              setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
            }
            if (DESCRIPTORS && !hasOwn(TypedArrayPrototype, TO_STRING_TAG)) {
              TYPED_ARRAY_TAG_REQUIRED = true;
              defineProperty(TypedArrayPrototype, TO_STRING_TAG, { get: function() {
                return isObject(this) ? this[TYPED_ARRAY_TAG] : void 0;
              } });
              for (NAME in TypedArrayConstructorsList)
                if (global[NAME]) {
                  createNonEnumerableProperty(global[NAME], TYPED_ARRAY_TAG, NAME);
                }
            }
            module2.exports = {
              NATIVE_ARRAY_BUFFER_VIEWS,
              TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQUIRED && TYPED_ARRAY_TAG,
              aTypedArray,
              aTypedArrayConstructor,
              exportTypedArrayMethod,
              exportTypedArrayStaticMethod,
              getTypedArrayConstructor,
              isView,
              isTypedArray,
              TypedArray,
              TypedArrayPrototype
            };
          },
          1318: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var toIndexedObject = __webpack_require__2(5656);
            var toAbsoluteIndex = __webpack_require__2(1400);
            var lengthOfArrayLike = __webpack_require__2(6244);
            var createMethod = function(IS_INCLUDES) {
              return function($this, el, fromIndex) {
                var O = toIndexedObject($this);
                var length = lengthOfArrayLike(O);
                var index = toAbsoluteIndex(fromIndex, length);
                var value;
                if (IS_INCLUDES && el != el)
                  while (length > index) {
                    value = O[index++];
                    if (value != value)
                      return true;
                  }
                else
                  for (; length > index; index++) {
                    if ((IS_INCLUDES || index in O) && O[index] === el)
                      return IS_INCLUDES || index || 0;
                  }
                return !IS_INCLUDES && -1;
              };
            };
            module2.exports = {
              includes: createMethod(true),
              indexOf: createMethod(false)
            };
          },
          9671: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var bind = __webpack_require__2(9974);
            var IndexedObject = __webpack_require__2(8361);
            var toObject = __webpack_require__2(7908);
            var lengthOfArrayLike = __webpack_require__2(6244);
            var createMethod = function(TYPE) {
              var IS_FIND_LAST_INDEX = TYPE == 1;
              return function($this, callbackfn, that) {
                var O = toObject($this);
                var self2 = IndexedObject(O);
                var boundFunction = bind(callbackfn, that);
                var index = lengthOfArrayLike(self2);
                var value, result;
                while (index-- > 0) {
                  value = self2[index];
                  result = boundFunction(value, index, O);
                  if (result)
                    switch (TYPE) {
                      case 0:
                        return value;
                      case 1:
                        return index;
                    }
                }
                return IS_FIND_LAST_INDEX ? -1 : void 0;
              };
            };
            module2.exports = {
              findLast: createMethod(0),
              findLastIndex: createMethod(1)
            };
          },
          3658: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            "use strict";
            var DESCRIPTORS = __webpack_require__2(9781);
            var isArray = __webpack_require__2(3157);
            var $TypeError = TypeError;
            var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
            var SILENT_ON_NON_WRITABLE_LENGTH_SET = DESCRIPTORS && !function() {
              if (this !== void 0)
                return true;
              try {
                Object.defineProperty([], "length", { writable: false }).length = 1;
              } catch (error) {
                return error instanceof TypeError;
              }
            }();
            module2.exports = SILENT_ON_NON_WRITABLE_LENGTH_SET ? function(O, length) {
              if (isArray(O) && !getOwnPropertyDescriptor(O, "length").writable) {
                throw $TypeError("Cannot set read only .length");
              }
              return O.length = length;
            } : function(O, length) {
              return O.length = length;
            };
          },
          4326: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var uncurryThisRaw = __webpack_require__2(84);
            var toString = uncurryThisRaw({}.toString);
            var stringSlice = uncurryThisRaw("".slice);
            module2.exports = function(it) {
              return stringSlice(toString(it), 8, -1);
            };
          },
          648: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var TO_STRING_TAG_SUPPORT = __webpack_require__2(1694);
            var isCallable = __webpack_require__2(614);
            var classofRaw = __webpack_require__2(4326);
            var wellKnownSymbol = __webpack_require__2(5112);
            var TO_STRING_TAG = wellKnownSymbol("toStringTag");
            var $Object = Object;
            var CORRECT_ARGUMENTS = classofRaw(function() {
              return arguments;
            }()) == "Arguments";
            var tryGet = function(it, key) {
              try {
                return it[key];
              } catch (error) {
              }
            };
            module2.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {
              var O, tag, result;
              return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == "Object" && isCallable(O.callee) ? "Arguments" : result;
            };
          },
          9920: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var hasOwn = __webpack_require__2(2597);
            var ownKeys = __webpack_require__2(3887);
            var getOwnPropertyDescriptorModule = __webpack_require__2(1236);
            var definePropertyModule = __webpack_require__2(3070);
            module2.exports = function(target, source, exceptions) {
              var keys = ownKeys(source);
              var defineProperty = definePropertyModule.f;
              var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
              for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
                  defineProperty(target, key, getOwnPropertyDescriptor(source, key));
                }
              }
            };
          },
          8544: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var fails = __webpack_require__2(7293);
            module2.exports = !fails(function() {
              function F() {
              }
              F.prototype.constructor = null;
              return Object.getPrototypeOf(new F()) !== F.prototype;
            });
          },
          8880: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var DESCRIPTORS = __webpack_require__2(9781);
            var definePropertyModule = __webpack_require__2(3070);
            var createPropertyDescriptor = __webpack_require__2(9114);
            module2.exports = DESCRIPTORS ? function(object, key, value) {
              return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
            } : function(object, key, value) {
              object[key] = value;
              return object;
            };
          },
          9114: function(module2) {
            module2.exports = function(bitmap, value) {
              return {
                enumerable: !(bitmap & 1),
                configurable: !(bitmap & 2),
                writable: !(bitmap & 4),
                value
              };
            };
          },
          7045: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var makeBuiltIn = __webpack_require__2(6339);
            var defineProperty = __webpack_require__2(3070);
            module2.exports = function(target, name, descriptor) {
              if (descriptor.get)
                makeBuiltIn(descriptor.get, name, { getter: true });
              if (descriptor.set)
                makeBuiltIn(descriptor.set, name, { setter: true });
              return defineProperty.f(target, name, descriptor);
            };
          },
          8052: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var isCallable = __webpack_require__2(614);
            var definePropertyModule = __webpack_require__2(3070);
            var makeBuiltIn = __webpack_require__2(6339);
            var defineGlobalProperty = __webpack_require__2(3072);
            module2.exports = function(O, key, value, options) {
              if (!options)
                options = {};
              var simple = options.enumerable;
              var name = options.name !== void 0 ? options.name : key;
              if (isCallable(value))
                makeBuiltIn(value, name, options);
              if (options.global) {
                if (simple)
                  O[key] = value;
                else
                  defineGlobalProperty(key, value);
              } else {
                try {
                  if (!options.unsafe)
                    delete O[key];
                  else if (O[key])
                    simple = true;
                } catch (error) {
                }
                if (simple)
                  O[key] = value;
                else
                  definePropertyModule.f(O, key, {
                    value,
                    enumerable: false,
                    configurable: !options.nonConfigurable,
                    writable: !options.nonWritable
                  });
              }
              return O;
            };
          },
          3072: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var global = __webpack_require__2(7854);
            var defineProperty = Object.defineProperty;
            module2.exports = function(key, value) {
              try {
                defineProperty(global, key, { value, configurable: true, writable: true });
              } catch (error) {
                global[key] = value;
              }
              return value;
            };
          },
          5117: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            "use strict";
            var tryToString = __webpack_require__2(6330);
            var $TypeError = TypeError;
            module2.exports = function(O, P) {
              if (!delete O[P])
                throw $TypeError("Cannot delete property " + tryToString(P) + " of " + tryToString(O));
            };
          },
          9781: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var fails = __webpack_require__2(7293);
            module2.exports = !fails(function() {
              return Object.defineProperty({}, 1, { get: function() {
                return 7;
              } })[1] != 7;
            });
          },
          4154: function(module2) {
            var documentAll = typeof document == "object" && document.all;
            var IS_HTMLDDA = typeof documentAll == "undefined" && documentAll !== void 0;
            module2.exports = {
              all: documentAll,
              IS_HTMLDDA
            };
          },
          317: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var global = __webpack_require__2(7854);
            var isObject = __webpack_require__2(111);
            var document2 = global.document;
            var EXISTS = isObject(document2) && isObject(document2.createElement);
            module2.exports = function(it) {
              return EXISTS ? document2.createElement(it) : {};
            };
          },
          7207: function(module2) {
            var $TypeError = TypeError;
            var MAX_SAFE_INTEGER = 9007199254740991;
            module2.exports = function(it) {
              if (it > MAX_SAFE_INTEGER)
                throw $TypeError("Maximum allowed index exceeded");
              return it;
            };
          },
          3678: function(module2) {
            module2.exports = {
              IndexSizeError: { s: "INDEX_SIZE_ERR", c: 1, m: 1 },
              DOMStringSizeError: { s: "DOMSTRING_SIZE_ERR", c: 2, m: 0 },
              HierarchyRequestError: { s: "HIERARCHY_REQUEST_ERR", c: 3, m: 1 },
              WrongDocumentError: { s: "WRONG_DOCUMENT_ERR", c: 4, m: 1 },
              InvalidCharacterError: { s: "INVALID_CHARACTER_ERR", c: 5, m: 1 },
              NoDataAllowedError: { s: "NO_DATA_ALLOWED_ERR", c: 6, m: 0 },
              NoModificationAllowedError: { s: "NO_MODIFICATION_ALLOWED_ERR", c: 7, m: 1 },
              NotFoundError: { s: "NOT_FOUND_ERR", c: 8, m: 1 },
              NotSupportedError: { s: "NOT_SUPPORTED_ERR", c: 9, m: 1 },
              InUseAttributeError: { s: "INUSE_ATTRIBUTE_ERR", c: 10, m: 1 },
              InvalidStateError: { s: "INVALID_STATE_ERR", c: 11, m: 1 },
              SyntaxError: { s: "SYNTAX_ERR", c: 12, m: 1 },
              InvalidModificationError: { s: "INVALID_MODIFICATION_ERR", c: 13, m: 1 },
              NamespaceError: { s: "NAMESPACE_ERR", c: 14, m: 1 },
              InvalidAccessError: { s: "INVALID_ACCESS_ERR", c: 15, m: 1 },
              ValidationError: { s: "VALIDATION_ERR", c: 16, m: 0 },
              TypeMismatchError: { s: "TYPE_MISMATCH_ERR", c: 17, m: 1 },
              SecurityError: { s: "SECURITY_ERR", c: 18, m: 1 },
              NetworkError: { s: "NETWORK_ERR", c: 19, m: 1 },
              AbortError: { s: "ABORT_ERR", c: 20, m: 1 },
              URLMismatchError: { s: "URL_MISMATCH_ERR", c: 21, m: 1 },
              QuotaExceededError: { s: "QUOTA_EXCEEDED_ERR", c: 22, m: 1 },
              TimeoutError: { s: "TIMEOUT_ERR", c: 23, m: 1 },
              InvalidNodeTypeError: { s: "INVALID_NODE_TYPE_ERR", c: 24, m: 1 },
              DataCloneError: { s: "DATA_CLONE_ERR", c: 25, m: 1 }
            };
          },
          8113: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var getBuiltIn = __webpack_require__2(5005);
            module2.exports = getBuiltIn("navigator", "userAgent") || "";
          },
          7392: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var global = __webpack_require__2(7854);
            var userAgent = __webpack_require__2(8113);
            var process2 = global.process;
            var Deno = global.Deno;
            var versions = process2 && process2.versions || Deno && Deno.version;
            var v8 = versions && versions.v8;
            var match, version2;
            if (v8) {
              match = v8.split(".");
              version2 = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
            }
            if (!version2 && userAgent) {
              match = userAgent.match(/Edge\/(\d+)/);
              if (!match || match[1] >= 74) {
                match = userAgent.match(/Chrome\/(\d+)/);
                if (match)
                  version2 = +match[1];
              }
            }
            module2.exports = version2;
          },
          748: function(module2) {
            module2.exports = [
              "constructor",
              "hasOwnProperty",
              "isPrototypeOf",
              "propertyIsEnumerable",
              "toLocaleString",
              "toString",
              "valueOf"
            ];
          },
          1060: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var uncurryThis = __webpack_require__2(1702);
            var $Error = Error;
            var replace = uncurryThis("".replace);
            var TEST = function(arg) {
              return String($Error(arg).stack);
            }("zxcasd");
            var V8_OR_CHAKRA_STACK_ENTRY = /\n\s*at [^:]*:[^\n]*/;
            var IS_V8_OR_CHAKRA_STACK = V8_OR_CHAKRA_STACK_ENTRY.test(TEST);
            module2.exports = function(stack, dropEntries) {
              if (IS_V8_OR_CHAKRA_STACK && typeof stack == "string" && !$Error.prepareStackTrace) {
                while (dropEntries--)
                  stack = replace(stack, V8_OR_CHAKRA_STACK_ENTRY, "");
              }
              return stack;
            };
          },
          2109: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var global = __webpack_require__2(7854);
            var getOwnPropertyDescriptor = __webpack_require__2(1236).f;
            var createNonEnumerableProperty = __webpack_require__2(8880);
            var defineBuiltIn = __webpack_require__2(8052);
            var defineGlobalProperty = __webpack_require__2(3072);
            var copyConstructorProperties = __webpack_require__2(9920);
            var isForced = __webpack_require__2(4705);
            module2.exports = function(options, source) {
              var TARGET = options.target;
              var GLOBAL = options.global;
              var STATIC = options.stat;
              var FORCED, target, key, targetProperty, sourceProperty, descriptor;
              if (GLOBAL) {
                target = global;
              } else if (STATIC) {
                target = global[TARGET] || defineGlobalProperty(TARGET, {});
              } else {
                target = (global[TARGET] || {}).prototype;
              }
              if (target)
                for (key in source) {
                  sourceProperty = source[key];
                  if (options.dontCallGetSet) {
                    descriptor = getOwnPropertyDescriptor(target, key);
                    targetProperty = descriptor && descriptor.value;
                  } else
                    targetProperty = target[key];
                  FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
                  if (!FORCED && targetProperty !== void 0) {
                    if (typeof sourceProperty == typeof targetProperty)
                      continue;
                    copyConstructorProperties(sourceProperty, targetProperty);
                  }
                  if (options.sham || targetProperty && targetProperty.sham) {
                    createNonEnumerableProperty(sourceProperty, "sham", true);
                  }
                  defineBuiltIn(target, key, sourceProperty, options);
                }
            };
          },
          7293: function(module2) {
            module2.exports = function(exec) {
              try {
                return !!exec();
              } catch (error) {
                return true;
              }
            };
          },
          9974: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var uncurryThis = __webpack_require__2(1702);
            var aCallable = __webpack_require__2(9662);
            var NATIVE_BIND = __webpack_require__2(4374);
            var bind = uncurryThis(uncurryThis.bind);
            module2.exports = function(fn, that) {
              aCallable(fn);
              return that === void 0 ? fn : NATIVE_BIND ? bind(fn, that) : function() {
                return fn.apply(that, arguments);
              };
            };
          },
          4374: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var fails = __webpack_require__2(7293);
            module2.exports = !fails(function() {
              var test = function() {
              }.bind();
              return typeof test != "function" || test.hasOwnProperty("prototype");
            });
          },
          6916: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var NATIVE_BIND = __webpack_require__2(4374);
            var call = Function.prototype.call;
            module2.exports = NATIVE_BIND ? call.bind(call) : function() {
              return call.apply(call, arguments);
            };
          },
          6530: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var DESCRIPTORS = __webpack_require__2(9781);
            var hasOwn = __webpack_require__2(2597);
            var FunctionPrototype = Function.prototype;
            var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;
            var EXISTS = hasOwn(FunctionPrototype, "name");
            var PROPER = EXISTS && function something() {
            }.name === "something";
            var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, "name").configurable);
            module2.exports = {
              EXISTS,
              PROPER,
              CONFIGURABLE
            };
          },
          84: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var NATIVE_BIND = __webpack_require__2(4374);
            var FunctionPrototype = Function.prototype;
            var call = FunctionPrototype.call;
            var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);
            module2.exports = NATIVE_BIND ? uncurryThisWithBind : function(fn) {
              return function() {
                return call.apply(fn, arguments);
              };
            };
          },
          1702: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var classofRaw = __webpack_require__2(4326);
            var uncurryThisRaw = __webpack_require__2(84);
            module2.exports = function(fn) {
              if (classofRaw(fn) === "Function")
                return uncurryThisRaw(fn);
            };
          },
          5005: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var global = __webpack_require__2(7854);
            var isCallable = __webpack_require__2(614);
            var aFunction = function(argument) {
              return isCallable(argument) ? argument : void 0;
            };
            module2.exports = function(namespace, method) {
              return arguments.length < 2 ? aFunction(global[namespace]) : global[namespace] && global[namespace][method];
            };
          },
          8173: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var aCallable = __webpack_require__2(9662);
            var isNullOrUndefined = __webpack_require__2(8554);
            module2.exports = function(V, P) {
              var func = V[P];
              return isNullOrUndefined(func) ? void 0 : aCallable(func);
            };
          },
          7854: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var check = function(it) {
              return it && it.Math == Math && it;
            };
            module2.exports = check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || check(typeof self == "object" && self) || check(typeof __webpack_require__2.g == "object" && __webpack_require__2.g) || function() {
              return this;
            }() || Function("return this")();
          },
          2597: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var uncurryThis = __webpack_require__2(1702);
            var toObject = __webpack_require__2(7908);
            var hasOwnProperty = uncurryThis({}.hasOwnProperty);
            module2.exports = Object.hasOwn || function hasOwn(it, key) {
              return hasOwnProperty(toObject(it), key);
            };
          },
          3501: function(module2) {
            module2.exports = {};
          },
          4664: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var DESCRIPTORS = __webpack_require__2(9781);
            var fails = __webpack_require__2(7293);
            var createElement = __webpack_require__2(317);
            module2.exports = !DESCRIPTORS && !fails(function() {
              return Object.defineProperty(createElement("div"), "a", {
                get: function() {
                  return 7;
                }
              }).a != 7;
            });
          },
          8361: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var uncurryThis = __webpack_require__2(1702);
            var fails = __webpack_require__2(7293);
            var classof = __webpack_require__2(4326);
            var $Object = Object;
            var split = uncurryThis("".split);
            module2.exports = fails(function() {
              return !$Object("z").propertyIsEnumerable(0);
            }) ? function(it) {
              return classof(it) == "String" ? split(it, "") : $Object(it);
            } : $Object;
          },
          9587: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var isCallable = __webpack_require__2(614);
            var isObject = __webpack_require__2(111);
            var setPrototypeOf = __webpack_require__2(7674);
            module2.exports = function($this, dummy, Wrapper) {
              var NewTarget, NewTargetPrototype;
              if (setPrototypeOf && isCallable(NewTarget = dummy.constructor) && NewTarget !== Wrapper && isObject(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype)
                setPrototypeOf($this, NewTargetPrototype);
              return $this;
            };
          },
          2788: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var uncurryThis = __webpack_require__2(1702);
            var isCallable = __webpack_require__2(614);
            var store = __webpack_require__2(5465);
            var functionToString = uncurryThis(Function.toString);
            if (!isCallable(store.inspectSource)) {
              store.inspectSource = function(it) {
                return functionToString(it);
              };
            }
            module2.exports = store.inspectSource;
          },
          9909: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var NATIVE_WEAK_MAP = __webpack_require__2(4811);
            var global = __webpack_require__2(7854);
            var isObject = __webpack_require__2(111);
            var createNonEnumerableProperty = __webpack_require__2(8880);
            var hasOwn = __webpack_require__2(2597);
            var shared = __webpack_require__2(5465);
            var sharedKey = __webpack_require__2(6200);
            var hiddenKeys = __webpack_require__2(3501);
            var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
            var TypeError2 = global.TypeError;
            var WeakMap2 = global.WeakMap;
            var set, get, has;
            var enforce = function(it) {
              return has(it) ? get(it) : set(it, {});
            };
            var getterFor = function(TYPE) {
              return function(it) {
                var state;
                if (!isObject(it) || (state = get(it)).type !== TYPE) {
                  throw TypeError2("Incompatible receiver, " + TYPE + " required");
                }
                return state;
              };
            };
            if (NATIVE_WEAK_MAP || shared.state) {
              var store = shared.state || (shared.state = new WeakMap2());
              store.get = store.get;
              store.has = store.has;
              store.set = store.set;
              set = function(it, metadata) {
                if (store.has(it))
                  throw TypeError2(OBJECT_ALREADY_INITIALIZED);
                metadata.facade = it;
                store.set(it, metadata);
                return metadata;
              };
              get = function(it) {
                return store.get(it) || {};
              };
              has = function(it) {
                return store.has(it);
              };
            } else {
              var STATE = sharedKey("state");
              hiddenKeys[STATE] = true;
              set = function(it, metadata) {
                if (hasOwn(it, STATE))
                  throw TypeError2(OBJECT_ALREADY_INITIALIZED);
                metadata.facade = it;
                createNonEnumerableProperty(it, STATE, metadata);
                return metadata;
              };
              get = function(it) {
                return hasOwn(it, STATE) ? it[STATE] : {};
              };
              has = function(it) {
                return hasOwn(it, STATE);
              };
            }
            module2.exports = {
              set,
              get,
              has,
              enforce,
              getterFor
            };
          },
          3157: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var classof = __webpack_require__2(4326);
            module2.exports = Array.isArray || function isArray(argument) {
              return classof(argument) == "Array";
            };
          },
          614: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var $documentAll = __webpack_require__2(4154);
            var documentAll = $documentAll.all;
            module2.exports = $documentAll.IS_HTMLDDA ? function(argument) {
              return typeof argument == "function" || argument === documentAll;
            } : function(argument) {
              return typeof argument == "function";
            };
          },
          4705: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var fails = __webpack_require__2(7293);
            var isCallable = __webpack_require__2(614);
            var replacement = /#|\.prototype\./;
            var isForced = function(feature, detection) {
              var value = data[normalize(feature)];
              return value == POLYFILL ? true : value == NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;
            };
            var normalize = isForced.normalize = function(string) {
              return String(string).replace(replacement, ".").toLowerCase();
            };
            var data = isForced.data = {};
            var NATIVE = isForced.NATIVE = "N";
            var POLYFILL = isForced.POLYFILL = "P";
            module2.exports = isForced;
          },
          8554: function(module2) {
            module2.exports = function(it) {
              return it === null || it === void 0;
            };
          },
          111: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var isCallable = __webpack_require__2(614);
            var $documentAll = __webpack_require__2(4154);
            var documentAll = $documentAll.all;
            module2.exports = $documentAll.IS_HTMLDDA ? function(it) {
              return typeof it == "object" ? it !== null : isCallable(it) || it === documentAll;
            } : function(it) {
              return typeof it == "object" ? it !== null : isCallable(it);
            };
          },
          1913: function(module2) {
            module2.exports = false;
          },
          2190: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var getBuiltIn = __webpack_require__2(5005);
            var isCallable = __webpack_require__2(614);
            var isPrototypeOf = __webpack_require__2(7976);
            var USE_SYMBOL_AS_UID = __webpack_require__2(3307);
            var $Object = Object;
            module2.exports = USE_SYMBOL_AS_UID ? function(it) {
              return typeof it == "symbol";
            } : function(it) {
              var $Symbol = getBuiltIn("Symbol");
              return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
            };
          },
          6244: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var toLength = __webpack_require__2(7466);
            module2.exports = function(obj) {
              return toLength(obj.length);
            };
          },
          6339: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var fails = __webpack_require__2(7293);
            var isCallable = __webpack_require__2(614);
            var hasOwn = __webpack_require__2(2597);
            var DESCRIPTORS = __webpack_require__2(9781);
            var CONFIGURABLE_FUNCTION_NAME = __webpack_require__2(6530).CONFIGURABLE;
            var inspectSource = __webpack_require__2(2788);
            var InternalStateModule = __webpack_require__2(9909);
            var enforceInternalState = InternalStateModule.enforce;
            var getInternalState = InternalStateModule.get;
            var defineProperty = Object.defineProperty;
            var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function() {
              return defineProperty(function() {
              }, "length", { value: 8 }).length !== 8;
            });
            var TEMPLATE = String(String).split("String");
            var makeBuiltIn = module2.exports = function(value, name, options) {
              if (String(name).slice(0, 7) === "Symbol(") {
                name = "[" + String(name).replace(/^Symbol\(([^)]*)\)/, "$1") + "]";
              }
              if (options && options.getter)
                name = "get " + name;
              if (options && options.setter)
                name = "set " + name;
              if (!hasOwn(value, "name") || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {
                if (DESCRIPTORS)
                  defineProperty(value, "name", { value: name, configurable: true });
                else
                  value.name = name;
              }
              if (CONFIGURABLE_LENGTH && options && hasOwn(options, "arity") && value.length !== options.arity) {
                defineProperty(value, "length", { value: options.arity });
              }
              try {
                if (options && hasOwn(options, "constructor") && options.constructor) {
                  if (DESCRIPTORS)
                    defineProperty(value, "prototype", { writable: false });
                } else if (value.prototype)
                  value.prototype = void 0;
              } catch (error) {
              }
              var state = enforceInternalState(value);
              if (!hasOwn(state, "source")) {
                state.source = TEMPLATE.join(typeof name == "string" ? name : "");
              }
              return value;
            };
            Function.prototype.toString = makeBuiltIn(function toString() {
              return isCallable(this) && getInternalState(this).source || inspectSource(this);
            }, "toString");
          },
          4758: function(module2) {
            var ceil = Math.ceil;
            var floor = Math.floor;
            module2.exports = Math.trunc || function trunc(x) {
              var n = +x;
              return (n > 0 ? floor : ceil)(n);
            };
          },
          6277: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var toString = __webpack_require__2(1340);
            module2.exports = function(argument, $default) {
              return argument === void 0 ? arguments.length < 2 ? "" : $default : toString(argument);
            };
          },
          3070: function(__unused_webpack_module2, exports2, __webpack_require__2) {
            var DESCRIPTORS = __webpack_require__2(9781);
            var IE8_DOM_DEFINE = __webpack_require__2(4664);
            var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__2(3353);
            var anObject = __webpack_require__2(9670);
            var toPropertyKey = __webpack_require__2(4948);
            var $TypeError = TypeError;
            var $defineProperty = Object.defineProperty;
            var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
            var ENUMERABLE = "enumerable";
            var CONFIGURABLE = "configurable";
            var WRITABLE = "writable";
            exports2.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
              anObject(O);
              P = toPropertyKey(P);
              anObject(Attributes);
              if (typeof O === "function" && P === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
                var current = $getOwnPropertyDescriptor(O, P);
                if (current && current[WRITABLE]) {
                  O[P] = Attributes.value;
                  Attributes = {
                    configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
                    enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
                    writable: false
                  };
                }
              }
              return $defineProperty(O, P, Attributes);
            } : $defineProperty : function defineProperty(O, P, Attributes) {
              anObject(O);
              P = toPropertyKey(P);
              anObject(Attributes);
              if (IE8_DOM_DEFINE)
                try {
                  return $defineProperty(O, P, Attributes);
                } catch (error) {
                }
              if ("get" in Attributes || "set" in Attributes)
                throw $TypeError("Accessors not supported");
              if ("value" in Attributes)
                O[P] = Attributes.value;
              return O;
            };
          },
          1236: function(__unused_webpack_module2, exports2, __webpack_require__2) {
            var DESCRIPTORS = __webpack_require__2(9781);
            var call = __webpack_require__2(6916);
            var propertyIsEnumerableModule = __webpack_require__2(5296);
            var createPropertyDescriptor = __webpack_require__2(9114);
            var toIndexedObject = __webpack_require__2(5656);
            var toPropertyKey = __webpack_require__2(4948);
            var hasOwn = __webpack_require__2(2597);
            var IE8_DOM_DEFINE = __webpack_require__2(4664);
            var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
            exports2.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
              O = toIndexedObject(O);
              P = toPropertyKey(P);
              if (IE8_DOM_DEFINE)
                try {
                  return $getOwnPropertyDescriptor(O, P);
                } catch (error) {
                }
              if (hasOwn(O, P))
                return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
            };
          },
          8006: function(__unused_webpack_module2, exports2, __webpack_require__2) {
            var internalObjectKeys = __webpack_require__2(6324);
            var enumBugKeys = __webpack_require__2(748);
            var hiddenKeys = enumBugKeys.concat("length", "prototype");
            exports2.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
              return internalObjectKeys(O, hiddenKeys);
            };
          },
          5181: function(__unused_webpack_module2, exports2) {
            exports2.f = Object.getOwnPropertySymbols;
          },
          9518: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var hasOwn = __webpack_require__2(2597);
            var isCallable = __webpack_require__2(614);
            var toObject = __webpack_require__2(7908);
            var sharedKey = __webpack_require__2(6200);
            var CORRECT_PROTOTYPE_GETTER = __webpack_require__2(8544);
            var IE_PROTO = sharedKey("IE_PROTO");
            var $Object = Object;
            var ObjectPrototype = $Object.prototype;
            module2.exports = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function(O) {
              var object = toObject(O);
              if (hasOwn(object, IE_PROTO))
                return object[IE_PROTO];
              var constructor = object.constructor;
              if (isCallable(constructor) && object instanceof constructor) {
                return constructor.prototype;
              }
              return object instanceof $Object ? ObjectPrototype : null;
            };
          },
          7976: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var uncurryThis = __webpack_require__2(1702);
            module2.exports = uncurryThis({}.isPrototypeOf);
          },
          6324: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var uncurryThis = __webpack_require__2(1702);
            var hasOwn = __webpack_require__2(2597);
            var toIndexedObject = __webpack_require__2(5656);
            var indexOf = __webpack_require__2(1318).indexOf;
            var hiddenKeys = __webpack_require__2(3501);
            var push = uncurryThis([].push);
            module2.exports = function(object, names) {
              var O = toIndexedObject(object);
              var i = 0;
              var result = [];
              var key;
              for (key in O)
                !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
              while (names.length > i)
                if (hasOwn(O, key = names[i++])) {
                  ~indexOf(result, key) || push(result, key);
                }
              return result;
            };
          },
          5296: function(__unused_webpack_module2, exports2) {
            "use strict";
            var $propertyIsEnumerable = {}.propertyIsEnumerable;
            var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
            var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);
            exports2.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
              var descriptor = getOwnPropertyDescriptor(this, V);
              return !!descriptor && descriptor.enumerable;
            } : $propertyIsEnumerable;
          },
          7674: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var uncurryThis = __webpack_require__2(1702);
            var anObject = __webpack_require__2(9670);
            var aPossiblePrototype = __webpack_require__2(6077);
            module2.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
              var CORRECT_SETTER = false;
              var test = {};
              var setter;
              try {
                setter = uncurryThis(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set);
                setter(test, []);
                CORRECT_SETTER = test instanceof Array;
              } catch (error) {
              }
              return function setPrototypeOf(O, proto) {
                anObject(O);
                aPossiblePrototype(proto);
                if (CORRECT_SETTER)
                  setter(O, proto);
                else
                  O.__proto__ = proto;
                return O;
              };
            }() : void 0);
          },
          2140: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var call = __webpack_require__2(6916);
            var isCallable = __webpack_require__2(614);
            var isObject = __webpack_require__2(111);
            var $TypeError = TypeError;
            module2.exports = function(input, pref) {
              var fn, val;
              if (pref === "string" && isCallable(fn = input.toString) && !isObject(val = call(fn, input)))
                return val;
              if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input)))
                return val;
              if (pref !== "string" && isCallable(fn = input.toString) && !isObject(val = call(fn, input)))
                return val;
              throw $TypeError("Can't convert object to primitive value");
            };
          },
          3887: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var getBuiltIn = __webpack_require__2(5005);
            var uncurryThis = __webpack_require__2(1702);
            var getOwnPropertyNamesModule = __webpack_require__2(8006);
            var getOwnPropertySymbolsModule = __webpack_require__2(5181);
            var anObject = __webpack_require__2(9670);
            var concat = uncurryThis([].concat);
            module2.exports = getBuiltIn("Reflect", "ownKeys") || function ownKeys(it) {
              var keys = getOwnPropertyNamesModule.f(anObject(it));
              var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
              return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
            };
          },
          7066: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            "use strict";
            var anObject = __webpack_require__2(9670);
            module2.exports = function() {
              var that = anObject(this);
              var result = "";
              if (that.hasIndices)
                result += "d";
              if (that.global)
                result += "g";
              if (that.ignoreCase)
                result += "i";
              if (that.multiline)
                result += "m";
              if (that.dotAll)
                result += "s";
              if (that.unicode)
                result += "u";
              if (that.unicodeSets)
                result += "v";
              if (that.sticky)
                result += "y";
              return result;
            };
          },
          4488: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var isNullOrUndefined = __webpack_require__2(8554);
            var $TypeError = TypeError;
            module2.exports = function(it) {
              if (isNullOrUndefined(it))
                throw $TypeError("Can't call method on " + it);
              return it;
            };
          },
          6200: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var shared = __webpack_require__2(2309);
            var uid = __webpack_require__2(9711);
            var keys = shared("keys");
            module2.exports = function(key) {
              return keys[key] || (keys[key] = uid(key));
            };
          },
          5465: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var global = __webpack_require__2(7854);
            var defineGlobalProperty = __webpack_require__2(3072);
            var SHARED = "__core-js_shared__";
            var store = global[SHARED] || defineGlobalProperty(SHARED, {});
            module2.exports = store;
          },
          2309: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var IS_PURE = __webpack_require__2(1913);
            var store = __webpack_require__2(5465);
            (module2.exports = function(key, value) {
              return store[key] || (store[key] = value !== void 0 ? value : {});
            })("versions", []).push({
              version: "3.26.0",
              mode: IS_PURE ? "pure" : "global",
              copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)",
              license: "https://github.com/zloirock/core-js/blob/v3.26.0/LICENSE",
              source: "https://github.com/zloirock/core-js"
            });
          },
          6293: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var V8_VERSION = __webpack_require__2(7392);
            var fails = __webpack_require__2(7293);
            module2.exports = !!Object.getOwnPropertySymbols && !fails(function() {
              var symbol = Symbol();
              return !String(symbol) || !(Object(symbol) instanceof Symbol) || !Symbol.sham && V8_VERSION && V8_VERSION < 41;
            });
          },
          1400: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var toIntegerOrInfinity = __webpack_require__2(9303);
            var max = Math.max;
            var min = Math.min;
            module2.exports = function(index, length) {
              var integer = toIntegerOrInfinity(index);
              return integer < 0 ? max(integer + length, 0) : min(integer, length);
            };
          },
          5656: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var IndexedObject = __webpack_require__2(8361);
            var requireObjectCoercible = __webpack_require__2(4488);
            module2.exports = function(it) {
              return IndexedObject(requireObjectCoercible(it));
            };
          },
          9303: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var trunc = __webpack_require__2(4758);
            module2.exports = function(argument) {
              var number = +argument;
              return number !== number || number === 0 ? 0 : trunc(number);
            };
          },
          7466: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var toIntegerOrInfinity = __webpack_require__2(9303);
            var min = Math.min;
            module2.exports = function(argument) {
              return argument > 0 ? min(toIntegerOrInfinity(argument), 9007199254740991) : 0;
            };
          },
          7908: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var requireObjectCoercible = __webpack_require__2(4488);
            var $Object = Object;
            module2.exports = function(argument) {
              return $Object(requireObjectCoercible(argument));
            };
          },
          7593: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var call = __webpack_require__2(6916);
            var isObject = __webpack_require__2(111);
            var isSymbol = __webpack_require__2(2190);
            var getMethod = __webpack_require__2(8173);
            var ordinaryToPrimitive = __webpack_require__2(2140);
            var wellKnownSymbol = __webpack_require__2(5112);
            var $TypeError = TypeError;
            var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
            module2.exports = function(input, pref) {
              if (!isObject(input) || isSymbol(input))
                return input;
              var exoticToPrim = getMethod(input, TO_PRIMITIVE);
              var result;
              if (exoticToPrim) {
                if (pref === void 0)
                  pref = "default";
                result = call(exoticToPrim, input, pref);
                if (!isObject(result) || isSymbol(result))
                  return result;
                throw $TypeError("Can't convert object to primitive value");
              }
              if (pref === void 0)
                pref = "number";
              return ordinaryToPrimitive(input, pref);
            };
          },
          4948: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var toPrimitive = __webpack_require__2(7593);
            var isSymbol = __webpack_require__2(2190);
            module2.exports = function(argument) {
              var key = toPrimitive(argument, "string");
              return isSymbol(key) ? key : key + "";
            };
          },
          1694: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var wellKnownSymbol = __webpack_require__2(5112);
            var TO_STRING_TAG = wellKnownSymbol("toStringTag");
            var test = {};
            test[TO_STRING_TAG] = "z";
            module2.exports = String(test) === "[object z]";
          },
          1340: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var classof = __webpack_require__2(648);
            var $String = String;
            module2.exports = function(argument) {
              if (classof(argument) === "Symbol")
                throw TypeError("Cannot convert a Symbol value to a string");
              return $String(argument);
            };
          },
          6330: function(module2) {
            var $String = String;
            module2.exports = function(argument) {
              try {
                return $String(argument);
              } catch (error) {
                return "Object";
              }
            };
          },
          9711: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var uncurryThis = __webpack_require__2(1702);
            var id = 0;
            var postfix = Math.random();
            var toString = uncurryThis(1 .toString);
            module2.exports = function(key) {
              return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString(++id + postfix, 36);
            };
          },
          3307: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var NATIVE_SYMBOL = __webpack_require__2(6293);
            module2.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
          },
          3353: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var DESCRIPTORS = __webpack_require__2(9781);
            var fails = __webpack_require__2(7293);
            module2.exports = DESCRIPTORS && fails(function() {
              return Object.defineProperty(function() {
              }, "prototype", {
                value: 42,
                writable: false
              }).prototype != 42;
            });
          },
          4811: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var global = __webpack_require__2(7854);
            var isCallable = __webpack_require__2(614);
            var WeakMap2 = global.WeakMap;
            module2.exports = isCallable(WeakMap2) && /native code/.test(String(WeakMap2));
          },
          5112: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var global = __webpack_require__2(7854);
            var shared = __webpack_require__2(2309);
            var hasOwn = __webpack_require__2(2597);
            var uid = __webpack_require__2(9711);
            var NATIVE_SYMBOL = __webpack_require__2(6293);
            var USE_SYMBOL_AS_UID = __webpack_require__2(3307);
            var WellKnownSymbolsStore = shared("wks");
            var Symbol2 = global.Symbol;
            var symbolFor = Symbol2 && Symbol2["for"];
            var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2 : Symbol2 && Symbol2.withoutSetter || uid;
            module2.exports = function(name) {
              if (!hasOwn(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == "string")) {
                var description = "Symbol." + name;
                if (NATIVE_SYMBOL && hasOwn(Symbol2, name)) {
                  WellKnownSymbolsStore[name] = Symbol2[name];
                } else if (USE_SYMBOL_AS_UID && symbolFor) {
                  WellKnownSymbolsStore[name] = symbolFor(description);
                } else {
                  WellKnownSymbolsStore[name] = createWellKnownSymbol(description);
                }
              }
              return WellKnownSymbolsStore[name];
            };
          },
          7658: function(__unused_webpack_module2, __unused_webpack_exports2, __webpack_require__2) {
            "use strict";
            var $ = __webpack_require__2(2109);
            var toObject = __webpack_require__2(7908);
            var lengthOfArrayLike = __webpack_require__2(6244);
            var setArrayLength = __webpack_require__2(3658);
            var doesNotExceedSafeInteger = __webpack_require__2(7207);
            var fails = __webpack_require__2(7293);
            var INCORRECT_TO_LENGTH = fails(function() {
              return [].push.call({ length: 4294967296 }, 1) !== 4294967297;
            });
            var SILENT_ON_NON_WRITABLE_LENGTH = !function() {
              try {
                Object.defineProperty([], "length", { writable: false }).push();
              } catch (error) {
                return error instanceof TypeError;
              }
            }();
            $({ target: "Array", proto: true, arity: 1, forced: INCORRECT_TO_LENGTH || SILENT_ON_NON_WRITABLE_LENGTH }, {
              push: function push(item) {
                var O = toObject(this);
                var len = lengthOfArrayLike(O);
                var argCount = arguments.length;
                doesNotExceedSafeInteger(len + argCount);
                for (var i = 0; i < argCount; i++) {
                  O[len] = arguments[i];
                  len++;
                }
                setArrayLength(O, len);
                return len;
              }
            });
          },
          541: function(__unused_webpack_module2, __unused_webpack_exports2, __webpack_require__2) {
            "use strict";
            var $ = __webpack_require__2(2109);
            var toObject = __webpack_require__2(7908);
            var lengthOfArrayLike = __webpack_require__2(6244);
            var setArrayLength = __webpack_require__2(3658);
            var deletePropertyOrThrow = __webpack_require__2(5117);
            var doesNotExceedSafeInteger = __webpack_require__2(7207);
            var INCORRECT_RESULT = [].unshift(0) !== 1;
            var SILENT_ON_NON_WRITABLE_LENGTH = !function() {
              try {
                Object.defineProperty([], "length", { writable: false }).unshift();
              } catch (error) {
                return error instanceof TypeError;
              }
            }();
            $({ target: "Array", proto: true, arity: 1, forced: INCORRECT_RESULT || SILENT_ON_NON_WRITABLE_LENGTH }, {
              unshift: function unshift(item) {
                var O = toObject(this);
                var len = lengthOfArrayLike(O);
                var argCount = arguments.length;
                if (argCount) {
                  doesNotExceedSafeInteger(len + argCount);
                  var k = len;
                  while (k--) {
                    var to = k + argCount;
                    if (k in O)
                      O[to] = O[k];
                    else
                      deletePropertyOrThrow(O, to);
                  }
                  for (var j = 0; j < argCount; j++) {
                    O[j] = arguments[j];
                  }
                }
                return setArrayLength(O, len + argCount);
              }
            });
          },
          2087: function(__unused_webpack_module2, __unused_webpack_exports2, __webpack_require__2) {
            var global = __webpack_require__2(7854);
            var DESCRIPTORS = __webpack_require__2(9781);
            var defineBuiltInAccessor = __webpack_require__2(7045);
            var regExpFlags = __webpack_require__2(7066);
            var fails = __webpack_require__2(7293);
            var RegExp2 = global.RegExp;
            var RegExpPrototype = RegExp2.prototype;
            var FORCED = DESCRIPTORS && fails(function() {
              var INDICES_SUPPORT = true;
              try {
                RegExp2(".", "d");
              } catch (error) {
                INDICES_SUPPORT = false;
              }
              var O = {};
              var calls = "";
              var expected = INDICES_SUPPORT ? "dgimsy" : "gimsy";
              var addGetter = function(key2, chr) {
                Object.defineProperty(O, key2, { get: function() {
                  calls += chr;
                  return true;
                } });
              };
              var pairs = {
                dotAll: "s",
                global: "g",
                ignoreCase: "i",
                multiline: "m",
                sticky: "y"
              };
              if (INDICES_SUPPORT)
                pairs.hasIndices = "d";
              for (var key in pairs)
                addGetter(key, pairs[key]);
              var result = Object.getOwnPropertyDescriptor(RegExpPrototype, "flags").get.call(O);
              return result !== expected || calls !== expected;
            });
            if (FORCED)
              defineBuiltInAccessor(RegExpPrototype, "flags", {
                configurable: true,
                get: regExpFlags
              });
          },
          4590: function(__unused_webpack_module2, __unused_webpack_exports2, __webpack_require__2) {
            "use strict";
            var ArrayBufferViewCore = __webpack_require__2(260);
            var $findLastIndex = __webpack_require__2(9671).findLastIndex;
            var aTypedArray = ArrayBufferViewCore.aTypedArray;
            var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
            exportTypedArrayMethod("findLastIndex", function findLastIndex(predicate) {
              return $findLastIndex(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : void 0);
            });
          },
          3408: function(__unused_webpack_module2, __unused_webpack_exports2, __webpack_require__2) {
            "use strict";
            var ArrayBufferViewCore = __webpack_require__2(260);
            var $findLast = __webpack_require__2(9671).findLast;
            var aTypedArray = ArrayBufferViewCore.aTypedArray;
            var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
            exportTypedArrayMethod("findLast", function findLast(predicate) {
              return $findLast(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : void 0);
            });
          },
          2801: function(__unused_webpack_module2, __unused_webpack_exports2, __webpack_require__2) {
            "use strict";
            var $ = __webpack_require__2(2109);
            var global = __webpack_require__2(7854);
            var getBuiltIn = __webpack_require__2(5005);
            var createPropertyDescriptor = __webpack_require__2(9114);
            var defineProperty = __webpack_require__2(3070).f;
            var hasOwn = __webpack_require__2(2597);
            var anInstance = __webpack_require__2(5787);
            var inheritIfRequired = __webpack_require__2(9587);
            var normalizeStringArgument = __webpack_require__2(6277);
            var DOMExceptionConstants = __webpack_require__2(3678);
            var clearErrorStack = __webpack_require__2(1060);
            var DESCRIPTORS = __webpack_require__2(9781);
            var IS_PURE = __webpack_require__2(1913);
            var DOM_EXCEPTION = "DOMException";
            var Error2 = getBuiltIn("Error");
            var NativeDOMException = getBuiltIn(DOM_EXCEPTION);
            var $DOMException = function DOMException2() {
              anInstance(this, DOMExceptionPrototype);
              var argumentsLength = arguments.length;
              var message = normalizeStringArgument(argumentsLength < 1 ? void 0 : arguments[0]);
              var name = normalizeStringArgument(argumentsLength < 2 ? void 0 : arguments[1], "Error");
              var that = new NativeDOMException(message, name);
              var error = Error2(message);
              error.name = DOM_EXCEPTION;
              defineProperty(that, "stack", createPropertyDescriptor(1, clearErrorStack(error.stack, 1)));
              inheritIfRequired(that, this, $DOMException);
              return that;
            };
            var DOMExceptionPrototype = $DOMException.prototype = NativeDOMException.prototype;
            var ERROR_HAS_STACK = "stack" in Error2(DOM_EXCEPTION);
            var DOM_EXCEPTION_HAS_STACK = "stack" in new NativeDOMException(1, 2);
            var descriptor = NativeDOMException && DESCRIPTORS && Object.getOwnPropertyDescriptor(global, DOM_EXCEPTION);
            var BUGGY_DESCRIPTOR = !!descriptor && !(descriptor.writable && descriptor.configurable);
            var FORCED_CONSTRUCTOR = ERROR_HAS_STACK && !BUGGY_DESCRIPTOR && !DOM_EXCEPTION_HAS_STACK;
            $({ global: true, constructor: true, forced: IS_PURE || FORCED_CONSTRUCTOR }, {
              DOMException: FORCED_CONSTRUCTOR ? $DOMException : NativeDOMException
            });
            var PolyfilledDOMException = getBuiltIn(DOM_EXCEPTION);
            var PolyfilledDOMExceptionPrototype = PolyfilledDOMException.prototype;
            if (PolyfilledDOMExceptionPrototype.constructor !== PolyfilledDOMException) {
              if (!IS_PURE) {
                defineProperty(PolyfilledDOMExceptionPrototype, "constructor", createPropertyDescriptor(1, PolyfilledDOMException));
              }
              for (var key in DOMExceptionConstants)
                if (hasOwn(DOMExceptionConstants, key)) {
                  var constant = DOMExceptionConstants[key];
                  var constantName = constant.s;
                  if (!hasOwn(PolyfilledDOMException, constantName)) {
                    defineProperty(PolyfilledDOMException, constantName, createPropertyDescriptor(6, constant.c));
                  }
                }
            }
          },
          1208: function(module2, __webpack_exports__2, __webpack_require__2) {
            "use strict";
            __webpack_require__2.r(__webpack_exports__2);
            var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(8081);
            var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
            var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(3645);
            var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__2.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
            var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default());
            ___CSS_LOADER_EXPORT___.push([module2.id, 'html{content:""}@media (prefers-color-scheme:light){html{content:"light"}}@media (prefers-color-scheme:dark){html{content:"dark"}}', ""]);
            __webpack_exports__2["default"] = ___CSS_LOADER_EXPORT___;
          },
          7503: function(module2, __webpack_exports__2, __webpack_require__2) {
            "use strict";
            __webpack_require__2.r(__webpack_exports__2);
            var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(8081);
            var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
            var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(3645);
            var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__2.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
            var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default());
            ___CSS_LOADER_EXPORT___.push([module2.id, "#sidebarContainer.zero-top[data-v-0d167ef6],#sidebarContent.zero-top[data-v-0d167ef6],#viewerContainer.zero-top[data-v-0d167ef6]{top:0}", ""]);
            __webpack_exports__2["default"] = ___CSS_LOADER_EXPORT___;
          },
          9401: function(module2, __webpack_exports__2, __webpack_require__2) {
            "use strict";
            __webpack_require__2.r(__webpack_exports__2);
            var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(8081);
            var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
            var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(3645);
            var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__2.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
            var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(1667);
            var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = __webpack_require__2.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);
            var ___CSS_LOADER_URL_IMPORT_0___ = new URL(__webpack_require__2(7557), __webpack_require__2.b);
            var ___CSS_LOADER_URL_IMPORT_1___ = new URL(__webpack_require__2(5803), __webpack_require__2.b);
            var ___CSS_LOADER_URL_IMPORT_2___ = new URL(__webpack_require__2(9953), __webpack_require__2.b);
            var ___CSS_LOADER_URL_IMPORT_3___ = new URL(__webpack_require__2(312), __webpack_require__2.b);
            var ___CSS_LOADER_URL_IMPORT_4___ = new URL(__webpack_require__2(5086), __webpack_require__2.b);
            var ___CSS_LOADER_URL_IMPORT_5___ = new URL(__webpack_require__2(8225), __webpack_require__2.b);
            var ___CSS_LOADER_URL_IMPORT_6___ = new URL(__webpack_require__2(3386), __webpack_require__2.b);
            var ___CSS_LOADER_URL_IMPORT_7___ = new URL(__webpack_require__2(8989), __webpack_require__2.b);
            var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default());
            var ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);
            var ___CSS_LOADER_URL_REPLACEMENT_1___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_1___);
            var ___CSS_LOADER_URL_REPLACEMENT_2___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_2___);
            var ___CSS_LOADER_URL_REPLACEMENT_3___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_3___);
            var ___CSS_LOADER_URL_REPLACEMENT_4___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_4___);
            var ___CSS_LOADER_URL_REPLACEMENT_5___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_5___);
            var ___CSS_LOADER_URL_REPLACEMENT_6___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_6___);
            var ___CSS_LOADER_URL_REPLACEMENT_7___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_7___);
            ___CSS_LOADER_EXPORT___.push([module2.id, '.pdf-app .textLayer{position:absolute;left:0;top:0;right:0;bottom:0;overflow:hidden;opacity:.2;line-height:1}.pdf-app .textLayer>span{color:transparent;position:absolute;white-space:pre;cursor:text;transform-origin:0 0}.pdf-app .textLayer .highlight{margin:-1px;padding:1px;background-color:#b400aa;border-radius:4px}.pdf-app .textLayer .highlight.begin{border-radius:4px 0 0 4px}.pdf-app .textLayer .highlight.end{border-radius:0 4px 4px 0}.pdf-app .textLayer .highlight.middle{border-radius:0}.pdf-app .textLayer .highlight.selected{background-color:#006400}.pdf-app .textLayer ::-moz-selection{background:blue}.pdf-app .textLayer ::selection{background:blue}.pdf-app .textLayer .endOfContent{display:block;position:absolute;left:0;top:100%;right:0;bottom:0;z-index:-1;cursor:default;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pdf-app .textLayer .endOfContent.active{top:0}.pdf-app .annotationLayer section{position:absolute}.pdf-app .annotationLayer .buttonWidgetAnnotation.pushButton>a,.pdf-app .annotationLayer .linkAnnotation>a{position:absolute;font-size:1em;top:0;left:0;width:100%;height:100%}.pdf-app .annotationLayer .buttonWidgetAnnotation.pushButton>a:hover,.pdf-app .annotationLayer .linkAnnotation>a:hover{opacity:.2;background:#ff0;box-shadow:0 2px 10px #ff0}.pdf-app .annotationLayer .textAnnotation img{position:absolute;cursor:pointer}.pdf-app .annotationLayer .buttonWidgetAnnotation.checkBox input,.pdf-app .annotationLayer .buttonWidgetAnnotation.radioButton input,.pdf-app .annotationLayer .choiceWidgetAnnotation select,.pdf-app .annotationLayer .textWidgetAnnotation input,.pdf-app .annotationLayer .textWidgetAnnotation textarea{background-color:rgba(0,54,255,.13);border:1px solid transparent;box-sizing:border-box;font-size:9px;height:100%;margin:0;padding:0 3px;vertical-align:top;width:100%}.pdf-app .annotationLayer .choiceWidgetAnnotation select option{padding:0}.pdf-app .annotationLayer .buttonWidgetAnnotation.radioButton input{border-radius:50%}.pdf-app .annotationLayer .textWidgetAnnotation textarea{font:message-box;font-size:9px;resize:none}.pdf-app .annotationLayer .buttonWidgetAnnotation.checkBox input[disabled],.pdf-app .annotationLayer .buttonWidgetAnnotation.radioButton input[disabled],.pdf-app .annotationLayer .choiceWidgetAnnotation select[disabled],.pdf-app .annotationLayer .textWidgetAnnotation input[disabled],.pdf-app .annotationLayer .textWidgetAnnotation textarea[disabled]{background:none;border:1px solid transparent;cursor:not-allowed}.pdf-app .annotationLayer .buttonWidgetAnnotation.checkBox input:hover,.pdf-app .annotationLayer .buttonWidgetAnnotation.radioButton input:hover,.pdf-app .annotationLayer .choiceWidgetAnnotation select:hover,.pdf-app .annotationLayer .textWidgetAnnotation input:hover,.pdf-app .annotationLayer .textWidgetAnnotation textarea:hover{border:1px solid #000}.pdf-app .annotationLayer .choiceWidgetAnnotation select:focus,.pdf-app .annotationLayer .textWidgetAnnotation input:focus,.pdf-app .annotationLayer .textWidgetAnnotation textarea:focus{background:none;border:1px solid transparent}.pdf-app .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after,.pdf-app .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before,.pdf-app .annotationLayer .buttonWidgetAnnotation.radioButton input:checked:before{background-color:#000;content:"";display:block;position:absolute}.pdf-app .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after,.pdf-app .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before{height:80%;left:45%;width:1px}.pdf-app .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before{transform:rotate(45deg)}.pdf-app .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after{transform:rotate(-45deg)}.pdf-app .annotationLayer .buttonWidgetAnnotation.radioButton input:checked:before{border-radius:50%;height:50%;left:30%;top:20%;width:50%}.pdf-app .annotationLayer .textWidgetAnnotation input.comb{font-family:monospace;padding-left:2px;padding-right:0}.pdf-app .annotationLayer .textWidgetAnnotation input.comb:focus{width:115%}.pdf-app .annotationLayer .buttonWidgetAnnotation.checkBox input,.pdf-app .annotationLayer .buttonWidgetAnnotation.radioButton input{-webkit-appearance:none;-moz-appearance:none;appearance:none;padding:0}.pdf-app .annotationLayer .popupWrapper{position:absolute;width:20em}.pdf-app .annotationLayer .popup{position:absolute;z-index:200;max-width:20em;background-color:#ff9;box-shadow:0 2px 5px #888;border-radius:2px;padding:6px;margin-left:5px;cursor:pointer;font:message-box;font-size:9px;word-wrap:break-word}.pdf-app .annotationLayer .popup>*{font-size:9px}.pdf-app .annotationLayer .popup h1{display:inline-block}.pdf-app .annotationLayer .popup span{display:inline-block;margin-left:5px}.pdf-app .annotationLayer .popup p{border-top:1px solid #333;margin-top:2px;padding-top:2px}.pdf-app .annotationLayer .caretAnnotation,.pdf-app .annotationLayer .circleAnnotation svg ellipse,.pdf-app .annotationLayer .fileAttachmentAnnotation,.pdf-app .annotationLayer .freeTextAnnotation,.pdf-app .annotationLayer .highlightAnnotation,.pdf-app .annotationLayer .inkAnnotation svg polyline,.pdf-app .annotationLayer .lineAnnotation svg line,.pdf-app .annotationLayer .polygonAnnotation svg polygon,.pdf-app .annotationLayer .polylineAnnotation svg polyline,.pdf-app .annotationLayer .squareAnnotation svg rect,.pdf-app .annotationLayer .squigglyAnnotation,.pdf-app .annotationLayer .stampAnnotation,.pdf-app .annotationLayer .strikeoutAnnotation,.pdf-app .annotationLayer .underlineAnnotation{cursor:pointer}.pdf-app .pdfViewer .canvasWrapper{overflow:hidden}.pdf-app .pdfViewer .page{direction:ltr;width:816px;height:1056px;margin:1px auto -8px auto;position:relative;overflow:visible;border:9px solid transparent;background-clip:content-box;-o-border-image:url(' + ___CSS_LOADER_URL_REPLACEMENT_0___ + ") 9 9 repeat;border-image:url(" + ___CSS_LOADER_URL_REPLACEMENT_0___ + ") 9 9 repeat;background-color:#fff}.pdf-app .pdfViewer.removePageBorders .page{margin:0 auto 10px auto;border:none}.pdf-app .pdfViewer.singlePageView{display:inline-block}.pdf-app .pdfViewer.singlePageView .page{margin:0;border:none}.pdf-app .pdfViewer.scrollHorizontal,.pdf-app .pdfViewer.scrollWrapped,.pdf-app .spread{margin-left:3.5px;margin-right:3.5px;text-align:center}.pdf-app .pdfViewer.scrollHorizontal,.pdf-app .spread{white-space:nowrap}.pdf-app .pdfViewer.removePageBorders,.pdf-app .pdfViewer.scrollHorizontal .spread,.pdf-app .pdfViewer.scrollWrapped .spread{margin-left:0;margin-right:0}.pdf-app .pdfViewer.scrollHorizontal .page,.pdf-app .pdfViewer.scrollHorizontal .spread,.pdf-app .pdfViewer.scrollWrapped .page,.pdf-app .pdfViewer.scrollWrapped .spread,.pdf-app .spread .page{display:inline-block;vertical-align:middle}.pdf-app .pdfViewer.scrollHorizontal .page,.pdf-app .pdfViewer.scrollWrapped .page,.pdf-app .spread .page{margin-left:-3.5px;margin-right:-3.5px}.pdf-app .pdfViewer.removePageBorders .spread .page,.pdf-app .pdfViewer.removePageBorders.scrollHorizontal .page,.pdf-app .pdfViewer.removePageBorders.scrollWrapped .page{margin-left:5px;margin-right:5px}.pdf-app .pdfViewer .page canvas{margin:0;display:block}.pdf-app .pdfViewer .page canvas[hidden]{display:none}.pdf-app .pdfViewer .page .loadingIcon{position:absolute;display:block;left:0;top:0;right:0;bottom:0;background:url(" + ___CSS_LOADER_URL_REPLACEMENT_1___ + ") 50% no-repeat}.pdf-app .pdfPresentationMode .pdfViewer{margin-left:0;margin-right:0}.pdf-app .pdfPresentationMode .pdfViewer .page,.pdf-app .pdfPresentationMode .pdfViewer .spread{display:block}.pdf-app .pdfPresentationMode .pdfViewer .page,.pdf-app .pdfPresentationMode .pdfViewer.removePageBorders .page{margin-left:auto;margin-right:auto}.pdf-app .pdfPresentationMode:-webkit-full-screen .pdfViewer .page{margin-bottom:100%;border:0}.pdf-app .pdfPresentationMode:fullscreen .pdfViewer .page{margin-bottom:100%;border:0}.pdf-app.dark{--pdf-app-background-color:#1d2636;--pdf-sidebar-content-color:rgba(36,54,78,.5);--pdf-toolbar-sidebar-color:#24364e;--pdf-toolbar-color:#24364e;--pdf-loading-bar-color:#606c88;--pdf-loading-bar-secondary-color:#11ece5;--pdf-find-results-count-color:#d9d9d9;--pdf-find-results-count-font-color:#525252;--pdf-find-message-font-color:#a6b7d0;--pdf-not-found-color:#f66;--pdf-split-toolbar-button-separator-color:#fff;--pdf-toolbar-font-color:#d9d9d9;--pdf-button-hover-font-color:#11ece5;--pdf-button-toggled-color:#606c88;--pdf-horizontal-toolbar-separator-color:#fff;--pdf-input-color:#606c88;--pdf-input-font-color:#d9d9d9;--pdf-find-input-placeholder-font-color:#11ece5;--pdf-thumbnail-selection-ring-color:hsla(0,0%,100%,.15);--pdf-thumbnail-selection-ring-selected-color:hsla(0,0%,100%,.3);--pdf-error-wrapper-color:#f55;--pdf-error-more-info-color:#d9d9d9;--pdf-error-more-info-font-color:#000;--pdf-overlay-container-color:rgba(0,0,0,.2);--pdf-overlay-container-dialog-color:#24364e;--pdf-overlay-container-dialog-font-color:#d9d9d9;--pdf-overlay-container-dialog-separator-color:#fff;--pdf-dialog-button-font-color:#d9d9d9;--pdf-dialog-button-color:#606c88}.pdf-app.light{--pdf-app-background-color:hsla(208,7%,46%,.3);--pdf-sidebar-content-color:hsla(208,7%,46%,.4);--pdf-toolbar-sidebar-color:hsla(208,7%,46%,.7);--pdf-toolbar-color:#6c757d;--pdf-loading-bar-color:#3f4b5b;--pdf-loading-bar-secondary-color:#8dd0ff;--pdf-find-results-count-color:#3f4b5b;--pdf-find-results-count-font-color:hsla(0,0%,100%,.87);--pdf-find-message-font-color:hsla(0,0%,100%,.87);--pdf-not-found-color:brown;--pdf-split-toolbar-button-separator-color:#000;--pdf-toolbar-font-color:hsla(0,0%,100%,.87);--pdf-button-hover-font-color:#8dd0ff;--pdf-button-toggled-color:#3f4b5b;--pdf-horizontal-toolbar-separator-color:#000;--pdf-input-color:#3f4b5b;--pdf-input-font-color:#d9d9d9;--pdf-find-input-placeholder-font-color:#8dd0ff;--pdf-thumbnail-selection-ring-color:hsla(208,7%,46%,.7);--pdf-thumbnail-selection-ring-selected-color:#3f4b5b;--pdf-error-wrapper-color:#f55;--pdf-error-more-info-color:#d9d9d9;--pdf-error-more-info-font-color:#000;--pdf-overlay-container-color:hsla(208,7%,46%,.7);--pdf-overlay-container-dialog-color:#6c757d;--pdf-overlay-container-dialog-font-color:#d9d9d9;--pdf-overlay-container-dialog-separator-color:#000;--pdf-dialog-button-font-color:#d9d9d9;--pdf-dialog-button-color:#3f4b5b}.pdf-app{background-color:#1d2636}.pdf-app #sidebarContent{background-color:rgba(36,54,78,.5)}.pdf-app #toolbarContainer,.pdf-app #toolbarSidebar,.pdf-app .findbar,.pdf-app .secondaryToolbar{background-color:#24364e}.pdf-app #loadingBar .progress{background-color:#606c88}.pdf-app #loadingBar .progress.indeterminate .glimmer{background:repeating-linear-gradient(135deg,transparent,#11ece5 5px,#11ece5 45px,transparent 55px,transparent 95px,transparent 100px)}.pdf-app #findInput::-moz-placeholder{color:#11ece5}.pdf-app #findInput::placeholder{color:#11ece5}.pdf-app .doorHanger:after,.pdf-app .doorHangerRight:after{border-bottom-color:#24364e}.pdf-app #findResultsCount{background-color:#d9d9d9;color:#525252}.pdf-app #findMsg{color:#a6b7d0}.pdf-app #findInput.notFound{background-color:#f66}.pdf-app .splitToolbarButtonSeparator{background-color:#fff}.pdf-app .dropdownToolbarButton,.pdf-app .overlayButton,.pdf-app .secondaryToolbarButton,.pdf-app .toolbarButton,.vue-pdf-app-icon{color:#d9d9d9}.pdf-app .dialog .overlayButton{background-color:#606c88;color:#d9d9d9}.pdf-app .dropdownToolbarButton:hover,.pdf-app .overlayButton,.pdf-app .secondaryToolbarButton:focus,.pdf-app .secondaryToolbarButton:hover,.pdf-app .toolbarButton:focus,.pdf-app .toolbarButton:hover,.vue-pdf-app-icon:hover{color:#11ece5}.pdf-app .dropdownToolbarButton>select{color:#d9d9d9;background:#24364e}.pdf-app .dropdownToolbarButton>select>option{background:#24364e}.pdf-app .horizontalToolbarSeparator,.pdf-app .verticalToolbarSeparator{background-color:#fff}.pdf-app .toolbarField{background-color:#606c88;color:#d9d9d9}.pdf-app .toolbarLabel{color:#d9d9d9}.pdf-app .thumbnail:hover>.thumbnailSelectionRing,.pdf-app a:focus>.thumbnail>.thumbnailSelectionRing{background-color:hsla(0,0%,100%,.15)}.pdf-app .thumbnail.selected>.thumbnailSelectionRing{background-color:hsla(0,0%,100%,.3)}.pdf-app .attachmentsItem>button,.pdf-app .outlineItem>a{color:#d9d9d9}.pdf-app .attachmentsItem>button:hover,.pdf-app .outlineItem>a:hover,.pdf-app .outlineItemToggler:hover,.pdf-app .outlineItemToggler:hover+a,.pdf-app .outlineItemToggler:hover~.outlineItems{background-color:#606c88}.pdf-app #errorWrapper{background-color:#f55}.pdf-app #errorMoreInfo{background-color:#d9d9d9;color:#000}.pdf-app #overlayContainer{background-color:rgba(0,0,0,.2)}.pdf-app #overlayContainer>.container>.dialog{background-color:#24364e;color:#d9d9d9}.pdf-app .dialog .separator{background-color:#fff}.pdf-app .secondaryToolbarButton.toggled,.pdf-app .splitToolbarButton.toggled>.toolbarButton.toggled,.pdf-app .toolbarButton.toggled{background-color:#606c88}.pdf-app.light{background-color:hsla(208,7%,46%,.3)}.pdf-app.light #sidebarContent{background-color:hsla(208,7%,46%,.4)}.pdf-app.light #toolbarSidebar{background-color:hsla(208,7%,46%,.7)}.pdf-app.light #toolbarContainer,.pdf-app.light .findbar,.pdf-app.light .secondaryToolbar{background-color:#6c757d}.pdf-app.light #loadingBar .progress{background-color:#3f4b5b}.pdf-app.light #loadingBar .progress.indeterminate .glimmer{background:repeating-linear-gradient(135deg,transparent,#8dd0ff 5px,#8dd0ff 45px,transparent 55px,transparent 95px,transparent 100px)}.pdf-app.light #findInput::-moz-placeholder{color:#8dd0ff}.pdf-app.light #findInput::placeholder{color:#8dd0ff}.pdf-app.light .doorHanger:after,.pdf-app.light .doorHangerRight:after{border-bottom-color:#6c757d}.pdf-app.light #findResultsCount{background-color:#3f4b5b;color:hsla(0,0%,100%,.87)}.pdf-app.light #findMsg{color:hsla(0,0%,100%,.87)}.pdf-app.light #findInput.notFound{background-color:brown}.pdf-app.light .splitToolbarButtonSeparator{background-color:#000}.light .vue-pdf-app-icon,.pdf-app.light .dropdownToolbarButton,.pdf-app.light .overlayButton,.pdf-app.light .secondaryToolbarButton,.pdf-app.light .toolbarButton{color:hsla(0,0%,100%,.87)}.pdf-app.light .dialog .overlayButton{background-color:#3f4b5b;color:#d9d9d9}.light .vue-pdf-app-icon:hover,.pdf-app.light .dropdownToolbarButton:hover,.pdf-app.light .overlayButton,.pdf-app.light .secondaryToolbarButton:focus,.pdf-app.light .secondaryToolbarButton:hover,.pdf-app.light .toolbarButton:focus,.pdf-app.light .toolbarButton:hover{color:#8dd0ff}.pdf-app.light .dropdownToolbarButton>select{color:hsla(0,0%,100%,.87);background:#6c757d}.pdf-app.light .dropdownToolbarButton>select>option{background:#6c757d}.pdf-app.light .horizontalToolbarSeparator,.pdf-app.light .verticalToolbarSeparator{background-color:#000}.pdf-app.light .toolbarField{background-color:#3f4b5b;color:#d9d9d9}.pdf-app.light .toolbarLabel{color:hsla(0,0%,100%,.87)}.pdf-app.light .thumbnail:hover>.thumbnailSelectionRing,.pdf-app.light a:focus>.thumbnail>.thumbnailSelectionRing{background-color:hsla(208,7%,46%,.7)}.pdf-app.light .thumbnail.selected>.thumbnailSelectionRing{background-color:#3f4b5b}.pdf-app.light .attachmentsItem>button,.pdf-app.light .outlineItem>a{color:hsla(0,0%,100%,.87)}.pdf-app.light .attachmentsItem>button:hover,.pdf-app.light .outlineItem>a:hover,.pdf-app.light .outlineItemToggler:hover,.pdf-app.light .outlineItemToggler:hover+a,.pdf-app.light .outlineItemToggler:hover~.outlineItems{background-color:#3f4b5b}.pdf-app.light #errorWrapper{background-color:#f55}.pdf-app.light #errorMoreInfo{background-color:#d9d9d9;color:#000}.pdf-app.light #overlayContainer{background-color:hsla(208,7%,46%,.7)}.pdf-app.light #overlayContainer>.container>.dialog{background-color:#6c757d;color:#d9d9d9}.pdf-app.light .dialog .separator{background-color:#000}.pdf-app.light .secondaryToolbarButton.toggled,.pdf-app.light .splitToolbarButton.toggled>.toolbarButton.toggled,.pdf-app.light .toolbarButton.toggled{background-color:#3f4b5b}.pdf-app[class]{background-color:var(--pdf-app-background-color)}.pdf-app[class] #sidebarContent{background-color:var(--pdf-sidebar-content-color)}.pdf-app[class] #toolbarSidebar{background-color:var(--pdf-toolbar-sidebar-color)}.pdf-app[class] #toolbarContainer,.pdf-app[class] .findbar,.pdf-app[class] .secondaryToolbar{background-color:var(--pdf-toolbar-color)}.pdf-app[class] #loadingBar .progress{background-color:var(--pdf-loading-bar-color)}.pdf-app[class] #loadingBar .progress.indeterminate .glimmer{background:repeating-linear-gradient(135deg,transparent 0,var(--pdf-loading-bar-secondary-color) 5px,var(--pdf-loading-bar-secondary-color) 45px,transparent 55px,transparent 95px,transparent 100px)}.pdf-app[class] #findInput::-moz-placeholder{color:var(--pdf-find-input-placeholder-font-color)}.pdf-app[class] #findInput::placeholder{color:var(--pdf-find-input-placeholder-font-color)}.pdf-app[class] .doorHanger:after,.pdf-app[class] .doorHangerRight:after{border-bottom-color:var(--pdf-toolbar-color)}.pdf-app[class] #findResultsCount{background-color:var(--pdf-find-results-count-color);color:var(--pdf-find-results-count-font-color)}.pdf-app[class] #findMsg{color:var(--pdf-find-message-font-color)}.pdf-app[class] #findInput.notFound{background-color:var(--pdf-not-found-color)}.pdf-app[class] .splitToolbarButtonSeparator{background-color:var(--pdf-split-toolbar-button-separator-color)}.pdf-app[class] .dropdownToolbarButton,.pdf-app[class] .overlayButton,.pdf-app[class] .secondaryToolbarButton,.pdf-app[class] .toolbarButton,.vue-pdf-app-icon[class]{color:var(--pdf-toolbar-font-color)}.pdf-app[class] .dialog .overlayButton{background-color:var(--pdf-dialog-button-color);color:var(--pdf-dialog-button-font-color)}.pdf-app[class] .dropdownToolbarButton:hover,.pdf-app[class] .overlayButton,.pdf-app[class] .secondaryToolbarButton:focus,.pdf-app[class] .secondaryToolbarButton:hover,.pdf-app[class] .toolbarButton:focus,.pdf-app[class] .toolbarButton:hover,.vue-pdf-app-icon:hover[class]{color:var(--pdf-button-hover-font-color)}.pdf-app[class] .dropdownToolbarButton>select{color:var(--pdf-toolbar-font-color);background:var(--pdf-toolbar-color)}.pdf-app[class] .dropdownToolbarButton>select>option{background:var(--pdf-toolbar-color)}.pdf-app[class] .verticalToolbarSeparator{background-color:var(--pdf-split-toolbar-button-separator-color)}.pdf-app[class] .horizontalToolbarSeparator{background-color:var(--pdf-horizontal-toolbar-separator-color)}.pdf-app[class] .toolbarField{background-color:var(--pdf-input-color);color:var(--pdf-input-font-color)}.pdf-app[class] .toolbarLabel{color:var(--pdf-toolbar-font-color)}.pdf-app[class] .thumbnail:hover>.thumbnailSelectionRing,.pdf-app[class] a:focus>.thumbnail>.thumbnailSelectionRing{background-color:var(--pdf-thumbnail-selection-ring-color)}.pdf-app[class] .thumbnail.selected>.thumbnailSelectionRing{background-color:var(--pdf-thumbnail-selection-ring-selected-color)}.pdf-app[class] .attachmentsItem>button,.pdf-app[class] .outlineItem>a{color:var(--pdf-toolbar-font-color)}.pdf-app[class] .attachmentsItem>button:hover,.pdf-app[class] .outlineItem>a:hover,.pdf-app[class] .outlineItemToggler:hover,.pdf-app[class] .outlineItemToggler:hover+a,.pdf-app[class] .outlineItemToggler:hover~.outlineItems{background-color:var(--pdf-button-toggled-color)}.pdf-app[class] #errorWrapper{background-color:var(--pdf-error-wrapper-color)}.pdf-app[class] #errorMoreInfo{background-color:var(--pdf-error-more-info-color);color:var(--pdf-error-more-info-font-color)}.pdf-app[class] #overlayContainer{background-color:var(--pdf-overlay-container-color)}.pdf-app[class] #overlayContainer>.container>.dialog{background-color:var(--pdf-overlay-container-dialog-color);color:var(--pdf-overlay-container-dialog-font-color)}.pdf-app[class] .dialog .separator{background-color:var(--pdf-overlay-container-dialog-separator-color)}.pdf-app[class] .secondaryToolbarButton.toggled,.pdf-app[class] .splitToolbarButton.toggled>.toolbarButton.toggled,.pdf-app[class] .toolbarButton.toggled{background-color:var(--pdf-button-toggled-color)}:root{--sidebar-width:200px;--sidebar-transition-duration:200ms;--sidebar-transition-timing-function:ease}.pdf-app{height:100%;overflow-x:hidden}.pdf-app *{padding:0;margin:0}.pdf-app #secondaryToolbar button,.pdf-app #sidebarContainer button,.pdf-app #toolbarContainer button{cursor:pointer}.pdf-app #sidebarContainer button[disabled]{cursor:no-drop}.pdf-app #viewBookmark{cursor:pointer}.pdf-app button,.pdf-app input,.pdf-app select{font:message-box;outline:none}.pdf-app .hidden,.pdf-app [hidden]{display:none!important}.pdf-app .pdfViewer.enablePermissions .textLayer>span{-webkit-user-select:none!important;-moz-user-select:none!important;user-select:none!important;cursor:not-allowed}.pdf-app #viewerContainer.pdfPresentationMode:-webkit-full-screen{top:0;border-top:2px solid transparent;background-color:#000;width:100%;height:100%;overflow:hidden;cursor:none;-webkit-user-select:none;user-select:none}.pdf-app #viewerContainer.pdfPresentationMode:fullscreen{top:0;border-top:2px solid transparent;background-color:#000;width:100%;height:100%;overflow:hidden;cursor:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pdf-app .pdfPresentationMode:-webkit-full-screen a:not(.internalLink){display:none}.pdf-app .pdfPresentationMode:fullscreen a:not(.internalLink){display:none}.pdf-app .pdfPresentationMode:-webkit-full-screen .textLayer>span{cursor:none}.pdf-app .pdfPresentationMode:fullscreen .textLayer>span{cursor:none}.pdf-app .pdfPresentationMode.pdfPresentationModeControls .textLayer>span,.pdf-app .pdfPresentationMode.pdfPresentationModeControls>*{cursor:default}.pdf-app #outerContainer{width:100%;height:100%;position:relative}.pdf-app #sidebarContainer{position:absolute;top:32px;bottom:0;width:200px;width:var(--sidebar-width);visibility:hidden;z-index:100;transition-duration:.2s;transition-duration:var(--sidebar-transition-duration);transition-timing-function:ease;transition-timing-function:var(--sidebar-transition-timing-function)}html[dir=ltr] .pdf-app #sidebarContainer{transition-property:left;left:-200px;left:calc(0px - var(--sidebar-width))}html[dir=rtl] .pdf-app #sidebarContainer{transition-property:right;right:-200px;right:calc(0px - var(--sidebar-width))}.loadingInProgress #sidebarContainer{top:4px}.pdf-app #outerContainer.sidebarResizing #sidebarContainer{transition-duration:0s;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pdf-app #outerContainer.sidebarMoving #sidebarContainer,.pdf-app #outerContainer.sidebarOpen #sidebarContainer{visibility:visible}html[dir=ltr] .pdf-app #outerContainer.sidebarOpen #sidebarContainer{left:0}html[dir=rtl] .pdf-app #outerContainer.sidebarOpen #sidebarContainer{right:0}.pdf-app #mainContainer{position:absolute;top:0;right:0;bottom:0;left:0}.pdf-app #sidebarContent{top:32px;bottom:0;overflow:auto;-webkit-overflow-scrolling:touch;position:absolute;width:100%}html[dir=ltr] .pdf-app #sidebarContent{left:0;box-shadow:inset -1px 0 0 rgba(0,0,0,.25)}html[dir=rtl] .pdf-app #sidebarContent{right:0;box-shadow:inset 1px 0 0 rgba(0,0,0,.25)}.pdf-app #viewerContainer{overflow:auto;-webkit-overflow-scrolling:touch;position:absolute;top:32px;right:0;bottom:0;left:0;outline:none}.pdf-app #viewerContainer:not(.pdfPresentationMode){transition-duration:.2s;transition-duration:var(--sidebar-transition-duration);transition-timing-function:ease;transition-timing-function:var(--sidebar-transition-timing-function)}html[dir=ltr] .pdf-app #viewerContainer{box-shadow:inset 1px 0 0 hsla(0,0%,100%,.05)}html[dir=rtl] .pdf-app #viewerContainer{box-shadow:inset -1px 0 0 hsla(0,0%,100%,.05)}.pdf-app #outerContainer.sidebarResizing #viewerContainer{transition-duration:0s}html[dir=ltr] .pdf-app #outerContainer.sidebarOpen #viewerContainer:not(.pdfPresentationMode){transition-property:left;left:200px;left:var(--sidebar-width)}html[dir=rtl] .pdf-app #outerContainer.sidebarOpen #viewerContainer:not(.pdfPresentationMode){transition-property:right;right:200px;right:var(--sidebar-width)}.pdf-app .toolbar{position:relative;left:0;right:0;z-index:9999;cursor:default}.pdf-app #toolbarContainer{width:100%}.pdf-app #toolbarSidebar{width:100%;height:32px}html[dir=ltr] .pdf-app #toolbarSidebar{box-shadow:inset -1px 0 0 rgba(0,0,0,.25),inset 0 -1px 0 hsla(0,0%,100%,.05),0 1px 0 rgba(0,0,0,.15),0 0 1px rgba(0,0,0,.1)}html[dir=rtl] .pdf-app #toolbarSidebar{box-shadow:inset 1px 0 0 rgba(0,0,0,.25),inset 0 1px 0 hsla(0,0%,100%,.05),0 1px 0 rgba(0,0,0,.15),0 0 1px rgba(0,0,0,.1)}.pdf-app #sidebarResizer{position:absolute;top:0;bottom:0;width:6px;z-index:200;cursor:ew-resize}html[dir=ltr] .pdf-app #sidebarResizer{right:-6px}html[dir=rtl] .pdf-app #sidebarResizer{left:-6px}.pdf-app #toolbarContainer,.pdf-app .findbar,.pdf-app .secondaryToolbar{position:relative;height:32px}.pdf-app .findbar,.pdf-app .secondaryToolbar,html[dir=ltr] .pdf-app #toolbarContainer,html[dir=rtl] .pdf-app #toolbarContainer{box-shadow:inset 0 1px 1px rgba(0,0,0,.15),inset 0 -1px 0 hsla(0,0%,100%,.05),0 1px 0 rgba(0,0,0,.15),0 1px 1px rgba(0,0,0,.1)}.pdf-app #toolbarViewer{height:32px}.pdf-app #loadingBar{position:relative;width:100%;height:4px}.pdf-app #loadingBar .progress{position:absolute;top:0;left:0;width:0;height:100%;overflow:hidden;transition:width .2s}@keyframes progressIndeterminate{0%{left:-142px}to{left:0}}.pdf-app #loadingBar .progress.indeterminate .glimmer{position:absolute;top:0;left:0;height:100%;width:calc(100% + 150px);animation:progressIndeterminate .95s linear infinite}.pdf-app .findbar,.pdf-app .secondaryToolbar{top:32px;position:absolute;z-index:10000;height:auto;min-width:16px;padding:0 6px 0 6px;margin:4px 2px 4px 2px;font-size:12px;line-height:14px;text-align:left;cursor:default}.pdf-app .findbar{min-width:300px}.pdf-app .findbar>div{height:32px}.pdf-app .findbar.wrapContainers>div{clear:both}.pdf-app .findbar.wrapContainers>div#findbarMessageContainer{height:auto}html[dir=ltr] .pdf-app .findbar{left:68px}html[dir=rtl] .pdf-app .findbar{right:68px}.pdf-app .findbar label{-webkit-user-select:none;-moz-user-select:none;user-select:none}.pdf-app #findInput{width:200px}.pdf-app #findInput::-moz-placeholder{font-style:italic}.pdf-app #findInput::placeholder{font-style:italic}.pdf-app #findInput[data-status=pending]{background-size:16px;background-image:url(" + ___CSS_LOADER_URL_REPLACEMENT_1___ + ');background-repeat:no-repeat;background-position:100%}html[dir=rtl] .pdf-app #findInput[data-status=pending]{background-position:0}.pdf-app .secondaryToolbar{padding:6px;height:auto;z-index:30000}html[dir=ltr] .pdf-app .secondaryToolbar{right:4px}html[dir=rtl] .pdf-app .secondaryToolbar{left:4px}.pdf-app #secondaryToolbarButtonContainer{max-width:200px;max-height:400px;overflow-y:auto;-webkit-overflow-scrolling:touch;margin-bottom:-4px}.pdf-app #secondaryToolbarButtonContainer.hiddenScrollModeButtons>.scrollModeButtons,.pdf-app #secondaryToolbarButtonContainer.hiddenSpreadModeButtons>.spreadModeButtons{display:none!important}.pdf-app .doorHanger,.pdf-app .doorHangerRight{border:1px solid rgba(0,0,0,.5);border-radius:2px;box-shadow:0 1px 4px rgba(0,0,0,.3)}.pdf-app .doorHanger:after,.pdf-app .doorHanger:before,.pdf-app .doorHangerRight:after,.pdf-app .doorHangerRight:before{bottom:100%;border:solid transparent;content:" ";height:0;width:0;position:absolute;pointer-events:none}.pdf-app .doorHanger:after,.pdf-app .doorHangerRight:after{border-width:8px}.pdf-app .doorHanger:before,.pdf-app .doorHangerRight:before{border-bottom-color:rgba(0,0,0,.5);border-width:9px}html[dir=ltr] .pdf-app .doorHanger:after,html[dir=rtl] .pdf-app .doorHangerRight:after{left:13px;margin-left:-8px}html[dir=ltr] .pdf-app .doorHanger:before,html[dir=rtl] .pdf-app .doorHangerRight:before{left:13px;margin-left:-9px}html[dir=ltr] .pdf-app .doorHangerRight:after,html[dir=rtl] .pdf-app .doorHanger:after{right:13px;margin-right:-8px}html[dir=ltr] .pdf-app .doorHangerRight:before,html[dir=rtl] .pdf-app .doorHanger:before{right:13px;margin-right:-9px}.pdf-app #findResultsCount{text-align:center;padding:3px 4px}.pdf-app #findMsg{font-style:italic}.pdf-app #findMsg:empty{display:none}.pdf-app #toolbarViewerMiddle{position:absolute;left:50%;transform:translateX(-50%)}html[dir=ltr] .pdf-app #toolbarViewerLeft,html[dir=rtl] .pdf-app #toolbarViewerRight{float:left}html[dir=ltr] .pdf-app #toolbarViewerRight,html[dir=rtl] .pdf-app #toolbarViewerLeft{float:right}html[dir=ltr] .pdf-app #toolbarViewerLeft>*,html[dir=ltr] .pdf-app #toolbarViewerMiddle>*,html[dir=ltr] .pdf-app #toolbarViewerRight>*,html[dir=ltr] .pdf-app .findbar *{position:relative;float:left}html[dir=rtl] .pdf-app #toolbarViewerLeft>*,html[dir=rtl] .pdf-app #toolbarViewerMiddle>*,html[dir=rtl] .pdf-app #toolbarViewerRight>*,html[dir=rtl] .pdf-app .findbar *{position:relative;float:right}html[dir=ltr] .pdf-app .splitToolbarButton{margin:3px 2px 4px 0;display:inline-block}html[dir=rtl] .pdf-app .splitToolbarButton{margin:3px 0 4px 2px;display:inline-block}html[dir=ltr] .pdf-app .splitToolbarButton>.toolbarButton{border-radius:0;float:left}html[dir=rtl] .pdf-app .splitToolbarButton>.toolbarButton{border-radius:0;float:right}.pdf-app .overlayButton,.pdf-app .secondaryToolbarButton,.pdf-app .toolbarButton,.vue-pdf-app-icon{border:0 none;background:none}.pdf-app .overlayButton,.pdf-app .secondaryToolbarButton,.pdf-app .toolbarButton{width:32px;height:25px}.pdf-app .toolbarButton>span{display:inline-block;width:0;height:0;overflow:hidden}.pdf-app .overlayButton[disabled],.pdf-app .secondaryToolbarButton[disabled],.pdf-app .toolbarButton[disabled]{opacity:.5}.pdf-app .splitToolbarButton.toggled .toolbarButton{margin:0}.pdf-app .splitToolbarButton>.toolbarButton{position:relative}html[dir=ltr] .pdf-app .splitToolbarButton>.toolbarButton:first-child,html[dir=rtl] .pdf-app .splitToolbarButton>.toolbarButton:last-child{position:relative;margin:0;margin-right:-1px;border-top-left-radius:2px;border-bottom-left-radius:2px;border-right-color:transparent}html[dir=ltr] .pdf-app .splitToolbarButton>.toolbarButton:last-child,html[dir=rtl] .pdf-app .splitToolbarButton>.toolbarButton:first-child{position:relative;margin:0;margin-left:-1px;border-top-right-radius:2px;border-bottom-right-radius:2px;border-left-color:transparent}.pdf-app .splitToolbarButtonSeparator{padding:8px 0;width:1px;z-index:99;display:inline-block;margin:5px 0}html[dir=ltr] .pdf-app .splitToolbarButtonSeparator{float:left}html[dir=rtl] .pdf-app .splitToolbarButtonSeparator{float:right}.pdf-app .splitToolbarButton.toggled>.splitToolbarButtonSeparator,.pdf-app .splitToolbarButton:hover>.splitToolbarButtonSeparator{padding:12px 0;margin:1px 0}.pdf-app .dropdownToolbarButton,.pdf-app .overlayButton,.pdf-app .secondaryToolbarButton,.pdf-app .toolbarButton{min-width:16px;padding:2px 6px 0;font-size:12px;line-height:14px;-webkit-user-select:none;-moz-user-select:none;user-select:none;cursor:default}.pdf-app .findbar .toolbarButton,.vue-pdf-app-icon{cursor:pointer}.pdf-app .dialog .overlayButton{cursor:pointer;border-radius:2px}html[dir=ltr] .pdf-app .dropdownToolbarButton,html[dir=ltr] .pdf-app .overlayButton,html[dir=ltr] .pdf-app .toolbarButton{margin:3px 2px 4px 0}html[dir=rtl] .pdf-app .dropdownToolbarButton,html[dir=rtl] .pdf-app .overlayButton,html[dir=rtl] .pdf-app .toolbarButton{margin:3px 0 4px 2px}.pdf-app .dropdownToolbarButton select:hover{cursor:pointer}.pdf-app .secondaryToolbarButton.toggled,.pdf-app .splitToolbarButton.toggled>.toolbarButton.toggled,.pdf-app .toolbarButton.toggled{border-radius:3px}.pdf-app .dropdownToolbarButton{width:140px;padding:0;overflow:hidden}.pdf-app .dropdownToolbarButton:after{position:absolute;display:inline-block;top:6px}html[dir=ltr] .pdf-app .dropdownToolbarButton:after{right:0}html[dir=rtl] .pdf-app .dropdownToolbarButton:after{left:0}.pdf-app .dropdownToolbarButton>select{width:162px;height:23px;font-size:12px;margin:0;padding:3px 2px 2px;border:none}.pdf-app #customScaleOption{display:none}.pdf-app .toolbarButtonSpacer{width:30px;display:inline-block;height:1px}.pdf-app .secondaryToolbarButton.bookmark,.pdf-app .toolbarButton.bookmark{box-sizing:border-box;outline:none;padding-top:4px;text-decoration:none}.pdf-app .secondaryToolbarButton.bookmark{padding-top:5px}.pdf-app .bookmark[href="#"]{opacity:.5;pointer-events:none}.pdf-app .toolbarButton.pdfSidebarNotification:after{position:absolute;display:inline-block;top:1px;content:"";background-color:#70db55;height:9px;width:9px;border-radius:50%}html[dir=ltr] .pdf-app .toolbarButton.pdfSidebarNotification:after{left:17px}html[dir=rtl] .pdf-app .toolbarButton.pdfSidebarNotification:after{right:17px}.pdf-app .secondaryToolbarButton{position:relative;margin:0 0 4px 0;padding:3px 0 1px 0;height:auto;min-height:25px;width:auto;min-width:100%;white-space:normal}.pdf-app .secondaryToolbarButton>span{vertical-align:top}html[dir=ltr] .pdf-app .secondaryToolbarButton{padding-left:14px;text-align:left}html[dir=rtl] .pdf-app .secondaryToolbarButton{padding-right:14px;text-align:right}html[dir=ltr] .pdf-app .secondaryToolbarButton>span{padding-left:8px}html[dir=rtl] .pdf-app .secondaryToolbarButton>span{padding-right:8px}html[dir=rtl] .pdf-app .secondaryToolbarButton:before{float:right}.pdf-app .verticalToolbarSeparator{display:block;padding:8px 0;margin:8px 4px;width:1px}html[dir=ltr] .pdf-app .verticalToolbarSeparator{margin-left:2px}html[dir=rtl] .pdf-app .verticalToolbarSeparator{margin-right:2px}.pdf-app .horizontalToolbarSeparator{display:block;margin:0 0 4px 0;height:1px;width:100%}.pdf-app .toolbarField{padding:3px 6px;margin:4px 0 4px 0;border-radius:2px;border-width:1px;border-style:solid;border-color:rgba(0,0,0,.32) rgba(0,0,0,.38) rgba(0,0,0,.42);font-size:12px;line-height:14px;outline-style:none}.pdf-app .toolbarField[type=checkbox]{display:inline-block;margin:8px 0;cursor:pointer}.pdf-app .toolbarField[type=checkbox]+label{cursor:pointer}.pdf-app .toolbarField.pageNumber{-moz-appearance:textfield;min-width:16px;text-align:right;width:40px}.pdf-app .toolbarField.pageNumber.visiblePageIsLoading{background-image:url(' + ___CSS_LOADER_URL_REPLACEMENT_1___ + ");background-repeat:no-repeat;background-position:1px;background-size:16px}.pdf-app .toolbarField.pageNumber::-webkit-inner-spin-button,.pdf-app .toolbarField.pageNumber::-webkit-outer-spin-button{-webkit-appearance:none;margin:0}.pdf-app .toolbarLabel{min-width:16px;padding:3px 6px 3px 2px;margin:4px 2px 4px 0;border:1px solid transparent;border-radius:2px;font-size:12px;line-height:14px;text-align:left;-webkit-user-select:none;-moz-user-select:none;user-select:none;cursor:default}.pdf-app #thumbnailView{position:absolute;width:calc(100% - 60px);top:0;bottom:0;padding:10px 30px 0;overflow:auto;-webkit-overflow-scrolling:touch}.pdf-app #thumbnailView>a:active,.pdf-app #thumbnailView>a:focus{outline:0}.pdf-app .thumbnail{margin:0 10px 5px 10px}html[dir=ltr] .pdf-app .thumbnail{float:left}html[dir=rtl] .pdf-app .thumbnail{float:right}.pdf-app #thumbnailView>a:last-of-type>.thumbnail{margin-bottom:10px}.pdf-app #thumbnailView>a:last-of-type>.thumbnail:not([data-loaded]){margin-bottom:9px}.pdf-app .thumbnail:not([data-loaded]){border:1px dashed hsla(0,0%,100%,.5);margin:-1px 9px 4px 9px}.pdf-app .thumbnailImage{border:1px solid transparent;box-shadow:0 0 0 1px rgba(0,0,0,.5),0 2px 8px rgba(0,0,0,.3);opacity:.8;z-index:99;background-color:#fff;background-clip:content-box}.pdf-app .thumbnailSelectionRing{border-radius:2px;padding:7px}.pdf-app .thumbnail:hover>.thumbnailSelectionRing>.thumbnailImage,.pdf-app a:focus>.thumbnail>.thumbnailSelectionRing>.thumbnailImage{opacity:.9}.pdf-app #attachmentsView,.pdf-app #outlineView{position:absolute;width:calc(100% - 8px);top:0;bottom:0;overflow:auto;-webkit-overflow-scrolling:touch;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pdf-app #outlineView{padding:4px 4px 0}.pdf-app #attachmentsView{padding:3px 4px 0}html[dir=ltr] .pdf-app .outlineItem>.outlineItems,html[dir=ltr] .pdf-app .outlineWithDeepNesting>.outlineItem{margin-left:20px}html[dir=rtl] .pdf-app .outlineItem>.outlineItems,html[dir=rtl] .pdf-app .outlineWithDeepNesting>.outlineItem{margin-right:20px}.pdf-app .attachmentsItem>button,.pdf-app .outlineItem>a{text-decoration:none;display:inline-block;min-width:95%;min-width:calc(100% - 4px);height:auto;margin-bottom:1px;border-radius:2px;font-size:13px;line-height:15px;-webkit-user-select:none;-moz-user-select:none;user-select:none;white-space:normal}.pdf-app .attachmentsItem>button{border:0 none;background:none;cursor:pointer;width:100%}html[dir=ltr] .pdf-app .outlineItem>a{padding:2px 0 5px 4px}html[dir=ltr] .pdf-app .attachmentsItem>button{padding:2px 0 3px 7px;text-align:left}html[dir=rtl] .pdf-app .outlineItem>a{padding:2px 4px 5px 0}html[dir=rtl] .pdf-app .attachmentsItem>button{padding:2px 7px 3px 0;text-align:right}.pdf-app .outlineItemToggler{position:relative;height:0;width:0;color:hsla(0,0%,100%,.5)}.pdf-app .outlineItemToggler:before{content:url(" + ___CSS_LOADER_URL_REPLACEMENT_2___ + ");display:inline-block;position:absolute}.pdf-app .outlineItemToggler.outlineItemsHidden:before{content:url(" + ___CSS_LOADER_URL_REPLACEMENT_3___ + ")}html[dir=rtl] .pdf-app .outlineItemToggler.outlineItemsHidden:before{transform:scaleX(-1)}.pdf-app .outlineItemToggler.outlineItemsHidden~.outlineItems{display:none}html[dir=ltr] .pdf-app .outlineItemToggler{float:left}html[dir=rtl] .pdf-app .outlineItemToggler{float:right}html[dir=ltr] .pdf-app .outlineItemToggler:before{right:4px}html[dir=rtl] .pdf-app .outlineItemToggler:before{left:4px}.pdf-app .attachmentsItem>button:hover,.pdf-app .outlineItem>a:hover,.pdf-app .outlineItemToggler:hover,.pdf-app .outlineItemToggler:hover+a,.pdf-app .outlineItemToggler:hover~.outlineItems{border-radius:2px}.pdf-app .noResults{font-size:12px;color:hsla(0,0%,100%,.8);font-style:italic;cursor:default}.pdf-app ::-moz-selection{background:rgba(0,0,255,.3)}.pdf-app ::selection{background:rgba(0,0,255,.3)}.pdf-app #errorWrapper{color:#fff;left:0;position:absolute;right:0;z-index:1000;padding:3px;font-size:.8em}.loadingInProgress #errorWrapper{top:4px}.pdf-app #errorMessageLeft{float:left}.pdf-app #errorMessageRight{float:right}.pdf-app #errorMoreInfo{padding:3px;margin:3px;width:98%}.pdf-app .overlayButton{width:auto;margin:3px 4px 2px 4px!important;padding:2px 6px 3px 6px}.pdf-app #overlayContainer{display:table;position:absolute;width:100%;height:100%;z-index:40000}.pdf-app #overlayContainer>*{overflow:auto;-webkit-overflow-scrolling:touch}.pdf-app #overlayContainer>.container{display:table-cell;vertical-align:middle;text-align:center}.pdf-app #overlayContainer>.container>.dialog{display:inline-block;padding:15px;border-spacing:4px;font-size:12px;line-height:14px;border:1px solid rgba(0,0,0,.5);border-radius:4px}.pdf-app .dialog>.row{display:table-row}.pdf-app .dialog>.row>*{display:table-cell}.pdf-app .dialog .toolbarField{margin:5px 0}.pdf-app .dialog .separator{display:block;margin:4px 0 4px 0;height:1px;width:100%}.pdf-app .dialog .buttonRow{text-align:center;vertical-align:middle}.pdf-app .dialog :link{color:#fff}.pdf-app #passwordOverlay>.dialog{text-align:center}.pdf-app #passwordOverlay .toolbarField{width:200px}.pdf-app #documentPropertiesOverlay>.dialog{text-align:left}.pdf-app #documentPropertiesOverlay .row>*{min-width:100px}html[dir=ltr] .pdf-app #documentPropertiesOverlay .row>*{text-align:left}html[dir=rtl] .pdf-app #documentPropertiesOverlay .row>*{text-align:right}.pdf-app #documentPropertiesOverlay .row>span{width:125px;word-wrap:break-word}.pdf-app #documentPropertiesOverlay .row>p{max-width:225px;word-wrap:break-word}.pdf-app #documentPropertiesOverlay .buttonRow{margin-top:10px}.pdf-app .clearBoth{clear:both}.fileInput{display:none}.pdf-app #PDFBug{background:none repeat scroll 0 0 #fff;border:1px solid #666;position:fixed;top:32px;right:0;bottom:0;font-size:10px;padding:0;width:300px}.pdf-app #PDFBug .controls{background:#eee;border-bottom:1px solid #666;padding:3px}.pdf-app #PDFBug .panels{bottom:0;left:0;overflow:auto;-webkit-overflow-scrolling:touch;position:absolute;right:0;top:27px}.pdf-app #PDFBug .panels>div{padding:5px}.pdf-app #PDFBug button.active{font-weight:700}.pdf-app .debuggerShowText{color:blue}.pdf-app .debuggerHideText:hover,.pdf-app .debuggerShowText{background:none repeat scroll 0 0 #ff0}.pdf-app #PDFBug .stats{font-family:courier;font-size:10px;white-space:pre}.pdf-app #PDFBug .stats .title{font-weight:700}.pdf-app #PDFBug table{font-size:10px}.pdf-app #viewer.textLayer-visible .textLayer{opacity:1}.pdf-app #viewer.textLayer-visible .canvasWrapper{background-color:#80ff80}.pdf-app #viewer.textLayer-visible .canvasWrapper canvas{mix-blend-mode:screen}.pdf-app #viewer.textLayer-visible .textLayer>span{background-color:rgba(255,255,0,.1);color:#000;border:1px solid rgba(255,0,0,.5);box-sizing:border-box}.pdf-app #viewer.textLayer-hover .textLayer>span:hover{background-color:#fff;color:#000}.pdf-app #viewer.textLayer-shadow .textLayer>span{background-color:hsla(0,0%,100%,.6);color:#000}.pdf-app .grab-to-pan-grab{cursor:url(" + ___CSS_LOADER_URL_REPLACEMENT_4___ + "),move!important;cursor:grab!important}.pdf-app .grab-to-pan-grab :not(input):not(textarea):not(button):not(select):not(:link){cursor:inherit!important}.grab-to-pan-grabbing,.pdf-app .grab-to-pan-grab:active{cursor:url(" + ___CSS_LOADER_URL_REPLACEMENT_5___ + "),move!important;cursor:grabbing!important;position:fixed;background:transparent;display:block;top:0;left:0;right:0;bottom:0;overflow:hidden;z-index:50000}@page{margin:0}#printContainer{display:none}@media screen and (-webkit-min-device-pixel-ratio:1.1),screen and (min-resolution:1.1dppx){.pdf-app .outlineItemToggler:before{transform:scale(.5);top:-1px;content:url(" + ___CSS_LOADER_URL_REPLACEMENT_6___ + ")}.pdf-app .outlineItemToggler.outlineItemsHidden:before{content:url(" + ___CSS_LOADER_URL_REPLACEMENT_7___ + ")}html[dir=rtl] .pdf-app .outlineItemToggler.outlineItemsHidden:before{transform:scaleX(-1) scale(.5)}}@media print{body{background:transparent none}.pdf-app #errorWrapper,.pdf-app #loadingBox,.pdf-app #secondaryToolbar,.pdf-app #sidebarContainer,.pdf-app .textLayer,.pdf-app .toolbar{display:none}.pdf-app #viewerContainer{overflow:visible}.pdf-app #mainContainer,.pdf-app #viewerContainer,.pdf-app .page,.pdf-app .page canvas{position:static;padding:0;margin:0}.pdf-app .page{float:left;display:none;border:none;box-shadow:none;background-clip:content-box;background-color:#fff}.pdf-app .page[data-loaded]{display:block}body[data-pdfjsprinting] #outerContainer{display:none}body[data-pdfjsprinting] #printContainer{display:block}#printContainer{height:100%}#printContainer>div{position:relative;top:0;left:0;width:1px;height:1px;overflow:visible;page-break-after:always;page-break-inside:avoid}#printContainer canvas,#printContainer img{display:block}}.pdf-app .visibleLargeView,.pdf-app .visibleMediumView,.pdf-app .visibleSmallView{display:none}@media (max-width:900px){.pdf-app #toolbarViewerMiddle{display:table;margin:auto;left:auto;position:inherit;transform:none}}@media (max-width:840px){html[dir=ltr] .pdf-app #outerContainer.sidebarOpen #viewerContainer{left:0!important}html[dir=rtl] .pdf-app #outerContainer.sidebarOpen #viewerContainer{right:0!important}.pdf-app #outerContainer .hiddenLargeView,.pdf-app #outerContainer .hiddenMediumView{display:inherit}.pdf-app #outerContainer .visibleLargeView,.pdf-app #outerContainer .visibleMediumView{display:none}}@media (max-width:770px){.pdf-app #outerContainer .hiddenLargeView{display:none}.pdf-app #outerContainer .visibleLargeView{display:inherit}}@media (max-width:700px){.pdf-app #outerContainer .hiddenMediumView{display:none}.pdf-app #outerContainer .visibleMediumView{display:inherit}}@media (max-width:640px){.pdf-app .hiddenSmallView,.pdf-app .hiddenSmallView *{display:none}.pdf-app .visibleSmallView{display:inherit}.pdf-app .toolbarButtonSpacer{width:0}html[dir=ltr] .pdf-app .findbar{left:38px}html[dir=rtl] .pdf-app .findbar{right:38px}}@media (max-width:535px){.pdf-app #scaleSelectContainer{display:none}}", ""]);
            __webpack_exports__2["default"] = ___CSS_LOADER_EXPORT___;
          },
          3645: function(module2) {
            "use strict";
            module2.exports = function(cssWithMappingToString) {
              var list = [];
              list.toString = function toString() {
                return this.map(function(item) {
                  var content = "";
                  var needLayer = typeof item[5] !== "undefined";
                  if (item[4]) {
                    content += "@supports (".concat(item[4], ") {");
                  }
                  if (item[2]) {
                    content += "@media ".concat(item[2], " {");
                  }
                  if (needLayer) {
                    content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
                  }
                  content += cssWithMappingToString(item);
                  if (needLayer) {
                    content += "}";
                  }
                  if (item[2]) {
                    content += "}";
                  }
                  if (item[4]) {
                    content += "}";
                  }
                  return content;
                }).join("");
              };
              list.i = function i(modules, media, dedupe, supports, layer) {
                if (typeof modules === "string") {
                  modules = [[null, modules, void 0]];
                }
                var alreadyImportedModules = {};
                if (dedupe) {
                  for (var k = 0; k < this.length; k++) {
                    var id = this[k][0];
                    if (id != null) {
                      alreadyImportedModules[id] = true;
                    }
                  }
                }
                for (var _k = 0; _k < modules.length; _k++) {
                  var item = [].concat(modules[_k]);
                  if (dedupe && alreadyImportedModules[item[0]]) {
                    continue;
                  }
                  if (typeof layer !== "undefined") {
                    if (typeof item[5] === "undefined") {
                      item[5] = layer;
                    } else {
                      item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
                      item[5] = layer;
                    }
                  }
                  if (media) {
                    if (!item[2]) {
                      item[2] = media;
                    } else {
                      item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
                      item[2] = media;
                    }
                  }
                  if (supports) {
                    if (!item[4]) {
                      item[4] = "".concat(supports);
                    } else {
                      item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
                      item[4] = supports;
                    }
                  }
                  list.push(item);
                }
              };
              return list;
            };
          },
          1667: function(module2) {
            "use strict";
            module2.exports = function(url, options) {
              if (!options) {
                options = {};
              }
              if (!url) {
                return url;
              }
              url = String(url.__esModule ? url.default : url);
              if (/^['"].*['"]$/.test(url)) {
                url = url.slice(1, -1);
              }
              if (options.hash) {
                url += options.hash;
              }
              if (/["'() \t\n]|(%20)/.test(url) || options.needQuotes) {
                return '"'.concat(url.replace(/"/g, '\\"').replace(/\n/g, "\\n"), '"');
              }
              return url;
            };
          },
          8081: function(module2) {
            "use strict";
            module2.exports = function(i) {
              return i[1];
            };
          },
          1353: function(__unused_webpack_module2, __unused_webpack_exports2, __webpack_require__2) {
            (typeof window !== "undefined" ? window : {}).pdfjsWorker = __webpack_require__2(5322);
          },
          5322: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            __webpack_require__2(3408);
            __webpack_require__2(4590);
            __webpack_require__2(7658);
            __webpack_require__2(2087);
            __webpack_require__2(541);
            (function webpackUniversalModuleDefinition(root, factory) {
              if (true)
                module2.exports = factory();
              else {
              }
            })(this, function() {
              return function(modules) {
                var installedModules = {};
                function __w_pdfjs_require__2(moduleId) {
                  if (installedModules[moduleId]) {
                    return installedModules[moduleId].exports;
                  }
                  var module3 = installedModules[moduleId] = { i: moduleId, l: false, exports: {} };
                  modules[moduleId].call(module3.exports, module3, module3.exports, __w_pdfjs_require__2);
                  module3.l = true;
                  return module3.exports;
                }
                __w_pdfjs_require__2.m = modules;
                __w_pdfjs_require__2.c = installedModules;
                __w_pdfjs_require__2.d = function(exports2, name, getter) {
                  if (!__w_pdfjs_require__2.o(exports2, name)) {
                    Object.defineProperty(exports2, name, { enumerable: true, get: getter });
                  }
                };
                __w_pdfjs_require__2.r = function(exports2) {
                  if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
                    Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
                  }
                  Object.defineProperty(exports2, "__esModule", { value: true });
                };
                __w_pdfjs_require__2.t = function(value, mode) {
                  if (mode & 1)
                    value = __w_pdfjs_require__2(value);
                  if (mode & 8)
                    return value;
                  if (mode & 4 && typeof value === "object" && value && value.__esModule)
                    return value;
                  var ns = /* @__PURE__ */ Object.create(null);
                  __w_pdfjs_require__2.r(ns);
                  Object.defineProperty(ns, "default", { enumerable: true, value });
                  if (mode & 2 && typeof value != "string")
                    for (var key in value)
                      __w_pdfjs_require__2.d(ns, key, function(key2) {
                        return value[key2];
                      }.bind(null, key));
                  return ns;
                };
                __w_pdfjs_require__2.n = function(module3) {
                  var getter = module3 && module3.__esModule ? function getDefault() {
                    return module3["default"];
                  } : function getModuleExports() {
                    return module3;
                  };
                  __w_pdfjs_require__2.d(getter, "a", getter);
                  return getter;
                };
                __w_pdfjs_require__2.o = function(object, property) {
                  return Object.prototype.hasOwnProperty.call(object, property);
                };
                __w_pdfjs_require__2.p = "";
                return __w_pdfjs_require__2(__w_pdfjs_require__2.s = 0);
              }([function(module3, exports2, __w_pdfjs_require__2) {
                "use strict";
                const pdfjsVersion = "2.4.456";
                const pdfjsBuild = "228a591c";
                const pdfjsCoreWorker = __w_pdfjs_require__2(1);
                exports2.WorkerMessageHandler = pdfjsCoreWorker.WorkerMessageHandler;
              }, function(module3, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.WorkerMessageHandler = exports2.WorkerTask = void 0;
                var _util2 = __w_pdfjs_require__2(2);
                var _primitives = __w_pdfjs_require__2(4);
                var _pdf_manager = __w_pdfjs_require__2(5);
                var _is_node2 = __w_pdfjs_require__2(44);
                var _message_handler2 = __w_pdfjs_require__2(45);
                var _worker_stream = __w_pdfjs_require__2(46);
                var _core_utils = __w_pdfjs_require__2(7);
                var WorkerTask = function WorkerTaskClosure() {
                  function WorkerTask2(name) {
                    this.name = name;
                    this.terminated = false;
                    this._capability = (0, _util2.createPromiseCapability)();
                  }
                  WorkerTask2.prototype = { get finished() {
                    return this._capability.promise;
                  }, finish() {
                    this._capability.resolve();
                  }, terminate() {
                    this.terminated = true;
                  }, ensureNotTerminated() {
                    if (this.terminated) {
                      throw new Error("Worker task was terminated");
                    }
                  } };
                  return WorkerTask2;
                }();
                exports2.WorkerTask = WorkerTask;
                var WorkerMessageHandler = { setup(handler, port) {
                  var testMessageProcessed = false;
                  handler.on("test", function wphSetupTest(data) {
                    if (testMessageProcessed) {
                      return;
                    }
                    testMessageProcessed = true;
                    if (!(data instanceof Uint8Array)) {
                      handler.send("test", null);
                      return;
                    }
                    const supportTransfers = data[0] === 255;
                    handler.postMessageTransfers = supportTransfers;
                    handler.send("test", { supportTransfers });
                  });
                  handler.on("configure", function wphConfigure(data) {
                    (0, _util2.setVerbosityLevel)(data.verbosity);
                  });
                  handler.on("GetDocRequest", function wphSetupDoc(data) {
                    return WorkerMessageHandler.createDocumentHandler(data, port);
                  });
                }, createDocumentHandler(docParams, port) {
                  var pdfManager;
                  var terminated = false;
                  var cancelXHRs = null;
                  var WorkerTasks = [];
                  const verbosity = (0, _util2.getVerbosityLevel)();
                  const apiVersion = docParams.apiVersion;
                  const workerVersion = "2.4.456";
                  if (apiVersion !== workerVersion) {
                    throw new Error(`The API version "${apiVersion}" does not match the Worker version "${workerVersion}".`);
                  }
                  const enumerableProperties = [];
                  for (const property in []) {
                    enumerableProperties.push(property);
                  }
                  if (enumerableProperties.length) {
                    throw new Error("The `Array.prototype` contains unexpected enumerable properties: " + enumerableProperties.join(", ") + "; thus breaking e.g. `for...in` iteration of `Array`s.");
                  }
                  var docId = docParams.docId;
                  var docBaseUrl = docParams.docBaseUrl;
                  var workerHandlerName = docParams.docId + "_worker";
                  var handler = new _message_handler2.MessageHandler(workerHandlerName, docId, port);
                  handler.postMessageTransfers = docParams.postMessageTransfers;
                  function ensureNotTerminated() {
                    if (terminated) {
                      throw new Error("Worker was terminated");
                    }
                  }
                  function startWorkerTask(task) {
                    WorkerTasks.push(task);
                  }
                  function finishWorkerTask(task) {
                    task.finish();
                    var i = WorkerTasks.indexOf(task);
                    WorkerTasks.splice(i, 1);
                  }
                  async function loadDocument(recoveryMode) {
                    await pdfManager.ensureDoc("checkHeader");
                    await pdfManager.ensureDoc("parseStartXRef");
                    await pdfManager.ensureDoc("parse", [recoveryMode]);
                    if (!recoveryMode) {
                      await pdfManager.ensureDoc("checkFirstPage");
                    }
                    const [numPages, fingerprint] = await Promise.all([pdfManager.ensureDoc("numPages"), pdfManager.ensureDoc("fingerprint")]);
                    return { numPages, fingerprint };
                  }
                  function getPdfManager(data, evaluatorOptions) {
                    var pdfManagerCapability = (0, _util2.createPromiseCapability)();
                    var pdfManager2;
                    var source = data.source;
                    if (source.data) {
                      try {
                        pdfManager2 = new _pdf_manager.LocalPdfManager(docId, source.data, source.password, evaluatorOptions, docBaseUrl);
                        pdfManagerCapability.resolve(pdfManager2);
                      } catch (ex) {
                        pdfManagerCapability.reject(ex);
                      }
                      return pdfManagerCapability.promise;
                    }
                    var pdfStream, cachedChunks = [];
                    try {
                      pdfStream = new _worker_stream.PDFWorkerStream(handler);
                    } catch (ex) {
                      pdfManagerCapability.reject(ex);
                      return pdfManagerCapability.promise;
                    }
                    var fullRequest = pdfStream.getFullReader();
                    fullRequest.headersReady.then(function() {
                      if (!fullRequest.isRangeSupported) {
                        return;
                      }
                      var disableAutoFetch = source.disableAutoFetch || fullRequest.isStreamingSupported;
                      pdfManager2 = new _pdf_manager.NetworkPdfManager(docId, pdfStream, { msgHandler: handler, password: source.password, length: fullRequest.contentLength, disableAutoFetch, rangeChunkSize: source.rangeChunkSize }, evaluatorOptions, docBaseUrl);
                      for (let i = 0; i < cachedChunks.length; i++) {
                        pdfManager2.sendProgressiveData(cachedChunks[i]);
                      }
                      cachedChunks = [];
                      pdfManagerCapability.resolve(pdfManager2);
                      cancelXHRs = null;
                    }).catch(function(reason) {
                      pdfManagerCapability.reject(reason);
                      cancelXHRs = null;
                    });
                    var loaded = 0;
                    var flushChunks = function() {
                      var pdfFile = (0, _util2.arraysToBytes)(cachedChunks);
                      if (source.length && pdfFile.length !== source.length) {
                        (0, _util2.warn)("reported HTTP length is different from actual");
                      }
                      try {
                        pdfManager2 = new _pdf_manager.LocalPdfManager(docId, pdfFile, source.password, evaluatorOptions, docBaseUrl);
                        pdfManagerCapability.resolve(pdfManager2);
                      } catch (ex) {
                        pdfManagerCapability.reject(ex);
                      }
                      cachedChunks = [];
                    };
                    var readPromise = new Promise(function(resolve, reject) {
                      var readChunk = function(chunk) {
                        try {
                          ensureNotTerminated();
                          if (chunk.done) {
                            if (!pdfManager2) {
                              flushChunks();
                            }
                            cancelXHRs = null;
                            return;
                          }
                          var data2 = chunk.value;
                          loaded += (0, _util2.arrayByteLength)(data2);
                          if (!fullRequest.isStreamingSupported) {
                            handler.send("DocProgress", { loaded, total: Math.max(loaded, fullRequest.contentLength || 0) });
                          }
                          if (pdfManager2) {
                            pdfManager2.sendProgressiveData(data2);
                          } else {
                            cachedChunks.push(data2);
                          }
                          fullRequest.read().then(readChunk, reject);
                        } catch (e) {
                          reject(e);
                        }
                      };
                      fullRequest.read().then(readChunk, reject);
                    });
                    readPromise.catch(function(e) {
                      pdfManagerCapability.reject(e);
                      cancelXHRs = null;
                    });
                    cancelXHRs = function(reason) {
                      pdfStream.cancelAllRequests(reason);
                    };
                    return pdfManagerCapability.promise;
                  }
                  function setupDoc(data) {
                    function onSuccess(doc) {
                      ensureNotTerminated();
                      handler.send("GetDoc", { pdfInfo: doc });
                    }
                    function onFailure(ex) {
                      ensureNotTerminated();
                      if (ex instanceof _util2.PasswordException) {
                        var task = new WorkerTask(`PasswordException: response ${ex.code}`);
                        startWorkerTask(task);
                        handler.sendWithPromise("PasswordRequest", ex).then(function(data2) {
                          finishWorkerTask(task);
                          pdfManager.updatePassword(data2.password);
                          pdfManagerReady();
                        }).catch(function() {
                          finishWorkerTask(task);
                          handler.send("DocException", ex);
                        });
                      } else if (ex instanceof _util2.InvalidPDFException || ex instanceof _util2.MissingPDFException || ex instanceof _util2.UnexpectedResponseException || ex instanceof _util2.UnknownErrorException) {
                        handler.send("DocException", ex);
                      } else {
                        handler.send("DocException", new _util2.UnknownErrorException(ex.message, ex.toString()));
                      }
                    }
                    function pdfManagerReady() {
                      ensureNotTerminated();
                      loadDocument(false).then(onSuccess, function loadFailure(ex) {
                        ensureNotTerminated();
                        if (!(ex instanceof _core_utils.XRefParseException)) {
                          onFailure(ex);
                          return;
                        }
                        pdfManager.requestLoadedStream();
                        pdfManager.onLoadedStream().then(function() {
                          ensureNotTerminated();
                          loadDocument(true).then(onSuccess, onFailure);
                        });
                      }, onFailure);
                    }
                    ensureNotTerminated();
                    var evaluatorOptions = { forceDataSchema: data.disableCreateObjectURL, maxImageSize: data.maxImageSize, disableFontFace: data.disableFontFace, nativeImageDecoderSupport: data.nativeImageDecoderSupport, ignoreErrors: data.ignoreErrors, isEvalSupported: data.isEvalSupported };
                    getPdfManager(data, evaluatorOptions).then(function(newPdfManager) {
                      if (terminated) {
                        newPdfManager.terminate(new _util2.AbortException("Worker was terminated."));
                        throw new Error("Worker was terminated");
                      }
                      pdfManager = newPdfManager;
                      pdfManager.onLoadedStream().then(function(stream) {
                        handler.send("DataLoaded", { length: stream.bytes.byteLength });
                      });
                    }).then(pdfManagerReady, onFailure);
                  }
                  handler.on("GetPage", function wphSetupGetPage(data) {
                    return pdfManager.getPage(data.pageIndex).then(function(page) {
                      return Promise.all([pdfManager.ensure(page, "rotate"), pdfManager.ensure(page, "ref"), pdfManager.ensure(page, "userUnit"), pdfManager.ensure(page, "view")]).then(function([rotate, ref, userUnit, view]) {
                        return { rotate, ref, userUnit, view };
                      });
                    });
                  });
                  handler.on("GetPageIndex", function wphSetupGetPageIndex(data) {
                    var ref = _primitives.Ref.get(data.ref.num, data.ref.gen);
                    var catalog = pdfManager.pdfDocument.catalog;
                    return catalog.getPageIndex(ref);
                  });
                  handler.on("GetDestinations", function wphSetupGetDestinations(data) {
                    return pdfManager.ensureCatalog("destinations");
                  });
                  handler.on("GetDestination", function wphSetupGetDestination(data) {
                    return pdfManager.ensureCatalog("getDestination", [data.id]);
                  });
                  handler.on("GetPageLabels", function wphSetupGetPageLabels(data) {
                    return pdfManager.ensureCatalog("pageLabels");
                  });
                  handler.on("GetPageLayout", function wphSetupGetPageLayout(data) {
                    return pdfManager.ensureCatalog("pageLayout");
                  });
                  handler.on("GetPageMode", function wphSetupGetPageMode(data) {
                    return pdfManager.ensureCatalog("pageMode");
                  });
                  handler.on("GetViewerPreferences", function(data) {
                    return pdfManager.ensureCatalog("viewerPreferences");
                  });
                  handler.on("GetOpenAction", function(data) {
                    return pdfManager.ensureCatalog("openAction");
                  });
                  handler.on("GetAttachments", function wphSetupGetAttachments(data) {
                    return pdfManager.ensureCatalog("attachments");
                  });
                  handler.on("GetJavaScript", function wphSetupGetJavaScript(data) {
                    return pdfManager.ensureCatalog("javaScript");
                  });
                  handler.on("GetOutline", function wphSetupGetOutline(data) {
                    return pdfManager.ensureCatalog("documentOutline");
                  });
                  handler.on("GetPermissions", function(data) {
                    return pdfManager.ensureCatalog("permissions");
                  });
                  handler.on("GetMetadata", function wphSetupGetMetadata(data) {
                    return Promise.all([pdfManager.ensureDoc("documentInfo"), pdfManager.ensureCatalog("metadata")]);
                  });
                  handler.on("GetData", function wphSetupGetData(data) {
                    pdfManager.requestLoadedStream();
                    return pdfManager.onLoadedStream().then(function(stream) {
                      return stream.bytes;
                    });
                  });
                  handler.on("GetStats", function wphSetupGetStats(data) {
                    return pdfManager.pdfDocument.xref.stats;
                  });
                  handler.on("GetAnnotations", function({ pageIndex, intent }) {
                    return pdfManager.getPage(pageIndex).then(function(page) {
                      return page.getAnnotationsData(intent);
                    });
                  });
                  handler.on("GetOperatorList", function wphSetupRenderPage(data, sink) {
                    var pageIndex = data.pageIndex;
                    pdfManager.getPage(pageIndex).then(function(page) {
                      var task = new WorkerTask(`GetOperatorList: page ${pageIndex}`);
                      startWorkerTask(task);
                      const start = verbosity >= _util2.VerbosityLevel.INFOS ? Date.now() : 0;
                      page.getOperatorList({ handler, sink, task, intent: data.intent, renderInteractiveForms: data.renderInteractiveForms }).then(function(operatorListInfo) {
                        finishWorkerTask(task);
                        if (start) {
                          (0, _util2.info)(`page=${pageIndex + 1} - getOperatorList: time=${Date.now() - start}ms, len=${operatorListInfo.length}`);
                        }
                        sink.close();
                      }, function(reason) {
                        finishWorkerTask(task);
                        if (task.terminated) {
                          return;
                        }
                        handler.send("UnsupportedFeature", { featureId: _util2.UNSUPPORTED_FEATURES.unknown });
                        sink.error(reason);
                      });
                    });
                  }, this);
                  handler.on("GetTextContent", function wphExtractText(data, sink) {
                    var pageIndex = data.pageIndex;
                    sink.onPull = function(desiredSize) {
                    };
                    sink.onCancel = function(reason) {
                    };
                    pdfManager.getPage(pageIndex).then(function(page) {
                      var task = new WorkerTask("GetTextContent: page " + pageIndex);
                      startWorkerTask(task);
                      const start = verbosity >= _util2.VerbosityLevel.INFOS ? Date.now() : 0;
                      page.extractTextContent({ handler, task, sink, normalizeWhitespace: data.normalizeWhitespace, combineTextItems: data.combineTextItems }).then(function() {
                        finishWorkerTask(task);
                        if (start) {
                          (0, _util2.info)(`page=${pageIndex + 1} - getTextContent: time=${Date.now() - start}ms`);
                        }
                        sink.close();
                      }, function(reason) {
                        finishWorkerTask(task);
                        if (task.terminated) {
                          return;
                        }
                        sink.error(reason);
                      });
                    });
                  });
                  handler.on("FontFallback", function(data) {
                    return pdfManager.fontFallback(data.id, handler);
                  });
                  handler.on("Cleanup", function wphCleanup(data) {
                    return pdfManager.cleanup();
                  });
                  handler.on("Terminate", function wphTerminate(data) {
                    terminated = true;
                    const waitOn = [];
                    if (pdfManager) {
                      pdfManager.terminate(new _util2.AbortException("Worker was terminated."));
                      const cleanupPromise = pdfManager.cleanup();
                      waitOn.push(cleanupPromise);
                      pdfManager = null;
                    } else {
                      (0, _primitives.clearPrimitiveCaches)();
                    }
                    if (cancelXHRs) {
                      cancelXHRs(new _util2.AbortException("Worker was terminated."));
                    }
                    WorkerTasks.forEach(function(task) {
                      waitOn.push(task.finished);
                      task.terminate();
                    });
                    return Promise.all(waitOn).then(function() {
                      handler.destroy();
                      handler = null;
                    });
                  });
                  handler.on("Ready", function wphReady(data) {
                    setupDoc(docParams);
                    docParams = null;
                  });
                  return workerHandlerName;
                }, initializeFromPort(port) {
                  var handler = new _message_handler2.MessageHandler("worker", "main", port);
                  WorkerMessageHandler.setup(handler, port);
                  handler.send("ready", null);
                } };
                exports2.WorkerMessageHandler = WorkerMessageHandler;
                function isMessagePort(maybePort) {
                  return typeof maybePort.postMessage === "function" && "onmessage" in maybePort;
                }
                if (typeof window === "undefined" && !_is_node2.isNodeJS && typeof self !== "undefined" && isMessagePort(self)) {
                  WorkerMessageHandler.initializeFromPort(self);
                }
              }, function(module3, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.arrayByteLength = arrayByteLength;
                exports2.arraysToBytes = arraysToBytes;
                exports2.assert = assert;
                exports2.bytesToString = bytesToString;
                exports2.createPromiseCapability = createPromiseCapability;
                exports2.getVerbosityLevel = getVerbosityLevel;
                exports2.info = info;
                exports2.isArrayBuffer = isArrayBuffer;
                exports2.isArrayEqual = isArrayEqual;
                exports2.isBool = isBool;
                exports2.isEmptyObj = isEmptyObj;
                exports2.isNum = isNum;
                exports2.isString = isString;
                exports2.isSameOrigin = isSameOrigin;
                exports2.createValidAbsoluteUrl = createValidAbsoluteUrl;
                exports2.removeNullCharacters = removeNullCharacters;
                exports2.setVerbosityLevel = setVerbosityLevel;
                exports2.shadow = shadow;
                exports2.string32 = string32;
                exports2.stringToBytes = stringToBytes;
                exports2.stringToPDFString = stringToPDFString;
                exports2.stringToUTF8String = stringToUTF8String;
                exports2.utf8StringToString = utf8StringToString;
                exports2.warn = warn;
                exports2.unreachable = unreachable;
                exports2.IsEvalSupportedCached = exports2.IsLittleEndianCached = exports2.createObjectURL = exports2.FormatError = exports2.Util = exports2.UnknownErrorException = exports2.UnexpectedResponseException = exports2.TextRenderingMode = exports2.StreamType = exports2.PermissionFlag = exports2.PasswordResponses = exports2.PasswordException = exports2.NativeImageDecoding = exports2.MissingPDFException = exports2.InvalidPDFException = exports2.AbortException = exports2.CMapCompressionType = exports2.ImageKind = exports2.FontType = exports2.AnnotationType = exports2.AnnotationStateModelType = exports2.AnnotationReviewState = exports2.AnnotationReplyType = exports2.AnnotationMarkedState = exports2.AnnotationFlag = exports2.AnnotationFieldFlag = exports2.AnnotationBorderStyleType = exports2.UNSUPPORTED_FEATURES = exports2.VerbosityLevel = exports2.OPS = exports2.IDENTITY_MATRIX = exports2.FONT_IDENTITY_MATRIX = exports2.BaseException = void 0;
                __w_pdfjs_require__2(3);
                const IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
                exports2.IDENTITY_MATRIX = IDENTITY_MATRIX;
                const FONT_IDENTITY_MATRIX = [1e-3, 0, 0, 1e-3, 0, 0];
                exports2.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;
                const NativeImageDecoding = { NONE: "none", DECODE: "decode", DISPLAY: "display" };
                exports2.NativeImageDecoding = NativeImageDecoding;
                const PermissionFlag = { PRINT: 4, MODIFY_CONTENTS: 8, COPY: 16, MODIFY_ANNOTATIONS: 32, FILL_INTERACTIVE_FORMS: 256, COPY_FOR_ACCESSIBILITY: 512, ASSEMBLE: 1024, PRINT_HIGH_QUALITY: 2048 };
                exports2.PermissionFlag = PermissionFlag;
                const TextRenderingMode = { FILL: 0, STROKE: 1, FILL_STROKE: 2, INVISIBLE: 3, FILL_ADD_TO_PATH: 4, STROKE_ADD_TO_PATH: 5, FILL_STROKE_ADD_TO_PATH: 6, ADD_TO_PATH: 7, FILL_STROKE_MASK: 3, ADD_TO_PATH_FLAG: 4 };
                exports2.TextRenderingMode = TextRenderingMode;
                const ImageKind = { GRAYSCALE_1BPP: 1, RGB_24BPP: 2, RGBA_32BPP: 3 };
                exports2.ImageKind = ImageKind;
                const AnnotationType = { TEXT: 1, LINK: 2, FREETEXT: 3, LINE: 4, SQUARE: 5, CIRCLE: 6, POLYGON: 7, POLYLINE: 8, HIGHLIGHT: 9, UNDERLINE: 10, SQUIGGLY: 11, STRIKEOUT: 12, STAMP: 13, CARET: 14, INK: 15, POPUP: 16, FILEATTACHMENT: 17, SOUND: 18, MOVIE: 19, WIDGET: 20, SCREEN: 21, PRINTERMARK: 22, TRAPNET: 23, WATERMARK: 24, THREED: 25, REDACT: 26 };
                exports2.AnnotationType = AnnotationType;
                const AnnotationStateModelType = { MARKED: "Marked", REVIEW: "Review" };
                exports2.AnnotationStateModelType = AnnotationStateModelType;
                const AnnotationMarkedState = { MARKED: "Marked", UNMARKED: "Unmarked" };
                exports2.AnnotationMarkedState = AnnotationMarkedState;
                const AnnotationReviewState = { ACCEPTED: "Accepted", REJECTED: "Rejected", CANCELLED: "Cancelled", COMPLETED: "Completed", NONE: "None" };
                exports2.AnnotationReviewState = AnnotationReviewState;
                const AnnotationReplyType = { GROUP: "Group", REPLY: "R" };
                exports2.AnnotationReplyType = AnnotationReplyType;
                const AnnotationFlag = { INVISIBLE: 1, HIDDEN: 2, PRINT: 4, NOZOOM: 8, NOROTATE: 16, NOVIEW: 32, READONLY: 64, LOCKED: 128, TOGGLENOVIEW: 256, LOCKEDCONTENTS: 512 };
                exports2.AnnotationFlag = AnnotationFlag;
                const AnnotationFieldFlag = { READONLY: 1, REQUIRED: 2, NOEXPORT: 4, MULTILINE: 4096, PASSWORD: 8192, NOTOGGLETOOFF: 16384, RADIO: 32768, PUSHBUTTON: 65536, COMBO: 131072, EDIT: 262144, SORT: 524288, FILESELECT: 1048576, MULTISELECT: 2097152, DONOTSPELLCHECK: 4194304, DONOTSCROLL: 8388608, COMB: 16777216, RICHTEXT: 33554432, RADIOSINUNISON: 33554432, COMMITONSELCHANGE: 67108864 };
                exports2.AnnotationFieldFlag = AnnotationFieldFlag;
                const AnnotationBorderStyleType = { SOLID: 1, DASHED: 2, BEVELED: 3, INSET: 4, UNDERLINE: 5 };
                exports2.AnnotationBorderStyleType = AnnotationBorderStyleType;
                const StreamType = { UNKNOWN: "UNKNOWN", FLATE: "FLATE", LZW: "LZW", DCT: "DCT", JPX: "JPX", JBIG: "JBIG", A85: "A85", AHX: "AHX", CCF: "CCF", RLX: "RLX" };
                exports2.StreamType = StreamType;
                const FontType = { UNKNOWN: "UNKNOWN", TYPE1: "TYPE1", TYPE1C: "TYPE1C", CIDFONTTYPE0: "CIDFONTTYPE0", CIDFONTTYPE0C: "CIDFONTTYPE0C", TRUETYPE: "TRUETYPE", CIDFONTTYPE2: "CIDFONTTYPE2", TYPE3: "TYPE3", OPENTYPE: "OPENTYPE", TYPE0: "TYPE0", MMTYPE1: "MMTYPE1" };
                exports2.FontType = FontType;
                const VerbosityLevel = { ERRORS: 0, WARNINGS: 1, INFOS: 5 };
                exports2.VerbosityLevel = VerbosityLevel;
                const CMapCompressionType = { NONE: 0, BINARY: 1, STREAM: 2 };
                exports2.CMapCompressionType = CMapCompressionType;
                const OPS = { dependency: 1, setLineWidth: 2, setLineCap: 3, setLineJoin: 4, setMiterLimit: 5, setDash: 6, setRenderingIntent: 7, setFlatness: 8, setGState: 9, save: 10, restore: 11, transform: 12, moveTo: 13, lineTo: 14, curveTo: 15, curveTo2: 16, curveTo3: 17, closePath: 18, rectangle: 19, stroke: 20, closeStroke: 21, fill: 22, eoFill: 23, fillStroke: 24, eoFillStroke: 25, closeFillStroke: 26, closeEOFillStroke: 27, endPath: 28, clip: 29, eoClip: 30, beginText: 31, endText: 32, setCharSpacing: 33, setWordSpacing: 34, setHScale: 35, setLeading: 36, setFont: 37, setTextRenderingMode: 38, setTextRise: 39, moveText: 40, setLeadingMoveText: 41, setTextMatrix: 42, nextLine: 43, showText: 44, showSpacedText: 45, nextLineShowText: 46, nextLineSetSpacingShowText: 47, setCharWidth: 48, setCharWidthAndBounds: 49, setStrokeColorSpace: 50, setFillColorSpace: 51, setStrokeColor: 52, setStrokeColorN: 53, setFillColor: 54, setFillColorN: 55, setStrokeGray: 56, setFillGray: 57, setStrokeRGBColor: 58, setFillRGBColor: 59, setStrokeCMYKColor: 60, setFillCMYKColor: 61, shadingFill: 62, beginInlineImage: 63, beginImageData: 64, endInlineImage: 65, paintXObject: 66, markPoint: 67, markPointProps: 68, beginMarkedContent: 69, beginMarkedContentProps: 70, endMarkedContent: 71, beginCompat: 72, endCompat: 73, paintFormXObjectBegin: 74, paintFormXObjectEnd: 75, beginGroup: 76, endGroup: 77, beginAnnotations: 78, endAnnotations: 79, beginAnnotation: 80, endAnnotation: 81, paintJpegXObject: 82, paintImageMaskXObject: 83, paintImageMaskXObjectGroup: 84, paintImageXObject: 85, paintInlineImageXObject: 86, paintInlineImageXObjectGroup: 87, paintImageXObjectRepeat: 88, paintImageMaskXObjectRepeat: 89, paintSolidColorImageMask: 90, constructPath: 91 };
                exports2.OPS = OPS;
                const UNSUPPORTED_FEATURES = { unknown: "unknown", forms: "forms", javaScript: "javaScript", smask: "smask", shadingPattern: "shadingPattern", font: "font" };
                exports2.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES;
                const PasswordResponses = { NEED_PASSWORD: 1, INCORRECT_PASSWORD: 2 };
                exports2.PasswordResponses = PasswordResponses;
                let verbosity = VerbosityLevel.WARNINGS;
                function setVerbosityLevel(level) {
                  if (Number.isInteger(level)) {
                    verbosity = level;
                  }
                }
                function getVerbosityLevel() {
                  return verbosity;
                }
                function info(msg) {
                  if (verbosity >= VerbosityLevel.INFOS) {
                    console.log(`Info: ${msg}`);
                  }
                }
                function warn(msg) {
                  if (verbosity >= VerbosityLevel.WARNINGS) {
                    console.log(`Warning: ${msg}`);
                  }
                }
                function unreachable(msg) {
                  throw new Error(msg);
                }
                function assert(cond, msg) {
                  if (!cond) {
                    unreachable(msg);
                  }
                }
                function isSameOrigin(baseUrl, otherUrl) {
                  let base;
                  try {
                    base = new URL(baseUrl);
                    if (!base.origin || base.origin === "null") {
                      return false;
                    }
                  } catch (e) {
                    return false;
                  }
                  const other = new URL(otherUrl, base);
                  return base.origin === other.origin;
                }
                function _isValidProtocol(url) {
                  if (!url) {
                    return false;
                  }
                  switch (url.protocol) {
                    case "http:":
                    case "https:":
                    case "ftp:":
                    case "mailto:":
                    case "tel:":
                      return true;
                    default:
                      return false;
                  }
                }
                function createValidAbsoluteUrl(url, baseUrl) {
                  if (!url) {
                    return null;
                  }
                  try {
                    const absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);
                    if (_isValidProtocol(absoluteUrl)) {
                      return absoluteUrl;
                    }
                  } catch (ex) {
                  }
                  return null;
                }
                function shadow(obj, prop, value) {
                  Object.defineProperty(obj, prop, { value, enumerable: true, configurable: true, writable: false });
                  return value;
                }
                const BaseException = function BaseExceptionClosure() {
                  function BaseException2(message) {
                    if (this.constructor === BaseException2) {
                      unreachable("Cannot initialize BaseException.");
                    }
                    this.message = message;
                    this.name = this.constructor.name;
                  }
                  BaseException2.prototype = new Error();
                  BaseException2.constructor = BaseException2;
                  return BaseException2;
                }();
                exports2.BaseException = BaseException;
                class PasswordException extends BaseException {
                  constructor(msg, code) {
                    super(msg);
                    this.code = code;
                  }
                }
                exports2.PasswordException = PasswordException;
                class UnknownErrorException extends BaseException {
                  constructor(msg, details) {
                    super(msg);
                    this.details = details;
                  }
                }
                exports2.UnknownErrorException = UnknownErrorException;
                class InvalidPDFException extends BaseException {
                }
                exports2.InvalidPDFException = InvalidPDFException;
                class MissingPDFException extends BaseException {
                }
                exports2.MissingPDFException = MissingPDFException;
                class UnexpectedResponseException extends BaseException {
                  constructor(msg, status) {
                    super(msg);
                    this.status = status;
                  }
                }
                exports2.UnexpectedResponseException = UnexpectedResponseException;
                class FormatError extends BaseException {
                }
                exports2.FormatError = FormatError;
                class AbortException extends BaseException {
                }
                exports2.AbortException = AbortException;
                const NullCharactersRegExp = /\x00/g;
                function removeNullCharacters(str) {
                  if (typeof str !== "string") {
                    warn("The argument for removeNullCharacters must be a string.");
                    return str;
                  }
                  return str.replace(NullCharactersRegExp, "");
                }
                function bytesToString(bytes) {
                  assert(bytes !== null && typeof bytes === "object" && bytes.length !== void 0, "Invalid argument for bytesToString");
                  const length = bytes.length;
                  const MAX_ARGUMENT_COUNT = 8192;
                  if (length < MAX_ARGUMENT_COUNT) {
                    return String.fromCharCode.apply(null, bytes);
                  }
                  const strBuf = [];
                  for (let i = 0; i < length; i += MAX_ARGUMENT_COUNT) {
                    const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);
                    const chunk = bytes.subarray(i, chunkEnd);
                    strBuf.push(String.fromCharCode.apply(null, chunk));
                  }
                  return strBuf.join("");
                }
                function stringToBytes(str) {
                  assert(typeof str === "string", "Invalid argument for stringToBytes");
                  const length = str.length;
                  const bytes = new Uint8Array(length);
                  for (let i = 0; i < length; ++i) {
                    bytes[i] = str.charCodeAt(i) & 255;
                  }
                  return bytes;
                }
                function arrayByteLength(arr) {
                  if (arr.length !== void 0) {
                    return arr.length;
                  }
                  assert(arr.byteLength !== void 0);
                  return arr.byteLength;
                }
                function arraysToBytes(arr) {
                  const length = arr.length;
                  if (length === 1 && arr[0] instanceof Uint8Array) {
                    return arr[0];
                  }
                  let resultLength = 0;
                  for (let i = 0; i < length; i++) {
                    resultLength += arrayByteLength(arr[i]);
                  }
                  let pos = 0;
                  const data = new Uint8Array(resultLength);
                  for (let i = 0; i < length; i++) {
                    let item = arr[i];
                    if (!(item instanceof Uint8Array)) {
                      if (typeof item === "string") {
                        item = stringToBytes(item);
                      } else {
                        item = new Uint8Array(item);
                      }
                    }
                    const itemLength = item.byteLength;
                    data.set(item, pos);
                    pos += itemLength;
                  }
                  return data;
                }
                function string32(value) {
                  return String.fromCharCode(value >> 24 & 255, value >> 16 & 255, value >> 8 & 255, value & 255);
                }
                function isLittleEndian() {
                  const buffer8 = new Uint8Array(4);
                  buffer8[0] = 1;
                  const view32 = new Uint32Array(buffer8.buffer, 0, 1);
                  return view32[0] === 1;
                }
                const IsLittleEndianCached = { get value() {
                  return shadow(this, "value", isLittleEndian());
                } };
                exports2.IsLittleEndianCached = IsLittleEndianCached;
                function isEvalSupported() {
                  try {
                    new Function("");
                    return true;
                  } catch (e) {
                    return false;
                  }
                }
                const IsEvalSupportedCached = { get value() {
                  return shadow(this, "value", isEvalSupported());
                } };
                exports2.IsEvalSupportedCached = IsEvalSupportedCached;
                const rgbBuf = ["rgb(", 0, ",", 0, ",", 0, ")"];
                class Util {
                  static makeCssRgb(r, g, b) {
                    rgbBuf[1] = r;
                    rgbBuf[3] = g;
                    rgbBuf[5] = b;
                    return rgbBuf.join("");
                  }
                  static transform(m1, m2) {
                    return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
                  }
                  static applyTransform(p, m) {
                    const xt = p[0] * m[0] + p[1] * m[2] + m[4];
                    const yt = p[0] * m[1] + p[1] * m[3] + m[5];
                    return [xt, yt];
                  }
                  static applyInverseTransform(p, m) {
                    const d = m[0] * m[3] - m[1] * m[2];
                    const xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
                    const yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
                    return [xt, yt];
                  }
                  static getAxialAlignedBoundingBox(r, m) {
                    const p1 = Util.applyTransform(r, m);
                    const p2 = Util.applyTransform(r.slice(2, 4), m);
                    const p3 = Util.applyTransform([r[0], r[3]], m);
                    const p4 = Util.applyTransform([r[2], r[1]], m);
                    return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];
                  }
                  static inverseTransform(m) {
                    const d = m[0] * m[3] - m[1] * m[2];
                    return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
                  }
                  static apply3dTransform(m, v) {
                    return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]];
                  }
                  static singularValueDecompose2dScale(m) {
                    const transpose = [m[0], m[2], m[1], m[3]];
                    const a = m[0] * transpose[0] + m[1] * transpose[2];
                    const b = m[0] * transpose[1] + m[1] * transpose[3];
                    const c = m[2] * transpose[0] + m[3] * transpose[2];
                    const d = m[2] * transpose[1] + m[3] * transpose[3];
                    const first = (a + d) / 2;
                    const second = Math.sqrt((a + d) * (a + d) - 4 * (a * d - c * b)) / 2;
                    const sx = first + second || 1;
                    const sy = first - second || 1;
                    return [Math.sqrt(sx), Math.sqrt(sy)];
                  }
                  static normalizeRect(rect) {
                    const r = rect.slice(0);
                    if (rect[0] > rect[2]) {
                      r[0] = rect[2];
                      r[2] = rect[0];
                    }
                    if (rect[1] > rect[3]) {
                      r[1] = rect[3];
                      r[3] = rect[1];
                    }
                    return r;
                  }
                  static intersect(rect1, rect2) {
                    function compare(a, b) {
                      return a - b;
                    }
                    const orderedX = [rect1[0], rect1[2], rect2[0], rect2[2]].sort(compare);
                    const orderedY = [rect1[1], rect1[3], rect2[1], rect2[3]].sort(compare);
                    const result = [];
                    rect1 = Util.normalizeRect(rect1);
                    rect2 = Util.normalizeRect(rect2);
                    if (orderedX[0] === rect1[0] && orderedX[1] === rect2[0] || orderedX[0] === rect2[0] && orderedX[1] === rect1[0]) {
                      result[0] = orderedX[1];
                      result[2] = orderedX[2];
                    } else {
                      return null;
                    }
                    if (orderedY[0] === rect1[1] && orderedY[1] === rect2[1] || orderedY[0] === rect2[1] && orderedY[1] === rect1[1]) {
                      result[1] = orderedY[1];
                      result[3] = orderedY[2];
                    } else {
                      return null;
                    }
                    return result;
                  }
                }
                exports2.Util = Util;
                const PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364];
                function stringToPDFString(str) {
                  const length = str.length, strBuf = [];
                  if (str[0] === "\xFE" && str[1] === "\xFF") {
                    for (let i = 2; i < length; i += 2) {
                      strBuf.push(String.fromCharCode(str.charCodeAt(i) << 8 | str.charCodeAt(i + 1)));
                    }
                  } else if (str[0] === "\xFF" && str[1] === "\xFE") {
                    for (let i = 2; i < length; i += 2) {
                      strBuf.push(String.fromCharCode(str.charCodeAt(i + 1) << 8 | str.charCodeAt(i)));
                    }
                  } else {
                    for (let i = 0; i < length; ++i) {
                      const code = PDFStringTranslateTable[str.charCodeAt(i)];
                      strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));
                    }
                  }
                  return strBuf.join("");
                }
                function stringToUTF8String(str) {
                  return decodeURIComponent(escape(str));
                }
                function utf8StringToString(str) {
                  return unescape(encodeURIComponent(str));
                }
                function isEmptyObj(obj) {
                  for (const key in obj) {
                    return false;
                  }
                  return true;
                }
                function isBool(v) {
                  return typeof v === "boolean";
                }
                function isNum(v) {
                  return typeof v === "number";
                }
                function isString(v) {
                  return typeof v === "string";
                }
                function isArrayBuffer(v) {
                  return typeof v === "object" && v !== null && v.byteLength !== void 0;
                }
                function isArrayEqual(arr1, arr2) {
                  if (arr1.length !== arr2.length) {
                    return false;
                  }
                  return arr1.every(function(element, index) {
                    return element === arr2[index];
                  });
                }
                function createPromiseCapability() {
                  const capability = /* @__PURE__ */ Object.create(null);
                  let isSettled = false;
                  Object.defineProperty(capability, "settled", { get() {
                    return isSettled;
                  } });
                  capability.promise = new Promise(function(resolve, reject) {
                    capability.resolve = function(data) {
                      isSettled = true;
                      resolve(data);
                    };
                    capability.reject = function(reason) {
                      isSettled = true;
                      reject(reason);
                    };
                  });
                  return capability;
                }
                const createObjectURL = function createObjectURLClosure() {
                  const digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
                  return function createObjectURL2(data, contentType, forceDataSchema = false) {
                    if (!forceDataSchema && URL.createObjectURL) {
                      const blob = new Blob([data], { type: contentType });
                      return URL.createObjectURL(blob);
                    }
                    let buffer = `data:${contentType};base64,`;
                    for (let i = 0, ii = data.length; i < ii; i += 3) {
                      const b1 = data[i] & 255;
                      const b2 = data[i + 1] & 255;
                      const b3 = data[i + 2] & 255;
                      const d1 = b1 >> 2, d2 = (b1 & 3) << 4 | b2 >> 4;
                      const d3 = i + 1 < ii ? (b2 & 15) << 2 | b3 >> 6 : 64;
                      const d4 = i + 2 < ii ? b3 & 63 : 64;
                      buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];
                    }
                    return buffer;
                  };
                }();
                exports2.createObjectURL = createObjectURL;
              }, function(module3, exports2, __w_pdfjs_require__2) {
                "use strict";
                ;
              }, function(module3, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.clearPrimitiveCaches = clearPrimitiveCaches;
                exports2.isEOF = isEOF;
                exports2.isCmd = isCmd;
                exports2.isDict = isDict;
                exports2.isName = isName;
                exports2.isRef = isRef;
                exports2.isRefsEqual = isRefsEqual;
                exports2.isStream = isStream;
                exports2.RefSetCache = exports2.RefSet = exports2.Ref = exports2.Name = exports2.Dict = exports2.Cmd = exports2.EOF = void 0;
                var _util2 = __w_pdfjs_require__2(2);
                var EOF = {};
                exports2.EOF = EOF;
                var Name = function NameClosure() {
                  let nameCache = /* @__PURE__ */ Object.create(null);
                  function Name2(name) {
                    this.name = name;
                  }
                  Name2.prototype = {};
                  Name2.get = function Name_get(name) {
                    var nameValue = nameCache[name];
                    return nameValue ? nameValue : nameCache[name] = new Name2(name);
                  };
                  Name2._clearCache = function() {
                    nameCache = /* @__PURE__ */ Object.create(null);
                  };
                  return Name2;
                }();
                exports2.Name = Name;
                var Cmd = function CmdClosure() {
                  let cmdCache = /* @__PURE__ */ Object.create(null);
                  function Cmd2(cmd) {
                    this.cmd = cmd;
                  }
                  Cmd2.prototype = {};
                  Cmd2.get = function Cmd_get(cmd) {
                    var cmdValue = cmdCache[cmd];
                    return cmdValue ? cmdValue : cmdCache[cmd] = new Cmd2(cmd);
                  };
                  Cmd2._clearCache = function() {
                    cmdCache = /* @__PURE__ */ Object.create(null);
                  };
                  return Cmd2;
                }();
                exports2.Cmd = Cmd;
                var Dict = function DictClosure() {
                  var nonSerializable = function nonSerializableClosure() {
                    return nonSerializable;
                  };
                  function Dict2(xref) {
                    this._map = /* @__PURE__ */ Object.create(null);
                    this.xref = xref;
                    this.objId = null;
                    this.suppressEncryption = false;
                    this.__nonSerializable__ = nonSerializable;
                  }
                  Dict2.prototype = { assignXref: function Dict_assignXref(newXref) {
                    this.xref = newXref;
                  }, get(key1, key2, key3) {
                    let value = this._map[key1];
                    if (value === void 0 && key2 !== void 0) {
                      value = this._map[key2];
                      if (value === void 0 && key3 !== void 0) {
                        value = this._map[key3];
                      }
                    }
                    if (value instanceof Ref && this.xref) {
                      return this.xref.fetch(value, this.suppressEncryption);
                    }
                    return value;
                  }, async getAsync(key1, key2, key3) {
                    let value = this._map[key1];
                    if (value === void 0 && key2 !== void 0) {
                      value = this._map[key2];
                      if (value === void 0 && key3 !== void 0) {
                        value = this._map[key3];
                      }
                    }
                    if (value instanceof Ref && this.xref) {
                      return this.xref.fetchAsync(value, this.suppressEncryption);
                    }
                    return value;
                  }, getArray(key1, key2, key3) {
                    let value = this.get(key1, key2, key3);
                    if (!Array.isArray(value) || !this.xref) {
                      return value;
                    }
                    value = value.slice();
                    for (let i = 0, ii = value.length; i < ii; i++) {
                      if (!(value[i] instanceof Ref)) {
                        continue;
                      }
                      value[i] = this.xref.fetch(value[i], this.suppressEncryption);
                    }
                    return value;
                  }, getRaw: function Dict_getRaw(key) {
                    return this._map[key];
                  }, getKeys: function Dict_getKeys() {
                    return Object.keys(this._map);
                  }, set: function Dict_set(key, value) {
                    this._map[key] = value;
                  }, has: function Dict_has(key) {
                    return this._map[key] !== void 0;
                  }, forEach: function Dict_forEach(callback) {
                    for (var key in this._map) {
                      callback(key, this.get(key));
                    }
                  } };
                  Dict2.empty = new Dict2(null);
                  Dict2.merge = function(xref, dictArray) {
                    const mergedDict = new Dict2(xref);
                    for (let i = 0, ii = dictArray.length; i < ii; i++) {
                      const dict = dictArray[i];
                      if (!isDict(dict)) {
                        continue;
                      }
                      for (const keyName in dict._map) {
                        if (mergedDict._map[keyName] !== void 0) {
                          continue;
                        }
                        mergedDict._map[keyName] = dict._map[keyName];
                      }
                    }
                    return mergedDict;
                  };
                  return Dict2;
                }();
                exports2.Dict = Dict;
                var Ref = function RefClosure() {
                  let refCache = /* @__PURE__ */ Object.create(null);
                  function Ref2(num, gen) {
                    this.num = num;
                    this.gen = gen;
                  }
                  Ref2.prototype = { toString: function Ref_toString() {
                    if (this.gen === 0) {
                      return `${this.num}R`;
                    }
                    return `${this.num}R${this.gen}`;
                  } };
                  Ref2.get = function(num, gen) {
                    const key = gen === 0 ? `${num}R` : `${num}R${gen}`;
                    const refValue = refCache[key];
                    return refValue ? refValue : refCache[key] = new Ref2(num, gen);
                  };
                  Ref2._clearCache = function() {
                    refCache = /* @__PURE__ */ Object.create(null);
                  };
                  return Ref2;
                }();
                exports2.Ref = Ref;
                var RefSet = function RefSetClosure() {
                  function RefSet2() {
                    this.dict = /* @__PURE__ */ Object.create(null);
                  }
                  RefSet2.prototype = { has: function RefSet_has(ref) {
                    return ref.toString() in this.dict;
                  }, put: function RefSet_put(ref) {
                    this.dict[ref.toString()] = true;
                  }, remove: function RefSet_remove(ref) {
                    delete this.dict[ref.toString()];
                  } };
                  return RefSet2;
                }();
                exports2.RefSet = RefSet;
                var RefSetCache = function RefSetCacheClosure() {
                  function RefSetCache2() {
                    this.dict = /* @__PURE__ */ Object.create(null);
                  }
                  RefSetCache2.prototype = { get: function RefSetCache_get(ref) {
                    return this.dict[ref.toString()];
                  }, has: function RefSetCache_has(ref) {
                    return ref.toString() in this.dict;
                  }, put: function RefSetCache_put(ref, obj) {
                    this.dict[ref.toString()] = obj;
                  }, putAlias: function RefSetCache_putAlias(ref, aliasRef) {
                    this.dict[ref.toString()] = this.get(aliasRef);
                  }, forEach: function RefSetCache_forEach(callback) {
                    for (const i in this.dict) {
                      callback(this.dict[i]);
                    }
                  }, clear: function RefSetCache_clear() {
                    this.dict = /* @__PURE__ */ Object.create(null);
                  } };
                  return RefSetCache2;
                }();
                exports2.RefSetCache = RefSetCache;
                function isEOF(v) {
                  return v === EOF;
                }
                function isName(v, name) {
                  return v instanceof Name && (name === void 0 || v.name === name);
                }
                function isCmd(v, cmd) {
                  return v instanceof Cmd && (cmd === void 0 || v.cmd === cmd);
                }
                function isDict(v, type) {
                  return v instanceof Dict && (type === void 0 || isName(v.get("Type"), type));
                }
                function isRef(v) {
                  return v instanceof Ref;
                }
                function isRefsEqual(v1, v2) {
                  return v1.num === v2.num && v1.gen === v2.gen;
                }
                function isStream(v) {
                  return typeof v === "object" && v !== null && v.getBytes !== void 0;
                }
                function clearPrimitiveCaches() {
                  Cmd._clearCache();
                  Name._clearCache();
                  Ref._clearCache();
                }
              }, function(module3, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.NetworkPdfManager = exports2.LocalPdfManager = void 0;
                var _util2 = __w_pdfjs_require__2(2);
                var _chunked_stream = __w_pdfjs_require__2(6);
                var _core_utils = __w_pdfjs_require__2(7);
                var _document = __w_pdfjs_require__2(8);
                var _stream = __w_pdfjs_require__2(11);
                class BasePdfManager {
                  constructor() {
                    if (this.constructor === BasePdfManager) {
                      (0, _util2.unreachable)("Cannot initialize BasePdfManager.");
                    }
                  }
                  get docId() {
                    return this._docId;
                  }
                  get password() {
                    return this._password;
                  }
                  get docBaseUrl() {
                    let docBaseUrl = null;
                    if (this._docBaseUrl) {
                      const absoluteUrl = (0, _util2.createValidAbsoluteUrl)(this._docBaseUrl);
                      if (absoluteUrl) {
                        docBaseUrl = absoluteUrl.href;
                      } else {
                        (0, _util2.warn)(`Invalid absolute docBaseUrl: "${this._docBaseUrl}".`);
                      }
                    }
                    return (0, _util2.shadow)(this, "docBaseUrl", docBaseUrl);
                  }
                  onLoadedStream() {
                    (0, _util2.unreachable)("Abstract method `onLoadedStream` called");
                  }
                  ensureDoc(prop, args) {
                    return this.ensure(this.pdfDocument, prop, args);
                  }
                  ensureXRef(prop, args) {
                    return this.ensure(this.pdfDocument.xref, prop, args);
                  }
                  ensureCatalog(prop, args) {
                    return this.ensure(this.pdfDocument.catalog, prop, args);
                  }
                  getPage(pageIndex) {
                    return this.pdfDocument.getPage(pageIndex);
                  }
                  fontFallback(id, handler) {
                    return this.pdfDocument.fontFallback(id, handler);
                  }
                  cleanup() {
                    return this.pdfDocument.cleanup();
                  }
                  async ensure(obj, prop, args) {
                    (0, _util2.unreachable)("Abstract method `ensure` called");
                  }
                  requestRange(begin, end) {
                    (0, _util2.unreachable)("Abstract method `requestRange` called");
                  }
                  requestLoadedStream() {
                    (0, _util2.unreachable)("Abstract method `requestLoadedStream` called");
                  }
                  sendProgressiveData(chunk) {
                    (0, _util2.unreachable)("Abstract method `sendProgressiveData` called");
                  }
                  updatePassword(password) {
                    this._password = password;
                  }
                  terminate(reason) {
                    (0, _util2.unreachable)("Abstract method `terminate` called");
                  }
                }
                class LocalPdfManager extends BasePdfManager {
                  constructor(docId, data, password, evaluatorOptions, docBaseUrl) {
                    super();
                    this._docId = docId;
                    this._password = password;
                    this._docBaseUrl = docBaseUrl;
                    this.evaluatorOptions = evaluatorOptions;
                    const stream = new _stream.Stream(data);
                    this.pdfDocument = new _document.PDFDocument(this, stream);
                    this._loadedStreamPromise = Promise.resolve(stream);
                  }
                  async ensure(obj, prop, args) {
                    const value = obj[prop];
                    if (typeof value === "function") {
                      return value.apply(obj, args);
                    }
                    return value;
                  }
                  requestRange(begin, end) {
                    return Promise.resolve();
                  }
                  requestLoadedStream() {
                  }
                  onLoadedStream() {
                    return this._loadedStreamPromise;
                  }
                  terminate(reason) {
                  }
                }
                exports2.LocalPdfManager = LocalPdfManager;
                class NetworkPdfManager extends BasePdfManager {
                  constructor(docId, pdfNetworkStream, args, evaluatorOptions, docBaseUrl) {
                    super();
                    this._docId = docId;
                    this._password = args.password;
                    this._docBaseUrl = docBaseUrl;
                    this.msgHandler = args.msgHandler;
                    this.evaluatorOptions = evaluatorOptions;
                    this.streamManager = new _chunked_stream.ChunkedStreamManager(pdfNetworkStream, { msgHandler: args.msgHandler, length: args.length, disableAutoFetch: args.disableAutoFetch, rangeChunkSize: args.rangeChunkSize });
                    this.pdfDocument = new _document.PDFDocument(this, this.streamManager.getStream());
                  }
                  async ensure(obj, prop, args) {
                    try {
                      const value = obj[prop];
                      if (typeof value === "function") {
                        return value.apply(obj, args);
                      }
                      return value;
                    } catch (ex) {
                      if (!(ex instanceof _core_utils.MissingDataException)) {
                        throw ex;
                      }
                      await this.requestRange(ex.begin, ex.end);
                      return this.ensure(obj, prop, args);
                    }
                  }
                  requestRange(begin, end) {
                    return this.streamManager.requestRange(begin, end);
                  }
                  requestLoadedStream() {
                    this.streamManager.requestAllChunks();
                  }
                  sendProgressiveData(chunk) {
                    this.streamManager.onReceiveData({ chunk });
                  }
                  onLoadedStream() {
                    return this.streamManager.onLoadedStream();
                  }
                  terminate(reason) {
                    this.streamManager.abort(reason);
                  }
                }
                exports2.NetworkPdfManager = NetworkPdfManager;
              }, function(module3, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.ChunkedStreamManager = exports2.ChunkedStream = void 0;
                var _util2 = __w_pdfjs_require__2(2);
                var _core_utils = __w_pdfjs_require__2(7);
                class ChunkedStream {
                  constructor(length, chunkSize, manager) {
                    this.bytes = new Uint8Array(length);
                    this.start = 0;
                    this.pos = 0;
                    this.end = length;
                    this.chunkSize = chunkSize;
                    this.loadedChunks = [];
                    this.numChunksLoaded = 0;
                    this.numChunks = Math.ceil(length / chunkSize);
                    this.manager = manager;
                    this.progressiveDataLength = 0;
                    this.lastSuccessfulEnsureByteChunk = -1;
                  }
                  getMissingChunks() {
                    const chunks = [];
                    for (let chunk = 0, n = this.numChunks; chunk < n; ++chunk) {
                      if (!this.loadedChunks[chunk]) {
                        chunks.push(chunk);
                      }
                    }
                    return chunks;
                  }
                  getBaseStreams() {
                    return [this];
                  }
                  allChunksLoaded() {
                    return this.numChunksLoaded === this.numChunks;
                  }
                  onReceiveData(begin, chunk) {
                    const chunkSize = this.chunkSize;
                    if (begin % chunkSize !== 0) {
                      throw new Error(`Bad begin offset: ${begin}`);
                    }
                    const end = begin + chunk.byteLength;
                    if (end % chunkSize !== 0 && end !== this.bytes.length) {
                      throw new Error(`Bad end offset: ${end}`);
                    }
                    this.bytes.set(new Uint8Array(chunk), begin);
                    const beginChunk = Math.floor(begin / chunkSize);
                    const endChunk = Math.floor((end - 1) / chunkSize) + 1;
                    for (let curChunk = beginChunk; curChunk < endChunk; ++curChunk) {
                      if (!this.loadedChunks[curChunk]) {
                        this.loadedChunks[curChunk] = true;
                        ++this.numChunksLoaded;
                      }
                    }
                  }
                  onReceiveProgressiveData(data) {
                    let position = this.progressiveDataLength;
                    const beginChunk = Math.floor(position / this.chunkSize);
                    this.bytes.set(new Uint8Array(data), position);
                    position += data.byteLength;
                    this.progressiveDataLength = position;
                    const endChunk = position >= this.end ? this.numChunks : Math.floor(position / this.chunkSize);
                    for (let curChunk = beginChunk; curChunk < endChunk; ++curChunk) {
                      if (!this.loadedChunks[curChunk]) {
                        this.loadedChunks[curChunk] = true;
                        ++this.numChunksLoaded;
                      }
                    }
                  }
                  ensureByte(pos) {
                    if (pos < this.progressiveDataLength) {
                      return;
                    }
                    const chunk = Math.floor(pos / this.chunkSize);
                    if (chunk === this.lastSuccessfulEnsureByteChunk) {
                      return;
                    }
                    if (!this.loadedChunks[chunk]) {
                      throw new _core_utils.MissingDataException(pos, pos + 1);
                    }
                    this.lastSuccessfulEnsureByteChunk = chunk;
                  }
                  ensureRange(begin, end) {
                    if (begin >= end) {
                      return;
                    }
                    if (end <= this.progressiveDataLength) {
                      return;
                    }
                    const chunkSize = this.chunkSize;
                    const beginChunk = Math.floor(begin / chunkSize);
                    const endChunk = Math.floor((end - 1) / chunkSize) + 1;
                    for (let chunk = beginChunk; chunk < endChunk; ++chunk) {
                      if (!this.loadedChunks[chunk]) {
                        throw new _core_utils.MissingDataException(begin, end);
                      }
                    }
                  }
                  nextEmptyChunk(beginChunk) {
                    const numChunks = this.numChunks;
                    for (let i = 0; i < numChunks; ++i) {
                      const chunk = (beginChunk + i) % numChunks;
                      if (!this.loadedChunks[chunk]) {
                        return chunk;
                      }
                    }
                    return null;
                  }
                  hasChunk(chunk) {
                    return !!this.loadedChunks[chunk];
                  }
                  get length() {
                    return this.end - this.start;
                  }
                  get isEmpty() {
                    return this.length === 0;
                  }
                  getByte() {
                    const pos = this.pos;
                    if (pos >= this.end) {
                      return -1;
                    }
                    if (pos >= this.progressiveDataLength) {
                      this.ensureByte(pos);
                    }
                    return this.bytes[this.pos++];
                  }
                  getUint16() {
                    const b0 = this.getByte();
                    const b1 = this.getByte();
                    if (b0 === -1 || b1 === -1) {
                      return -1;
                    }
                    return (b0 << 8) + b1;
                  }
                  getInt32() {
                    const b0 = this.getByte();
                    const b1 = this.getByte();
                    const b2 = this.getByte();
                    const b3 = this.getByte();
                    return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
                  }
                  getBytes(length, forceClamped = false) {
                    const bytes = this.bytes;
                    const pos = this.pos;
                    const strEnd = this.end;
                    if (!length) {
                      if (strEnd > this.progressiveDataLength) {
                        this.ensureRange(pos, strEnd);
                      }
                      const subarray2 = bytes.subarray(pos, strEnd);
                      return forceClamped ? new Uint8ClampedArray(subarray2) : subarray2;
                    }
                    let end = pos + length;
                    if (end > strEnd) {
                      end = strEnd;
                    }
                    if (end > this.progressiveDataLength) {
                      this.ensureRange(pos, end);
                    }
                    this.pos = end;
                    const subarray = bytes.subarray(pos, end);
                    return forceClamped ? new Uint8ClampedArray(subarray) : subarray;
                  }
                  peekByte() {
                    const peekedByte = this.getByte();
                    if (peekedByte !== -1) {
                      this.pos--;
                    }
                    return peekedByte;
                  }
                  peekBytes(length, forceClamped = false) {
                    const bytes = this.getBytes(length, forceClamped);
                    this.pos -= bytes.length;
                    return bytes;
                  }
                  getByteRange(begin, end) {
                    if (begin < 0) {
                      begin = 0;
                    }
                    if (end > this.end) {
                      end = this.end;
                    }
                    if (end > this.progressiveDataLength) {
                      this.ensureRange(begin, end);
                    }
                    return this.bytes.subarray(begin, end);
                  }
                  skip(n) {
                    if (!n) {
                      n = 1;
                    }
                    this.pos += n;
                  }
                  reset() {
                    this.pos = this.start;
                  }
                  moveStart() {
                    this.start = this.pos;
                  }
                  makeSubStream(start, length, dict) {
                    if (length) {
                      if (start + length > this.progressiveDataLength) {
                        this.ensureRange(start, start + length);
                      }
                    } else {
                      if (start >= this.progressiveDataLength) {
                        this.ensureByte(start);
                      }
                    }
                    function ChunkedStreamSubstream() {
                    }
                    ChunkedStreamSubstream.prototype = Object.create(this);
                    ChunkedStreamSubstream.prototype.getMissingChunks = function() {
                      const chunkSize = this.chunkSize;
                      const beginChunk = Math.floor(this.start / chunkSize);
                      const endChunk = Math.floor((this.end - 1) / chunkSize) + 1;
                      const missingChunks = [];
                      for (let chunk = beginChunk; chunk < endChunk; ++chunk) {
                        if (!this.loadedChunks[chunk]) {
                          missingChunks.push(chunk);
                        }
                      }
                      return missingChunks;
                    };
                    ChunkedStreamSubstream.prototype.allChunksLoaded = function() {
                      if (this.numChunksLoaded === this.numChunks) {
                        return true;
                      }
                      return this.getMissingChunks().length === 0;
                    };
                    const subStream = new ChunkedStreamSubstream();
                    subStream.pos = subStream.start = start;
                    subStream.end = start + length || this.end;
                    subStream.dict = dict;
                    return subStream;
                  }
                }
                exports2.ChunkedStream = ChunkedStream;
                class ChunkedStreamManager {
                  constructor(pdfNetworkStream, args) {
                    this.length = args.length;
                    this.chunkSize = args.rangeChunkSize;
                    this.stream = new ChunkedStream(this.length, this.chunkSize, this);
                    this.pdfNetworkStream = pdfNetworkStream;
                    this.disableAutoFetch = args.disableAutoFetch;
                    this.msgHandler = args.msgHandler;
                    this.currRequestId = 0;
                    this.chunksNeededByRequest = /* @__PURE__ */ Object.create(null);
                    this.requestsByChunk = /* @__PURE__ */ Object.create(null);
                    this.promisesByRequest = /* @__PURE__ */ Object.create(null);
                    this.progressiveDataLength = 0;
                    this.aborted = false;
                    this._loadedStreamCapability = (0, _util2.createPromiseCapability)();
                  }
                  onLoadedStream() {
                    return this._loadedStreamCapability.promise;
                  }
                  sendRequest(begin, end) {
                    const rangeReader = this.pdfNetworkStream.getRangeReader(begin, end);
                    if (!rangeReader.isStreamingSupported) {
                      rangeReader.onProgress = this.onProgress.bind(this);
                    }
                    let chunks = [], loaded = 0;
                    const promise = new Promise((resolve, reject) => {
                      const readChunk = (chunk) => {
                        try {
                          if (!chunk.done) {
                            const data = chunk.value;
                            chunks.push(data);
                            loaded += (0, _util2.arrayByteLength)(data);
                            if (rangeReader.isStreamingSupported) {
                              this.onProgress({ loaded });
                            }
                            rangeReader.read().then(readChunk, reject);
                            return;
                          }
                          const chunkData = (0, _util2.arraysToBytes)(chunks);
                          chunks = null;
                          resolve(chunkData);
                        } catch (e) {
                          reject(e);
                        }
                      };
                      rangeReader.read().then(readChunk, reject);
                    });
                    promise.then((data) => {
                      if (this.aborted) {
                        return;
                      }
                      this.onReceiveData({ chunk: data, begin });
                    });
                  }
                  requestAllChunks() {
                    const missingChunks = this.stream.getMissingChunks();
                    this._requestChunks(missingChunks);
                    return this._loadedStreamCapability.promise;
                  }
                  _requestChunks(chunks) {
                    const requestId = this.currRequestId++;
                    const chunksNeeded = /* @__PURE__ */ Object.create(null);
                    this.chunksNeededByRequest[requestId] = chunksNeeded;
                    for (const chunk of chunks) {
                      if (!this.stream.hasChunk(chunk)) {
                        chunksNeeded[chunk] = true;
                      }
                    }
                    if ((0, _util2.isEmptyObj)(chunksNeeded)) {
                      return Promise.resolve();
                    }
                    const capability = (0, _util2.createPromiseCapability)();
                    this.promisesByRequest[requestId] = capability;
                    const chunksToRequest = [];
                    for (let chunk in chunksNeeded) {
                      chunk = chunk | 0;
                      if (!(chunk in this.requestsByChunk)) {
                        this.requestsByChunk[chunk] = [];
                        chunksToRequest.push(chunk);
                      }
                      this.requestsByChunk[chunk].push(requestId);
                    }
                    if (!chunksToRequest.length) {
                      return capability.promise;
                    }
                    const groupedChunksToRequest = this.groupChunks(chunksToRequest);
                    for (const groupedChunk of groupedChunksToRequest) {
                      const begin = groupedChunk.beginChunk * this.chunkSize;
                      const end = Math.min(groupedChunk.endChunk * this.chunkSize, this.length);
                      this.sendRequest(begin, end);
                    }
                    return capability.promise;
                  }
                  getStream() {
                    return this.stream;
                  }
                  requestRange(begin, end) {
                    end = Math.min(end, this.length);
                    const beginChunk = this.getBeginChunk(begin);
                    const endChunk = this.getEndChunk(end);
                    const chunks = [];
                    for (let chunk = beginChunk; chunk < endChunk; ++chunk) {
                      chunks.push(chunk);
                    }
                    return this._requestChunks(chunks);
                  }
                  requestRanges(ranges = []) {
                    const chunksToRequest = [];
                    for (const range of ranges) {
                      const beginChunk = this.getBeginChunk(range.begin);
                      const endChunk = this.getEndChunk(range.end);
                      for (let chunk = beginChunk; chunk < endChunk; ++chunk) {
                        if (!chunksToRequest.includes(chunk)) {
                          chunksToRequest.push(chunk);
                        }
                      }
                    }
                    chunksToRequest.sort(function(a, b) {
                      return a - b;
                    });
                    return this._requestChunks(chunksToRequest);
                  }
                  groupChunks(chunks) {
                    const groupedChunks = [];
                    let beginChunk = -1;
                    let prevChunk = -1;
                    for (let i = 0, ii = chunks.length; i < ii; ++i) {
                      const chunk = chunks[i];
                      if (beginChunk < 0) {
                        beginChunk = chunk;
                      }
                      if (prevChunk >= 0 && prevChunk + 1 !== chunk) {
                        groupedChunks.push({ beginChunk, endChunk: prevChunk + 1 });
                        beginChunk = chunk;
                      }
                      if (i + 1 === chunks.length) {
                        groupedChunks.push({ beginChunk, endChunk: chunk + 1 });
                      }
                      prevChunk = chunk;
                    }
                    return groupedChunks;
                  }
                  onProgress(args) {
                    this.msgHandler.send("DocProgress", { loaded: this.stream.numChunksLoaded * this.chunkSize + args.loaded, total: this.length });
                  }
                  onReceiveData(args) {
                    const chunk = args.chunk;
                    const isProgressive = args.begin === void 0;
                    const begin = isProgressive ? this.progressiveDataLength : args.begin;
                    const end = begin + chunk.byteLength;
                    const beginChunk = Math.floor(begin / this.chunkSize);
                    const endChunk = end < this.length ? Math.floor(end / this.chunkSize) : Math.ceil(end / this.chunkSize);
                    if (isProgressive) {
                      this.stream.onReceiveProgressiveData(chunk);
                      this.progressiveDataLength = end;
                    } else {
                      this.stream.onReceiveData(begin, chunk);
                    }
                    if (this.stream.allChunksLoaded()) {
                      this._loadedStreamCapability.resolve(this.stream);
                    }
                    const loadedRequests = [];
                    for (let chunk2 = beginChunk; chunk2 < endChunk; ++chunk2) {
                      const requestIds = this.requestsByChunk[chunk2] || [];
                      delete this.requestsByChunk[chunk2];
                      for (const requestId of requestIds) {
                        const chunksNeeded = this.chunksNeededByRequest[requestId];
                        if (chunk2 in chunksNeeded) {
                          delete chunksNeeded[chunk2];
                        }
                        if (!(0, _util2.isEmptyObj)(chunksNeeded)) {
                          continue;
                        }
                        loadedRequests.push(requestId);
                      }
                    }
                    if (!this.disableAutoFetch && (0, _util2.isEmptyObj)(this.requestsByChunk)) {
                      let nextEmptyChunk;
                      if (this.stream.numChunksLoaded === 1) {
                        const lastChunk = this.stream.numChunks - 1;
                        if (!this.stream.hasChunk(lastChunk)) {
                          nextEmptyChunk = lastChunk;
                        }
                      } else {
                        nextEmptyChunk = this.stream.nextEmptyChunk(endChunk);
                      }
                      if (Number.isInteger(nextEmptyChunk)) {
                        this._requestChunks([nextEmptyChunk]);
                      }
                    }
                    for (const requestId of loadedRequests) {
                      const capability = this.promisesByRequest[requestId];
                      delete this.promisesByRequest[requestId];
                      capability.resolve();
                    }
                    this.msgHandler.send("DocProgress", { loaded: this.stream.numChunksLoaded * this.chunkSize, total: this.length });
                  }
                  onError(err) {
                    this._loadedStreamCapability.reject(err);
                  }
                  getBeginChunk(begin) {
                    return Math.floor(begin / this.chunkSize);
                  }
                  getEndChunk(end) {
                    return Math.floor((end - 1) / this.chunkSize) + 1;
                  }
                  abort(reason) {
                    this.aborted = true;
                    if (this.pdfNetworkStream) {
                      this.pdfNetworkStream.cancelAllRequests(reason);
                    }
                    for (const requestId in this.promisesByRequest) {
                      this.promisesByRequest[requestId].reject(reason);
                    }
                  }
                }
                exports2.ChunkedStreamManager = ChunkedStreamManager;
              }, function(module3, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.getLookupTableFactory = getLookupTableFactory;
                exports2.getInheritableProperty = getInheritableProperty;
                exports2.toRomanNumerals = toRomanNumerals;
                exports2.log2 = log2;
                exports2.readInt8 = readInt8;
                exports2.readUint16 = readUint16;
                exports2.readUint32 = readUint32;
                exports2.isWhiteSpace = isWhiteSpace;
                exports2.XRefParseException = exports2.XRefEntryException = exports2.MissingDataException = void 0;
                var _util2 = __w_pdfjs_require__2(2);
                function getLookupTableFactory(initializer) {
                  let lookup;
                  return function() {
                    if (initializer) {
                      lookup = /* @__PURE__ */ Object.create(null);
                      initializer(lookup);
                      initializer = null;
                    }
                    return lookup;
                  };
                }
                class MissingDataException extends _util2.BaseException {
                  constructor(begin, end) {
                    super(`Missing data [${begin}, ${end})`);
                    this.begin = begin;
                    this.end = end;
                  }
                }
                exports2.MissingDataException = MissingDataException;
                class XRefEntryException extends _util2.BaseException {
                }
                exports2.XRefEntryException = XRefEntryException;
                class XRefParseException extends _util2.BaseException {
                }
                exports2.XRefParseException = XRefParseException;
                function getInheritableProperty({ dict, key, getArray = false, stopWhenFound = true }) {
                  const LOOP_LIMIT = 100;
                  let loopCount = 0;
                  let values;
                  while (dict) {
                    const value = getArray ? dict.getArray(key) : dict.get(key);
                    if (value !== void 0) {
                      if (stopWhenFound) {
                        return value;
                      }
                      if (!values) {
                        values = [];
                      }
                      values.push(value);
                    }
                    if (++loopCount > LOOP_LIMIT) {
                      (0, _util2.warn)(`getInheritableProperty: maximum loop count exceeded for "${key}"`);
                      break;
                    }
                    dict = dict.get("Parent");
                  }
                  return values;
                }
                const ROMAN_NUMBER_MAP = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM", "", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC", "", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"];
                function toRomanNumerals(number, lowerCase = false) {
                  (0, _util2.assert)(Number.isInteger(number) && number > 0, "The number should be a positive integer.");
                  const romanBuf = [];
                  let pos;
                  while (number >= 1e3) {
                    number -= 1e3;
                    romanBuf.push("M");
                  }
                  pos = number / 100 | 0;
                  number %= 100;
                  romanBuf.push(ROMAN_NUMBER_MAP[pos]);
                  pos = number / 10 | 0;
                  number %= 10;
                  romanBuf.push(ROMAN_NUMBER_MAP[10 + pos]);
                  romanBuf.push(ROMAN_NUMBER_MAP[20 + number]);
                  const romanStr = romanBuf.join("");
                  return lowerCase ? romanStr.toLowerCase() : romanStr;
                }
                function log2(x) {
                  if (x <= 0) {
                    return 0;
                  }
                  return Math.ceil(Math.log2(x));
                }
                function readInt8(data, offset) {
                  return data[offset] << 24 >> 24;
                }
                function readUint16(data, offset) {
                  return data[offset] << 8 | data[offset + 1];
                }
                function readUint32(data, offset) {
                  return (data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3]) >>> 0;
                }
                function isWhiteSpace(ch) {
                  return ch === 32 || ch === 9 || ch === 13 || ch === 10;
                }
              }, function(module3, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.PDFDocument = exports2.Page = void 0;
                var _util2 = __w_pdfjs_require__2(2);
                var _obj = __w_pdfjs_require__2(9);
                var _primitives = __w_pdfjs_require__2(4);
                var _core_utils = __w_pdfjs_require__2(7);
                var _stream = __w_pdfjs_require__2(11);
                var _annotation = __w_pdfjs_require__2(23);
                var _crypto = __w_pdfjs_require__2(21);
                var _parser = __w_pdfjs_require__2(10);
                var _operator_list = __w_pdfjs_require__2(24);
                var _evaluator = __w_pdfjs_require__2(25);
                var _function = __w_pdfjs_require__2(39);
                const DEFAULT_USER_UNIT = 1;
                const LETTER_SIZE_MEDIABOX = [0, 0, 612, 792];
                function isAnnotationRenderable(annotation, intent) {
                  return intent === "display" && annotation.viewable || intent === "print" && annotation.printable;
                }
                class Page {
                  constructor({ pdfManager, xref, pageIndex, pageDict, ref, fontCache, builtInCMapCache, pdfFunctionFactory }) {
                    this.pdfManager = pdfManager;
                    this.pageIndex = pageIndex;
                    this.pageDict = pageDict;
                    this.xref = xref;
                    this.ref = ref;
                    this.fontCache = fontCache;
                    this.builtInCMapCache = builtInCMapCache;
                    this.pdfFunctionFactory = pdfFunctionFactory;
                    this.evaluatorOptions = pdfManager.evaluatorOptions;
                    this.resourcesPromise = null;
                    const idCounters = { obj: 0 };
                    this.idFactory = { createObjId() {
                      return `p${pageIndex}_${++idCounters.obj}`;
                    }, getDocId() {
                      return `g_${pdfManager.docId}`;
                    } };
                  }
                  _getInheritableProperty(key, getArray = false) {
                    const value = (0, _core_utils.getInheritableProperty)({ dict: this.pageDict, key, getArray, stopWhenFound: false });
                    if (!Array.isArray(value)) {
                      return value;
                    }
                    if (value.length === 1 || !(0, _primitives.isDict)(value[0])) {
                      return value[0];
                    }
                    return _primitives.Dict.merge(this.xref, value);
                  }
                  get content() {
                    return this.pageDict.get("Contents");
                  }
                  get resources() {
                    return (0, _util2.shadow)(this, "resources", this._getInheritableProperty("Resources") || _primitives.Dict.empty);
                  }
                  _getBoundingBox(name) {
                    const box = this._getInheritableProperty(name, true);
                    if (Array.isArray(box) && box.length === 4) {
                      if (box[2] - box[0] !== 0 && box[3] - box[1] !== 0) {
                        return box;
                      }
                      (0, _util2.warn)(`Empty /${name} entry.`);
                    }
                    return null;
                  }
                  get mediaBox() {
                    return (0, _util2.shadow)(this, "mediaBox", this._getBoundingBox("MediaBox") || LETTER_SIZE_MEDIABOX);
                  }
                  get cropBox() {
                    return (0, _util2.shadow)(this, "cropBox", this._getBoundingBox("CropBox") || this.mediaBox);
                  }
                  get userUnit() {
                    let obj = this.pageDict.get("UserUnit");
                    if (!(0, _util2.isNum)(obj) || obj <= 0) {
                      obj = DEFAULT_USER_UNIT;
                    }
                    return (0, _util2.shadow)(this, "userUnit", obj);
                  }
                  get view() {
                    const { cropBox, mediaBox } = this;
                    let view;
                    if (cropBox === mediaBox || (0, _util2.isArrayEqual)(cropBox, mediaBox)) {
                      view = mediaBox;
                    } else {
                      const box = _util2.Util.intersect(cropBox, mediaBox);
                      if (box && box[2] - box[0] !== 0 && box[3] - box[1] !== 0) {
                        view = box;
                      } else {
                        (0, _util2.warn)("Empty /CropBox and /MediaBox intersection.");
                      }
                    }
                    return (0, _util2.shadow)(this, "view", view || mediaBox);
                  }
                  get rotate() {
                    let rotate = this._getInheritableProperty("Rotate") || 0;
                    if (rotate % 90 !== 0) {
                      rotate = 0;
                    } else if (rotate >= 360) {
                      rotate = rotate % 360;
                    } else if (rotate < 0) {
                      rotate = (rotate % 360 + 360) % 360;
                    }
                    return (0, _util2.shadow)(this, "rotate", rotate);
                  }
                  getContentStream() {
                    const content = this.content;
                    let stream;
                    if (Array.isArray(content)) {
                      const xref = this.xref;
                      const streams = [];
                      for (const stream2 of content) {
                        streams.push(xref.fetchIfRef(stream2));
                      }
                      stream = new _stream.StreamsSequenceStream(streams);
                    } else if ((0, _primitives.isStream)(content)) {
                      stream = content;
                    } else {
                      stream = new _stream.NullStream();
                    }
                    return stream;
                  }
                  loadResources(keys) {
                    if (!this.resourcesPromise) {
                      this.resourcesPromise = this.pdfManager.ensure(this, "resources");
                    }
                    return this.resourcesPromise.then(() => {
                      const objectLoader = new _obj.ObjectLoader(this.resources, keys, this.xref);
                      return objectLoader.load();
                    });
                  }
                  getOperatorList({ handler, sink, task, intent, renderInteractiveForms }) {
                    const contentStreamPromise = this.pdfManager.ensure(this, "getContentStream");
                    const resourcesPromise = this.loadResources(["ExtGState", "ColorSpace", "Pattern", "Shading", "XObject", "Font"]);
                    const partialEvaluator = new _evaluator.PartialEvaluator({ xref: this.xref, handler, pageIndex: this.pageIndex, idFactory: this.idFactory, fontCache: this.fontCache, builtInCMapCache: this.builtInCMapCache, options: this.evaluatorOptions, pdfFunctionFactory: this.pdfFunctionFactory });
                    const dataPromises = Promise.all([contentStreamPromise, resourcesPromise]);
                    const pageListPromise = dataPromises.then(([contentStream]) => {
                      const opList = new _operator_list.OperatorList(intent, sink, this.pageIndex);
                      handler.send("StartRenderPage", { transparency: partialEvaluator.hasBlendModes(this.resources), pageIndex: this.pageIndex, intent });
                      return partialEvaluator.getOperatorList({ stream: contentStream, task, resources: this.resources, operatorList: opList }).then(function() {
                        return opList;
                      });
                    });
                    return Promise.all([pageListPromise, this._parsedAnnotations]).then(function([pageOpList, annotations]) {
                      if (annotations.length === 0) {
                        pageOpList.flush(true);
                        return { length: pageOpList.totalLength };
                      }
                      const opListPromises = [];
                      for (const annotation of annotations) {
                        if (isAnnotationRenderable(annotation, intent)) {
                          opListPromises.push(annotation.getOperatorList(partialEvaluator, task, renderInteractiveForms));
                        }
                      }
                      return Promise.all(opListPromises).then(function(opLists) {
                        pageOpList.addOp(_util2.OPS.beginAnnotations, []);
                        for (const opList of opLists) {
                          pageOpList.addOpList(opList);
                        }
                        pageOpList.addOp(_util2.OPS.endAnnotations, []);
                        pageOpList.flush(true);
                        return { length: pageOpList.totalLength };
                      });
                    });
                  }
                  extractTextContent({ handler, task, normalizeWhitespace, sink, combineTextItems }) {
                    const contentStreamPromise = this.pdfManager.ensure(this, "getContentStream");
                    const resourcesPromise = this.loadResources(["ExtGState", "XObject", "Font"]);
                    const dataPromises = Promise.all([contentStreamPromise, resourcesPromise]);
                    return dataPromises.then(([contentStream]) => {
                      const partialEvaluator = new _evaluator.PartialEvaluator({ xref: this.xref, handler, pageIndex: this.pageIndex, idFactory: this.idFactory, fontCache: this.fontCache, builtInCMapCache: this.builtInCMapCache, options: this.evaluatorOptions, pdfFunctionFactory: this.pdfFunctionFactory });
                      return partialEvaluator.getTextContent({ stream: contentStream, task, resources: this.resources, normalizeWhitespace, combineTextItems, sink });
                    });
                  }
                  getAnnotationsData(intent) {
                    return this._parsedAnnotations.then(function(annotations) {
                      const annotationsData = [];
                      for (let i = 0, ii = annotations.length; i < ii; i++) {
                        if (!intent || isAnnotationRenderable(annotations[i], intent)) {
                          annotationsData.push(annotations[i].data);
                        }
                      }
                      return annotationsData;
                    });
                  }
                  get annotations() {
                    return (0, _util2.shadow)(this, "annotations", this._getInheritableProperty("Annots") || []);
                  }
                  get _parsedAnnotations() {
                    const parsedAnnotations = this.pdfManager.ensure(this, "annotations").then(() => {
                      const annotationRefs = this.annotations;
                      const annotationPromises = [];
                      for (let i = 0, ii = annotationRefs.length; i < ii; i++) {
                        annotationPromises.push(_annotation.AnnotationFactory.create(this.xref, annotationRefs[i], this.pdfManager, this.idFactory));
                      }
                      return Promise.all(annotationPromises).then(function(annotations) {
                        return annotations.filter(function isDefined(annotation) {
                          return !!annotation;
                        });
                      }, function(reason) {
                        (0, _util2.warn)(`_parsedAnnotations: "${reason}".`);
                        return [];
                      });
                    });
                    return (0, _util2.shadow)(this, "_parsedAnnotations", parsedAnnotations);
                  }
                }
                exports2.Page = Page;
                const PDF_HEADER_SIGNATURE = new Uint8Array([37, 80, 68, 70, 45]);
                const STARTXREF_SIGNATURE = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]);
                const ENDOBJ_SIGNATURE = new Uint8Array([101, 110, 100, 111, 98, 106]);
                const FINGERPRINT_FIRST_BYTES = 1024;
                const EMPTY_FINGERPRINT = "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
                const PDF_HEADER_VERSION_REGEXP = /^[1-9]\.[0-9]$/;
                function find(stream, signature, limit = 1024, backwards = false) {
                  const signatureLength = signature.length;
                  const scanBytes = stream.peekBytes(limit);
                  const scanLength = scanBytes.length - signatureLength;
                  if (scanLength <= 0) {
                    return false;
                  }
                  if (backwards) {
                    const signatureEnd = signatureLength - 1;
                    let pos = scanBytes.length - 1;
                    while (pos >= signatureEnd) {
                      let j = 0;
                      while (j < signatureLength && scanBytes[pos - j] === signature[signatureEnd - j]) {
                        j++;
                      }
                      if (j >= signatureLength) {
                        stream.pos += pos - signatureEnd;
                        return true;
                      }
                      pos--;
                    }
                  } else {
                    let pos = 0;
                    while (pos <= scanLength) {
                      let j = 0;
                      while (j < signatureLength && scanBytes[pos + j] === signature[j]) {
                        j++;
                      }
                      if (j >= signatureLength) {
                        stream.pos += pos;
                        return true;
                      }
                      pos++;
                    }
                  }
                  return false;
                }
                class PDFDocument {
                  constructor(pdfManager, arg) {
                    let stream;
                    if ((0, _primitives.isStream)(arg)) {
                      stream = arg;
                    } else if ((0, _util2.isArrayBuffer)(arg)) {
                      stream = new _stream.Stream(arg);
                    } else {
                      throw new Error("PDFDocument: Unknown argument type");
                    }
                    if (stream.length <= 0) {
                      throw new _util2.InvalidPDFException("The PDF file is empty, i.e. its size is zero bytes.");
                    }
                    this.pdfManager = pdfManager;
                    this.stream = stream;
                    this.xref = new _obj.XRef(stream, pdfManager);
                    this.pdfFunctionFactory = new _function.PDFFunctionFactory({ xref: this.xref, isEvalSupported: pdfManager.evaluatorOptions.isEvalSupported });
                    this._pagePromises = [];
                  }
                  parse(recoveryMode) {
                    this.setup(recoveryMode);
                    const version2 = this.catalog.catDict.get("Version");
                    if ((0, _primitives.isName)(version2)) {
                      this.pdfFormatVersion = version2.name;
                    }
                    try {
                      this.acroForm = this.catalog.catDict.get("AcroForm");
                      if (this.acroForm) {
                        this.xfa = this.acroForm.get("XFA");
                        const fields = this.acroForm.get("Fields");
                        if ((!Array.isArray(fields) || fields.length === 0) && !this.xfa) {
                          this.acroForm = null;
                        }
                      }
                    } catch (ex) {
                      if (ex instanceof _core_utils.MissingDataException) {
                        throw ex;
                      }
                      (0, _util2.info)("Cannot fetch AcroForm entry; assuming no AcroForms are present");
                      this.acroForm = null;
                    }
                    try {
                      const collection = this.catalog.catDict.get("Collection");
                      if ((0, _primitives.isDict)(collection) && collection.getKeys().length > 0) {
                        this.collection = collection;
                      }
                    } catch (ex) {
                      if (ex instanceof _core_utils.MissingDataException) {
                        throw ex;
                      }
                      (0, _util2.info)("Cannot fetch Collection dictionary.");
                    }
                  }
                  get linearization() {
                    let linearization = null;
                    try {
                      linearization = _parser.Linearization.create(this.stream);
                    } catch (err) {
                      if (err instanceof _core_utils.MissingDataException) {
                        throw err;
                      }
                      (0, _util2.info)(err);
                    }
                    return (0, _util2.shadow)(this, "linearization", linearization);
                  }
                  get startXRef() {
                    const stream = this.stream;
                    let startXRef = 0;
                    if (this.linearization) {
                      stream.reset();
                      if (find(stream, ENDOBJ_SIGNATURE)) {
                        startXRef = stream.pos + 6 - stream.start;
                      }
                    } else {
                      const step = 1024;
                      const startXRefLength = STARTXREF_SIGNATURE.length;
                      let found = false, pos = stream.end;
                      while (!found && pos > 0) {
                        pos -= step - startXRefLength;
                        if (pos < 0) {
                          pos = 0;
                        }
                        stream.pos = pos;
                        found = find(stream, STARTXREF_SIGNATURE, step, true);
                      }
                      if (found) {
                        stream.skip(9);
                        let ch;
                        do {
                          ch = stream.getByte();
                        } while ((0, _core_utils.isWhiteSpace)(ch));
                        let str = "";
                        while (ch >= 32 && ch <= 57) {
                          str += String.fromCharCode(ch);
                          ch = stream.getByte();
                        }
                        startXRef = parseInt(str, 10);
                        if (isNaN(startXRef)) {
                          startXRef = 0;
                        }
                      }
                    }
                    return (0, _util2.shadow)(this, "startXRef", startXRef);
                  }
                  checkHeader() {
                    const stream = this.stream;
                    stream.reset();
                    if (!find(stream, PDF_HEADER_SIGNATURE)) {
                      return;
                    }
                    stream.moveStart();
                    const MAX_PDF_VERSION_LENGTH = 12;
                    let version2 = "", ch;
                    while ((ch = stream.getByte()) > 32) {
                      if (version2.length >= MAX_PDF_VERSION_LENGTH) {
                        break;
                      }
                      version2 += String.fromCharCode(ch);
                    }
                    if (!this.pdfFormatVersion) {
                      this.pdfFormatVersion = version2.substring(5);
                    }
                  }
                  parseStartXRef() {
                    this.xref.setStartXRef(this.startXRef);
                  }
                  setup(recoveryMode) {
                    this.xref.parse(recoveryMode);
                    this.catalog = new _obj.Catalog(this.pdfManager, this.xref);
                  }
                  get numPages() {
                    const linearization = this.linearization;
                    const num = linearization ? linearization.numPages : this.catalog.numPages;
                    return (0, _util2.shadow)(this, "numPages", num);
                  }
                  get documentInfo() {
                    const DocumentInfoValidators = { Title: _util2.isString, Author: _util2.isString, Subject: _util2.isString, Keywords: _util2.isString, Creator: _util2.isString, Producer: _util2.isString, CreationDate: _util2.isString, ModDate: _util2.isString, Trapped: _primitives.isName };
                    let version2 = this.pdfFormatVersion;
                    if (typeof version2 !== "string" || !PDF_HEADER_VERSION_REGEXP.test(version2)) {
                      (0, _util2.warn)(`Invalid PDF header version number: ${version2}`);
                      version2 = null;
                    }
                    const docInfo = { PDFFormatVersion: version2, IsLinearized: !!this.linearization, IsAcroFormPresent: !!this.acroForm, IsXFAPresent: !!this.xfa, IsCollectionPresent: !!this.collection };
                    let infoDict;
                    try {
                      infoDict = this.xref.trailer.get("Info");
                    } catch (err) {
                      if (err instanceof _core_utils.MissingDataException) {
                        throw err;
                      }
                      (0, _util2.info)("The document information dictionary is invalid.");
                    }
                    if ((0, _primitives.isDict)(infoDict)) {
                      for (const key of infoDict.getKeys()) {
                        const value = infoDict.get(key);
                        if (DocumentInfoValidators[key]) {
                          if (DocumentInfoValidators[key](value)) {
                            docInfo[key] = typeof value !== "string" ? value : (0, _util2.stringToPDFString)(value);
                          } else {
                            (0, _util2.info)(`Bad value in document info for "${key}".`);
                          }
                        } else if (typeof key === "string") {
                          let customValue;
                          if ((0, _util2.isString)(value)) {
                            customValue = (0, _util2.stringToPDFString)(value);
                          } else if ((0, _primitives.isName)(value) || (0, _util2.isNum)(value) || (0, _util2.isBool)(value)) {
                            customValue = value;
                          } else {
                            (0, _util2.info)(`Unsupported value in document info for (custom) "${key}".`);
                            continue;
                          }
                          if (!docInfo["Custom"]) {
                            docInfo["Custom"] = /* @__PURE__ */ Object.create(null);
                          }
                          docInfo["Custom"][key] = customValue;
                        }
                      }
                    }
                    return (0, _util2.shadow)(this, "documentInfo", docInfo);
                  }
                  get fingerprint() {
                    let hash;
                    const idArray = this.xref.trailer.get("ID");
                    if (Array.isArray(idArray) && idArray[0] && (0, _util2.isString)(idArray[0]) && idArray[0] !== EMPTY_FINGERPRINT) {
                      hash = (0, _util2.stringToBytes)(idArray[0]);
                    } else {
                      hash = (0, _crypto.calculateMD5)(this.stream.getByteRange(0, FINGERPRINT_FIRST_BYTES), 0, FINGERPRINT_FIRST_BYTES);
                    }
                    const fingerprintBuf = [];
                    for (let i = 0, ii = hash.length; i < ii; i++) {
                      const hex = hash[i].toString(16);
                      fingerprintBuf.push(hex.padStart(2, "0"));
                    }
                    return (0, _util2.shadow)(this, "fingerprint", fingerprintBuf.join(""));
                  }
                  _getLinearizationPage(pageIndex) {
                    const { catalog, linearization } = this;
                    (0, _util2.assert)(linearization && linearization.pageFirst === pageIndex);
                    const ref = _primitives.Ref.get(linearization.objectNumberFirst, 0);
                    return this.xref.fetchAsync(ref).then((obj) => {
                      if ((0, _primitives.isDict)(obj, "Page") || (0, _primitives.isDict)(obj) && !obj.has("Type") && obj.has("Contents")) {
                        if (ref && !catalog.pageKidsCountCache.has(ref)) {
                          catalog.pageKidsCountCache.put(ref, 1);
                        }
                        return [obj, ref];
                      }
                      throw new _util2.FormatError("The Linearization dictionary doesn't point to a valid Page dictionary.");
                    }).catch((reason) => {
                      (0, _util2.info)(reason);
                      return catalog.getPageDict(pageIndex);
                    });
                  }
                  getPage(pageIndex) {
                    if (this._pagePromises[pageIndex] !== void 0) {
                      return this._pagePromises[pageIndex];
                    }
                    const { catalog, linearization } = this;
                    const promise = linearization && linearization.pageFirst === pageIndex ? this._getLinearizationPage(pageIndex) : catalog.getPageDict(pageIndex);
                    return this._pagePromises[pageIndex] = promise.then(([pageDict, ref]) => {
                      return new Page({ pdfManager: this.pdfManager, xref: this.xref, pageIndex, pageDict, ref, fontCache: catalog.fontCache, builtInCMapCache: catalog.builtInCMapCache, pdfFunctionFactory: this.pdfFunctionFactory });
                    });
                  }
                  checkFirstPage() {
                    return this.getPage(0).catch(async (reason) => {
                      if (reason instanceof _core_utils.XRefEntryException) {
                        this._pagePromises.length = 0;
                        await this.cleanup();
                        throw new _core_utils.XRefParseException();
                      }
                    });
                  }
                  fontFallback(id, handler) {
                    return this.catalog.fontFallback(id, handler);
                  }
                  async cleanup() {
                    return this.catalog ? this.catalog.cleanup() : (0, _primitives.clearPrimitiveCaches)();
                  }
                }
                exports2.PDFDocument = PDFDocument;
              }, function(module3, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.FileSpec = exports2.XRef = exports2.ObjectLoader = exports2.Catalog = void 0;
                var _util2 = __w_pdfjs_require__2(2);
                var _primitives = __w_pdfjs_require__2(4);
                var _parser = __w_pdfjs_require__2(10);
                var _core_utils = __w_pdfjs_require__2(7);
                var _crypto = __w_pdfjs_require__2(21);
                var _colorspace = __w_pdfjs_require__2(22);
                function fetchDestination(dest) {
                  return (0, _primitives.isDict)(dest) ? dest.get("D") : dest;
                }
                class Catalog {
                  constructor(pdfManager, xref) {
                    this.pdfManager = pdfManager;
                    this.xref = xref;
                    this.catDict = xref.getCatalogObj();
                    if (!(0, _primitives.isDict)(this.catDict)) {
                      throw new _util2.FormatError("Catalog object is not a dictionary.");
                    }
                    this.fontCache = new _primitives.RefSetCache();
                    this.builtInCMapCache = /* @__PURE__ */ new Map();
                    this.pageKidsCountCache = new _primitives.RefSetCache();
                  }
                  get metadata() {
                    const streamRef = this.catDict.getRaw("Metadata");
                    if (!(0, _primitives.isRef)(streamRef)) {
                      return (0, _util2.shadow)(this, "metadata", null);
                    }
                    const suppressEncryption = !(this.xref.encrypt && this.xref.encrypt.encryptMetadata);
                    const stream = this.xref.fetch(streamRef, suppressEncryption);
                    let metadata;
                    if (stream && (0, _primitives.isDict)(stream.dict)) {
                      const type = stream.dict.get("Type");
                      const subtype = stream.dict.get("Subtype");
                      if ((0, _primitives.isName)(type, "Metadata") && (0, _primitives.isName)(subtype, "XML")) {
                        try {
                          metadata = (0, _util2.stringToUTF8String)((0, _util2.bytesToString)(stream.getBytes()));
                        } catch (e) {
                          if (e instanceof _core_utils.MissingDataException) {
                            throw e;
                          }
                          (0, _util2.info)("Skipping invalid metadata.");
                        }
                      }
                    }
                    return (0, _util2.shadow)(this, "metadata", metadata);
                  }
                  get toplevelPagesDict() {
                    const pagesObj = this.catDict.get("Pages");
                    if (!(0, _primitives.isDict)(pagesObj)) {
                      throw new _util2.FormatError("Invalid top-level pages dictionary.");
                    }
                    return (0, _util2.shadow)(this, "toplevelPagesDict", pagesObj);
                  }
                  get documentOutline() {
                    let obj = null;
                    try {
                      obj = this._readDocumentOutline();
                    } catch (ex) {
                      if (ex instanceof _core_utils.MissingDataException) {
                        throw ex;
                      }
                      (0, _util2.warn)("Unable to read document outline.");
                    }
                    return (0, _util2.shadow)(this, "documentOutline", obj);
                  }
                  _readDocumentOutline() {
                    let obj = this.catDict.get("Outlines");
                    if (!(0, _primitives.isDict)(obj)) {
                      return null;
                    }
                    obj = obj.getRaw("First");
                    if (!(0, _primitives.isRef)(obj)) {
                      return null;
                    }
                    const root = { items: [] };
                    const queue = [{ obj, parent: root }];
                    const processed = new _primitives.RefSet();
                    processed.put(obj);
                    const xref = this.xref, blackColor = new Uint8ClampedArray(3);
                    while (queue.length > 0) {
                      const i = queue.shift();
                      const outlineDict = xref.fetchIfRef(i.obj);
                      if (outlineDict === null) {
                        continue;
                      }
                      if (!outlineDict.has("Title")) {
                        throw new _util2.FormatError("Invalid outline item encountered.");
                      }
                      const data = { url: null, dest: null };
                      Catalog.parseDestDictionary({ destDict: outlineDict, resultObj: data, docBaseUrl: this.pdfManager.docBaseUrl });
                      const title = outlineDict.get("Title");
                      const flags = outlineDict.get("F") || 0;
                      const color = outlineDict.getArray("C");
                      const count = outlineDict.get("Count");
                      let rgbColor = blackColor;
                      if (Array.isArray(color) && color.length === 3 && (color[0] !== 0 || color[1] !== 0 || color[2] !== 0)) {
                        rgbColor = _colorspace.ColorSpace.singletons.rgb.getRgb(color, 0);
                      }
                      const outlineItem = { dest: data.dest, url: data.url, unsafeUrl: data.unsafeUrl, newWindow: data.newWindow, title: (0, _util2.stringToPDFString)(title), color: rgbColor, count: Number.isInteger(count) ? count : void 0, bold: !!(flags & 2), italic: !!(flags & 1), items: [] };
                      i.parent.items.push(outlineItem);
                      obj = outlineDict.getRaw("First");
                      if ((0, _primitives.isRef)(obj) && !processed.has(obj)) {
                        queue.push({ obj, parent: outlineItem });
                        processed.put(obj);
                      }
                      obj = outlineDict.getRaw("Next");
                      if ((0, _primitives.isRef)(obj) && !processed.has(obj)) {
                        queue.push({ obj, parent: i.parent });
                        processed.put(obj);
                      }
                    }
                    return root.items.length > 0 ? root.items : null;
                  }
                  get permissions() {
                    let permissions = null;
                    try {
                      permissions = this._readPermissions();
                    } catch (ex) {
                      if (ex instanceof _core_utils.MissingDataException) {
                        throw ex;
                      }
                      (0, _util2.warn)("Unable to read permissions.");
                    }
                    return (0, _util2.shadow)(this, "permissions", permissions);
                  }
                  _readPermissions() {
                    const encrypt = this.xref.trailer.get("Encrypt");
                    if (!(0, _primitives.isDict)(encrypt)) {
                      return null;
                    }
                    let flags = encrypt.get("P");
                    if (!(0, _util2.isNum)(flags)) {
                      return null;
                    }
                    flags += 2 ** 32;
                    const permissions = [];
                    for (const key in _util2.PermissionFlag) {
                      const value = _util2.PermissionFlag[key];
                      if (flags & value) {
                        permissions.push(value);
                      }
                    }
                    return permissions;
                  }
                  get numPages() {
                    const obj = this.toplevelPagesDict.get("Count");
                    if (!Number.isInteger(obj)) {
                      throw new _util2.FormatError("Page count in top-level pages dictionary is not an integer.");
                    }
                    return (0, _util2.shadow)(this, "numPages", obj);
                  }
                  get destinations() {
                    const obj = this._readDests(), dests = /* @__PURE__ */ Object.create(null);
                    if (obj instanceof NameTree) {
                      const names = obj.getAll();
                      for (const name in names) {
                        dests[name] = fetchDestination(names[name]);
                      }
                    } else if (obj instanceof _primitives.Dict) {
                      obj.forEach(function(key, value) {
                        if (value) {
                          dests[key] = fetchDestination(value);
                        }
                      });
                    }
                    return (0, _util2.shadow)(this, "destinations", dests);
                  }
                  getDestination(destinationId) {
                    const obj = this._readDests();
                    if (obj instanceof NameTree || obj instanceof _primitives.Dict) {
                      return fetchDestination(obj.get(destinationId) || null);
                    }
                    return null;
                  }
                  _readDests() {
                    const obj = this.catDict.get("Names");
                    if (obj && obj.has("Dests")) {
                      return new NameTree(obj.getRaw("Dests"), this.xref);
                    } else if (this.catDict.has("Dests")) {
                      return this.catDict.get("Dests");
                    }
                    return void 0;
                  }
                  get pageLabels() {
                    let obj = null;
                    try {
                      obj = this._readPageLabels();
                    } catch (ex) {
                      if (ex instanceof _core_utils.MissingDataException) {
                        throw ex;
                      }
                      (0, _util2.warn)("Unable to read page labels.");
                    }
                    return (0, _util2.shadow)(this, "pageLabels", obj);
                  }
                  _readPageLabels() {
                    const obj = this.catDict.getRaw("PageLabels");
                    if (!obj) {
                      return null;
                    }
                    const pageLabels = new Array(this.numPages);
                    let style = null, prefix = "";
                    const numberTree = new NumberTree(obj, this.xref);
                    const nums = numberTree.getAll();
                    let currentLabel = "", currentIndex = 1;
                    for (let i = 0, ii = this.numPages; i < ii; i++) {
                      if (i in nums) {
                        const labelDict = nums[i];
                        if (!(0, _primitives.isDict)(labelDict)) {
                          throw new _util2.FormatError("PageLabel is not a dictionary.");
                        }
                        if (labelDict.has("Type") && !(0, _primitives.isName)(labelDict.get("Type"), "PageLabel")) {
                          throw new _util2.FormatError("Invalid type in PageLabel dictionary.");
                        }
                        if (labelDict.has("S")) {
                          const s = labelDict.get("S");
                          if (!(0, _primitives.isName)(s)) {
                            throw new _util2.FormatError("Invalid style in PageLabel dictionary.");
                          }
                          style = s.name;
                        } else {
                          style = null;
                        }
                        if (labelDict.has("P")) {
                          const p = labelDict.get("P");
                          if (!(0, _util2.isString)(p)) {
                            throw new _util2.FormatError("Invalid prefix in PageLabel dictionary.");
                          }
                          prefix = (0, _util2.stringToPDFString)(p);
                        } else {
                          prefix = "";
                        }
                        if (labelDict.has("St")) {
                          const st = labelDict.get("St");
                          if (!(Number.isInteger(st) && st >= 1)) {
                            throw new _util2.FormatError("Invalid start in PageLabel dictionary.");
                          }
                          currentIndex = st;
                        } else {
                          currentIndex = 1;
                        }
                      }
                      switch (style) {
                        case "D":
                          currentLabel = currentIndex;
                          break;
                        case "R":
                        case "r":
                          currentLabel = (0, _core_utils.toRomanNumerals)(currentIndex, style === "r");
                          break;
                        case "A":
                        case "a":
                          const LIMIT = 26;
                          const A_UPPER_CASE = 65, A_LOWER_CASE = 97;
                          const baseCharCode = style === "a" ? A_LOWER_CASE : A_UPPER_CASE;
                          const letterIndex = currentIndex - 1;
                          const character = String.fromCharCode(baseCharCode + letterIndex % LIMIT);
                          const charBuf = [];
                          for (let j = 0, jj = letterIndex / LIMIT | 0; j <= jj; j++) {
                            charBuf.push(character);
                          }
                          currentLabel = charBuf.join("");
                          break;
                        default:
                          if (style) {
                            throw new _util2.FormatError(`Invalid style "${style}" in PageLabel dictionary.`);
                          }
                          currentLabel = "";
                      }
                      pageLabels[i] = prefix + currentLabel;
                      currentIndex++;
                    }
                    return pageLabels;
                  }
                  get pageLayout() {
                    const obj = this.catDict.get("PageLayout");
                    let pageLayout = "";
                    if ((0, _primitives.isName)(obj)) {
                      switch (obj.name) {
                        case "SinglePage":
                        case "OneColumn":
                        case "TwoColumnLeft":
                        case "TwoColumnRight":
                        case "TwoPageLeft":
                        case "TwoPageRight":
                          pageLayout = obj.name;
                      }
                    }
                    return (0, _util2.shadow)(this, "pageLayout", pageLayout);
                  }
                  get pageMode() {
                    const obj = this.catDict.get("PageMode");
                    let pageMode = "UseNone";
                    if ((0, _primitives.isName)(obj)) {
                      switch (obj.name) {
                        case "UseNone":
                        case "UseOutlines":
                        case "UseThumbs":
                        case "FullScreen":
                        case "UseOC":
                        case "UseAttachments":
                          pageMode = obj.name;
                      }
                    }
                    return (0, _util2.shadow)(this, "pageMode", pageMode);
                  }
                  get viewerPreferences() {
                    const ViewerPreferencesValidators = { HideToolbar: _util2.isBool, HideMenubar: _util2.isBool, HideWindowUI: _util2.isBool, FitWindow: _util2.isBool, CenterWindow: _util2.isBool, DisplayDocTitle: _util2.isBool, NonFullScreenPageMode: _primitives.isName, Direction: _primitives.isName, ViewArea: _primitives.isName, ViewClip: _primitives.isName, PrintArea: _primitives.isName, PrintClip: _primitives.isName, PrintScaling: _primitives.isName, Duplex: _primitives.isName, PickTrayByPDFSize: _util2.isBool, PrintPageRange: Array.isArray, NumCopies: Number.isInteger };
                    const obj = this.catDict.get("ViewerPreferences");
                    const prefs = /* @__PURE__ */ Object.create(null);
                    if ((0, _primitives.isDict)(obj)) {
                      for (const key in ViewerPreferencesValidators) {
                        if (!obj.has(key)) {
                          continue;
                        }
                        const value = obj.get(key);
                        if (!ViewerPreferencesValidators[key](value)) {
                          (0, _util2.info)(`Bad value in ViewerPreferences for "${key}".`);
                          continue;
                        }
                        let prefValue;
                        switch (key) {
                          case "NonFullScreenPageMode":
                            switch (value.name) {
                              case "UseNone":
                              case "UseOutlines":
                              case "UseThumbs":
                              case "UseOC":
                                prefValue = value.name;
                                break;
                              default:
                                prefValue = "UseNone";
                            }
                            break;
                          case "Direction":
                            switch (value.name) {
                              case "L2R":
                              case "R2L":
                                prefValue = value.name;
                                break;
                              default:
                                prefValue = "L2R";
                            }
                            break;
                          case "ViewArea":
                          case "ViewClip":
                          case "PrintArea":
                          case "PrintClip":
                            switch (value.name) {
                              case "MediaBox":
                              case "CropBox":
                              case "BleedBox":
                              case "TrimBox":
                              case "ArtBox":
                                prefValue = value.name;
                                break;
                              default:
                                prefValue = "CropBox";
                            }
                            break;
                          case "PrintScaling":
                            switch (value.name) {
                              case "None":
                              case "AppDefault":
                                prefValue = value.name;
                                break;
                              default:
                                prefValue = "AppDefault";
                            }
                            break;
                          case "Duplex":
                            switch (value.name) {
                              case "Simplex":
                              case "DuplexFlipShortEdge":
                              case "DuplexFlipLongEdge":
                                prefValue = value.name;
                                break;
                              default:
                                prefValue = "None";
                            }
                            break;
                          case "PrintPageRange":
                            const length = value.length;
                            if (length % 2 !== 0) {
                              break;
                            }
                            const isValid = value.every((page, i, arr) => {
                              return Number.isInteger(page) && page > 0 && (i === 0 || page >= arr[i - 1]) && page <= this.numPages;
                            });
                            if (isValid) {
                              prefValue = value;
                            }
                            break;
                          case "NumCopies":
                            if (value > 0) {
                              prefValue = value;
                            }
                            break;
                          default:
                            (0, _util2.assert)(typeof value === "boolean");
                            prefValue = value;
                        }
                        if (prefValue !== void 0) {
                          prefs[key] = prefValue;
                        } else {
                          (0, _util2.info)(`Bad value in ViewerPreferences for "${key}".`);
                        }
                      }
                    }
                    return (0, _util2.shadow)(this, "viewerPreferences", prefs);
                  }
                  get openAction() {
                    const obj = this.catDict.get("OpenAction");
                    let openAction = null;
                    if ((0, _primitives.isDict)(obj)) {
                      const destDict = new _primitives.Dict(this.xref);
                      destDict.set("A", obj);
                      const resultObj = { url: null, dest: null, action: null };
                      Catalog.parseDestDictionary({ destDict, resultObj });
                      if (Array.isArray(resultObj.dest)) {
                        if (!openAction) {
                          openAction = /* @__PURE__ */ Object.create(null);
                        }
                        openAction.dest = resultObj.dest;
                      } else if (resultObj.action) {
                        if (!openAction) {
                          openAction = /* @__PURE__ */ Object.create(null);
                        }
                        openAction.action = resultObj.action;
                      }
                    } else if (Array.isArray(obj)) {
                      if (!openAction) {
                        openAction = /* @__PURE__ */ Object.create(null);
                      }
                      openAction.dest = obj;
                    }
                    return (0, _util2.shadow)(this, "openAction", openAction);
                  }
                  get attachments() {
                    const obj = this.catDict.get("Names");
                    let attachments = null;
                    if (obj && obj.has("EmbeddedFiles")) {
                      const nameTree = new NameTree(obj.getRaw("EmbeddedFiles"), this.xref);
                      const names = nameTree.getAll();
                      for (const name in names) {
                        const fs = new FileSpec(names[name], this.xref);
                        if (!attachments) {
                          attachments = /* @__PURE__ */ Object.create(null);
                        }
                        attachments[(0, _util2.stringToPDFString)(name)] = fs.serializable;
                      }
                    }
                    return (0, _util2.shadow)(this, "attachments", attachments);
                  }
                  get javaScript() {
                    const obj = this.catDict.get("Names");
                    let javaScript = null;
                    function appendIfJavaScriptDict(jsDict) {
                      const type = jsDict.get("S");
                      if (!(0, _primitives.isName)(type, "JavaScript")) {
                        return;
                      }
                      let js = jsDict.get("JS");
                      if ((0, _primitives.isStream)(js)) {
                        js = (0, _util2.bytesToString)(js.getBytes());
                      } else if (!(0, _util2.isString)(js)) {
                        return;
                      }
                      if (!javaScript) {
                        javaScript = [];
                      }
                      javaScript.push((0, _util2.stringToPDFString)(js));
                    }
                    if (obj && obj.has("JavaScript")) {
                      const nameTree = new NameTree(obj.getRaw("JavaScript"), this.xref);
                      const names = nameTree.getAll();
                      for (const name in names) {
                        const jsDict = names[name];
                        if ((0, _primitives.isDict)(jsDict)) {
                          appendIfJavaScriptDict(jsDict);
                        }
                      }
                    }
                    const openAction = this.catDict.get("OpenAction");
                    if ((0, _primitives.isDict)(openAction) && (0, _primitives.isName)(openAction.get("S"), "JavaScript")) {
                      appendIfJavaScriptDict(openAction);
                    }
                    return (0, _util2.shadow)(this, "javaScript", javaScript);
                  }
                  fontFallback(id, handler) {
                    const promises = [];
                    this.fontCache.forEach(function(promise) {
                      promises.push(promise);
                    });
                    return Promise.all(promises).then((translatedFonts) => {
                      for (const translatedFont of translatedFonts) {
                        if (translatedFont.loadedName === id) {
                          translatedFont.fallback(handler);
                          return;
                        }
                      }
                    });
                  }
                  cleanup() {
                    (0, _primitives.clearPrimitiveCaches)();
                    this.pageKidsCountCache.clear();
                    const promises = [];
                    this.fontCache.forEach(function(promise) {
                      promises.push(promise);
                    });
                    return Promise.all(promises).then((translatedFonts) => {
                      for (const { dict } of translatedFonts) {
                        delete dict.translated;
                      }
                      this.fontCache.clear();
                      this.builtInCMapCache.clear();
                    });
                  }
                  getPageDict(pageIndex) {
                    const capability = (0, _util2.createPromiseCapability)();
                    const nodesToVisit = [this.catDict.getRaw("Pages")];
                    const visitedNodes = new _primitives.RefSet();
                    const xref = this.xref, pageKidsCountCache = this.pageKidsCountCache;
                    let count, currentPageIndex = 0;
                    function next() {
                      while (nodesToVisit.length) {
                        const currentNode = nodesToVisit.pop();
                        if ((0, _primitives.isRef)(currentNode)) {
                          count = pageKidsCountCache.get(currentNode);
                          if (count > 0 && currentPageIndex + count < pageIndex) {
                            currentPageIndex += count;
                            continue;
                          }
                          if (visitedNodes.has(currentNode)) {
                            capability.reject(new _util2.FormatError("Pages tree contains circular reference."));
                            return;
                          }
                          visitedNodes.put(currentNode);
                          xref.fetchAsync(currentNode).then(function(obj) {
                            if ((0, _primitives.isDict)(obj, "Page") || (0, _primitives.isDict)(obj) && !obj.has("Kids")) {
                              if (pageIndex === currentPageIndex) {
                                if (currentNode && !pageKidsCountCache.has(currentNode)) {
                                  pageKidsCountCache.put(currentNode, 1);
                                }
                                capability.resolve([obj, currentNode]);
                              } else {
                                currentPageIndex++;
                                next();
                              }
                              return;
                            }
                            nodesToVisit.push(obj);
                            next();
                          }, capability.reject);
                          return;
                        }
                        if (!(0, _primitives.isDict)(currentNode)) {
                          capability.reject(new _util2.FormatError("Page dictionary kid reference points to wrong type of object."));
                          return;
                        }
                        count = currentNode.get("Count");
                        if (Number.isInteger(count) && count >= 0) {
                          const objId = currentNode.objId;
                          if (objId && !pageKidsCountCache.has(objId)) {
                            pageKidsCountCache.put(objId, count);
                          }
                          if (currentPageIndex + count <= pageIndex) {
                            currentPageIndex += count;
                            continue;
                          }
                        }
                        const kids = currentNode.get("Kids");
                        if (!Array.isArray(kids)) {
                          if ((0, _primitives.isName)(currentNode.get("Type"), "Page") || !currentNode.has("Type") && currentNode.has("Contents")) {
                            if (currentPageIndex === pageIndex) {
                              capability.resolve([currentNode, null]);
                              return;
                            }
                            currentPageIndex++;
                            continue;
                          }
                          capability.reject(new _util2.FormatError("Page dictionary kids object is not an array."));
                          return;
                        }
                        for (let last = kids.length - 1; last >= 0; last--) {
                          nodesToVisit.push(kids[last]);
                        }
                      }
                      capability.reject(new Error(`Page index ${pageIndex} not found.`));
                    }
                    next();
                    return capability.promise;
                  }
                  getPageIndex(pageRef) {
                    const xref = this.xref;
                    function pagesBeforeRef(kidRef) {
                      let total2 = 0, parentRef;
                      return xref.fetchAsync(kidRef).then(function(node) {
                        if ((0, _primitives.isRefsEqual)(kidRef, pageRef) && !(0, _primitives.isDict)(node, "Page") && !((0, _primitives.isDict)(node) && !node.has("Type") && node.has("Contents"))) {
                          throw new _util2.FormatError("The reference does not point to a /Page dictionary.");
                        }
                        if (!node) {
                          return null;
                        }
                        if (!(0, _primitives.isDict)(node)) {
                          throw new _util2.FormatError("Node must be a dictionary.");
                        }
                        parentRef = node.getRaw("Parent");
                        return node.getAsync("Parent");
                      }).then(function(parent) {
                        if (!parent) {
                          return null;
                        }
                        if (!(0, _primitives.isDict)(parent)) {
                          throw new _util2.FormatError("Parent must be a dictionary.");
                        }
                        return parent.getAsync("Kids");
                      }).then(function(kids) {
                        if (!kids) {
                          return null;
                        }
                        const kidPromises = [];
                        let found = false;
                        for (let i = 0, ii = kids.length; i < ii; i++) {
                          const kid = kids[i];
                          if (!(0, _primitives.isRef)(kid)) {
                            throw new _util2.FormatError("Kid must be a reference.");
                          }
                          if ((0, _primitives.isRefsEqual)(kid, kidRef)) {
                            found = true;
                            break;
                          }
                          kidPromises.push(xref.fetchAsync(kid).then(function(kid2) {
                            if (!(0, _primitives.isDict)(kid2)) {
                              throw new _util2.FormatError("Kid node must be a dictionary.");
                            }
                            if (kid2.has("Count")) {
                              total2 += kid2.get("Count");
                            } else {
                              total2++;
                            }
                          }));
                        }
                        if (!found) {
                          throw new _util2.FormatError("Kid reference not found in parent's kids.");
                        }
                        return Promise.all(kidPromises).then(function() {
                          return [total2, parentRef];
                        });
                      });
                    }
                    let total = 0;
                    function next(ref) {
                      return pagesBeforeRef(ref).then(function(args) {
                        if (!args) {
                          return total;
                        }
                        const [count, parentRef] = args;
                        total += count;
                        return next(parentRef);
                      });
                    }
                    return next(pageRef);
                  }
                  static parseDestDictionary(params) {
                    function addDefaultProtocolToUrl(url2) {
                      return url2.startsWith("www.") ? `http://${url2}` : url2;
                    }
                    function tryConvertUrlEncoding(url2) {
                      try {
                        return (0, _util2.stringToUTF8String)(url2);
                      } catch (e) {
                        return url2;
                      }
                    }
                    const destDict = params.destDict;
                    if (!(0, _primitives.isDict)(destDict)) {
                      (0, _util2.warn)("parseDestDictionary: `destDict` must be a dictionary.");
                      return;
                    }
                    const resultObj = params.resultObj;
                    if (typeof resultObj !== "object") {
                      (0, _util2.warn)("parseDestDictionary: `resultObj` must be an object.");
                      return;
                    }
                    const docBaseUrl = params.docBaseUrl || null;
                    let action = destDict.get("A"), url, dest;
                    if (!(0, _primitives.isDict)(action) && destDict.has("Dest")) {
                      action = destDict.get("Dest");
                    }
                    if ((0, _primitives.isDict)(action)) {
                      const actionType = action.get("S");
                      if (!(0, _primitives.isName)(actionType)) {
                        (0, _util2.warn)("parseDestDictionary: Invalid type in Action dictionary.");
                        return;
                      }
                      const actionName = actionType.name;
                      switch (actionName) {
                        case "URI":
                          url = action.get("URI");
                          if ((0, _primitives.isName)(url)) {
                            url = "/" + url.name;
                          } else if ((0, _util2.isString)(url)) {
                            url = addDefaultProtocolToUrl(url);
                          }
                          break;
                        case "GoTo":
                          dest = action.get("D");
                          break;
                        case "Launch":
                        case "GoToR":
                          const urlDict = action.get("F");
                          if ((0, _primitives.isDict)(urlDict)) {
                            url = urlDict.get("F") || null;
                          } else if ((0, _util2.isString)(urlDict)) {
                            url = urlDict;
                          }
                          let remoteDest = action.get("D");
                          if (remoteDest) {
                            if ((0, _primitives.isName)(remoteDest)) {
                              remoteDest = remoteDest.name;
                            }
                            if ((0, _util2.isString)(url)) {
                              const baseUrl = url.split("#")[0];
                              if ((0, _util2.isString)(remoteDest)) {
                                url = baseUrl + "#" + remoteDest;
                              } else if (Array.isArray(remoteDest)) {
                                url = baseUrl + "#" + JSON.stringify(remoteDest);
                              }
                            }
                          }
                          const newWindow = action.get("NewWindow");
                          if ((0, _util2.isBool)(newWindow)) {
                            resultObj.newWindow = newWindow;
                          }
                          break;
                        case "Named":
                          const namedAction = action.get("N");
                          if ((0, _primitives.isName)(namedAction)) {
                            resultObj.action = namedAction.name;
                          }
                          break;
                        case "JavaScript":
                          const jsAction = action.get("JS");
                          let js;
                          if ((0, _primitives.isStream)(jsAction)) {
                            js = (0, _util2.bytesToString)(jsAction.getBytes());
                          } else if ((0, _util2.isString)(jsAction)) {
                            js = jsAction;
                          }
                          if (js) {
                            const URL_OPEN_METHODS = ["app.launchURL", "window.open"];
                            const regex = new RegExp("^\\s*(" + URL_OPEN_METHODS.join("|").split(".").join("\\.") + `)\\((?:'|")([^'"]*)(?:'|")(?:,\\s*(\\w+)\\)|\\))`, "i");
                            const jsUrl = regex.exec((0, _util2.stringToPDFString)(js));
                            if (jsUrl && jsUrl[2]) {
                              url = jsUrl[2];
                              if (jsUrl[3] === "true" && jsUrl[1] === "app.launchURL") {
                                resultObj.newWindow = true;
                              }
                              break;
                            }
                          }
                        default:
                          (0, _util2.warn)(`parseDestDictionary: unsupported action type "${actionName}".`);
                          break;
                      }
                    } else if (destDict.has("Dest")) {
                      dest = destDict.get("Dest");
                    }
                    if ((0, _util2.isString)(url)) {
                      url = tryConvertUrlEncoding(url);
                      const absoluteUrl = (0, _util2.createValidAbsoluteUrl)(url, docBaseUrl);
                      if (absoluteUrl) {
                        resultObj.url = absoluteUrl.href;
                      }
                      resultObj.unsafeUrl = url;
                    }
                    if (dest) {
                      if ((0, _primitives.isName)(dest)) {
                        dest = dest.name;
                      }
                      if ((0, _util2.isString)(dest) || Array.isArray(dest)) {
                        resultObj.dest = dest;
                      }
                    }
                  }
                }
                exports2.Catalog = Catalog;
                var XRef = function XRefClosure() {
                  function XRef2(stream, pdfManager) {
                    this.stream = stream;
                    this.pdfManager = pdfManager;
                    this.entries = [];
                    this.xrefstms = /* @__PURE__ */ Object.create(null);
                    this._cacheMap = /* @__PURE__ */ new Map();
                    this.stats = { streamTypes: /* @__PURE__ */ Object.create(null), fontTypes: /* @__PURE__ */ Object.create(null) };
                  }
                  XRef2.prototype = { setStartXRef: function XRef_setStartXRef(startXRef) {
                    this.startXRefQueue = [startXRef];
                  }, parse: function XRef_parse(recoveryMode) {
                    var trailerDict;
                    if (!recoveryMode) {
                      trailerDict = this.readXRef();
                    } else {
                      (0, _util2.warn)("Indexing all PDF objects");
                      trailerDict = this.indexObjects();
                    }
                    trailerDict.assignXref(this);
                    this.trailer = trailerDict;
                    let encrypt;
                    try {
                      encrypt = trailerDict.get("Encrypt");
                    } catch (ex) {
                      if (ex instanceof _core_utils.MissingDataException) {
                        throw ex;
                      }
                      (0, _util2.warn)(`XRef.parse - Invalid "Encrypt" reference: "${ex}".`);
                    }
                    if ((0, _primitives.isDict)(encrypt)) {
                      var ids = trailerDict.get("ID");
                      var fileId = ids && ids.length ? ids[0] : "";
                      encrypt.suppressEncryption = true;
                      this.encrypt = new _crypto.CipherTransformFactory(encrypt, fileId, this.pdfManager.password);
                    }
                    let root;
                    try {
                      root = trailerDict.get("Root");
                    } catch (ex) {
                      if (ex instanceof _core_utils.MissingDataException) {
                        throw ex;
                      }
                      (0, _util2.warn)(`XRef.parse - Invalid "Root" reference: "${ex}".`);
                    }
                    if ((0, _primitives.isDict)(root) && root.has("Pages")) {
                      this.root = root;
                    } else {
                      if (!recoveryMode) {
                        throw new _core_utils.XRefParseException();
                      }
                      throw new _util2.FormatError("Invalid root reference");
                    }
                  }, processXRefTable: function XRef_processXRefTable(parser) {
                    if (!("tableState" in this)) {
                      this.tableState = { entryNum: 0, streamPos: parser.lexer.stream.pos, parserBuf1: parser.buf1, parserBuf2: parser.buf2 };
                    }
                    var obj = this.readXRefTable(parser);
                    if (!(0, _primitives.isCmd)(obj, "trailer")) {
                      throw new _util2.FormatError("Invalid XRef table: could not find trailer dictionary");
                    }
                    var dict = parser.getObj();
                    if (!(0, _primitives.isDict)(dict) && dict.dict) {
                      dict = dict.dict;
                    }
                    if (!(0, _primitives.isDict)(dict)) {
                      throw new _util2.FormatError("Invalid XRef table: could not parse trailer dictionary");
                    }
                    delete this.tableState;
                    return dict;
                  }, readXRefTable: function XRef_readXRefTable(parser) {
                    var stream = parser.lexer.stream;
                    var tableState = this.tableState;
                    stream.pos = tableState.streamPos;
                    parser.buf1 = tableState.parserBuf1;
                    parser.buf2 = tableState.parserBuf2;
                    var obj;
                    while (true) {
                      if (!("firstEntryNum" in tableState) || !("entryCount" in tableState)) {
                        if ((0, _primitives.isCmd)(obj = parser.getObj(), "trailer")) {
                          break;
                        }
                        tableState.firstEntryNum = obj;
                        tableState.entryCount = parser.getObj();
                      }
                      var first = tableState.firstEntryNum;
                      var count = tableState.entryCount;
                      if (!Number.isInteger(first) || !Number.isInteger(count)) {
                        throw new _util2.FormatError("Invalid XRef table: wrong types in subsection header");
                      }
                      for (var i = tableState.entryNum; i < count; i++) {
                        tableState.streamPos = stream.pos;
                        tableState.entryNum = i;
                        tableState.parserBuf1 = parser.buf1;
                        tableState.parserBuf2 = parser.buf2;
                        var entry = {};
                        entry.offset = parser.getObj();
                        entry.gen = parser.getObj();
                        var type = parser.getObj();
                        if (type instanceof _primitives.Cmd) {
                          switch (type.cmd) {
                            case "f":
                              entry.free = true;
                              break;
                            case "n":
                              entry.uncompressed = true;
                              break;
                          }
                        }
                        if (!Number.isInteger(entry.offset) || !Number.isInteger(entry.gen) || !(entry.free || entry.uncompressed)) {
                          throw new _util2.FormatError(`Invalid entry in XRef subsection: ${first}, ${count}`);
                        }
                        if (i === 0 && entry.free && first === 1) {
                          first = 0;
                        }
                        if (!this.entries[i + first]) {
                          this.entries[i + first] = entry;
                        }
                      }
                      tableState.entryNum = 0;
                      tableState.streamPos = stream.pos;
                      tableState.parserBuf1 = parser.buf1;
                      tableState.parserBuf2 = parser.buf2;
                      delete tableState.firstEntryNum;
                      delete tableState.entryCount;
                    }
                    if (this.entries[0] && !this.entries[0].free) {
                      throw new _util2.FormatError("Invalid XRef table: unexpected first object");
                    }
                    return obj;
                  }, processXRefStream: function XRef_processXRefStream(stream) {
                    if (!("streamState" in this)) {
                      var streamParameters = stream.dict;
                      var byteWidths = streamParameters.get("W");
                      var range = streamParameters.get("Index");
                      if (!range) {
                        range = [0, streamParameters.get("Size")];
                      }
                      this.streamState = { entryRanges: range, byteWidths, entryNum: 0, streamPos: stream.pos };
                    }
                    this.readXRefStream(stream);
                    delete this.streamState;
                    return stream.dict;
                  }, readXRefStream: function XRef_readXRefStream(stream) {
                    var i, j;
                    var streamState = this.streamState;
                    stream.pos = streamState.streamPos;
                    var byteWidths = streamState.byteWidths;
                    var typeFieldWidth = byteWidths[0];
                    var offsetFieldWidth = byteWidths[1];
                    var generationFieldWidth = byteWidths[2];
                    var entryRanges = streamState.entryRanges;
                    while (entryRanges.length > 0) {
                      var first = entryRanges[0];
                      var n = entryRanges[1];
                      if (!Number.isInteger(first) || !Number.isInteger(n)) {
                        throw new _util2.FormatError(`Invalid XRef range fields: ${first}, ${n}`);
                      }
                      if (!Number.isInteger(typeFieldWidth) || !Number.isInteger(offsetFieldWidth) || !Number.isInteger(generationFieldWidth)) {
                        throw new _util2.FormatError(`Invalid XRef entry fields length: ${first}, ${n}`);
                      }
                      for (i = streamState.entryNum; i < n; ++i) {
                        streamState.entryNum = i;
                        streamState.streamPos = stream.pos;
                        var type = 0, offset = 0, generation = 0;
                        for (j = 0; j < typeFieldWidth; ++j) {
                          type = type << 8 | stream.getByte();
                        }
                        if (typeFieldWidth === 0) {
                          type = 1;
                        }
                        for (j = 0; j < offsetFieldWidth; ++j) {
                          offset = offset << 8 | stream.getByte();
                        }
                        for (j = 0; j < generationFieldWidth; ++j) {
                          generation = generation << 8 | stream.getByte();
                        }
                        var entry = {};
                        entry.offset = offset;
                        entry.gen = generation;
                        switch (type) {
                          case 0:
                            entry.free = true;
                            break;
                          case 1:
                            entry.uncompressed = true;
                            break;
                          case 2:
                            break;
                          default:
                            throw new _util2.FormatError(`Invalid XRef entry type: ${type}`);
                        }
                        if (!this.entries[first + i]) {
                          this.entries[first + i] = entry;
                        }
                      }
                      streamState.entryNum = 0;
                      streamState.streamPos = stream.pos;
                      entryRanges.splice(0, 2);
                    }
                  }, indexObjects: function XRef_indexObjects() {
                    var TAB = 9, LF = 10, CR = 13, SPACE = 32;
                    var PERCENT = 37, LT = 60;
                    function readToken(data, offset) {
                      var token2 = "", ch2 = data[offset];
                      while (ch2 !== LF && ch2 !== CR && ch2 !== LT) {
                        if (++offset >= data.length) {
                          break;
                        }
                        token2 += String.fromCharCode(ch2);
                        ch2 = data[offset];
                      }
                      return token2;
                    }
                    function skipUntil(data, offset, what) {
                      var length2 = what.length, dataLength = data.length;
                      var skipped = 0;
                      while (offset < dataLength) {
                        var i2 = 0;
                        while (i2 < length2 && data[offset + i2] === what[i2]) {
                          ++i2;
                        }
                        if (i2 >= length2) {
                          break;
                        }
                        offset++;
                        skipped++;
                      }
                      return skipped;
                    }
                    var objRegExp = /^(\d+)\s+(\d+)\s+obj\b/;
                    const endobjRegExp = /\bendobj[\b\s]$/;
                    const nestedObjRegExp = /\s+(\d+\s+\d+\s+obj[\b\s<])$/;
                    const CHECK_CONTENT_LENGTH = 25;
                    var trailerBytes = new Uint8Array([116, 114, 97, 105, 108, 101, 114]);
                    var startxrefBytes = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]);
                    const objBytes = new Uint8Array([111, 98, 106]);
                    var xrefBytes = new Uint8Array([47, 88, 82, 101, 102]);
                    this.entries.length = 0;
                    var stream = this.stream;
                    stream.pos = 0;
                    var buffer = stream.getBytes();
                    var position = stream.start, length = buffer.length;
                    var trailers = [], xrefStms = [];
                    while (position < length) {
                      var ch = buffer[position];
                      if (ch === TAB || ch === LF || ch === CR || ch === SPACE) {
                        ++position;
                        continue;
                      }
                      if (ch === PERCENT) {
                        do {
                          ++position;
                          if (position >= length) {
                            break;
                          }
                          ch = buffer[position];
                        } while (ch !== LF && ch !== CR);
                        continue;
                      }
                      var token = readToken(buffer, position);
                      var m;
                      if (token.startsWith("xref") && (token.length === 4 || /\s/.test(token[4]))) {
                        position += skipUntil(buffer, position, trailerBytes);
                        trailers.push(position);
                        position += skipUntil(buffer, position, startxrefBytes);
                      } else if (m = objRegExp.exec(token)) {
                        const num = m[1] | 0, gen = m[2] | 0;
                        if (!this.entries[num] || this.entries[num].gen === gen) {
                          this.entries[num] = { offset: position - stream.start, gen, uncompressed: true };
                        }
                        let contentLength, startPos = position + token.length;
                        while (startPos < buffer.length) {
                          const endPos = startPos + skipUntil(buffer, startPos, objBytes) + 4;
                          contentLength = endPos - position;
                          const checkPos = Math.max(endPos - CHECK_CONTENT_LENGTH, startPos);
                          const tokenStr = (0, _util2.bytesToString)(buffer.subarray(checkPos, endPos));
                          if (endobjRegExp.test(tokenStr)) {
                            break;
                          } else {
                            const objToken = nestedObjRegExp.exec(tokenStr);
                            if (objToken && objToken[1]) {
                              (0, _util2.warn)('indexObjects: Found new "obj" inside of another "obj", caused by missing "endobj" -- trying to recover.');
                              contentLength -= objToken[1].length;
                              break;
                            }
                          }
                          startPos = endPos;
                        }
                        const content = buffer.subarray(position, position + contentLength);
                        var xrefTagOffset = skipUntil(content, 0, xrefBytes);
                        if (xrefTagOffset < contentLength && content[xrefTagOffset + 5] < 64) {
                          xrefStms.push(position - stream.start);
                          this.xrefstms[position - stream.start] = 1;
                        }
                        position += contentLength;
                      } else if (token.startsWith("trailer") && (token.length === 7 || /\s/.test(token[7]))) {
                        trailers.push(position);
                        position += skipUntil(buffer, position, startxrefBytes);
                      } else {
                        position += token.length + 1;
                      }
                    }
                    var i, ii;
                    for (i = 0, ii = xrefStms.length; i < ii; ++i) {
                      this.startXRefQueue.push(xrefStms[i]);
                      this.readXRef(true);
                    }
                    let trailerDict;
                    for (i = 0, ii = trailers.length; i < ii; ++i) {
                      stream.pos = trailers[i];
                      const parser = new _parser.Parser({ lexer: new _parser.Lexer(stream), xref: this, allowStreams: true, recoveryMode: true });
                      var obj = parser.getObj();
                      if (!(0, _primitives.isCmd)(obj, "trailer")) {
                        continue;
                      }
                      const dict = parser.getObj();
                      if (!(0, _primitives.isDict)(dict)) {
                        continue;
                      }
                      let rootDict;
                      try {
                        rootDict = dict.get("Root");
                      } catch (ex) {
                        if (ex instanceof _core_utils.MissingDataException) {
                          throw ex;
                        }
                        continue;
                      }
                      if (!(0, _primitives.isDict)(rootDict) || !rootDict.has("Pages")) {
                        continue;
                      }
                      if (dict.has("ID")) {
                        return dict;
                      }
                      trailerDict = dict;
                    }
                    if (trailerDict) {
                      return trailerDict;
                    }
                    throw new _util2.InvalidPDFException("Invalid PDF structure.");
                  }, readXRef: function XRef_readXRef(recoveryMode) {
                    var stream = this.stream;
                    const startXRefParsedCache = /* @__PURE__ */ Object.create(null);
                    try {
                      while (this.startXRefQueue.length) {
                        var startXRef = this.startXRefQueue[0];
                        if (startXRefParsedCache[startXRef]) {
                          (0, _util2.warn)("readXRef - skipping XRef table since it was already parsed.");
                          this.startXRefQueue.shift();
                          continue;
                        }
                        startXRefParsedCache[startXRef] = true;
                        stream.pos = startXRef + stream.start;
                        const parser = new _parser.Parser({ lexer: new _parser.Lexer(stream), xref: this, allowStreams: true });
                        var obj = parser.getObj();
                        var dict;
                        if ((0, _primitives.isCmd)(obj, "xref")) {
                          dict = this.processXRefTable(parser);
                          if (!this.topDict) {
                            this.topDict = dict;
                          }
                          obj = dict.get("XRefStm");
                          if (Number.isInteger(obj)) {
                            var pos = obj;
                            if (!(pos in this.xrefstms)) {
                              this.xrefstms[pos] = 1;
                              this.startXRefQueue.push(pos);
                            }
                          }
                        } else if (Number.isInteger(obj)) {
                          if (!Number.isInteger(parser.getObj()) || !(0, _primitives.isCmd)(parser.getObj(), "obj") || !(0, _primitives.isStream)(obj = parser.getObj())) {
                            throw new _util2.FormatError("Invalid XRef stream");
                          }
                          dict = this.processXRefStream(obj);
                          if (!this.topDict) {
                            this.topDict = dict;
                          }
                          if (!dict) {
                            throw new _util2.FormatError("Failed to read XRef stream");
                          }
                        } else {
                          throw new _util2.FormatError("Invalid XRef stream header");
                        }
                        obj = dict.get("Prev");
                        if (Number.isInteger(obj)) {
                          this.startXRefQueue.push(obj);
                        } else if ((0, _primitives.isRef)(obj)) {
                          this.startXRefQueue.push(obj.num);
                        }
                        this.startXRefQueue.shift();
                      }
                      return this.topDict;
                    } catch (e) {
                      if (e instanceof _core_utils.MissingDataException) {
                        throw e;
                      }
                      (0, _util2.info)("(while reading XRef): " + e);
                    }
                    if (recoveryMode) {
                      return void 0;
                    }
                    throw new _core_utils.XRefParseException();
                  }, getEntry: function XRef_getEntry(i) {
                    var xrefEntry = this.entries[i];
                    if (xrefEntry && !xrefEntry.free && xrefEntry.offset) {
                      return xrefEntry;
                    }
                    return null;
                  }, fetchIfRef: function XRef_fetchIfRef(obj, suppressEncryption) {
                    if (obj instanceof _primitives.Ref) {
                      return this.fetch(obj, suppressEncryption);
                    }
                    return obj;
                  }, fetch: function XRef_fetch(ref, suppressEncryption) {
                    if (!(ref instanceof _primitives.Ref)) {
                      throw new Error("ref object is not a reference");
                    }
                    const num = ref.num;
                    const cacheEntry = this._cacheMap.get(num);
                    if (cacheEntry !== void 0) {
                      if (cacheEntry instanceof _primitives.Dict && !cacheEntry.objId) {
                        cacheEntry.objId = ref.toString();
                      }
                      return cacheEntry;
                    }
                    let xrefEntry = this.getEntry(num);
                    if (xrefEntry === null) {
                      this._cacheMap.set(num, xrefEntry);
                      return xrefEntry;
                    }
                    if (xrefEntry.uncompressed) {
                      xrefEntry = this.fetchUncompressed(ref, xrefEntry, suppressEncryption);
                    } else {
                      xrefEntry = this.fetchCompressed(ref, xrefEntry, suppressEncryption);
                    }
                    if ((0, _primitives.isDict)(xrefEntry)) {
                      xrefEntry.objId = ref.toString();
                    } else if ((0, _primitives.isStream)(xrefEntry)) {
                      xrefEntry.dict.objId = ref.toString();
                    }
                    return xrefEntry;
                  }, fetchUncompressed(ref, xrefEntry, suppressEncryption = false) {
                    var gen = ref.gen;
                    var num = ref.num;
                    if (xrefEntry.gen !== gen) {
                      throw new _core_utils.XRefEntryException(`Inconsistent generation in XRef: ${ref}`);
                    }
                    var stream = this.stream.makeSubStream(xrefEntry.offset + this.stream.start);
                    const parser = new _parser.Parser({ lexer: new _parser.Lexer(stream), xref: this, allowStreams: true });
                    var obj1 = parser.getObj();
                    var obj2 = parser.getObj();
                    var obj3 = parser.getObj();
                    if (obj1 !== num || obj2 !== gen || !(obj3 instanceof _primitives.Cmd)) {
                      throw new _core_utils.XRefEntryException(`Bad (uncompressed) XRef entry: ${ref}`);
                    }
                    if (obj3.cmd !== "obj") {
                      if (obj3.cmd.startsWith("obj")) {
                        num = parseInt(obj3.cmd.substring(3), 10);
                        if (!Number.isNaN(num)) {
                          return num;
                        }
                      }
                      throw new _core_utils.XRefEntryException(`Bad (uncompressed) XRef entry: ${ref}`);
                    }
                    if (this.encrypt && !suppressEncryption) {
                      xrefEntry = parser.getObj(this.encrypt.createCipherTransform(num, gen));
                    } else {
                      xrefEntry = parser.getObj();
                    }
                    if (!(0, _primitives.isStream)(xrefEntry)) {
                      this._cacheMap.set(num, xrefEntry);
                    }
                    return xrefEntry;
                  }, fetchCompressed(ref, xrefEntry, suppressEncryption = false) {
                    const tableOffset = xrefEntry.offset;
                    const stream = this.fetch(_primitives.Ref.get(tableOffset, 0));
                    if (!(0, _primitives.isStream)(stream)) {
                      throw new _util2.FormatError("bad ObjStm stream");
                    }
                    const first = stream.dict.get("First");
                    const n = stream.dict.get("N");
                    if (!Number.isInteger(first) || !Number.isInteger(n)) {
                      throw new _util2.FormatError("invalid first and n parameters for ObjStm stream");
                    }
                    const parser = new _parser.Parser({ lexer: new _parser.Lexer(stream), xref: this, allowStreams: true });
                    const nums = new Array(n);
                    for (let i = 0; i < n; ++i) {
                      const num = parser.getObj();
                      if (!Number.isInteger(num)) {
                        throw new _util2.FormatError(`invalid object number in the ObjStm stream: ${num}`);
                      }
                      const offset = parser.getObj();
                      if (!Number.isInteger(offset)) {
                        throw new _util2.FormatError(`invalid object offset in the ObjStm stream: ${offset}`);
                      }
                      nums[i] = num;
                    }
                    const entries = new Array(n);
                    for (let i = 0; i < n; ++i) {
                      const obj = parser.getObj();
                      entries[i] = obj;
                      if (parser.buf1 instanceof _primitives.Cmd && parser.buf1.cmd === "endobj") {
                        parser.shift();
                      }
                      if ((0, _primitives.isStream)(obj)) {
                        continue;
                      }
                      const num = nums[i], entry = this.entries[num];
                      if (entry && entry.offset === tableOffset && entry.gen === i) {
                        this._cacheMap.set(num, obj);
                      }
                    }
                    xrefEntry = entries[xrefEntry.gen];
                    if (xrefEntry === void 0) {
                      throw new _core_utils.XRefEntryException(`Bad (compressed) XRef entry: ${ref}`);
                    }
                    return xrefEntry;
                  }, async fetchIfRefAsync(obj, suppressEncryption) {
                    if (obj instanceof _primitives.Ref) {
                      return this.fetchAsync(obj, suppressEncryption);
                    }
                    return obj;
                  }, async fetchAsync(ref, suppressEncryption) {
                    try {
                      return this.fetch(ref, suppressEncryption);
                    } catch (ex) {
                      if (!(ex instanceof _core_utils.MissingDataException)) {
                        throw ex;
                      }
                      await this.pdfManager.requestRange(ex.begin, ex.end);
                      return this.fetchAsync(ref, suppressEncryption);
                    }
                  }, getCatalogObj: function XRef_getCatalogObj() {
                    return this.root;
                  } };
                  return XRef2;
                }();
                exports2.XRef = XRef;
                class NameOrNumberTree {
                  constructor(root, xref, type) {
                    if (this.constructor === NameOrNumberTree) {
                      (0, _util2.unreachable)("Cannot initialize NameOrNumberTree.");
                    }
                    this.root = root;
                    this.xref = xref;
                    this._type = type;
                  }
                  getAll() {
                    const dict = /* @__PURE__ */ Object.create(null);
                    if (!this.root) {
                      return dict;
                    }
                    const xref = this.xref;
                    const processed = new _primitives.RefSet();
                    processed.put(this.root);
                    const queue = [this.root];
                    while (queue.length > 0) {
                      const obj = xref.fetchIfRef(queue.shift());
                      if (!(0, _primitives.isDict)(obj)) {
                        continue;
                      }
                      if (obj.has("Kids")) {
                        const kids = obj.get("Kids");
                        for (let i = 0, ii = kids.length; i < ii; i++) {
                          const kid = kids[i];
                          if (processed.has(kid)) {
                            throw new _util2.FormatError(`Duplicate entry in "${this._type}" tree.`);
                          }
                          queue.push(kid);
                          processed.put(kid);
                        }
                        continue;
                      }
                      const entries = obj.get(this._type);
                      if (Array.isArray(entries)) {
                        for (let i = 0, ii = entries.length; i < ii; i += 2) {
                          dict[xref.fetchIfRef(entries[i])] = xref.fetchIfRef(entries[i + 1]);
                        }
                      }
                    }
                    return dict;
                  }
                  get(key) {
                    if (!this.root) {
                      return null;
                    }
                    const xref = this.xref;
                    let kidsOrEntries = xref.fetchIfRef(this.root);
                    let loopCount = 0;
                    const MAX_LEVELS = 10;
                    while (kidsOrEntries.has("Kids")) {
                      if (++loopCount > MAX_LEVELS) {
                        (0, _util2.warn)(`Search depth limit reached for "${this._type}" tree.`);
                        return null;
                      }
                      const kids = kidsOrEntries.get("Kids");
                      if (!Array.isArray(kids)) {
                        return null;
                      }
                      let l = 0, r = kids.length - 1;
                      while (l <= r) {
                        const m = l + r >> 1;
                        const kid = xref.fetchIfRef(kids[m]);
                        const limits = kid.get("Limits");
                        if (key < xref.fetchIfRef(limits[0])) {
                          r = m - 1;
                        } else if (key > xref.fetchIfRef(limits[1])) {
                          l = m + 1;
                        } else {
                          kidsOrEntries = xref.fetchIfRef(kids[m]);
                          break;
                        }
                      }
                      if (l > r) {
                        return null;
                      }
                    }
                    const entries = kidsOrEntries.get(this._type);
                    if (Array.isArray(entries)) {
                      let l = 0, r = entries.length - 2;
                      while (l <= r) {
                        const tmp = l + r >> 1, m = tmp + (tmp & 1);
                        const currentKey = xref.fetchIfRef(entries[m]);
                        if (key < currentKey) {
                          r = m - 2;
                        } else if (key > currentKey) {
                          l = m + 2;
                        } else {
                          return xref.fetchIfRef(entries[m + 1]);
                        }
                      }
                      (0, _util2.info)(`Falling back to an exhaustive search, for key "${key}", in "${this._type}" tree.`);
                      for (let m = 0, mm = entries.length; m < mm; m += 2) {
                        const currentKey = xref.fetchIfRef(entries[m]);
                        if (currentKey === key) {
                          (0, _util2.warn)(`The "${key}" key was found at an incorrect, i.e. out-of-order, position in "${this._type}" tree.`);
                          return xref.fetchIfRef(entries[m + 1]);
                        }
                      }
                    }
                    return null;
                  }
                }
                class NameTree extends NameOrNumberTree {
                  constructor(root, xref) {
                    super(root, xref, "Names");
                  }
                }
                class NumberTree extends NameOrNumberTree {
                  constructor(root, xref) {
                    super(root, xref, "Nums");
                  }
                }
                var FileSpec = function FileSpecClosure() {
                  function FileSpec2(root, xref) {
                    if (!root || !(0, _primitives.isDict)(root)) {
                      return;
                    }
                    this.xref = xref;
                    this.root = root;
                    if (root.has("FS")) {
                      this.fs = root.get("FS");
                    }
                    this.description = root.has("Desc") ? (0, _util2.stringToPDFString)(root.get("Desc")) : "";
                    if (root.has("RF")) {
                      (0, _util2.warn)("Related file specifications are not supported");
                    }
                    this.contentAvailable = true;
                    if (!root.has("EF")) {
                      this.contentAvailable = false;
                      (0, _util2.warn)("Non-embedded file specifications are not supported");
                    }
                  }
                  function pickPlatformItem(dict) {
                    if (dict.has("UF")) {
                      return dict.get("UF");
                    } else if (dict.has("F")) {
                      return dict.get("F");
                    } else if (dict.has("Unix")) {
                      return dict.get("Unix");
                    } else if (dict.has("Mac")) {
                      return dict.get("Mac");
                    } else if (dict.has("DOS")) {
                      return dict.get("DOS");
                    }
                    return null;
                  }
                  FileSpec2.prototype = { get filename() {
                    if (!this._filename && this.root) {
                      var filename = pickPlatformItem(this.root) || "unnamed";
                      this._filename = (0, _util2.stringToPDFString)(filename).replace(/\\\\/g, "\\").replace(/\\\//g, "/").replace(/\\/g, "/");
                    }
                    return this._filename;
                  }, get content() {
                    if (!this.contentAvailable) {
                      return null;
                    }
                    if (!this.contentRef && this.root) {
                      this.contentRef = pickPlatformItem(this.root.get("EF"));
                    }
                    var content = null;
                    if (this.contentRef) {
                      var xref = this.xref;
                      var fileObj = xref.fetchIfRef(this.contentRef);
                      if (fileObj && (0, _primitives.isStream)(fileObj)) {
                        content = fileObj.getBytes();
                      } else {
                        (0, _util2.warn)("Embedded file specification points to non-existing/invalid content");
                      }
                    } else {
                      (0, _util2.warn)("Embedded file specification does not have a content");
                    }
                    return content;
                  }, get serializable() {
                    return { filename: this.filename, content: this.content };
                  } };
                  return FileSpec2;
                }();
                exports2.FileSpec = FileSpec;
                const ObjectLoader = function() {
                  function mayHaveChildren(value) {
                    return value instanceof _primitives.Ref || value instanceof _primitives.Dict || Array.isArray(value) || (0, _primitives.isStream)(value);
                  }
                  function addChildren(node, nodesToVisit) {
                    if (node instanceof _primitives.Dict || (0, _primitives.isStream)(node)) {
                      const dict = node instanceof _primitives.Dict ? node : node.dict;
                      const dictKeys = dict.getKeys();
                      for (let i = 0, ii = dictKeys.length; i < ii; i++) {
                        const rawValue = dict.getRaw(dictKeys[i]);
                        if (mayHaveChildren(rawValue)) {
                          nodesToVisit.push(rawValue);
                        }
                      }
                    } else if (Array.isArray(node)) {
                      for (let i = 0, ii = node.length; i < ii; i++) {
                        const value = node[i];
                        if (mayHaveChildren(value)) {
                          nodesToVisit.push(value);
                        }
                      }
                    }
                  }
                  function ObjectLoader2(dict, keys, xref) {
                    this.dict = dict;
                    this.keys = keys;
                    this.xref = xref;
                    this.refSet = null;
                  }
                  ObjectLoader2.prototype = { async load() {
                    if (!this.xref.stream.allChunksLoaded || this.xref.stream.allChunksLoaded()) {
                      return void 0;
                    }
                    const { keys, dict } = this;
                    this.refSet = new _primitives.RefSet();
                    const nodesToVisit = [];
                    for (let i = 0, ii = keys.length; i < ii; i++) {
                      const rawValue = dict.getRaw(keys[i]);
                      if (rawValue !== void 0) {
                        nodesToVisit.push(rawValue);
                      }
                    }
                    return this._walk(nodesToVisit);
                  }, async _walk(nodesToVisit) {
                    const nodesToRevisit = [];
                    const pendingRequests = [];
                    while (nodesToVisit.length) {
                      let currentNode = nodesToVisit.pop();
                      if (currentNode instanceof _primitives.Ref) {
                        if (this.refSet.has(currentNode)) {
                          continue;
                        }
                        try {
                          this.refSet.put(currentNode);
                          currentNode = this.xref.fetch(currentNode);
                        } catch (ex) {
                          if (!(ex instanceof _core_utils.MissingDataException)) {
                            throw ex;
                          }
                          nodesToRevisit.push(currentNode);
                          pendingRequests.push({ begin: ex.begin, end: ex.end });
                        }
                      }
                      if (currentNode && currentNode.getBaseStreams) {
                        const baseStreams = currentNode.getBaseStreams();
                        let foundMissingData = false;
                        for (let i = 0, ii = baseStreams.length; i < ii; i++) {
                          const stream = baseStreams[i];
                          if (stream.allChunksLoaded && !stream.allChunksLoaded()) {
                            foundMissingData = true;
                            pendingRequests.push({ begin: stream.start, end: stream.end });
                          }
                        }
                        if (foundMissingData) {
                          nodesToRevisit.push(currentNode);
                        }
                      }
                      addChildren(currentNode, nodesToVisit);
                    }
                    if (pendingRequests.length) {
                      await this.xref.stream.manager.requestRanges(pendingRequests);
                      for (let i = 0, ii = nodesToRevisit.length; i < ii; i++) {
                        const node = nodesToRevisit[i];
                        if (node instanceof _primitives.Ref) {
                          this.refSet.remove(node);
                        }
                      }
                      return this._walk(nodesToRevisit);
                    }
                    this.refSet = null;
                    return void 0;
                  } };
                  return ObjectLoader2;
                }();
                exports2.ObjectLoader = ObjectLoader;
              }, function(module3, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.Parser = exports2.Linearization = exports2.Lexer = void 0;
                var _stream = __w_pdfjs_require__2(11);
                var _util2 = __w_pdfjs_require__2(2);
                var _primitives = __w_pdfjs_require__2(4);
                var _core_utils = __w_pdfjs_require__2(7);
                var _ccitt_stream = __w_pdfjs_require__2(12);
                var _jbig2_stream = __w_pdfjs_require__2(14);
                var _jpeg_stream = __w_pdfjs_require__2(17);
                var _jpx_stream = __w_pdfjs_require__2(19);
                const MAX_LENGTH_TO_CACHE = 1e3;
                const MAX_ADLER32_LENGTH = 5552;
                function computeAdler32(bytes) {
                  const bytesLength = bytes.length;
                  let a = 1, b = 0;
                  for (let i = 0; i < bytesLength; ++i) {
                    a += bytes[i] & 255;
                    b += a;
                  }
                  return b % 65521 << 16 | a % 65521;
                }
                class Parser {
                  constructor({ lexer, xref, allowStreams = false, recoveryMode = false }) {
                    this.lexer = lexer;
                    this.xref = xref;
                    this.allowStreams = allowStreams;
                    this.recoveryMode = recoveryMode;
                    this.imageCache = /* @__PURE__ */ Object.create(null);
                    this.refill();
                  }
                  refill() {
                    this.buf1 = this.lexer.getObj();
                    this.buf2 = this.lexer.getObj();
                  }
                  shift() {
                    if (this.buf2 instanceof _primitives.Cmd && this.buf2.cmd === "ID") {
                      this.buf1 = this.buf2;
                      this.buf2 = null;
                    } else {
                      this.buf1 = this.buf2;
                      this.buf2 = this.lexer.getObj();
                    }
                  }
                  tryShift() {
                    try {
                      this.shift();
                      return true;
                    } catch (e) {
                      if (e instanceof _core_utils.MissingDataException) {
                        throw e;
                      }
                      return false;
                    }
                  }
                  getObj(cipherTransform = null) {
                    const buf1 = this.buf1;
                    this.shift();
                    if (buf1 instanceof _primitives.Cmd) {
                      switch (buf1.cmd) {
                        case "BI":
                          return this.makeInlineImage(cipherTransform);
                        case "[":
                          const array = [];
                          while (!(0, _primitives.isCmd)(this.buf1, "]") && !(0, _primitives.isEOF)(this.buf1)) {
                            array.push(this.getObj(cipherTransform));
                          }
                          if ((0, _primitives.isEOF)(this.buf1)) {
                            if (!this.recoveryMode) {
                              throw new _util2.FormatError("End of file inside array");
                            }
                            return array;
                          }
                          this.shift();
                          return array;
                        case "<<":
                          const dict = new _primitives.Dict(this.xref);
                          while (!(0, _primitives.isCmd)(this.buf1, ">>") && !(0, _primitives.isEOF)(this.buf1)) {
                            if (!(0, _primitives.isName)(this.buf1)) {
                              (0, _util2.info)("Malformed dictionary: key must be a name object");
                              this.shift();
                              continue;
                            }
                            const key = this.buf1.name;
                            this.shift();
                            if ((0, _primitives.isEOF)(this.buf1)) {
                              break;
                            }
                            dict.set(key, this.getObj(cipherTransform));
                          }
                          if ((0, _primitives.isEOF)(this.buf1)) {
                            if (!this.recoveryMode) {
                              throw new _util2.FormatError("End of file inside dictionary");
                            }
                            return dict;
                          }
                          if ((0, _primitives.isCmd)(this.buf2, "stream")) {
                            return this.allowStreams ? this.makeStream(dict, cipherTransform) : dict;
                          }
                          this.shift();
                          return dict;
                        default:
                          return buf1;
                      }
                    }
                    if (Number.isInteger(buf1)) {
                      if (Number.isInteger(this.buf1) && (0, _primitives.isCmd)(this.buf2, "R")) {
                        const ref = _primitives.Ref.get(buf1, this.buf1);
                        this.shift();
                        this.shift();
                        return ref;
                      }
                      return buf1;
                    }
                    if (typeof buf1 === "string") {
                      if (cipherTransform) {
                        return cipherTransform.decryptString(buf1);
                      }
                      return buf1;
                    }
                    return buf1;
                  }
                  findDefaultInlineStreamEnd(stream) {
                    const E = 69, I = 73, SPACE = 32, LF = 10, CR = 13;
                    const n = 10, NUL = 0;
                    const startPos = stream.pos;
                    let state = 0, ch, maybeEIPos;
                    while ((ch = stream.getByte()) !== -1) {
                      if (state === 0) {
                        state = ch === E ? 1 : 0;
                      } else if (state === 1) {
                        state = ch === I ? 2 : 0;
                      } else {
                        (0, _util2.assert)(state === 2);
                        if (ch === SPACE || ch === LF || ch === CR) {
                          maybeEIPos = stream.pos;
                          const followingBytes = stream.peekBytes(n);
                          for (let i = 0, ii = followingBytes.length; i < ii; i++) {
                            ch = followingBytes[i];
                            if (ch === NUL && followingBytes[i + 1] !== NUL) {
                              continue;
                            }
                            if (ch !== LF && ch !== CR && (ch < SPACE || ch > 127)) {
                              state = 0;
                              break;
                            }
                          }
                          if (state === 2) {
                            break;
                          }
                        } else {
                          state = 0;
                        }
                      }
                    }
                    if (ch === -1) {
                      (0, _util2.warn)("findDefaultInlineStreamEnd: Reached the end of the stream without finding a valid EI marker");
                      if (maybeEIPos) {
                        (0, _util2.warn)('... trying to recover by using the last "EI" occurrence.');
                        stream.skip(-(stream.pos - maybeEIPos));
                      }
                    }
                    let endOffset = 4;
                    stream.skip(-endOffset);
                    ch = stream.peekByte();
                    stream.skip(endOffset);
                    if (!(0, _core_utils.isWhiteSpace)(ch)) {
                      endOffset--;
                    }
                    return stream.pos - endOffset - startPos;
                  }
                  findDCTDecodeInlineStreamEnd(stream) {
                    const startPos = stream.pos;
                    let foundEOI = false, b, markerLength;
                    while ((b = stream.getByte()) !== -1) {
                      if (b !== 255) {
                        continue;
                      }
                      switch (stream.getByte()) {
                        case 0:
                          break;
                        case 255:
                          stream.skip(-1);
                          break;
                        case 217:
                          foundEOI = true;
                          break;
                        case 192:
                        case 193:
                        case 194:
                        case 195:
                        case 197:
                        case 198:
                        case 199:
                        case 201:
                        case 202:
                        case 203:
                        case 205:
                        case 206:
                        case 207:
                        case 196:
                        case 204:
                        case 218:
                        case 219:
                        case 220:
                        case 221:
                        case 222:
                        case 223:
                        case 224:
                        case 225:
                        case 226:
                        case 227:
                        case 228:
                        case 229:
                        case 230:
                        case 231:
                        case 232:
                        case 233:
                        case 234:
                        case 235:
                        case 236:
                        case 237:
                        case 238:
                        case 239:
                        case 254:
                          markerLength = stream.getUint16();
                          if (markerLength > 2) {
                            stream.skip(markerLength - 2);
                          } else {
                            stream.skip(-2);
                          }
                          break;
                      }
                      if (foundEOI) {
                        break;
                      }
                    }
                    const length = stream.pos - startPos;
                    if (b === -1) {
                      (0, _util2.warn)("Inline DCTDecode image stream: EOI marker not found, searching for /EI/ instead.");
                      stream.skip(-length);
                      return this.findDefaultInlineStreamEnd(stream);
                    }
                    this.inlineStreamSkipEI(stream);
                    return length;
                  }
                  findASCII85DecodeInlineStreamEnd(stream) {
                    const TILDE = 126, GT = 62;
                    const startPos = stream.pos;
                    let ch;
                    while ((ch = stream.getByte()) !== -1) {
                      if (ch === TILDE) {
                        const tildePos = stream.pos;
                        ch = stream.peekByte();
                        while ((0, _core_utils.isWhiteSpace)(ch)) {
                          stream.skip();
                          ch = stream.peekByte();
                        }
                        if (ch === GT) {
                          stream.skip();
                          break;
                        }
                        if (stream.pos > tildePos) {
                          const maybeEI = stream.peekBytes(2);
                          if (maybeEI[0] === 69 && maybeEI[1] === 73) {
                            break;
                          }
                        }
                      }
                    }
                    const length = stream.pos - startPos;
                    if (ch === -1) {
                      (0, _util2.warn)("Inline ASCII85Decode image stream: EOD marker not found, searching for /EI/ instead.");
                      stream.skip(-length);
                      return this.findDefaultInlineStreamEnd(stream);
                    }
                    this.inlineStreamSkipEI(stream);
                    return length;
                  }
                  findASCIIHexDecodeInlineStreamEnd(stream) {
                    const GT = 62;
                    const startPos = stream.pos;
                    let ch;
                    while ((ch = stream.getByte()) !== -1) {
                      if (ch === GT) {
                        break;
                      }
                    }
                    const length = stream.pos - startPos;
                    if (ch === -1) {
                      (0, _util2.warn)("Inline ASCIIHexDecode image stream: EOD marker not found, searching for /EI/ instead.");
                      stream.skip(-length);
                      return this.findDefaultInlineStreamEnd(stream);
                    }
                    this.inlineStreamSkipEI(stream);
                    return length;
                  }
                  inlineStreamSkipEI(stream) {
                    const E = 69, I = 73;
                    let state = 0, ch;
                    while ((ch = stream.getByte()) !== -1) {
                      if (state === 0) {
                        state = ch === E ? 1 : 0;
                      } else if (state === 1) {
                        state = ch === I ? 2 : 0;
                      } else if (state === 2) {
                        break;
                      }
                    }
                  }
                  makeInlineImage(cipherTransform) {
                    const lexer = this.lexer;
                    const stream = lexer.stream;
                    const dict = new _primitives.Dict(this.xref);
                    let dictLength;
                    while (!(0, _primitives.isCmd)(this.buf1, "ID") && !(0, _primitives.isEOF)(this.buf1)) {
                      if (!(0, _primitives.isName)(this.buf1)) {
                        throw new _util2.FormatError("Dictionary key must be a name object");
                      }
                      const key = this.buf1.name;
                      this.shift();
                      if ((0, _primitives.isEOF)(this.buf1)) {
                        break;
                      }
                      dict.set(key, this.getObj(cipherTransform));
                    }
                    if (lexer.beginInlineImagePos !== -1) {
                      dictLength = stream.pos - lexer.beginInlineImagePos;
                    }
                    const filter = dict.get("Filter", "F");
                    let filterName;
                    if ((0, _primitives.isName)(filter)) {
                      filterName = filter.name;
                    } else if (Array.isArray(filter)) {
                      const filterZero = this.xref.fetchIfRef(filter[0]);
                      if ((0, _primitives.isName)(filterZero)) {
                        filterName = filterZero.name;
                      }
                    }
                    const startPos = stream.pos;
                    let length;
                    if (filterName === "DCTDecode" || filterName === "DCT") {
                      length = this.findDCTDecodeInlineStreamEnd(stream);
                    } else if (filterName === "ASCII85Decode" || filterName === "A85") {
                      length = this.findASCII85DecodeInlineStreamEnd(stream);
                    } else if (filterName === "ASCIIHexDecode" || filterName === "AHx") {
                      length = this.findASCIIHexDecodeInlineStreamEnd(stream);
                    } else {
                      length = this.findDefaultInlineStreamEnd(stream);
                    }
                    let imageStream = stream.makeSubStream(startPos, length, dict);
                    let cacheKey;
                    if (length < MAX_LENGTH_TO_CACHE && dictLength < MAX_ADLER32_LENGTH) {
                      const imageBytes = imageStream.getBytes();
                      imageStream.reset();
                      const initialStreamPos = stream.pos;
                      stream.pos = lexer.beginInlineImagePos;
                      const dictBytes = stream.getBytes(dictLength);
                      stream.pos = initialStreamPos;
                      cacheKey = computeAdler32(imageBytes) + "_" + computeAdler32(dictBytes);
                      const cacheEntry = this.imageCache[cacheKey];
                      if (cacheEntry !== void 0) {
                        this.buf2 = _primitives.Cmd.get("EI");
                        this.shift();
                        cacheEntry.reset();
                        return cacheEntry;
                      }
                    }
                    if (cipherTransform) {
                      imageStream = cipherTransform.createStream(imageStream, length);
                    }
                    imageStream = this.filter(imageStream, dict, length);
                    imageStream.dict = dict;
                    if (cacheKey !== void 0) {
                      imageStream.cacheKey = `inline_${length}_${cacheKey}`;
                      this.imageCache[cacheKey] = imageStream;
                    }
                    this.buf2 = _primitives.Cmd.get("EI");
                    this.shift();
                    return imageStream;
                  }
                  _findStreamLength(startPos, signature) {
                    const { stream } = this.lexer;
                    stream.pos = startPos;
                    const SCAN_BLOCK_LENGTH = 2048;
                    const signatureLength = signature.length;
                    while (stream.pos < stream.end) {
                      const scanBytes = stream.peekBytes(SCAN_BLOCK_LENGTH);
                      const scanLength = scanBytes.length - signatureLength;
                      if (scanLength <= 0) {
                        break;
                      }
                      let pos = 0;
                      while (pos < scanLength) {
                        let j = 0;
                        while (j < signatureLength && scanBytes[pos + j] === signature[j]) {
                          j++;
                        }
                        if (j >= signatureLength) {
                          stream.pos += pos;
                          return stream.pos - startPos;
                        }
                        pos++;
                      }
                      stream.pos += scanLength;
                    }
                    return -1;
                  }
                  makeStream(dict, cipherTransform) {
                    const lexer = this.lexer;
                    let stream = lexer.stream;
                    lexer.skipToNextLine();
                    const startPos = stream.pos - 1;
                    let length = dict.get("Length");
                    if (!Number.isInteger(length)) {
                      (0, _util2.info)(`Bad length "${length}" in stream`);
                      length = 0;
                    }
                    stream.pos = startPos + length;
                    lexer.nextChar();
                    if (this.tryShift() && (0, _primitives.isCmd)(this.buf2, "endstream")) {
                      this.shift();
                    } else {
                      const ENDSTREAM_SIGNATURE = new Uint8Array([101, 110, 100, 115, 116, 114, 101, 97, 109]);
                      let actualLength = this._findStreamLength(startPos, ENDSTREAM_SIGNATURE);
                      if (actualLength < 0) {
                        const MAX_TRUNCATION = 1;
                        for (let i = 1; i <= MAX_TRUNCATION; i++) {
                          const end = ENDSTREAM_SIGNATURE.length - i;
                          const TRUNCATED_SIGNATURE = ENDSTREAM_SIGNATURE.slice(0, end);
                          const maybeLength = this._findStreamLength(startPos, TRUNCATED_SIGNATURE);
                          if (maybeLength >= 0) {
                            const lastByte = stream.peekBytes(end + 1)[end];
                            if (!(0, _core_utils.isWhiteSpace)(lastByte)) {
                              break;
                            }
                            (0, _util2.info)(`Found "${(0, _util2.bytesToString)(TRUNCATED_SIGNATURE)}" when searching for endstream command.`);
                            actualLength = maybeLength;
                            break;
                          }
                        }
                        if (actualLength < 0) {
                          throw new _util2.FormatError("Missing endstream command.");
                        }
                      }
                      length = actualLength;
                      lexer.nextChar();
                      this.shift();
                      this.shift();
                    }
                    this.shift();
                    stream = stream.makeSubStream(startPos, length, dict);
                    if (cipherTransform) {
                      stream = cipherTransform.createStream(stream, length);
                    }
                    stream = this.filter(stream, dict, length);
                    stream.dict = dict;
                    return stream;
                  }
                  filter(stream, dict, length) {
                    let filter = dict.get("Filter", "F");
                    let params = dict.get("DecodeParms", "DP");
                    if ((0, _primitives.isName)(filter)) {
                      if (Array.isArray(params)) {
                        (0, _util2.warn)("/DecodeParms should not contain an Array, when /Filter contains a Name.");
                      }
                      return this.makeFilter(stream, filter.name, length, params);
                    }
                    let maybeLength = length;
                    if (Array.isArray(filter)) {
                      const filterArray = filter;
                      const paramsArray = params;
                      for (let i = 0, ii = filterArray.length; i < ii; ++i) {
                        filter = this.xref.fetchIfRef(filterArray[i]);
                        if (!(0, _primitives.isName)(filter)) {
                          throw new _util2.FormatError(`Bad filter name "${filter}"`);
                        }
                        params = null;
                        if (Array.isArray(paramsArray) && i in paramsArray) {
                          params = this.xref.fetchIfRef(paramsArray[i]);
                        }
                        stream = this.makeFilter(stream, filter.name, maybeLength, params);
                        maybeLength = null;
                      }
                    }
                    return stream;
                  }
                  makeFilter(stream, name, maybeLength, params) {
                    if (maybeLength === 0) {
                      (0, _util2.warn)(`Empty "${name}" stream.`);
                      return new _stream.NullStream();
                    }
                    try {
                      const xrefStreamStats = this.xref.stats.streamTypes;
                      if (name === "FlateDecode" || name === "Fl") {
                        xrefStreamStats[_util2.StreamType.FLATE] = true;
                        if (params) {
                          return new _stream.PredictorStream(new _stream.FlateStream(stream, maybeLength), maybeLength, params);
                        }
                        return new _stream.FlateStream(stream, maybeLength);
                      }
                      if (name === "LZWDecode" || name === "LZW") {
                        xrefStreamStats[_util2.StreamType.LZW] = true;
                        let earlyChange = 1;
                        if (params) {
                          if (params.has("EarlyChange")) {
                            earlyChange = params.get("EarlyChange");
                          }
                          return new _stream.PredictorStream(new _stream.LZWStream(stream, maybeLength, earlyChange), maybeLength, params);
                        }
                        return new _stream.LZWStream(stream, maybeLength, earlyChange);
                      }
                      if (name === "DCTDecode" || name === "DCT") {
                        xrefStreamStats[_util2.StreamType.DCT] = true;
                        return new _jpeg_stream.JpegStream(stream, maybeLength, stream.dict, params);
                      }
                      if (name === "JPXDecode" || name === "JPX") {
                        xrefStreamStats[_util2.StreamType.JPX] = true;
                        return new _jpx_stream.JpxStream(stream, maybeLength, stream.dict, params);
                      }
                      if (name === "ASCII85Decode" || name === "A85") {
                        xrefStreamStats[_util2.StreamType.A85] = true;
                        return new _stream.Ascii85Stream(stream, maybeLength);
                      }
                      if (name === "ASCIIHexDecode" || name === "AHx") {
                        xrefStreamStats[_util2.StreamType.AHX] = true;
                        return new _stream.AsciiHexStream(stream, maybeLength);
                      }
                      if (name === "CCITTFaxDecode" || name === "CCF") {
                        xrefStreamStats[_util2.StreamType.CCF] = true;
                        return new _ccitt_stream.CCITTFaxStream(stream, maybeLength, params);
                      }
                      if (name === "RunLengthDecode" || name === "RL") {
                        xrefStreamStats[_util2.StreamType.RLX] = true;
                        return new _stream.RunLengthStream(stream, maybeLength);
                      }
                      if (name === "JBIG2Decode") {
                        xrefStreamStats[_util2.StreamType.JBIG] = true;
                        return new _jbig2_stream.Jbig2Stream(stream, maybeLength, stream.dict, params);
                      }
                      (0, _util2.warn)(`Filter "${name}" is not supported.`);
                      return stream;
                    } catch (ex) {
                      if (ex instanceof _core_utils.MissingDataException) {
                        throw ex;
                      }
                      (0, _util2.warn)(`Invalid stream: "${ex}"`);
                      return new _stream.NullStream();
                    }
                  }
                }
                exports2.Parser = Parser;
                const specialChars = [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                function toHexDigit(ch) {
                  if (ch >= 48 && ch <= 57) {
                    return ch & 15;
                  }
                  if (ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102) {
                    return (ch & 15) + 9;
                  }
                  return -1;
                }
                class Lexer {
                  constructor(stream, knownCommands = null) {
                    this.stream = stream;
                    this.nextChar();
                    this.strBuf = [];
                    this.knownCommands = knownCommands;
                    this._hexStringNumWarn = 0;
                    this.beginInlineImagePos = -1;
                  }
                  nextChar() {
                    return this.currentChar = this.stream.getByte();
                  }
                  peekChar() {
                    return this.stream.peekByte();
                  }
                  getNumber() {
                    let ch = this.currentChar;
                    let eNotation = false;
                    let divideBy = 0;
                    let sign = 0;
                    if (ch === 45) {
                      sign = -1;
                      ch = this.nextChar();
                      if (ch === 45) {
                        ch = this.nextChar();
                      }
                    } else if (ch === 43) {
                      sign = 1;
                      ch = this.nextChar();
                    }
                    if (ch === 10 || ch === 13) {
                      do {
                        ch = this.nextChar();
                      } while (ch === 10 || ch === 13);
                    }
                    if (ch === 46) {
                      divideBy = 10;
                      ch = this.nextChar();
                    }
                    if (ch < 48 || ch > 57) {
                      if (divideBy === 10 && sign === 0 && ((0, _core_utils.isWhiteSpace)(ch) || ch === -1)) {
                        (0, _util2.warn)("Lexer.getNumber - treating a single decimal point as zero.");
                        return 0;
                      }
                      throw new _util2.FormatError(`Invalid number: ${String.fromCharCode(ch)} (charCode ${ch})`);
                    }
                    sign = sign || 1;
                    let baseValue = ch - 48;
                    let powerValue = 0;
                    let powerValueSign = 1;
                    while ((ch = this.nextChar()) >= 0) {
                      if (ch >= 48 && ch <= 57) {
                        const currentDigit = ch - 48;
                        if (eNotation) {
                          powerValue = powerValue * 10 + currentDigit;
                        } else {
                          if (divideBy !== 0) {
                            divideBy *= 10;
                          }
                          baseValue = baseValue * 10 + currentDigit;
                        }
                      } else if (ch === 46) {
                        if (divideBy === 0) {
                          divideBy = 1;
                        } else {
                          break;
                        }
                      } else if (ch === 45) {
                        (0, _util2.warn)("Badly formatted number: minus sign in the middle");
                      } else if (ch === 69 || ch === 101) {
                        ch = this.peekChar();
                        if (ch === 43 || ch === 45) {
                          powerValueSign = ch === 45 ? -1 : 1;
                          this.nextChar();
                        } else if (ch < 48 || ch > 57) {
                          break;
                        }
                        eNotation = true;
                      } else {
                        break;
                      }
                    }
                    if (divideBy !== 0) {
                      baseValue /= divideBy;
                    }
                    if (eNotation) {
                      baseValue *= 10 ** (powerValueSign * powerValue);
                    }
                    return sign * baseValue;
                  }
                  getString() {
                    let numParen = 1;
                    let done = false;
                    const strBuf = this.strBuf;
                    strBuf.length = 0;
                    let ch = this.nextChar();
                    while (true) {
                      let charBuffered = false;
                      switch (ch | 0) {
                        case -1:
                          (0, _util2.warn)("Unterminated string");
                          done = true;
                          break;
                        case 40:
                          ++numParen;
                          strBuf.push("(");
                          break;
                        case 41:
                          if (--numParen === 0) {
                            this.nextChar();
                            done = true;
                          } else {
                            strBuf.push(")");
                          }
                          break;
                        case 92:
                          ch = this.nextChar();
                          switch (ch) {
                            case -1:
                              (0, _util2.warn)("Unterminated string");
                              done = true;
                              break;
                            case 110:
                              strBuf.push("\n");
                              break;
                            case 114:
                              strBuf.push("\r");
                              break;
                            case 116:
                              strBuf.push("	");
                              break;
                            case 98:
                              strBuf.push("\b");
                              break;
                            case 102:
                              strBuf.push("\f");
                              break;
                            case 92:
                            case 40:
                            case 41:
                              strBuf.push(String.fromCharCode(ch));
                              break;
                            case 48:
                            case 49:
                            case 50:
                            case 51:
                            case 52:
                            case 53:
                            case 54:
                            case 55:
                              let x = ch & 15;
                              ch = this.nextChar();
                              charBuffered = true;
                              if (ch >= 48 && ch <= 55) {
                                x = (x << 3) + (ch & 15);
                                ch = this.nextChar();
                                if (ch >= 48 && ch <= 55) {
                                  charBuffered = false;
                                  x = (x << 3) + (ch & 15);
                                }
                              }
                              strBuf.push(String.fromCharCode(x));
                              break;
                            case 13:
                              if (this.peekChar() === 10) {
                                this.nextChar();
                              }
                              break;
                            case 10:
                              break;
                            default:
                              strBuf.push(String.fromCharCode(ch));
                              break;
                          }
                          break;
                        default:
                          strBuf.push(String.fromCharCode(ch));
                          break;
                      }
                      if (done) {
                        break;
                      }
                      if (!charBuffered) {
                        ch = this.nextChar();
                      }
                    }
                    return strBuf.join("");
                  }
                  getName() {
                    let ch, previousCh;
                    const strBuf = this.strBuf;
                    strBuf.length = 0;
                    while ((ch = this.nextChar()) >= 0 && !specialChars[ch]) {
                      if (ch === 35) {
                        ch = this.nextChar();
                        if (specialChars[ch]) {
                          (0, _util2.warn)("Lexer_getName: NUMBER SIGN (#) should be followed by a hexadecimal number.");
                          strBuf.push("#");
                          break;
                        }
                        const x = toHexDigit(ch);
                        if (x !== -1) {
                          previousCh = ch;
                          ch = this.nextChar();
                          const x2 = toHexDigit(ch);
                          if (x2 === -1) {
                            (0, _util2.warn)(`Lexer_getName: Illegal digit (${String.fromCharCode(ch)}) in hexadecimal number.`);
                            strBuf.push("#", String.fromCharCode(previousCh));
                            if (specialChars[ch]) {
                              break;
                            }
                            strBuf.push(String.fromCharCode(ch));
                            continue;
                          }
                          strBuf.push(String.fromCharCode(x << 4 | x2));
                        } else {
                          strBuf.push("#", String.fromCharCode(ch));
                        }
                      } else {
                        strBuf.push(String.fromCharCode(ch));
                      }
                    }
                    if (strBuf.length > 127) {
                      (0, _util2.warn)(`Name token is longer than allowed by the spec: ${strBuf.length}`);
                    }
                    return _primitives.Name.get(strBuf.join(""));
                  }
                  _hexStringWarn(ch) {
                    const MAX_HEX_STRING_NUM_WARN = 5;
                    if (this._hexStringNumWarn++ === MAX_HEX_STRING_NUM_WARN) {
                      (0, _util2.warn)("getHexString - ignoring additional invalid characters.");
                      return;
                    }
                    if (this._hexStringNumWarn > MAX_HEX_STRING_NUM_WARN) {
                      return;
                    }
                    (0, _util2.warn)(`getHexString - ignoring invalid character: ${ch}`);
                  }
                  getHexString() {
                    const strBuf = this.strBuf;
                    strBuf.length = 0;
                    let ch = this.currentChar;
                    let isFirstHex = true;
                    let firstDigit, secondDigit;
                    this._hexStringNumWarn = 0;
                    while (true) {
                      if (ch < 0) {
                        (0, _util2.warn)("Unterminated hex string");
                        break;
                      } else if (ch === 62) {
                        this.nextChar();
                        break;
                      } else if (specialChars[ch] === 1) {
                        ch = this.nextChar();
                        continue;
                      } else {
                        if (isFirstHex) {
                          firstDigit = toHexDigit(ch);
                          if (firstDigit === -1) {
                            this._hexStringWarn(ch);
                            ch = this.nextChar();
                            continue;
                          }
                        } else {
                          secondDigit = toHexDigit(ch);
                          if (secondDigit === -1) {
                            this._hexStringWarn(ch);
                            ch = this.nextChar();
                            continue;
                          }
                          strBuf.push(String.fromCharCode(firstDigit << 4 | secondDigit));
                        }
                        isFirstHex = !isFirstHex;
                        ch = this.nextChar();
                      }
                    }
                    return strBuf.join("");
                  }
                  getObj() {
                    let comment = false;
                    let ch = this.currentChar;
                    while (true) {
                      if (ch < 0) {
                        return _primitives.EOF;
                      }
                      if (comment) {
                        if (ch === 10 || ch === 13) {
                          comment = false;
                        }
                      } else if (ch === 37) {
                        comment = true;
                      } else if (specialChars[ch] !== 1) {
                        break;
                      }
                      ch = this.nextChar();
                    }
                    switch (ch | 0) {
                      case 48:
                      case 49:
                      case 50:
                      case 51:
                      case 52:
                      case 53:
                      case 54:
                      case 55:
                      case 56:
                      case 57:
                      case 43:
                      case 45:
                      case 46:
                        return this.getNumber();
                      case 40:
                        return this.getString();
                      case 47:
                        return this.getName();
                      case 91:
                        this.nextChar();
                        return _primitives.Cmd.get("[");
                      case 93:
                        this.nextChar();
                        return _primitives.Cmd.get("]");
                      case 60:
                        ch = this.nextChar();
                        if (ch === 60) {
                          this.nextChar();
                          return _primitives.Cmd.get("<<");
                        }
                        return this.getHexString();
                      case 62:
                        ch = this.nextChar();
                        if (ch === 62) {
                          this.nextChar();
                          return _primitives.Cmd.get(">>");
                        }
                        return _primitives.Cmd.get(">");
                      case 123:
                        this.nextChar();
                        return _primitives.Cmd.get("{");
                      case 125:
                        this.nextChar();
                        return _primitives.Cmd.get("}");
                      case 41:
                        this.nextChar();
                        throw new _util2.FormatError(`Illegal character: ${ch}`);
                    }
                    let str = String.fromCharCode(ch);
                    const knownCommands = this.knownCommands;
                    let knownCommandFound = knownCommands && knownCommands[str] !== void 0;
                    while ((ch = this.nextChar()) >= 0 && !specialChars[ch]) {
                      const possibleCommand = str + String.fromCharCode(ch);
                      if (knownCommandFound && knownCommands[possibleCommand] === void 0) {
                        break;
                      }
                      if (str.length === 128) {
                        throw new _util2.FormatError(`Command token too long: ${str.length}`);
                      }
                      str = possibleCommand;
                      knownCommandFound = knownCommands && knownCommands[str] !== void 0;
                    }
                    if (str === "true") {
                      return true;
                    }
                    if (str === "false") {
                      return false;
                    }
                    if (str === "null") {
                      return null;
                    }
                    if (str === "BI") {
                      this.beginInlineImagePos = this.stream.pos;
                    }
                    return _primitives.Cmd.get(str);
                  }
                  skipToNextLine() {
                    let ch = this.currentChar;
                    while (ch >= 0) {
                      if (ch === 13) {
                        ch = this.nextChar();
                        if (ch === 10) {
                          this.nextChar();
                        }
                        break;
                      } else if (ch === 10) {
                        this.nextChar();
                        break;
                      }
                      ch = this.nextChar();
                    }
                  }
                }
                exports2.Lexer = Lexer;
                class Linearization {
                  static create(stream) {
                    function getInt(linDict2, name, allowZeroValue = false) {
                      const obj4 = linDict2.get(name);
                      if (Number.isInteger(obj4) && (allowZeroValue ? obj4 >= 0 : obj4 > 0)) {
                        return obj4;
                      }
                      throw new Error(`The "${name}" parameter in the linearization dictionary is invalid.`);
                    }
                    function getHints(linDict2) {
                      const hints = linDict2.get("H");
                      let hintsLength;
                      if (Array.isArray(hints) && ((hintsLength = hints.length) === 2 || hintsLength === 4)) {
                        for (let index = 0; index < hintsLength; index++) {
                          const hint = hints[index];
                          if (!(Number.isInteger(hint) && hint > 0)) {
                            throw new Error(`Hint (${index}) in the linearization dictionary is invalid.`);
                          }
                        }
                        return hints;
                      }
                      throw new Error("Hint array in the linearization dictionary is invalid.");
                    }
                    const parser = new Parser({ lexer: new Lexer(stream), xref: null });
                    const obj1 = parser.getObj();
                    const obj2 = parser.getObj();
                    const obj3 = parser.getObj();
                    const linDict = parser.getObj();
                    let obj, length;
                    if (!(Number.isInteger(obj1) && Number.isInteger(obj2) && (0, _primitives.isCmd)(obj3, "obj") && (0, _primitives.isDict)(linDict) && (0, _util2.isNum)(obj = linDict.get("Linearized")) && obj > 0)) {
                      return null;
                    } else if ((length = getInt(linDict, "L")) !== stream.length) {
                      throw new Error('The "L" parameter in the linearization dictionary does not equal the stream length.');
                    }
                    return { length, hints: getHints(linDict), objectNumberFirst: getInt(linDict, "O"), endFirst: getInt(linDict, "E"), numPages: getInt(linDict, "N"), mainXRefEntriesOffset: getInt(linDict, "T"), pageFirst: linDict.has("P") ? getInt(linDict, "P", true) : 0 };
                  }
                }
                exports2.Linearization = Linearization;
              }, function(module3, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.LZWStream = exports2.StringStream = exports2.StreamsSequenceStream = exports2.Stream = exports2.RunLengthStream = exports2.PredictorStream = exports2.NullStream = exports2.FlateStream = exports2.DecodeStream = exports2.DecryptStream = exports2.AsciiHexStream = exports2.Ascii85Stream = void 0;
                var _util2 = __w_pdfjs_require__2(2);
                var _primitives = __w_pdfjs_require__2(4);
                var _core_utils = __w_pdfjs_require__2(7);
                var Stream = function StreamClosure() {
                  function Stream2(arrayBuffer, start, length, dict) {
                    this.bytes = arrayBuffer instanceof Uint8Array ? arrayBuffer : new Uint8Array(arrayBuffer);
                    this.start = start || 0;
                    this.pos = this.start;
                    this.end = start + length || this.bytes.length;
                    this.dict = dict;
                  }
                  Stream2.prototype = { get length() {
                    return this.end - this.start;
                  }, get isEmpty() {
                    return this.length === 0;
                  }, getByte: function Stream_getByte() {
                    if (this.pos >= this.end) {
                      return -1;
                    }
                    return this.bytes[this.pos++];
                  }, getUint16: function Stream_getUint16() {
                    var b0 = this.getByte();
                    var b1 = this.getByte();
                    if (b0 === -1 || b1 === -1) {
                      return -1;
                    }
                    return (b0 << 8) + b1;
                  }, getInt32: function Stream_getInt32() {
                    var b0 = this.getByte();
                    var b1 = this.getByte();
                    var b2 = this.getByte();
                    var b3 = this.getByte();
                    return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
                  }, getBytes(length, forceClamped = false) {
                    var bytes = this.bytes;
                    var pos = this.pos;
                    var strEnd = this.end;
                    if (!length) {
                      const subarray2 = bytes.subarray(pos, strEnd);
                      return forceClamped ? new Uint8ClampedArray(subarray2) : subarray2;
                    }
                    var end = pos + length;
                    if (end > strEnd) {
                      end = strEnd;
                    }
                    this.pos = end;
                    const subarray = bytes.subarray(pos, end);
                    return forceClamped ? new Uint8ClampedArray(subarray) : subarray;
                  }, peekByte: function Stream_peekByte() {
                    var peekedByte = this.getByte();
                    if (peekedByte !== -1) {
                      this.pos--;
                    }
                    return peekedByte;
                  }, peekBytes(length, forceClamped = false) {
                    var bytes = this.getBytes(length, forceClamped);
                    this.pos -= bytes.length;
                    return bytes;
                  }, getByteRange(begin, end) {
                    if (begin < 0) {
                      begin = 0;
                    }
                    if (end > this.end) {
                      end = this.end;
                    }
                    return this.bytes.subarray(begin, end);
                  }, skip: function Stream_skip(n) {
                    if (!n) {
                      n = 1;
                    }
                    this.pos += n;
                  }, reset: function Stream_reset() {
                    this.pos = this.start;
                  }, moveStart: function Stream_moveStart() {
                    this.start = this.pos;
                  }, makeSubStream: function Stream_makeSubStream(start, length, dict) {
                    return new Stream2(this.bytes.buffer, start, length, dict);
                  } };
                  return Stream2;
                }();
                exports2.Stream = Stream;
                var StringStream = function StringStreamClosure() {
                  function StringStream2(str) {
                    const bytes = (0, _util2.stringToBytes)(str);
                    Stream.call(this, bytes);
                  }
                  StringStream2.prototype = Stream.prototype;
                  return StringStream2;
                }();
                exports2.StringStream = StringStream;
                var DecodeStream = function DecodeStreamClosure() {
                  var emptyBuffer = new Uint8Array(0);
                  function DecodeStream2(maybeMinBufferLength) {
                    this._rawMinBufferLength = maybeMinBufferLength || 0;
                    this.pos = 0;
                    this.bufferLength = 0;
                    this.eof = false;
                    this.buffer = emptyBuffer;
                    this.minBufferLength = 512;
                    if (maybeMinBufferLength) {
                      while (this.minBufferLength < maybeMinBufferLength) {
                        this.minBufferLength *= 2;
                      }
                    }
                  }
                  DecodeStream2.prototype = { get isEmpty() {
                    while (!this.eof && this.bufferLength === 0) {
                      this.readBlock();
                    }
                    return this.bufferLength === 0;
                  }, ensureBuffer: function DecodeStream_ensureBuffer(requested) {
                    var buffer = this.buffer;
                    if (requested <= buffer.byteLength) {
                      return buffer;
                    }
                    var size = this.minBufferLength;
                    while (size < requested) {
                      size *= 2;
                    }
                    var buffer2 = new Uint8Array(size);
                    buffer2.set(buffer);
                    return this.buffer = buffer2;
                  }, getByte: function DecodeStream_getByte() {
                    var pos = this.pos;
                    while (this.bufferLength <= pos) {
                      if (this.eof) {
                        return -1;
                      }
                      this.readBlock();
                    }
                    return this.buffer[this.pos++];
                  }, getUint16: function DecodeStream_getUint16() {
                    var b0 = this.getByte();
                    var b1 = this.getByte();
                    if (b0 === -1 || b1 === -1) {
                      return -1;
                    }
                    return (b0 << 8) + b1;
                  }, getInt32: function DecodeStream_getInt32() {
                    var b0 = this.getByte();
                    var b1 = this.getByte();
                    var b2 = this.getByte();
                    var b3 = this.getByte();
                    return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
                  }, getBytes(length, forceClamped = false) {
                    var end, pos = this.pos;
                    if (length) {
                      this.ensureBuffer(pos + length);
                      end = pos + length;
                      while (!this.eof && this.bufferLength < end) {
                        this.readBlock();
                      }
                      var bufEnd = this.bufferLength;
                      if (end > bufEnd) {
                        end = bufEnd;
                      }
                    } else {
                      while (!this.eof) {
                        this.readBlock();
                      }
                      end = this.bufferLength;
                    }
                    this.pos = end;
                    const subarray = this.buffer.subarray(pos, end);
                    return forceClamped && !(subarray instanceof Uint8ClampedArray) ? new Uint8ClampedArray(subarray) : subarray;
                  }, peekByte: function DecodeStream_peekByte() {
                    var peekedByte = this.getByte();
                    if (peekedByte !== -1) {
                      this.pos--;
                    }
                    return peekedByte;
                  }, peekBytes(length, forceClamped = false) {
                    var bytes = this.getBytes(length, forceClamped);
                    this.pos -= bytes.length;
                    return bytes;
                  }, makeSubStream: function DecodeStream_makeSubStream(start, length, dict) {
                    var end = start + length;
                    while (this.bufferLength <= end && !this.eof) {
                      this.readBlock();
                    }
                    return new Stream(this.buffer, start, length, dict);
                  }, getByteRange(begin, end) {
                    (0, _util2.unreachable)("Should not call DecodeStream.getByteRange");
                  }, skip: function DecodeStream_skip(n) {
                    if (!n) {
                      n = 1;
                    }
                    this.pos += n;
                  }, reset: function DecodeStream_reset() {
                    this.pos = 0;
                  }, getBaseStreams: function DecodeStream_getBaseStreams() {
                    if (this.str && this.str.getBaseStreams) {
                      return this.str.getBaseStreams();
                    }
                    return [];
                  } };
                  return DecodeStream2;
                }();
                exports2.DecodeStream = DecodeStream;
                var StreamsSequenceStream = function StreamsSequenceStreamClosure() {
                  function StreamsSequenceStream2(streams) {
                    this.streams = streams;
                    let maybeLength = 0;
                    for (let i = 0, ii = streams.length; i < ii; i++) {
                      const stream = streams[i];
                      if (stream instanceof DecodeStream) {
                        maybeLength += stream._rawMinBufferLength;
                      } else {
                        maybeLength += stream.length;
                      }
                    }
                    DecodeStream.call(this, maybeLength);
                  }
                  StreamsSequenceStream2.prototype = Object.create(DecodeStream.prototype);
                  StreamsSequenceStream2.prototype.readBlock = function streamSequenceStreamReadBlock() {
                    var streams = this.streams;
                    if (streams.length === 0) {
                      this.eof = true;
                      return;
                    }
                    var stream = streams.shift();
                    var chunk = stream.getBytes();
                    var bufferLength = this.bufferLength;
                    var newLength = bufferLength + chunk.length;
                    var buffer = this.ensureBuffer(newLength);
                    buffer.set(chunk, bufferLength);
                    this.bufferLength = newLength;
                  };
                  StreamsSequenceStream2.prototype.getBaseStreams = function StreamsSequenceStream_getBaseStreams() {
                    var baseStreams = [];
                    for (var i = 0, ii = this.streams.length; i < ii; i++) {
                      var stream = this.streams[i];
                      if (stream.getBaseStreams) {
                        baseStreams.push(...stream.getBaseStreams());
                      }
                    }
                    return baseStreams;
                  };
                  return StreamsSequenceStream2;
                }();
                exports2.StreamsSequenceStream = StreamsSequenceStream;
                var FlateStream = function FlateStreamClosure() {
                  var codeLenCodeMap = new Int32Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
                  var lengthDecode = new Int32Array([3, 4, 5, 6, 7, 8, 9, 10, 65547, 65549, 65551, 65553, 131091, 131095, 131099, 131103, 196643, 196651, 196659, 196667, 262211, 262227, 262243, 262259, 327811, 327843, 327875, 327907, 258, 258, 258]);
                  var distDecode = new Int32Array([1, 2, 3, 4, 65541, 65543, 131081, 131085, 196625, 196633, 262177, 262193, 327745, 327777, 393345, 393409, 459009, 459137, 524801, 525057, 590849, 591361, 657409, 658433, 724993, 727041, 794625, 798721, 868353, 876545]);
                  var fixedLitCodeTab = [new Int32Array([459008, 524368, 524304, 524568, 459024, 524400, 524336, 590016, 459016, 524384, 524320, 589984, 524288, 524416, 524352, 590048, 459012, 524376, 524312, 589968, 459028, 524408, 524344, 590032, 459020, 524392, 524328, 59e4, 524296, 524424, 524360, 590064, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590024, 459018, 524388, 524324, 589992, 524292, 524420, 524356, 590056, 459014, 524380, 524316, 589976, 459030, 524412, 524348, 590040, 459022, 524396, 524332, 590008, 524300, 524428, 524364, 590072, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590020, 459017, 524386, 524322, 589988, 524290, 524418, 524354, 590052, 459013, 524378, 524314, 589972, 459029, 524410, 524346, 590036, 459021, 524394, 524330, 590004, 524298, 524426, 524362, 590068, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590028, 459019, 524390, 524326, 589996, 524294, 524422, 524358, 590060, 459015, 524382, 524318, 589980, 459031, 524414, 524350, 590044, 459023, 524398, 524334, 590012, 524302, 524430, 524366, 590076, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590018, 459016, 524385, 524321, 589986, 524289, 524417, 524353, 590050, 459012, 524377, 524313, 589970, 459028, 524409, 524345, 590034, 459020, 524393, 524329, 590002, 524297, 524425, 524361, 590066, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590026, 459018, 524389, 524325, 589994, 524293, 524421, 524357, 590058, 459014, 524381, 524317, 589978, 459030, 524413, 524349, 590042, 459022, 524397, 524333, 590010, 524301, 524429, 524365, 590074, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590022, 459017, 524387, 524323, 589990, 524291, 524419, 524355, 590054, 459013, 524379, 524315, 589974, 459029, 524411, 524347, 590038, 459021, 524395, 524331, 590006, 524299, 524427, 524363, 590070, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590030, 459019, 524391, 524327, 589998, 524295, 524423, 524359, 590062, 459015, 524383, 524319, 589982, 459031, 524415, 524351, 590046, 459023, 524399, 524335, 590014, 524303, 524431, 524367, 590078, 459008, 524368, 524304, 524568, 459024, 524400, 524336, 590017, 459016, 524384, 524320, 589985, 524288, 524416, 524352, 590049, 459012, 524376, 524312, 589969, 459028, 524408, 524344, 590033, 459020, 524392, 524328, 590001, 524296, 524424, 524360, 590065, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590025, 459018, 524388, 524324, 589993, 524292, 524420, 524356, 590057, 459014, 524380, 524316, 589977, 459030, 524412, 524348, 590041, 459022, 524396, 524332, 590009, 524300, 524428, 524364, 590073, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590021, 459017, 524386, 524322, 589989, 524290, 524418, 524354, 590053, 459013, 524378, 524314, 589973, 459029, 524410, 524346, 590037, 459021, 524394, 524330, 590005, 524298, 524426, 524362, 590069, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590029, 459019, 524390, 524326, 589997, 524294, 524422, 524358, 590061, 459015, 524382, 524318, 589981, 459031, 524414, 524350, 590045, 459023, 524398, 524334, 590013, 524302, 524430, 524366, 590077, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590019, 459016, 524385, 524321, 589987, 524289, 524417, 524353, 590051, 459012, 524377, 524313, 589971, 459028, 524409, 524345, 590035, 459020, 524393, 524329, 590003, 524297, 524425, 524361, 590067, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590027, 459018, 524389, 524325, 589995, 524293, 524421, 524357, 590059, 459014, 524381, 524317, 589979, 459030, 524413, 524349, 590043, 459022, 524397, 524333, 590011, 524301, 524429, 524365, 590075, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590023, 459017, 524387, 524323, 589991, 524291, 524419, 524355, 590055, 459013, 524379, 524315, 589975, 459029, 524411, 524347, 590039, 459021, 524395, 524331, 590007, 524299, 524427, 524363, 590071, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590031, 459019, 524391, 524327, 589999, 524295, 524423, 524359, 590063, 459015, 524383, 524319, 589983, 459031, 524415, 524351, 590047, 459023, 524399, 524335, 590015, 524303, 524431, 524367, 590079]), 9];
                  var fixedDistCodeTab = [new Int32Array([327680, 327696, 327688, 327704, 327684, 327700, 327692, 327708, 327682, 327698, 327690, 327706, 327686, 327702, 327694, 0, 327681, 327697, 327689, 327705, 327685, 327701, 327693, 327709, 327683, 327699, 327691, 327707, 327687, 327703, 327695, 0]), 5];
                  function FlateStream2(str, maybeLength) {
                    this.str = str;
                    this.dict = str.dict;
                    var cmf = str.getByte();
                    var flg = str.getByte();
                    if (cmf === -1 || flg === -1) {
                      throw new _util2.FormatError(`Invalid header in flate stream: ${cmf}, ${flg}`);
                    }
                    if ((cmf & 15) !== 8) {
                      throw new _util2.FormatError(`Unknown compression method in flate stream: ${cmf}, ${flg}`);
                    }
                    if (((cmf << 8) + flg) % 31 !== 0) {
                      throw new _util2.FormatError(`Bad FCHECK in flate stream: ${cmf}, ${flg}`);
                    }
                    if (flg & 32) {
                      throw new _util2.FormatError(`FDICT bit set in flate stream: ${cmf}, ${flg}`);
                    }
                    this.codeSize = 0;
                    this.codeBuf = 0;
                    DecodeStream.call(this, maybeLength);
                  }
                  FlateStream2.prototype = Object.create(DecodeStream.prototype);
                  FlateStream2.prototype.getBits = function FlateStream_getBits(bits) {
                    var str = this.str;
                    var codeSize = this.codeSize;
                    var codeBuf = this.codeBuf;
                    var b;
                    while (codeSize < bits) {
                      if ((b = str.getByte()) === -1) {
                        throw new _util2.FormatError("Bad encoding in flate stream");
                      }
                      codeBuf |= b << codeSize;
                      codeSize += 8;
                    }
                    b = codeBuf & (1 << bits) - 1;
                    this.codeBuf = codeBuf >> bits;
                    this.codeSize = codeSize -= bits;
                    return b;
                  };
                  FlateStream2.prototype.getCode = function FlateStream_getCode(table) {
                    var str = this.str;
                    var codes = table[0];
                    var maxLen = table[1];
                    var codeSize = this.codeSize;
                    var codeBuf = this.codeBuf;
                    var b;
                    while (codeSize < maxLen) {
                      if ((b = str.getByte()) === -1) {
                        break;
                      }
                      codeBuf |= b << codeSize;
                      codeSize += 8;
                    }
                    var code = codes[codeBuf & (1 << maxLen) - 1];
                    var codeLen = code >> 16;
                    var codeVal = code & 65535;
                    if (codeLen < 1 || codeSize < codeLen) {
                      throw new _util2.FormatError("Bad encoding in flate stream");
                    }
                    this.codeBuf = codeBuf >> codeLen;
                    this.codeSize = codeSize - codeLen;
                    return codeVal;
                  };
                  FlateStream2.prototype.generateHuffmanTable = function flateStreamGenerateHuffmanTable(lengths) {
                    var n = lengths.length;
                    var maxLen = 0;
                    var i;
                    for (i = 0; i < n; ++i) {
                      if (lengths[i] > maxLen) {
                        maxLen = lengths[i];
                      }
                    }
                    var size = 1 << maxLen;
                    var codes = new Int32Array(size);
                    for (var len = 1, code = 0, skip = 2; len <= maxLen; ++len, code <<= 1, skip <<= 1) {
                      for (var val = 0; val < n; ++val) {
                        if (lengths[val] === len) {
                          var code2 = 0;
                          var t = code;
                          for (i = 0; i < len; ++i) {
                            code2 = code2 << 1 | t & 1;
                            t >>= 1;
                          }
                          for (i = code2; i < size; i += skip) {
                            codes[i] = len << 16 | val;
                          }
                          ++code;
                        }
                      }
                    }
                    return [codes, maxLen];
                  };
                  FlateStream2.prototype.readBlock = function FlateStream_readBlock() {
                    var buffer, len;
                    var str = this.str;
                    var hdr = this.getBits(3);
                    if (hdr & 1) {
                      this.eof = true;
                    }
                    hdr >>= 1;
                    if (hdr === 0) {
                      var b;
                      if ((b = str.getByte()) === -1) {
                        throw new _util2.FormatError("Bad block header in flate stream");
                      }
                      var blockLen = b;
                      if ((b = str.getByte()) === -1) {
                        throw new _util2.FormatError("Bad block header in flate stream");
                      }
                      blockLen |= b << 8;
                      if ((b = str.getByte()) === -1) {
                        throw new _util2.FormatError("Bad block header in flate stream");
                      }
                      var check = b;
                      if ((b = str.getByte()) === -1) {
                        throw new _util2.FormatError("Bad block header in flate stream");
                      }
                      check |= b << 8;
                      if (check !== (~blockLen & 65535) && (blockLen !== 0 || check !== 0)) {
                        throw new _util2.FormatError("Bad uncompressed block length in flate stream");
                      }
                      this.codeBuf = 0;
                      this.codeSize = 0;
                      const bufferLength = this.bufferLength, end = bufferLength + blockLen;
                      buffer = this.ensureBuffer(end);
                      this.bufferLength = end;
                      if (blockLen === 0) {
                        if (str.peekByte() === -1) {
                          this.eof = true;
                        }
                      } else {
                        const block = str.getBytes(blockLen);
                        buffer.set(block, bufferLength);
                        if (block.length < blockLen) {
                          this.eof = true;
                        }
                      }
                      return;
                    }
                    var litCodeTable;
                    var distCodeTable;
                    if (hdr === 1) {
                      litCodeTable = fixedLitCodeTab;
                      distCodeTable = fixedDistCodeTab;
                    } else if (hdr === 2) {
                      var numLitCodes = this.getBits(5) + 257;
                      var numDistCodes = this.getBits(5) + 1;
                      var numCodeLenCodes = this.getBits(4) + 4;
                      var codeLenCodeLengths = new Uint8Array(codeLenCodeMap.length);
                      var i;
                      for (i = 0; i < numCodeLenCodes; ++i) {
                        codeLenCodeLengths[codeLenCodeMap[i]] = this.getBits(3);
                      }
                      var codeLenCodeTab = this.generateHuffmanTable(codeLenCodeLengths);
                      len = 0;
                      i = 0;
                      var codes = numLitCodes + numDistCodes;
                      var codeLengths = new Uint8Array(codes);
                      var bitsLength, bitsOffset, what;
                      while (i < codes) {
                        var code = this.getCode(codeLenCodeTab);
                        if (code === 16) {
                          bitsLength = 2;
                          bitsOffset = 3;
                          what = len;
                        } else if (code === 17) {
                          bitsLength = 3;
                          bitsOffset = 3;
                          what = len = 0;
                        } else if (code === 18) {
                          bitsLength = 7;
                          bitsOffset = 11;
                          what = len = 0;
                        } else {
                          codeLengths[i++] = len = code;
                          continue;
                        }
                        var repeatLength = this.getBits(bitsLength) + bitsOffset;
                        while (repeatLength-- > 0) {
                          codeLengths[i++] = what;
                        }
                      }
                      litCodeTable = this.generateHuffmanTable(codeLengths.subarray(0, numLitCodes));
                      distCodeTable = this.generateHuffmanTable(codeLengths.subarray(numLitCodes, codes));
                    } else {
                      throw new _util2.FormatError("Unknown block type in flate stream");
                    }
                    buffer = this.buffer;
                    var limit = buffer ? buffer.length : 0;
                    var pos = this.bufferLength;
                    while (true) {
                      var code1 = this.getCode(litCodeTable);
                      if (code1 < 256) {
                        if (pos + 1 >= limit) {
                          buffer = this.ensureBuffer(pos + 1);
                          limit = buffer.length;
                        }
                        buffer[pos++] = code1;
                        continue;
                      }
                      if (code1 === 256) {
                        this.bufferLength = pos;
                        return;
                      }
                      code1 -= 257;
                      code1 = lengthDecode[code1];
                      var code2 = code1 >> 16;
                      if (code2 > 0) {
                        code2 = this.getBits(code2);
                      }
                      len = (code1 & 65535) + code2;
                      code1 = this.getCode(distCodeTable);
                      code1 = distDecode[code1];
                      code2 = code1 >> 16;
                      if (code2 > 0) {
                        code2 = this.getBits(code2);
                      }
                      var dist = (code1 & 65535) + code2;
                      if (pos + len >= limit) {
                        buffer = this.ensureBuffer(pos + len);
                        limit = buffer.length;
                      }
                      for (var k = 0; k < len; ++k, ++pos) {
                        buffer[pos] = buffer[pos - dist];
                      }
                    }
                  };
                  return FlateStream2;
                }();
                exports2.FlateStream = FlateStream;
                var PredictorStream = function PredictorStreamClosure() {
                  function PredictorStream2(str, maybeLength, params) {
                    if (!(0, _primitives.isDict)(params)) {
                      return str;
                    }
                    var predictor = this.predictor = params.get("Predictor") || 1;
                    if (predictor <= 1) {
                      return str;
                    }
                    if (predictor !== 2 && (predictor < 10 || predictor > 15)) {
                      throw new _util2.FormatError(`Unsupported predictor: ${predictor}`);
                    }
                    if (predictor === 2) {
                      this.readBlock = this.readBlockTiff;
                    } else {
                      this.readBlock = this.readBlockPng;
                    }
                    this.str = str;
                    this.dict = str.dict;
                    var colors = this.colors = params.get("Colors") || 1;
                    var bits = this.bits = params.get("BitsPerComponent") || 8;
                    var columns = this.columns = params.get("Columns") || 1;
                    this.pixBytes = colors * bits + 7 >> 3;
                    this.rowBytes = columns * colors * bits + 7 >> 3;
                    DecodeStream.call(this, maybeLength);
                    return this;
                  }
                  PredictorStream2.prototype = Object.create(DecodeStream.prototype);
                  PredictorStream2.prototype.readBlockTiff = function predictorStreamReadBlockTiff() {
                    var rowBytes = this.rowBytes;
                    var bufferLength = this.bufferLength;
                    var buffer = this.ensureBuffer(bufferLength + rowBytes);
                    var bits = this.bits;
                    var colors = this.colors;
                    var rawBytes = this.str.getBytes(rowBytes);
                    this.eof = !rawBytes.length;
                    if (this.eof) {
                      return;
                    }
                    var inbuf = 0, outbuf = 0;
                    var inbits = 0, outbits = 0;
                    var pos = bufferLength;
                    var i;
                    if (bits === 1 && colors === 1) {
                      for (i = 0; i < rowBytes; ++i) {
                        var c = rawBytes[i] ^ inbuf;
                        c ^= c >> 1;
                        c ^= c >> 2;
                        c ^= c >> 4;
                        inbuf = (c & 1) << 7;
                        buffer[pos++] = c;
                      }
                    } else if (bits === 8) {
                      for (i = 0; i < colors; ++i) {
                        buffer[pos++] = rawBytes[i];
                      }
                      for (; i < rowBytes; ++i) {
                        buffer[pos] = buffer[pos - colors] + rawBytes[i];
                        pos++;
                      }
                    } else if (bits === 16) {
                      var bytesPerPixel = colors * 2;
                      for (i = 0; i < bytesPerPixel; ++i) {
                        buffer[pos++] = rawBytes[i];
                      }
                      for (; i < rowBytes; i += 2) {
                        var sum = ((rawBytes[i] & 255) << 8) + (rawBytes[i + 1] & 255) + ((buffer[pos - bytesPerPixel] & 255) << 8) + (buffer[pos - bytesPerPixel + 1] & 255);
                        buffer[pos++] = sum >> 8 & 255;
                        buffer[pos++] = sum & 255;
                      }
                    } else {
                      var compArray = new Uint8Array(colors + 1);
                      var bitMask = (1 << bits) - 1;
                      var j = 0, k = bufferLength;
                      var columns = this.columns;
                      for (i = 0; i < columns; ++i) {
                        for (var kk = 0; kk < colors; ++kk) {
                          if (inbits < bits) {
                            inbuf = inbuf << 8 | rawBytes[j++] & 255;
                            inbits += 8;
                          }
                          compArray[kk] = compArray[kk] + (inbuf >> inbits - bits) & bitMask;
                          inbits -= bits;
                          outbuf = outbuf << bits | compArray[kk];
                          outbits += bits;
                          if (outbits >= 8) {
                            buffer[k++] = outbuf >> outbits - 8 & 255;
                            outbits -= 8;
                          }
                        }
                      }
                      if (outbits > 0) {
                        buffer[k++] = (outbuf << 8 - outbits) + (inbuf & (1 << 8 - outbits) - 1);
                      }
                    }
                    this.bufferLength += rowBytes;
                  };
                  PredictorStream2.prototype.readBlockPng = function predictorStreamReadBlockPng() {
                    var rowBytes = this.rowBytes;
                    var pixBytes = this.pixBytes;
                    var predictor = this.str.getByte();
                    var rawBytes = this.str.getBytes(rowBytes);
                    this.eof = !rawBytes.length;
                    if (this.eof) {
                      return;
                    }
                    var bufferLength = this.bufferLength;
                    var buffer = this.ensureBuffer(bufferLength + rowBytes);
                    var prevRow = buffer.subarray(bufferLength - rowBytes, bufferLength);
                    if (prevRow.length === 0) {
                      prevRow = new Uint8Array(rowBytes);
                    }
                    var i, j = bufferLength, up, c;
                    switch (predictor) {
                      case 0:
                        for (i = 0; i < rowBytes; ++i) {
                          buffer[j++] = rawBytes[i];
                        }
                        break;
                      case 1:
                        for (i = 0; i < pixBytes; ++i) {
                          buffer[j++] = rawBytes[i];
                        }
                        for (; i < rowBytes; ++i) {
                          buffer[j] = buffer[j - pixBytes] + rawBytes[i] & 255;
                          j++;
                        }
                        break;
                      case 2:
                        for (i = 0; i < rowBytes; ++i) {
                          buffer[j++] = prevRow[i] + rawBytes[i] & 255;
                        }
                        break;
                      case 3:
                        for (i = 0; i < pixBytes; ++i) {
                          buffer[j++] = (prevRow[i] >> 1) + rawBytes[i];
                        }
                        for (; i < rowBytes; ++i) {
                          buffer[j] = (prevRow[i] + buffer[j - pixBytes] >> 1) + rawBytes[i] & 255;
                          j++;
                        }
                        break;
                      case 4:
                        for (i = 0; i < pixBytes; ++i) {
                          up = prevRow[i];
                          c = rawBytes[i];
                          buffer[j++] = up + c;
                        }
                        for (; i < rowBytes; ++i) {
                          up = prevRow[i];
                          var upLeft = prevRow[i - pixBytes];
                          var left = buffer[j - pixBytes];
                          var p = left + up - upLeft;
                          var pa = p - left;
                          if (pa < 0) {
                            pa = -pa;
                          }
                          var pb = p - up;
                          if (pb < 0) {
                            pb = -pb;
                          }
                          var pc = p - upLeft;
                          if (pc < 0) {
                            pc = -pc;
                          }
                          c = rawBytes[i];
                          if (pa <= pb && pa <= pc) {
                            buffer[j++] = left + c;
                          } else if (pb <= pc) {
                            buffer[j++] = up + c;
                          } else {
                            buffer[j++] = upLeft + c;
                          }
                        }
                        break;
                      default:
                        throw new _util2.FormatError(`Unsupported predictor: ${predictor}`);
                    }
                    this.bufferLength += rowBytes;
                  };
                  return PredictorStream2;
                }();
                exports2.PredictorStream = PredictorStream;
                var DecryptStream = function DecryptStreamClosure() {
                  function DecryptStream2(str, maybeLength, decrypt) {
                    this.str = str;
                    this.dict = str.dict;
                    this.decrypt = decrypt;
                    this.nextChunk = null;
                    this.initialized = false;
                    DecodeStream.call(this, maybeLength);
                  }
                  var chunkSize = 512;
                  DecryptStream2.prototype = Object.create(DecodeStream.prototype);
                  DecryptStream2.prototype.readBlock = function DecryptStream_readBlock() {
                    var chunk;
                    if (this.initialized) {
                      chunk = this.nextChunk;
                    } else {
                      chunk = this.str.getBytes(chunkSize);
                      this.initialized = true;
                    }
                    if (!chunk || chunk.length === 0) {
                      this.eof = true;
                      return;
                    }
                    this.nextChunk = this.str.getBytes(chunkSize);
                    var hasMoreData = this.nextChunk && this.nextChunk.length > 0;
                    var decrypt = this.decrypt;
                    chunk = decrypt(chunk, !hasMoreData);
                    var bufferLength = this.bufferLength;
                    var i, n = chunk.length;
                    var buffer = this.ensureBuffer(bufferLength + n);
                    for (i = 0; i < n; i++) {
                      buffer[bufferLength++] = chunk[i];
                    }
                    this.bufferLength = bufferLength;
                  };
                  return DecryptStream2;
                }();
                exports2.DecryptStream = DecryptStream;
                var Ascii85Stream = function Ascii85StreamClosure() {
                  function Ascii85Stream2(str, maybeLength) {
                    this.str = str;
                    this.dict = str.dict;
                    this.input = new Uint8Array(5);
                    if (maybeLength) {
                      maybeLength = 0.8 * maybeLength;
                    }
                    DecodeStream.call(this, maybeLength);
                  }
                  Ascii85Stream2.prototype = Object.create(DecodeStream.prototype);
                  Ascii85Stream2.prototype.readBlock = function Ascii85Stream_readBlock() {
                    var TILDA_CHAR = 126;
                    var Z_LOWER_CHAR = 122;
                    var EOF = -1;
                    var str = this.str;
                    var c = str.getByte();
                    while ((0, _core_utils.isWhiteSpace)(c)) {
                      c = str.getByte();
                    }
                    if (c === EOF || c === TILDA_CHAR) {
                      this.eof = true;
                      return;
                    }
                    var bufferLength = this.bufferLength, buffer;
                    var i;
                    if (c === Z_LOWER_CHAR) {
                      buffer = this.ensureBuffer(bufferLength + 4);
                      for (i = 0; i < 4; ++i) {
                        buffer[bufferLength + i] = 0;
                      }
                      this.bufferLength += 4;
                    } else {
                      var input = this.input;
                      input[0] = c;
                      for (i = 1; i < 5; ++i) {
                        c = str.getByte();
                        while ((0, _core_utils.isWhiteSpace)(c)) {
                          c = str.getByte();
                        }
                        input[i] = c;
                        if (c === EOF || c === TILDA_CHAR) {
                          break;
                        }
                      }
                      buffer = this.ensureBuffer(bufferLength + i - 1);
                      this.bufferLength += i - 1;
                      if (i < 5) {
                        for (; i < 5; ++i) {
                          input[i] = 33 + 84;
                        }
                        this.eof = true;
                      }
                      var t = 0;
                      for (i = 0; i < 5; ++i) {
                        t = t * 85 + (input[i] - 33);
                      }
                      for (i = 3; i >= 0; --i) {
                        buffer[bufferLength + i] = t & 255;
                        t >>= 8;
                      }
                    }
                  };
                  return Ascii85Stream2;
                }();
                exports2.Ascii85Stream = Ascii85Stream;
                var AsciiHexStream = function AsciiHexStreamClosure() {
                  function AsciiHexStream2(str, maybeLength) {
                    this.str = str;
                    this.dict = str.dict;
                    this.firstDigit = -1;
                    if (maybeLength) {
                      maybeLength = 0.5 * maybeLength;
                    }
                    DecodeStream.call(this, maybeLength);
                  }
                  AsciiHexStream2.prototype = Object.create(DecodeStream.prototype);
                  AsciiHexStream2.prototype.readBlock = function AsciiHexStream_readBlock() {
                    var UPSTREAM_BLOCK_SIZE = 8e3;
                    var bytes = this.str.getBytes(UPSTREAM_BLOCK_SIZE);
                    if (!bytes.length) {
                      this.eof = true;
                      return;
                    }
                    var maxDecodeLength = bytes.length + 1 >> 1;
                    var buffer = this.ensureBuffer(this.bufferLength + maxDecodeLength);
                    var bufferLength = this.bufferLength;
                    var firstDigit = this.firstDigit;
                    for (var i = 0, ii = bytes.length; i < ii; i++) {
                      var ch = bytes[i], digit;
                      if (ch >= 48 && ch <= 57) {
                        digit = ch & 15;
                      } else if (ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102) {
                        digit = (ch & 15) + 9;
                      } else if (ch === 62) {
                        this.eof = true;
                        break;
                      } else {
                        continue;
                      }
                      if (firstDigit < 0) {
                        firstDigit = digit;
                      } else {
                        buffer[bufferLength++] = firstDigit << 4 | digit;
                        firstDigit = -1;
                      }
                    }
                    if (firstDigit >= 0 && this.eof) {
                      buffer[bufferLength++] = firstDigit << 4;
                      firstDigit = -1;
                    }
                    this.firstDigit = firstDigit;
                    this.bufferLength = bufferLength;
                  };
                  return AsciiHexStream2;
                }();
                exports2.AsciiHexStream = AsciiHexStream;
                var RunLengthStream = function RunLengthStreamClosure() {
                  function RunLengthStream2(str, maybeLength) {
                    this.str = str;
                    this.dict = str.dict;
                    DecodeStream.call(this, maybeLength);
                  }
                  RunLengthStream2.prototype = Object.create(DecodeStream.prototype);
                  RunLengthStream2.prototype.readBlock = function RunLengthStream_readBlock() {
                    var repeatHeader = this.str.getBytes(2);
                    if (!repeatHeader || repeatHeader.length < 2 || repeatHeader[0] === 128) {
                      this.eof = true;
                      return;
                    }
                    var buffer;
                    var bufferLength = this.bufferLength;
                    var n = repeatHeader[0];
                    if (n < 128) {
                      buffer = this.ensureBuffer(bufferLength + n + 1);
                      buffer[bufferLength++] = repeatHeader[1];
                      if (n > 0) {
                        var source = this.str.getBytes(n);
                        buffer.set(source, bufferLength);
                        bufferLength += n;
                      }
                    } else {
                      n = 257 - n;
                      var b = repeatHeader[1];
                      buffer = this.ensureBuffer(bufferLength + n + 1);
                      for (var i = 0; i < n; i++) {
                        buffer[bufferLength++] = b;
                      }
                    }
                    this.bufferLength = bufferLength;
                  };
                  return RunLengthStream2;
                }();
                exports2.RunLengthStream = RunLengthStream;
                var LZWStream = function LZWStreamClosure() {
                  function LZWStream2(str, maybeLength, earlyChange) {
                    this.str = str;
                    this.dict = str.dict;
                    this.cachedData = 0;
                    this.bitsCached = 0;
                    var maxLzwDictionarySize = 4096;
                    var lzwState = { earlyChange, codeLength: 9, nextCode: 258, dictionaryValues: new Uint8Array(maxLzwDictionarySize), dictionaryLengths: new Uint16Array(maxLzwDictionarySize), dictionaryPrevCodes: new Uint16Array(maxLzwDictionarySize), currentSequence: new Uint8Array(maxLzwDictionarySize), currentSequenceLength: 0 };
                    for (var i = 0; i < 256; ++i) {
                      lzwState.dictionaryValues[i] = i;
                      lzwState.dictionaryLengths[i] = 1;
                    }
                    this.lzwState = lzwState;
                    DecodeStream.call(this, maybeLength);
                  }
                  LZWStream2.prototype = Object.create(DecodeStream.prototype);
                  LZWStream2.prototype.readBits = function LZWStream_readBits(n) {
                    var bitsCached = this.bitsCached;
                    var cachedData = this.cachedData;
                    while (bitsCached < n) {
                      var c = this.str.getByte();
                      if (c === -1) {
                        this.eof = true;
                        return null;
                      }
                      cachedData = cachedData << 8 | c;
                      bitsCached += 8;
                    }
                    this.bitsCached = bitsCached -= n;
                    this.cachedData = cachedData;
                    this.lastCode = null;
                    return cachedData >>> bitsCached & (1 << n) - 1;
                  };
                  LZWStream2.prototype.readBlock = function LZWStream_readBlock() {
                    var blockSize = 512;
                    var estimatedDecodedSize = blockSize * 2, decodedSizeDelta = blockSize;
                    var i, j, q;
                    var lzwState = this.lzwState;
                    if (!lzwState) {
                      return;
                    }
                    var earlyChange = lzwState.earlyChange;
                    var nextCode = lzwState.nextCode;
                    var dictionaryValues = lzwState.dictionaryValues;
                    var dictionaryLengths = lzwState.dictionaryLengths;
                    var dictionaryPrevCodes = lzwState.dictionaryPrevCodes;
                    var codeLength = lzwState.codeLength;
                    var prevCode = lzwState.prevCode;
                    var currentSequence = lzwState.currentSequence;
                    var currentSequenceLength = lzwState.currentSequenceLength;
                    var decodedLength = 0;
                    var currentBufferLength = this.bufferLength;
                    var buffer = this.ensureBuffer(this.bufferLength + estimatedDecodedSize);
                    for (i = 0; i < blockSize; i++) {
                      var code = this.readBits(codeLength);
                      var hasPrev = currentSequenceLength > 0;
                      if (code < 256) {
                        currentSequence[0] = code;
                        currentSequenceLength = 1;
                      } else if (code >= 258) {
                        if (code < nextCode) {
                          currentSequenceLength = dictionaryLengths[code];
                          for (j = currentSequenceLength - 1, q = code; j >= 0; j--) {
                            currentSequence[j] = dictionaryValues[q];
                            q = dictionaryPrevCodes[q];
                          }
                        } else {
                          currentSequence[currentSequenceLength++] = currentSequence[0];
                        }
                      } else if (code === 256) {
                        codeLength = 9;
                        nextCode = 258;
                        currentSequenceLength = 0;
                        continue;
                      } else {
                        this.eof = true;
                        delete this.lzwState;
                        break;
                      }
                      if (hasPrev) {
                        dictionaryPrevCodes[nextCode] = prevCode;
                        dictionaryLengths[nextCode] = dictionaryLengths[prevCode] + 1;
                        dictionaryValues[nextCode] = currentSequence[0];
                        nextCode++;
                        codeLength = nextCode + earlyChange & nextCode + earlyChange - 1 ? codeLength : Math.min(Math.log(nextCode + earlyChange) / 0.6931471805599453 + 1, 12) | 0;
                      }
                      prevCode = code;
                      decodedLength += currentSequenceLength;
                      if (estimatedDecodedSize < decodedLength) {
                        do {
                          estimatedDecodedSize += decodedSizeDelta;
                        } while (estimatedDecodedSize < decodedLength);
                        buffer = this.ensureBuffer(this.bufferLength + estimatedDecodedSize);
                      }
                      for (j = 0; j < currentSequenceLength; j++) {
                        buffer[currentBufferLength++] = currentSequence[j];
                      }
                    }
                    lzwState.nextCode = nextCode;
                    lzwState.codeLength = codeLength;
                    lzwState.prevCode = prevCode;
                    lzwState.currentSequenceLength = currentSequenceLength;
                    this.bufferLength = currentBufferLength;
                  };
                  return LZWStream2;
                }();
                exports2.LZWStream = LZWStream;
                var NullStream = function NullStreamClosure() {
                  function NullStream2() {
                    Stream.call(this, new Uint8Array(0));
                  }
                  NullStream2.prototype = Stream.prototype;
                  return NullStream2;
                }();
                exports2.NullStream = NullStream;
              }, function(module3, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.CCITTFaxStream = void 0;
                var _primitives = __w_pdfjs_require__2(4);
                var _ccitt = __w_pdfjs_require__2(13);
                var _stream = __w_pdfjs_require__2(11);
                var CCITTFaxStream = function CCITTFaxStreamClosure() {
                  function CCITTFaxStream2(str, maybeLength, params) {
                    this.str = str;
                    this.dict = str.dict;
                    if (!(0, _primitives.isDict)(params)) {
                      params = _primitives.Dict.empty;
                    }
                    const source = { next() {
                      return str.getByte();
                    } };
                    this.ccittFaxDecoder = new _ccitt.CCITTFaxDecoder(source, { K: params.get("K"), EndOfLine: params.get("EndOfLine"), EncodedByteAlign: params.get("EncodedByteAlign"), Columns: params.get("Columns"), Rows: params.get("Rows"), EndOfBlock: params.get("EndOfBlock"), BlackIs1: params.get("BlackIs1") });
                    _stream.DecodeStream.call(this, maybeLength);
                  }
                  CCITTFaxStream2.prototype = Object.create(_stream.DecodeStream.prototype);
                  CCITTFaxStream2.prototype.readBlock = function() {
                    while (!this.eof) {
                      const c = this.ccittFaxDecoder.readNextChar();
                      if (c === -1) {
                        this.eof = true;
                        return;
                      }
                      this.ensureBuffer(this.bufferLength + 1);
                      this.buffer[this.bufferLength++] = c;
                    }
                  };
                  return CCITTFaxStream2;
                }();
                exports2.CCITTFaxStream = CCITTFaxStream;
              }, function(module3, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.CCITTFaxDecoder = void 0;
                var _util2 = __w_pdfjs_require__2(2);
                const CCITTFaxDecoder = function CCITTFaxDecoder2() {
                  const ccittEOL = -2;
                  const ccittEOF = -1;
                  const twoDimPass = 0;
                  const twoDimHoriz = 1;
                  const twoDimVert0 = 2;
                  const twoDimVertR1 = 3;
                  const twoDimVertL1 = 4;
                  const twoDimVertR2 = 5;
                  const twoDimVertL2 = 6;
                  const twoDimVertR3 = 7;
                  const twoDimVertL3 = 8;
                  const twoDimTable = [[-1, -1], [-1, -1], [7, twoDimVertL3], [7, twoDimVertR3], [6, twoDimVertL2], [6, twoDimVertL2], [6, twoDimVertR2], [6, twoDimVertR2], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [4, twoDimPass], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimHoriz], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertL1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [3, twoDimVertR1], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0], [1, twoDimVert0]];
                  const whiteTable1 = [[-1, -1], [12, ccittEOL], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [12, 1984], [12, 2048], [12, 2112], [12, 2176], [12, 2240], [12, 2304], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [12, 2368], [12, 2432], [12, 2496], [12, 2560]];
                  const whiteTable2 = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [8, 29], [8, 29], [8, 30], [8, 30], [8, 45], [8, 45], [8, 46], [8, 46], [7, 22], [7, 22], [7, 22], [7, 22], [7, 23], [7, 23], [7, 23], [7, 23], [8, 47], [8, 47], [8, 48], [8, 48], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [7, 20], [7, 20], [7, 20], [7, 20], [8, 33], [8, 33], [8, 34], [8, 34], [8, 35], [8, 35], [8, 36], [8, 36], [8, 37], [8, 37], [8, 38], [8, 38], [7, 19], [7, 19], [7, 19], [7, 19], [8, 31], [8, 31], [8, 32], [8, 32], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [8, 53], [8, 53], [8, 54], [8, 54], [7, 26], [7, 26], [7, 26], [7, 26], [8, 39], [8, 39], [8, 40], [8, 40], [8, 41], [8, 41], [8, 42], [8, 42], [8, 43], [8, 43], [8, 44], [8, 44], [7, 21], [7, 21], [7, 21], [7, 21], [7, 28], [7, 28], [7, 28], [7, 28], [8, 61], [8, 61], [8, 62], [8, 62], [8, 63], [8, 63], [8, 0], [8, 0], [8, 320], [8, 320], [8, 384], [8, 384], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [7, 27], [7, 27], [7, 27], [7, 27], [8, 59], [8, 59], [8, 60], [8, 60], [9, 1472], [9, 1536], [9, 1600], [9, 1728], [7, 18], [7, 18], [7, 18], [7, 18], [7, 24], [7, 24], [7, 24], [7, 24], [8, 49], [8, 49], [8, 50], [8, 50], [8, 51], [8, 51], [8, 52], [8, 52], [7, 25], [7, 25], [7, 25], [7, 25], [8, 55], [8, 55], [8, 56], [8, 56], [8, 57], [8, 57], [8, 58], [8, 58], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [8, 448], [8, 448], [8, 512], [8, 512], [9, 704], [9, 768], [8, 640], [8, 640], [8, 576], [8, 576], [9, 832], [9, 896], [9, 960], [9, 1024], [9, 1088], [9, 1152], [9, 1216], [9, 1280], [9, 1344], [9, 1408], [7, 256], [7, 256], [7, 256], [7, 256], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7]];
                  const blackTable1 = [[-1, -1], [-1, -1], [12, ccittEOL], [12, ccittEOL], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [11, 1792], [11, 1792], [12, 1984], [12, 1984], [12, 2048], [12, 2048], [12, 2112], [12, 2112], [12, 2176], [12, 2176], [12, 2240], [12, 2240], [12, 2304], [12, 2304], [11, 1856], [11, 1856], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [11, 1920], [11, 1920], [12, 2368], [12, 2368], [12, 2432], [12, 2432], [12, 2496], [12, 2496], [12, 2560], [12, 2560], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [12, 52], [12, 52], [13, 640], [13, 704], [13, 768], [13, 832], [12, 55], [12, 55], [12, 56], [12, 56], [13, 1280], [13, 1344], [13, 1408], [13, 1472], [12, 59], [12, 59], [12, 60], [12, 60], [13, 1536], [13, 1600], [11, 24], [11, 24], [11, 24], [11, 24], [11, 25], [11, 25], [11, 25], [11, 25], [13, 1664], [13, 1728], [12, 320], [12, 320], [12, 384], [12, 384], [12, 448], [12, 448], [13, 512], [13, 576], [12, 53], [12, 53], [12, 54], [12, 54], [13, 896], [13, 960], [13, 1024], [13, 1088], [13, 1152], [13, 1216], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64]];
                  const blackTable2 = [[8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [11, 23], [11, 23], [12, 50], [12, 51], [12, 44], [12, 45], [12, 46], [12, 47], [12, 57], [12, 58], [12, 61], [12, 256], [10, 16], [10, 16], [10, 16], [10, 16], [10, 17], [10, 17], [10, 17], [10, 17], [12, 48], [12, 49], [12, 62], [12, 63], [12, 30], [12, 31], [12, 32], [12, 33], [12, 40], [12, 41], [11, 22], [11, 22], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [12, 128], [12, 192], [12, 26], [12, 27], [12, 28], [12, 29], [11, 19], [11, 19], [11, 20], [11, 20], [12, 34], [12, 35], [12, 36], [12, 37], [12, 38], [12, 39], [11, 21], [11, 21], [12, 42], [12, 43], [10, 0], [10, 0], [10, 0], [10, 0], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12]];
                  const blackTable3 = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [6, 9], [6, 8], [5, 7], [5, 7], [4, 6], [4, 6], [4, 6], [4, 6], [4, 5], [4, 5], [4, 5], [4, 5], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2]];
                  function CCITTFaxDecoder3(source, options = {}) {
                    if (!source || typeof source.next !== "function") {
                      throw new Error('CCITTFaxDecoder - invalid "source" parameter.');
                    }
                    this.source = source;
                    this.eof = false;
                    this.encoding = options["K"] || 0;
                    this.eoline = options["EndOfLine"] || false;
                    this.byteAlign = options["EncodedByteAlign"] || false;
                    this.columns = options["Columns"] || 1728;
                    this.rows = options["Rows"] || 0;
                    let eoblock = options["EndOfBlock"];
                    if (eoblock === null || eoblock === void 0) {
                      eoblock = true;
                    }
                    this.eoblock = eoblock;
                    this.black = options["BlackIs1"] || false;
                    this.codingLine = new Uint32Array(this.columns + 1);
                    this.refLine = new Uint32Array(this.columns + 2);
                    this.codingLine[0] = this.columns;
                    this.codingPos = 0;
                    this.row = 0;
                    this.nextLine2D = this.encoding < 0;
                    this.inputBits = 0;
                    this.inputBuf = 0;
                    this.outputBits = 0;
                    this.rowsDone = false;
                    let code1;
                    while ((code1 = this._lookBits(12)) === 0) {
                      this._eatBits(1);
                    }
                    if (code1 === 1) {
                      this._eatBits(12);
                    }
                    if (this.encoding > 0) {
                      this.nextLine2D = !this._lookBits(1);
                      this._eatBits(1);
                    }
                  }
                  CCITTFaxDecoder3.prototype = { readNextChar() {
                    if (this.eof) {
                      return -1;
                    }
                    const refLine = this.refLine;
                    const codingLine = this.codingLine;
                    const columns = this.columns;
                    let refPos, blackPixels, bits, i;
                    if (this.outputBits === 0) {
                      if (this.rowsDone) {
                        this.eof = true;
                      }
                      if (this.eof) {
                        return -1;
                      }
                      this.err = false;
                      let code1, code2, code3;
                      if (this.nextLine2D) {
                        for (i = 0; codingLine[i] < columns; ++i) {
                          refLine[i] = codingLine[i];
                        }
                        refLine[i++] = columns;
                        refLine[i] = columns;
                        codingLine[0] = 0;
                        this.codingPos = 0;
                        refPos = 0;
                        blackPixels = 0;
                        while (codingLine[this.codingPos] < columns) {
                          code1 = this._getTwoDimCode();
                          switch (code1) {
                            case twoDimPass:
                              this._addPixels(refLine[refPos + 1], blackPixels);
                              if (refLine[refPos + 1] < columns) {
                                refPos += 2;
                              }
                              break;
                            case twoDimHoriz:
                              code1 = code2 = 0;
                              if (blackPixels) {
                                do {
                                  code1 += code3 = this._getBlackCode();
                                } while (code3 >= 64);
                                do {
                                  code2 += code3 = this._getWhiteCode();
                                } while (code3 >= 64);
                              } else {
                                do {
                                  code1 += code3 = this._getWhiteCode();
                                } while (code3 >= 64);
                                do {
                                  code2 += code3 = this._getBlackCode();
                                } while (code3 >= 64);
                              }
                              this._addPixels(codingLine[this.codingPos] + code1, blackPixels);
                              if (codingLine[this.codingPos] < columns) {
                                this._addPixels(codingLine[this.codingPos] + code2, blackPixels ^ 1);
                              }
                              while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                                refPos += 2;
                              }
                              break;
                            case twoDimVertR3:
                              this._addPixels(refLine[refPos] + 3, blackPixels);
                              blackPixels ^= 1;
                              if (codingLine[this.codingPos] < columns) {
                                ++refPos;
                                while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                                  refPos += 2;
                                }
                              }
                              break;
                            case twoDimVertR2:
                              this._addPixels(refLine[refPos] + 2, blackPixels);
                              blackPixels ^= 1;
                              if (codingLine[this.codingPos] < columns) {
                                ++refPos;
                                while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                                  refPos += 2;
                                }
                              }
                              break;
                            case twoDimVertR1:
                              this._addPixels(refLine[refPos] + 1, blackPixels);
                              blackPixels ^= 1;
                              if (codingLine[this.codingPos] < columns) {
                                ++refPos;
                                while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                                  refPos += 2;
                                }
                              }
                              break;
                            case twoDimVert0:
                              this._addPixels(refLine[refPos], blackPixels);
                              blackPixels ^= 1;
                              if (codingLine[this.codingPos] < columns) {
                                ++refPos;
                                while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                                  refPos += 2;
                                }
                              }
                              break;
                            case twoDimVertL3:
                              this._addPixelsNeg(refLine[refPos] - 3, blackPixels);
                              blackPixels ^= 1;
                              if (codingLine[this.codingPos] < columns) {
                                if (refPos > 0) {
                                  --refPos;
                                } else {
                                  ++refPos;
                                }
                                while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                                  refPos += 2;
                                }
                              }
                              break;
                            case twoDimVertL2:
                              this._addPixelsNeg(refLine[refPos] - 2, blackPixels);
                              blackPixels ^= 1;
                              if (codingLine[this.codingPos] < columns) {
                                if (refPos > 0) {
                                  --refPos;
                                } else {
                                  ++refPos;
                                }
                                while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                                  refPos += 2;
                                }
                              }
                              break;
                            case twoDimVertL1:
                              this._addPixelsNeg(refLine[refPos] - 1, blackPixels);
                              blackPixels ^= 1;
                              if (codingLine[this.codingPos] < columns) {
                                if (refPos > 0) {
                                  --refPos;
                                } else {
                                  ++refPos;
                                }
                                while (refLine[refPos] <= codingLine[this.codingPos] && refLine[refPos] < columns) {
                                  refPos += 2;
                                }
                              }
                              break;
                            case ccittEOF:
                              this._addPixels(columns, 0);
                              this.eof = true;
                              break;
                            default:
                              (0, _util2.info)("bad 2d code");
                              this._addPixels(columns, 0);
                              this.err = true;
                          }
                        }
                      } else {
                        codingLine[0] = 0;
                        this.codingPos = 0;
                        blackPixels = 0;
                        while (codingLine[this.codingPos] < columns) {
                          code1 = 0;
                          if (blackPixels) {
                            do {
                              code1 += code3 = this._getBlackCode();
                            } while (code3 >= 64);
                          } else {
                            do {
                              code1 += code3 = this._getWhiteCode();
                            } while (code3 >= 64);
                          }
                          this._addPixels(codingLine[this.codingPos] + code1, blackPixels);
                          blackPixels ^= 1;
                        }
                      }
                      let gotEOL = false;
                      if (this.byteAlign) {
                        this.inputBits &= ~7;
                      }
                      if (!this.eoblock && this.row === this.rows - 1) {
                        this.rowsDone = true;
                      } else {
                        code1 = this._lookBits(12);
                        if (this.eoline) {
                          while (code1 !== ccittEOF && code1 !== 1) {
                            this._eatBits(1);
                            code1 = this._lookBits(12);
                          }
                        } else {
                          while (code1 === 0) {
                            this._eatBits(1);
                            code1 = this._lookBits(12);
                          }
                        }
                        if (code1 === 1) {
                          this._eatBits(12);
                          gotEOL = true;
                        } else if (code1 === ccittEOF) {
                          this.eof = true;
                        }
                      }
                      if (!this.eof && this.encoding > 0 && !this.rowsDone) {
                        this.nextLine2D = !this._lookBits(1);
                        this._eatBits(1);
                      }
                      if (this.eoblock && gotEOL && this.byteAlign) {
                        code1 = this._lookBits(12);
                        if (code1 === 1) {
                          this._eatBits(12);
                          if (this.encoding > 0) {
                            this._lookBits(1);
                            this._eatBits(1);
                          }
                          if (this.encoding >= 0) {
                            for (i = 0; i < 4; ++i) {
                              code1 = this._lookBits(12);
                              if (code1 !== 1) {
                                (0, _util2.info)("bad rtc code: " + code1);
                              }
                              this._eatBits(12);
                              if (this.encoding > 0) {
                                this._lookBits(1);
                                this._eatBits(1);
                              }
                            }
                          }
                          this.eof = true;
                        }
                      } else if (this.err && this.eoline) {
                        while (true) {
                          code1 = this._lookBits(13);
                          if (code1 === ccittEOF) {
                            this.eof = true;
                            return -1;
                          }
                          if (code1 >> 1 === 1) {
                            break;
                          }
                          this._eatBits(1);
                        }
                        this._eatBits(12);
                        if (this.encoding > 0) {
                          this._eatBits(1);
                          this.nextLine2D = !(code1 & 1);
                        }
                      }
                      if (codingLine[0] > 0) {
                        this.outputBits = codingLine[this.codingPos = 0];
                      } else {
                        this.outputBits = codingLine[this.codingPos = 1];
                      }
                      this.row++;
                    }
                    let c;
                    if (this.outputBits >= 8) {
                      c = this.codingPos & 1 ? 0 : 255;
                      this.outputBits -= 8;
                      if (this.outputBits === 0 && codingLine[this.codingPos] < columns) {
                        this.codingPos++;
                        this.outputBits = codingLine[this.codingPos] - codingLine[this.codingPos - 1];
                      }
                    } else {
                      bits = 8;
                      c = 0;
                      do {
                        if (this.outputBits > bits) {
                          c <<= bits;
                          if (!(this.codingPos & 1)) {
                            c |= 255 >> 8 - bits;
                          }
                          this.outputBits -= bits;
                          bits = 0;
                        } else {
                          c <<= this.outputBits;
                          if (!(this.codingPos & 1)) {
                            c |= 255 >> 8 - this.outputBits;
                          }
                          bits -= this.outputBits;
                          this.outputBits = 0;
                          if (codingLine[this.codingPos] < columns) {
                            this.codingPos++;
                            this.outputBits = codingLine[this.codingPos] - codingLine[this.codingPos - 1];
                          } else if (bits > 0) {
                            c <<= bits;
                            bits = 0;
                          }
                        }
                      } while (bits);
                    }
                    if (this.black) {
                      c ^= 255;
                    }
                    return c;
                  }, _addPixels(a1, blackPixels) {
                    const codingLine = this.codingLine;
                    let codingPos = this.codingPos;
                    if (a1 > codingLine[codingPos]) {
                      if (a1 > this.columns) {
                        (0, _util2.info)("row is wrong length");
                        this.err = true;
                        a1 = this.columns;
                      }
                      if (codingPos & 1 ^ blackPixels) {
                        ++codingPos;
                      }
                      codingLine[codingPos] = a1;
                    }
                    this.codingPos = codingPos;
                  }, _addPixelsNeg(a1, blackPixels) {
                    const codingLine = this.codingLine;
                    let codingPos = this.codingPos;
                    if (a1 > codingLine[codingPos]) {
                      if (a1 > this.columns) {
                        (0, _util2.info)("row is wrong length");
                        this.err = true;
                        a1 = this.columns;
                      }
                      if (codingPos & 1 ^ blackPixels) {
                        ++codingPos;
                      }
                      codingLine[codingPos] = a1;
                    } else if (a1 < codingLine[codingPos]) {
                      if (a1 < 0) {
                        (0, _util2.info)("invalid code");
                        this.err = true;
                        a1 = 0;
                      }
                      while (codingPos > 0 && a1 < codingLine[codingPos - 1]) {
                        --codingPos;
                      }
                      codingLine[codingPos] = a1;
                    }
                    this.codingPos = codingPos;
                  }, _findTableCode(start, end, table, limit) {
                    const limitValue = limit || 0;
                    for (let i = start; i <= end; ++i) {
                      let code = this._lookBits(i);
                      if (code === ccittEOF) {
                        return [true, 1, false];
                      }
                      if (i < end) {
                        code <<= end - i;
                      }
                      if (!limitValue || code >= limitValue) {
                        const p = table[code - limitValue];
                        if (p[0] === i) {
                          this._eatBits(i);
                          return [true, p[1], true];
                        }
                      }
                    }
                    return [false, 0, false];
                  }, _getTwoDimCode() {
                    let code = 0;
                    let p;
                    if (this.eoblock) {
                      code = this._lookBits(7);
                      p = twoDimTable[code];
                      if (p && p[0] > 0) {
                        this._eatBits(p[0]);
                        return p[1];
                      }
                    } else {
                      const result = this._findTableCode(1, 7, twoDimTable);
                      if (result[0] && result[2]) {
                        return result[1];
                      }
                    }
                    (0, _util2.info)("Bad two dim code");
                    return ccittEOF;
                  }, _getWhiteCode() {
                    let code = 0;
                    let p;
                    if (this.eoblock) {
                      code = this._lookBits(12);
                      if (code === ccittEOF) {
                        return 1;
                      }
                      if (code >> 5 === 0) {
                        p = whiteTable1[code];
                      } else {
                        p = whiteTable2[code >> 3];
                      }
                      if (p[0] > 0) {
                        this._eatBits(p[0]);
                        return p[1];
                      }
                    } else {
                      let result = this._findTableCode(1, 9, whiteTable2);
                      if (result[0]) {
                        return result[1];
                      }
                      result = this._findTableCode(11, 12, whiteTable1);
                      if (result[0]) {
                        return result[1];
                      }
                    }
                    (0, _util2.info)("bad white code");
                    this._eatBits(1);
                    return 1;
                  }, _getBlackCode() {
                    let code, p;
                    if (this.eoblock) {
                      code = this._lookBits(13);
                      if (code === ccittEOF) {
                        return 1;
                      }
                      if (code >> 7 === 0) {
                        p = blackTable1[code];
                      } else if (code >> 9 === 0 && code >> 7 !== 0) {
                        p = blackTable2[(code >> 1) - 64];
                      } else {
                        p = blackTable3[code >> 7];
                      }
                      if (p[0] > 0) {
                        this._eatBits(p[0]);
                        return p[1];
                      }
                    } else {
                      let result = this._findTableCode(2, 6, blackTable3);
                      if (result[0]) {
                        return result[1];
                      }
                      result = this._findTableCode(7, 12, blackTable2, 64);
                      if (result[0]) {
                        return result[1];
                      }
                      result = this._findTableCode(10, 13, blackTable1);
                      if (result[0]) {
                        return result[1];
                      }
                    }
                    (0, _util2.info)("bad black code");
                    this._eatBits(1);
                    return 1;
                  }, _lookBits(n) {
                    let c;
                    while (this.inputBits < n) {
                      if ((c = this.source.next()) === -1) {
                        if (this.inputBits === 0) {
                          return ccittEOF;
                        }
                        return this.inputBuf << n - this.inputBits & 65535 >> 16 - n;
                      }
                      this.inputBuf = this.inputBuf << 8 | c;
                      this.inputBits += 8;
                    }
                    return this.inputBuf >> this.inputBits - n & 65535 >> 16 - n;
                  }, _eatBits(n) {
                    if ((this.inputBits -= n) < 0) {
                      this.inputBits = 0;
                    }
                  } };
                  return CCITTFaxDecoder3;
                }();
                exports2.CCITTFaxDecoder = CCITTFaxDecoder;
              }, function(module3, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.Jbig2Stream = void 0;
                var _primitives = __w_pdfjs_require__2(4);
                var _stream = __w_pdfjs_require__2(11);
                var _jbig = __w_pdfjs_require__2(15);
                var _util2 = __w_pdfjs_require__2(2);
                const Jbig2Stream = function Jbig2StreamClosure() {
                  function Jbig2Stream2(stream, maybeLength, dict, params) {
                    this.stream = stream;
                    this.maybeLength = maybeLength;
                    this.dict = dict;
                    this.params = params;
                    _stream.DecodeStream.call(this, maybeLength);
                  }
                  Jbig2Stream2.prototype = Object.create(_stream.DecodeStream.prototype);
                  Object.defineProperty(Jbig2Stream2.prototype, "bytes", { get() {
                    return (0, _util2.shadow)(this, "bytes", this.stream.getBytes(this.maybeLength));
                  }, configurable: true });
                  Jbig2Stream2.prototype.ensureBuffer = function(requested) {
                  };
                  Jbig2Stream2.prototype.readBlock = function() {
                    if (this.eof) {
                      return;
                    }
                    const jbig2Image = new _jbig.Jbig2Image();
                    const chunks = [];
                    if ((0, _primitives.isDict)(this.params)) {
                      const globalsStream = this.params.get("JBIG2Globals");
                      if ((0, _primitives.isStream)(globalsStream)) {
                        const globals = globalsStream.getBytes();
                        chunks.push({ data: globals, start: 0, end: globals.length });
                      }
                    }
                    chunks.push({ data: this.bytes, start: 0, end: this.bytes.length });
                    const data = jbig2Image.parseChunks(chunks);
                    const dataLength = data.length;
                    for (let i = 0; i < dataLength; i++) {
                      data[i] ^= 255;
                    }
                    this.buffer = data;
                    this.bufferLength = dataLength;
                    this.eof = true;
                  };
                  return Jbig2Stream2;
                }();
                exports2.Jbig2Stream = Jbig2Stream;
              }, function(module3, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.Jbig2Image = void 0;
                var _util2 = __w_pdfjs_require__2(2);
                var _core_utils = __w_pdfjs_require__2(7);
                var _arithmetic_decoder = __w_pdfjs_require__2(16);
                var _ccitt = __w_pdfjs_require__2(13);
                class Jbig2Error extends _util2.BaseException {
                  constructor(msg) {
                    super(`JBIG2 error: ${msg}`);
                  }
                }
                var Jbig2Image = function Jbig2ImageClosure() {
                  function ContextCache() {
                  }
                  ContextCache.prototype = { getContexts(id) {
                    if (id in this) {
                      return this[id];
                    }
                    return this[id] = new Int8Array(1 << 16);
                  } };
                  function DecodingContext(data, start, end) {
                    this.data = data;
                    this.start = start;
                    this.end = end;
                  }
                  DecodingContext.prototype = { get decoder() {
                    var decoder = new _arithmetic_decoder.ArithmeticDecoder(this.data, this.start, this.end);
                    return (0, _util2.shadow)(this, "decoder", decoder);
                  }, get contextCache() {
                    var cache = new ContextCache();
                    return (0, _util2.shadow)(this, "contextCache", cache);
                  } };
                  function decodeInteger(contextCache, procedure, decoder) {
                    var contexts = contextCache.getContexts(procedure);
                    var prev = 1;
                    function readBits(length) {
                      var v = 0;
                      for (var i = 0; i < length; i++) {
                        var bit = decoder.readBit(contexts, prev);
                        prev = prev < 256 ? prev << 1 | bit : (prev << 1 | bit) & 511 | 256;
                        v = v << 1 | bit;
                      }
                      return v >>> 0;
                    }
                    var sign = readBits(1);
                    var value = readBits(1) ? readBits(1) ? readBits(1) ? readBits(1) ? readBits(1) ? readBits(32) + 4436 : readBits(12) + 340 : readBits(8) + 84 : readBits(6) + 20 : readBits(4) + 4 : readBits(2);
                    if (sign === 0) {
                      return value;
                    } else if (value > 0) {
                      return -value;
                    }
                    return null;
                  }
                  function decodeIAID(contextCache, decoder, codeLength) {
                    var contexts = contextCache.getContexts("IAID");
                    var prev = 1;
                    for (var i = 0; i < codeLength; i++) {
                      var bit = decoder.readBit(contexts, prev);
                      prev = prev << 1 | bit;
                    }
                    if (codeLength < 31) {
                      return prev & (1 << codeLength) - 1;
                    }
                    return prev & 2147483647;
                  }
                  var SegmentTypes = ["SymbolDictionary", null, null, null, "IntermediateTextRegion", null, "ImmediateTextRegion", "ImmediateLosslessTextRegion", null, null, null, null, null, null, null, null, "PatternDictionary", null, null, null, "IntermediateHalftoneRegion", null, "ImmediateHalftoneRegion", "ImmediateLosslessHalftoneRegion", null, null, null, null, null, null, null, null, null, null, null, null, "IntermediateGenericRegion", null, "ImmediateGenericRegion", "ImmediateLosslessGenericRegion", "IntermediateGenericRefinementRegion", null, "ImmediateGenericRefinementRegion", "ImmediateLosslessGenericRefinementRegion", null, null, null, null, "PageInformation", "EndOfPage", "EndOfStripe", "EndOfFile", "Profiles", "Tables", null, null, null, null, null, null, null, null, "Extension"];
                  var CodingTemplates = [[{ x: -1, y: -2 }, { x: 0, y: -2 }, { x: 1, y: -2 }, { x: -2, y: -1 }, { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: 2, y: -1 }, { x: -4, y: 0 }, { x: -3, y: 0 }, { x: -2, y: 0 }, { x: -1, y: 0 }], [{ x: -1, y: -2 }, { x: 0, y: -2 }, { x: 1, y: -2 }, { x: 2, y: -2 }, { x: -2, y: -1 }, { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: 2, y: -1 }, { x: -3, y: 0 }, { x: -2, y: 0 }, { x: -1, y: 0 }], [{ x: -1, y: -2 }, { x: 0, y: -2 }, { x: 1, y: -2 }, { x: -2, y: -1 }, { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: -2, y: 0 }, { x: -1, y: 0 }], [{ x: -3, y: -1 }, { x: -2, y: -1 }, { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: -4, y: 0 }, { x: -3, y: 0 }, { x: -2, y: 0 }, { x: -1, y: 0 }]];
                  var RefinementTemplates = [{ coding: [{ x: 0, y: -1 }, { x: 1, y: -1 }, { x: -1, y: 0 }], reference: [{ x: 0, y: -1 }, { x: 1, y: -1 }, { x: -1, y: 0 }, { x: 0, y: 0 }, { x: 1, y: 0 }, { x: -1, y: 1 }, { x: 0, y: 1 }, { x: 1, y: 1 }] }, { coding: [{ x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: -1, y: 0 }], reference: [{ x: 0, y: -1 }, { x: -1, y: 0 }, { x: 0, y: 0 }, { x: 1, y: 0 }, { x: 0, y: 1 }, { x: 1, y: 1 }] }];
                  var ReusedContexts = [39717, 1941, 229, 405];
                  var RefinementReusedContexts = [32, 8];
                  function decodeBitmapTemplate0(width, height, decodingContext) {
                    var decoder = decodingContext.decoder;
                    var contexts = decodingContext.contextCache.getContexts("GB");
                    var contextLabel, i, j, pixel, row, row1, row2, bitmap = [];
                    var OLD_PIXEL_MASK = 31735;
                    for (i = 0; i < height; i++) {
                      row = bitmap[i] = new Uint8Array(width);
                      row1 = i < 1 ? row : bitmap[i - 1];
                      row2 = i < 2 ? row : bitmap[i - 2];
                      contextLabel = row2[0] << 13 | row2[1] << 12 | row2[2] << 11 | row1[0] << 7 | row1[1] << 6 | row1[2] << 5 | row1[3] << 4;
                      for (j = 0; j < width; j++) {
                        row[j] = pixel = decoder.readBit(contexts, contextLabel);
                        contextLabel = (contextLabel & OLD_PIXEL_MASK) << 1 | (j + 3 < width ? row2[j + 3] << 11 : 0) | (j + 4 < width ? row1[j + 4] << 4 : 0) | pixel;
                      }
                    }
                    return bitmap;
                  }
                  function decodeBitmap(mmr, width, height, templateIndex, prediction, skip, at, decodingContext) {
                    if (mmr) {
                      const input = new Reader(decodingContext.data, decodingContext.start, decodingContext.end);
                      return decodeMMRBitmap(input, width, height, false);
                    }
                    if (templateIndex === 0 && !skip && !prediction && at.length === 4 && at[0].x === 3 && at[0].y === -1 && at[1].x === -3 && at[1].y === -1 && at[2].x === 2 && at[2].y === -2 && at[3].x === -2 && at[3].y === -2) {
                      return decodeBitmapTemplate0(width, height, decodingContext);
                    }
                    var useskip = !!skip;
                    var template = CodingTemplates[templateIndex].concat(at);
                    template.sort(function(a, b) {
                      return a.y - b.y || a.x - b.x;
                    });
                    var templateLength = template.length;
                    var templateX = new Int8Array(templateLength);
                    var templateY = new Int8Array(templateLength);
                    var changingTemplateEntries = [];
                    var reuseMask = 0, minX = 0, maxX = 0, minY = 0;
                    var c, k;
                    for (k = 0; k < templateLength; k++) {
                      templateX[k] = template[k].x;
                      templateY[k] = template[k].y;
                      minX = Math.min(minX, template[k].x);
                      maxX = Math.max(maxX, template[k].x);
                      minY = Math.min(minY, template[k].y);
                      if (k < templateLength - 1 && template[k].y === template[k + 1].y && template[k].x === template[k + 1].x - 1) {
                        reuseMask |= 1 << templateLength - 1 - k;
                      } else {
                        changingTemplateEntries.push(k);
                      }
                    }
                    var changingEntriesLength = changingTemplateEntries.length;
                    var changingTemplateX = new Int8Array(changingEntriesLength);
                    var changingTemplateY = new Int8Array(changingEntriesLength);
                    var changingTemplateBit = new Uint16Array(changingEntriesLength);
                    for (c = 0; c < changingEntriesLength; c++) {
                      k = changingTemplateEntries[c];
                      changingTemplateX[c] = template[k].x;
                      changingTemplateY[c] = template[k].y;
                      changingTemplateBit[c] = 1 << templateLength - 1 - k;
                    }
                    var sbb_left = -minX;
                    var sbb_top = -minY;
                    var sbb_right = width - maxX;
                    var pseudoPixelContext = ReusedContexts[templateIndex];
                    var row = new Uint8Array(width);
                    var bitmap = [];
                    var decoder = decodingContext.decoder;
                    var contexts = decodingContext.contextCache.getContexts("GB");
                    var ltp = 0, j, i0, j0, contextLabel = 0, bit, shift;
                    for (var i = 0; i < height; i++) {
                      if (prediction) {
                        var sltp = decoder.readBit(contexts, pseudoPixelContext);
                        ltp ^= sltp;
                        if (ltp) {
                          bitmap.push(row);
                          continue;
                        }
                      }
                      row = new Uint8Array(row);
                      bitmap.push(row);
                      for (j = 0; j < width; j++) {
                        if (useskip && skip[i][j]) {
                          row[j] = 0;
                          continue;
                        }
                        if (j >= sbb_left && j < sbb_right && i >= sbb_top) {
                          contextLabel = contextLabel << 1 & reuseMask;
                          for (k = 0; k < changingEntriesLength; k++) {
                            i0 = i + changingTemplateY[k];
                            j0 = j + changingTemplateX[k];
                            bit = bitmap[i0][j0];
                            if (bit) {
                              bit = changingTemplateBit[k];
                              contextLabel |= bit;
                            }
                          }
                        } else {
                          contextLabel = 0;
                          shift = templateLength - 1;
                          for (k = 0; k < templateLength; k++, shift--) {
                            j0 = j + templateX[k];
                            if (j0 >= 0 && j0 < width) {
                              i0 = i + templateY[k];
                              if (i0 >= 0) {
                                bit = bitmap[i0][j0];
                                if (bit) {
                                  contextLabel |= bit << shift;
                                }
                              }
                            }
                          }
                        }
                        var pixel = decoder.readBit(contexts, contextLabel);
                        row[j] = pixel;
                      }
                    }
                    return bitmap;
                  }
                  function decodeRefinement(width, height, templateIndex, referenceBitmap, offsetX, offsetY, prediction, at, decodingContext) {
                    var codingTemplate = RefinementTemplates[templateIndex].coding;
                    if (templateIndex === 0) {
                      codingTemplate = codingTemplate.concat([at[0]]);
                    }
                    var codingTemplateLength = codingTemplate.length;
                    var codingTemplateX = new Int32Array(codingTemplateLength);
                    var codingTemplateY = new Int32Array(codingTemplateLength);
                    var k;
                    for (k = 0; k < codingTemplateLength; k++) {
                      codingTemplateX[k] = codingTemplate[k].x;
                      codingTemplateY[k] = codingTemplate[k].y;
                    }
                    var referenceTemplate = RefinementTemplates[templateIndex].reference;
                    if (templateIndex === 0) {
                      referenceTemplate = referenceTemplate.concat([at[1]]);
                    }
                    var referenceTemplateLength = referenceTemplate.length;
                    var referenceTemplateX = new Int32Array(referenceTemplateLength);
                    var referenceTemplateY = new Int32Array(referenceTemplateLength);
                    for (k = 0; k < referenceTemplateLength; k++) {
                      referenceTemplateX[k] = referenceTemplate[k].x;
                      referenceTemplateY[k] = referenceTemplate[k].y;
                    }
                    var referenceWidth = referenceBitmap[0].length;
                    var referenceHeight = referenceBitmap.length;
                    var pseudoPixelContext = RefinementReusedContexts[templateIndex];
                    var bitmap = [];
                    var decoder = decodingContext.decoder;
                    var contexts = decodingContext.contextCache.getContexts("GR");
                    var ltp = 0;
                    for (var i = 0; i < height; i++) {
                      if (prediction) {
                        var sltp = decoder.readBit(contexts, pseudoPixelContext);
                        ltp ^= sltp;
                        if (ltp) {
                          throw new Jbig2Error("prediction is not supported");
                        }
                      }
                      var row = new Uint8Array(width);
                      bitmap.push(row);
                      for (var j = 0; j < width; j++) {
                        var i0, j0;
                        var contextLabel = 0;
                        for (k = 0; k < codingTemplateLength; k++) {
                          i0 = i + codingTemplateY[k];
                          j0 = j + codingTemplateX[k];
                          if (i0 < 0 || j0 < 0 || j0 >= width) {
                            contextLabel <<= 1;
                          } else {
                            contextLabel = contextLabel << 1 | bitmap[i0][j0];
                          }
                        }
                        for (k = 0; k < referenceTemplateLength; k++) {
                          i0 = i + referenceTemplateY[k] - offsetY;
                          j0 = j + referenceTemplateX[k] - offsetX;
                          if (i0 < 0 || i0 >= referenceHeight || j0 < 0 || j0 >= referenceWidth) {
                            contextLabel <<= 1;
                          } else {
                            contextLabel = contextLabel << 1 | referenceBitmap[i0][j0];
                          }
                        }
                        var pixel = decoder.readBit(contexts, contextLabel);
                        row[j] = pixel;
                      }
                    }
                    return bitmap;
                  }
                  function decodeSymbolDictionary(huffman, refinement, symbols, numberOfNewSymbols, numberOfExportedSymbols, huffmanTables, templateIndex, at, refinementTemplateIndex, refinementAt, decodingContext, huffmanInput) {
                    if (huffman && refinement) {
                      throw new Jbig2Error("symbol refinement with Huffman is not supported");
                    }
                    var newSymbols = [];
                    var currentHeight = 0;
                    var symbolCodeLength = (0, _core_utils.log2)(symbols.length + numberOfNewSymbols);
                    var decoder = decodingContext.decoder;
                    var contextCache = decodingContext.contextCache;
                    let tableB1, symbolWidths;
                    if (huffman) {
                      tableB1 = getStandardTable(1);
                      symbolWidths = [];
                      symbolCodeLength = Math.max(symbolCodeLength, 1);
                    }
                    while (newSymbols.length < numberOfNewSymbols) {
                      var deltaHeight = huffman ? huffmanTables.tableDeltaHeight.decode(huffmanInput) : decodeInteger(contextCache, "IADH", decoder);
                      currentHeight += deltaHeight;
                      let currentWidth = 0, totalWidth = 0;
                      const firstSymbol = huffman ? symbolWidths.length : 0;
                      while (true) {
                        var deltaWidth = huffman ? huffmanTables.tableDeltaWidth.decode(huffmanInput) : decodeInteger(contextCache, "IADW", decoder);
                        if (deltaWidth === null) {
                          break;
                        }
                        currentWidth += deltaWidth;
                        totalWidth += currentWidth;
                        var bitmap;
                        if (refinement) {
                          var numberOfInstances = decodeInteger(contextCache, "IAAI", decoder);
                          if (numberOfInstances > 1) {
                            bitmap = decodeTextRegion(huffman, refinement, currentWidth, currentHeight, 0, numberOfInstances, 1, symbols.concat(newSymbols), symbolCodeLength, 0, 0, 1, 0, huffmanTables, refinementTemplateIndex, refinementAt, decodingContext, 0, huffmanInput);
                          } else {
                            var symbolId = decodeIAID(contextCache, decoder, symbolCodeLength);
                            var rdx = decodeInteger(contextCache, "IARDX", decoder);
                            var rdy = decodeInteger(contextCache, "IARDY", decoder);
                            var symbol = symbolId < symbols.length ? symbols[symbolId] : newSymbols[symbolId - symbols.length];
                            bitmap = decodeRefinement(currentWidth, currentHeight, refinementTemplateIndex, symbol, rdx, rdy, false, refinementAt, decodingContext);
                          }
                          newSymbols.push(bitmap);
                        } else if (huffman) {
                          symbolWidths.push(currentWidth);
                        } else {
                          bitmap = decodeBitmap(false, currentWidth, currentHeight, templateIndex, false, null, at, decodingContext);
                          newSymbols.push(bitmap);
                        }
                      }
                      if (huffman && !refinement) {
                        const bitmapSize = huffmanTables.tableBitmapSize.decode(huffmanInput);
                        huffmanInput.byteAlign();
                        let collectiveBitmap;
                        if (bitmapSize === 0) {
                          collectiveBitmap = readUncompressedBitmap(huffmanInput, totalWidth, currentHeight);
                        } else {
                          const originalEnd = huffmanInput.end;
                          const bitmapEnd = huffmanInput.position + bitmapSize;
                          huffmanInput.end = bitmapEnd;
                          collectiveBitmap = decodeMMRBitmap(huffmanInput, totalWidth, currentHeight, false);
                          huffmanInput.end = originalEnd;
                          huffmanInput.position = bitmapEnd;
                        }
                        const numberOfSymbolsDecoded = symbolWidths.length;
                        if (firstSymbol === numberOfSymbolsDecoded - 1) {
                          newSymbols.push(collectiveBitmap);
                        } else {
                          let i2, y, xMin = 0, xMax, bitmapWidth, symbolBitmap;
                          for (i2 = firstSymbol; i2 < numberOfSymbolsDecoded; i2++) {
                            bitmapWidth = symbolWidths[i2];
                            xMax = xMin + bitmapWidth;
                            symbolBitmap = [];
                            for (y = 0; y < currentHeight; y++) {
                              symbolBitmap.push(collectiveBitmap[y].subarray(xMin, xMax));
                            }
                            newSymbols.push(symbolBitmap);
                            xMin = xMax;
                          }
                        }
                      }
                    }
                    var exportedSymbols = [];
                    var flags = [], currentFlag = false;
                    var totalSymbolsLength = symbols.length + numberOfNewSymbols;
                    while (flags.length < totalSymbolsLength) {
                      var runLength = huffman ? tableB1.decode(huffmanInput) : decodeInteger(contextCache, "IAEX", decoder);
                      while (runLength--) {
                        flags.push(currentFlag);
                      }
                      currentFlag = !currentFlag;
                    }
                    for (var i = 0, ii = symbols.length; i < ii; i++) {
                      if (flags[i]) {
                        exportedSymbols.push(symbols[i]);
                      }
                    }
                    for (var j = 0; j < numberOfNewSymbols; i++, j++) {
                      if (flags[i]) {
                        exportedSymbols.push(newSymbols[j]);
                      }
                    }
                    return exportedSymbols;
                  }
                  function decodeTextRegion(huffman, refinement, width, height, defaultPixelValue, numberOfSymbolInstances, stripSize, inputSymbols, symbolCodeLength, transposed, dsOffset, referenceCorner, combinationOperator, huffmanTables, refinementTemplateIndex, refinementAt, decodingContext, logStripSize, huffmanInput) {
                    if (huffman && refinement) {
                      throw new Jbig2Error("refinement with Huffman is not supported");
                    }
                    var bitmap = [];
                    var i, row;
                    for (i = 0; i < height; i++) {
                      row = new Uint8Array(width);
                      if (defaultPixelValue) {
                        for (var j = 0; j < width; j++) {
                          row[j] = defaultPixelValue;
                        }
                      }
                      bitmap.push(row);
                    }
                    var decoder = decodingContext.decoder;
                    var contextCache = decodingContext.contextCache;
                    var stripT = huffman ? -huffmanTables.tableDeltaT.decode(huffmanInput) : -decodeInteger(contextCache, "IADT", decoder);
                    var firstS = 0;
                    i = 0;
                    while (i < numberOfSymbolInstances) {
                      var deltaT = huffman ? huffmanTables.tableDeltaT.decode(huffmanInput) : decodeInteger(contextCache, "IADT", decoder);
                      stripT += deltaT;
                      var deltaFirstS = huffman ? huffmanTables.tableFirstS.decode(huffmanInput) : decodeInteger(contextCache, "IAFS", decoder);
                      firstS += deltaFirstS;
                      var currentS = firstS;
                      do {
                        let currentT = 0;
                        if (stripSize > 1) {
                          currentT = huffman ? huffmanInput.readBits(logStripSize) : decodeInteger(contextCache, "IAIT", decoder);
                        }
                        var t = stripSize * stripT + currentT;
                        var symbolId = huffman ? huffmanTables.symbolIDTable.decode(huffmanInput) : decodeIAID(contextCache, decoder, symbolCodeLength);
                        var applyRefinement = refinement && (huffman ? huffmanInput.readBit() : decodeInteger(contextCache, "IARI", decoder));
                        var symbolBitmap = inputSymbols[symbolId];
                        var symbolWidth = symbolBitmap[0].length;
                        var symbolHeight = symbolBitmap.length;
                        if (applyRefinement) {
                          var rdw = decodeInteger(contextCache, "IARDW", decoder);
                          var rdh = decodeInteger(contextCache, "IARDH", decoder);
                          var rdx = decodeInteger(contextCache, "IARDX", decoder);
                          var rdy = decodeInteger(contextCache, "IARDY", decoder);
                          symbolWidth += rdw;
                          symbolHeight += rdh;
                          symbolBitmap = decodeRefinement(symbolWidth, symbolHeight, refinementTemplateIndex, symbolBitmap, (rdw >> 1) + rdx, (rdh >> 1) + rdy, false, refinementAt, decodingContext);
                        }
                        var offsetT = t - (referenceCorner & 1 ? 0 : symbolHeight - 1);
                        var offsetS = currentS - (referenceCorner & 2 ? symbolWidth - 1 : 0);
                        var s2, t2, symbolRow;
                        if (transposed) {
                          for (s2 = 0; s2 < symbolHeight; s2++) {
                            row = bitmap[offsetS + s2];
                            if (!row) {
                              continue;
                            }
                            symbolRow = symbolBitmap[s2];
                            var maxWidth = Math.min(width - offsetT, symbolWidth);
                            switch (combinationOperator) {
                              case 0:
                                for (t2 = 0; t2 < maxWidth; t2++) {
                                  row[offsetT + t2] |= symbolRow[t2];
                                }
                                break;
                              case 2:
                                for (t2 = 0; t2 < maxWidth; t2++) {
                                  row[offsetT + t2] ^= symbolRow[t2];
                                }
                                break;
                              default:
                                throw new Jbig2Error(`operator ${combinationOperator} is not supported`);
                            }
                          }
                          currentS += symbolHeight - 1;
                        } else {
                          for (t2 = 0; t2 < symbolHeight; t2++) {
                            row = bitmap[offsetT + t2];
                            if (!row) {
                              continue;
                            }
                            symbolRow = symbolBitmap[t2];
                            switch (combinationOperator) {
                              case 0:
                                for (s2 = 0; s2 < symbolWidth; s2++) {
                                  row[offsetS + s2] |= symbolRow[s2];
                                }
                                break;
                              case 2:
                                for (s2 = 0; s2 < symbolWidth; s2++) {
                                  row[offsetS + s2] ^= symbolRow[s2];
                                }
                                break;
                              default:
                                throw new Jbig2Error(`operator ${combinationOperator} is not supported`);
                            }
                          }
                          currentS += symbolWidth - 1;
                        }
                        i++;
                        var deltaS = huffman ? huffmanTables.tableDeltaS.decode(huffmanInput) : decodeInteger(contextCache, "IADS", decoder);
                        if (deltaS === null) {
                          break;
                        }
                        currentS += deltaS + dsOffset;
                      } while (true);
                    }
                    return bitmap;
                  }
                  function decodePatternDictionary(mmr, patternWidth, patternHeight, maxPatternIndex, template, decodingContext) {
                    const at = [];
                    if (!mmr) {
                      at.push({ x: -patternWidth, y: 0 });
                      if (template === 0) {
                        at.push({ x: -3, y: -1 });
                        at.push({ x: 2, y: -2 });
                        at.push({ x: -2, y: -2 });
                      }
                    }
                    const collectiveWidth = (maxPatternIndex + 1) * patternWidth;
                    const collectiveBitmap = decodeBitmap(mmr, collectiveWidth, patternHeight, template, false, null, at, decodingContext);
                    const patterns = [];
                    for (let i = 0; i <= maxPatternIndex; i++) {
                      const patternBitmap = [];
                      const xMin = patternWidth * i;
                      const xMax = xMin + patternWidth;
                      for (let y = 0; y < patternHeight; y++) {
                        patternBitmap.push(collectiveBitmap[y].subarray(xMin, xMax));
                      }
                      patterns.push(patternBitmap);
                    }
                    return patterns;
                  }
                  function decodeHalftoneRegion(mmr, patterns, template, regionWidth, regionHeight, defaultPixelValue, enableSkip, combinationOperator, gridWidth, gridHeight, gridOffsetX, gridOffsetY, gridVectorX, gridVectorY, decodingContext) {
                    const skip = null;
                    if (enableSkip) {
                      throw new Jbig2Error("skip is not supported");
                    }
                    if (combinationOperator !== 0) {
                      throw new Jbig2Error("operator " + combinationOperator + " is not supported in halftone region");
                    }
                    const regionBitmap = [];
                    let i, j, row;
                    for (i = 0; i < regionHeight; i++) {
                      row = new Uint8Array(regionWidth);
                      if (defaultPixelValue) {
                        for (j = 0; j < regionWidth; j++) {
                          row[j] = defaultPixelValue;
                        }
                      }
                      regionBitmap.push(row);
                    }
                    const numberOfPatterns = patterns.length;
                    const pattern0 = patterns[0];
                    const patternWidth = pattern0[0].length, patternHeight = pattern0.length;
                    const bitsPerValue = (0, _core_utils.log2)(numberOfPatterns);
                    const at = [];
                    if (!mmr) {
                      at.push({ x: template <= 1 ? 3 : 2, y: -1 });
                      if (template === 0) {
                        at.push({ x: -3, y: -1 });
                        at.push({ x: 2, y: -2 });
                        at.push({ x: -2, y: -2 });
                      }
                    }
                    const grayScaleBitPlanes = [];
                    let mmrInput, bitmap;
                    if (mmr) {
                      mmrInput = new Reader(decodingContext.data, decodingContext.start, decodingContext.end);
                    }
                    for (i = bitsPerValue - 1; i >= 0; i--) {
                      if (mmr) {
                        bitmap = decodeMMRBitmap(mmrInput, gridWidth, gridHeight, true);
                      } else {
                        bitmap = decodeBitmap(false, gridWidth, gridHeight, template, false, skip, at, decodingContext);
                      }
                      grayScaleBitPlanes[i] = bitmap;
                    }
                    let mg, ng, bit, patternIndex, patternBitmap, x, y, patternRow, regionRow;
                    for (mg = 0; mg < gridHeight; mg++) {
                      for (ng = 0; ng < gridWidth; ng++) {
                        bit = 0;
                        patternIndex = 0;
                        for (j = bitsPerValue - 1; j >= 0; j--) {
                          bit = grayScaleBitPlanes[j][mg][ng] ^ bit;
                          patternIndex |= bit << j;
                        }
                        patternBitmap = patterns[patternIndex];
                        x = gridOffsetX + mg * gridVectorY + ng * gridVectorX >> 8;
                        y = gridOffsetY + mg * gridVectorX - ng * gridVectorY >> 8;
                        if (x >= 0 && x + patternWidth <= regionWidth && y >= 0 && y + patternHeight <= regionHeight) {
                          for (i = 0; i < patternHeight; i++) {
                            regionRow = regionBitmap[y + i];
                            patternRow = patternBitmap[i];
                            for (j = 0; j < patternWidth; j++) {
                              regionRow[x + j] |= patternRow[j];
                            }
                          }
                        } else {
                          let regionX, regionY;
                          for (i = 0; i < patternHeight; i++) {
                            regionY = y + i;
                            if (regionY < 0 || regionY >= regionHeight) {
                              continue;
                            }
                            regionRow = regionBitmap[regionY];
                            patternRow = patternBitmap[i];
                            for (j = 0; j < patternWidth; j++) {
                              regionX = x + j;
                              if (regionX >= 0 && regionX < regionWidth) {
                                regionRow[regionX] |= patternRow[j];
                              }
                            }
                          }
                        }
                      }
                    }
                    return regionBitmap;
                  }
                  function readSegmentHeader(data, start) {
                    var segmentHeader = {};
                    segmentHeader.number = (0, _core_utils.readUint32)(data, start);
                    var flags = data[start + 4];
                    var segmentType = flags & 63;
                    if (!SegmentTypes[segmentType]) {
                      throw new Jbig2Error("invalid segment type: " + segmentType);
                    }
                    segmentHeader.type = segmentType;
                    segmentHeader.typeName = SegmentTypes[segmentType];
                    segmentHeader.deferredNonRetain = !!(flags & 128);
                    var pageAssociationFieldSize = !!(flags & 64);
                    var referredFlags = data[start + 5];
                    var referredToCount = referredFlags >> 5 & 7;
                    var retainBits = [referredFlags & 31];
                    var position = start + 6;
                    if (referredFlags === 7) {
                      referredToCount = (0, _core_utils.readUint32)(data, position - 1) & 536870911;
                      position += 3;
                      var bytes = referredToCount + 7 >> 3;
                      retainBits[0] = data[position++];
                      while (--bytes > 0) {
                        retainBits.push(data[position++]);
                      }
                    } else if (referredFlags === 5 || referredFlags === 6) {
                      throw new Jbig2Error("invalid referred-to flags");
                    }
                    segmentHeader.retainBits = retainBits;
                    let referredToSegmentNumberSize = 4;
                    if (segmentHeader.number <= 256) {
                      referredToSegmentNumberSize = 1;
                    } else if (segmentHeader.number <= 65536) {
                      referredToSegmentNumberSize = 2;
                    }
                    var referredTo = [];
                    var i, ii;
                    for (i = 0; i < referredToCount; i++) {
                      let number;
                      if (referredToSegmentNumberSize === 1) {
                        number = data[position];
                      } else if (referredToSegmentNumberSize === 2) {
                        number = (0, _core_utils.readUint16)(data, position);
                      } else {
                        number = (0, _core_utils.readUint32)(data, position);
                      }
                      referredTo.push(number);
                      position += referredToSegmentNumberSize;
                    }
                    segmentHeader.referredTo = referredTo;
                    if (!pageAssociationFieldSize) {
                      segmentHeader.pageAssociation = data[position++];
                    } else {
                      segmentHeader.pageAssociation = (0, _core_utils.readUint32)(data, position);
                      position += 4;
                    }
                    segmentHeader.length = (0, _core_utils.readUint32)(data, position);
                    position += 4;
                    if (segmentHeader.length === 4294967295) {
                      if (segmentType === 38) {
                        var genericRegionInfo = readRegionSegmentInformation(data, position);
                        var genericRegionSegmentFlags = data[position + RegionSegmentInformationFieldLength];
                        var genericRegionMmr = !!(genericRegionSegmentFlags & 1);
                        var searchPatternLength = 6;
                        var searchPattern = new Uint8Array(searchPatternLength);
                        if (!genericRegionMmr) {
                          searchPattern[0] = 255;
                          searchPattern[1] = 172;
                        }
                        searchPattern[2] = genericRegionInfo.height >>> 24 & 255;
                        searchPattern[3] = genericRegionInfo.height >> 16 & 255;
                        searchPattern[4] = genericRegionInfo.height >> 8 & 255;
                        searchPattern[5] = genericRegionInfo.height & 255;
                        for (i = position, ii = data.length; i < ii; i++) {
                          var j = 0;
                          while (j < searchPatternLength && searchPattern[j] === data[i + j]) {
                            j++;
                          }
                          if (j === searchPatternLength) {
                            segmentHeader.length = i + searchPatternLength;
                            break;
                          }
                        }
                        if (segmentHeader.length === 4294967295) {
                          throw new Jbig2Error("segment end was not found");
                        }
                      } else {
                        throw new Jbig2Error("invalid unknown segment length");
                      }
                    }
                    segmentHeader.headerEnd = position;
                    return segmentHeader;
                  }
                  function readSegments(header, data, start, end) {
                    var segments = [];
                    var position = start;
                    while (position < end) {
                      var segmentHeader = readSegmentHeader(data, position);
                      position = segmentHeader.headerEnd;
                      var segment = { header: segmentHeader, data };
                      if (!header.randomAccess) {
                        segment.start = position;
                        position += segmentHeader.length;
                        segment.end = position;
                      }
                      segments.push(segment);
                      if (segmentHeader.type === 51) {
                        break;
                      }
                    }
                    if (header.randomAccess) {
                      for (var i = 0, ii = segments.length; i < ii; i++) {
                        segments[i].start = position;
                        position += segments[i].header.length;
                        segments[i].end = position;
                      }
                    }
                    return segments;
                  }
                  function readRegionSegmentInformation(data, start) {
                    return { width: (0, _core_utils.readUint32)(data, start), height: (0, _core_utils.readUint32)(data, start + 4), x: (0, _core_utils.readUint32)(data, start + 8), y: (0, _core_utils.readUint32)(data, start + 12), combinationOperator: data[start + 16] & 7 };
                  }
                  var RegionSegmentInformationFieldLength = 17;
                  function processSegment(segment, visitor) {
                    var header = segment.header;
                    var data = segment.data, position = segment.start, end = segment.end;
                    var args, at, i, atLength;
                    switch (header.type) {
                      case 0:
                        var dictionary = {};
                        var dictionaryFlags = (0, _core_utils.readUint16)(data, position);
                        dictionary.huffman = !!(dictionaryFlags & 1);
                        dictionary.refinement = !!(dictionaryFlags & 2);
                        dictionary.huffmanDHSelector = dictionaryFlags >> 2 & 3;
                        dictionary.huffmanDWSelector = dictionaryFlags >> 4 & 3;
                        dictionary.bitmapSizeSelector = dictionaryFlags >> 6 & 1;
                        dictionary.aggregationInstancesSelector = dictionaryFlags >> 7 & 1;
                        dictionary.bitmapCodingContextUsed = !!(dictionaryFlags & 256);
                        dictionary.bitmapCodingContextRetained = !!(dictionaryFlags & 512);
                        dictionary.template = dictionaryFlags >> 10 & 3;
                        dictionary.refinementTemplate = dictionaryFlags >> 12 & 1;
                        position += 2;
                        if (!dictionary.huffman) {
                          atLength = dictionary.template === 0 ? 4 : 1;
                          at = [];
                          for (i = 0; i < atLength; i++) {
                            at.push({ x: (0, _core_utils.readInt8)(data, position), y: (0, _core_utils.readInt8)(data, position + 1) });
                            position += 2;
                          }
                          dictionary.at = at;
                        }
                        if (dictionary.refinement && !dictionary.refinementTemplate) {
                          at = [];
                          for (i = 0; i < 2; i++) {
                            at.push({ x: (0, _core_utils.readInt8)(data, position), y: (0, _core_utils.readInt8)(data, position + 1) });
                            position += 2;
                          }
                          dictionary.refinementAt = at;
                        }
                        dictionary.numberOfExportedSymbols = (0, _core_utils.readUint32)(data, position);
                        position += 4;
                        dictionary.numberOfNewSymbols = (0, _core_utils.readUint32)(data, position);
                        position += 4;
                        args = [dictionary, header.number, header.referredTo, data, position, end];
                        break;
                      case 6:
                      case 7:
                        var textRegion = {};
                        textRegion.info = readRegionSegmentInformation(data, position);
                        position += RegionSegmentInformationFieldLength;
                        var textRegionSegmentFlags = (0, _core_utils.readUint16)(data, position);
                        position += 2;
                        textRegion.huffman = !!(textRegionSegmentFlags & 1);
                        textRegion.refinement = !!(textRegionSegmentFlags & 2);
                        textRegion.logStripSize = textRegionSegmentFlags >> 2 & 3;
                        textRegion.stripSize = 1 << textRegion.logStripSize;
                        textRegion.referenceCorner = textRegionSegmentFlags >> 4 & 3;
                        textRegion.transposed = !!(textRegionSegmentFlags & 64);
                        textRegion.combinationOperator = textRegionSegmentFlags >> 7 & 3;
                        textRegion.defaultPixelValue = textRegionSegmentFlags >> 9 & 1;
                        textRegion.dsOffset = textRegionSegmentFlags << 17 >> 27;
                        textRegion.refinementTemplate = textRegionSegmentFlags >> 15 & 1;
                        if (textRegion.huffman) {
                          var textRegionHuffmanFlags = (0, _core_utils.readUint16)(data, position);
                          position += 2;
                          textRegion.huffmanFS = textRegionHuffmanFlags & 3;
                          textRegion.huffmanDS = textRegionHuffmanFlags >> 2 & 3;
                          textRegion.huffmanDT = textRegionHuffmanFlags >> 4 & 3;
                          textRegion.huffmanRefinementDW = textRegionHuffmanFlags >> 6 & 3;
                          textRegion.huffmanRefinementDH = textRegionHuffmanFlags >> 8 & 3;
                          textRegion.huffmanRefinementDX = textRegionHuffmanFlags >> 10 & 3;
                          textRegion.huffmanRefinementDY = textRegionHuffmanFlags >> 12 & 3;
                          textRegion.huffmanRefinementSizeSelector = !!(textRegionHuffmanFlags & 16384);
                        }
                        if (textRegion.refinement && !textRegion.refinementTemplate) {
                          at = [];
                          for (i = 0; i < 2; i++) {
                            at.push({ x: (0, _core_utils.readInt8)(data, position), y: (0, _core_utils.readInt8)(data, position + 1) });
                            position += 2;
                          }
                          textRegion.refinementAt = at;
                        }
                        textRegion.numberOfSymbolInstances = (0, _core_utils.readUint32)(data, position);
                        position += 4;
                        args = [textRegion, header.referredTo, data, position, end];
                        break;
                      case 16:
                        const patternDictionary = {};
                        const patternDictionaryFlags = data[position++];
                        patternDictionary.mmr = !!(patternDictionaryFlags & 1);
                        patternDictionary.template = patternDictionaryFlags >> 1 & 3;
                        patternDictionary.patternWidth = data[position++];
                        patternDictionary.patternHeight = data[position++];
                        patternDictionary.maxPatternIndex = (0, _core_utils.readUint32)(data, position);
                        position += 4;
                        args = [patternDictionary, header.number, data, position, end];
                        break;
                      case 22:
                      case 23:
                        const halftoneRegion = {};
                        halftoneRegion.info = readRegionSegmentInformation(data, position);
                        position += RegionSegmentInformationFieldLength;
                        const halftoneRegionFlags = data[position++];
                        halftoneRegion.mmr = !!(halftoneRegionFlags & 1);
                        halftoneRegion.template = halftoneRegionFlags >> 1 & 3;
                        halftoneRegion.enableSkip = !!(halftoneRegionFlags & 8);
                        halftoneRegion.combinationOperator = halftoneRegionFlags >> 4 & 7;
                        halftoneRegion.defaultPixelValue = halftoneRegionFlags >> 7 & 1;
                        halftoneRegion.gridWidth = (0, _core_utils.readUint32)(data, position);
                        position += 4;
                        halftoneRegion.gridHeight = (0, _core_utils.readUint32)(data, position);
                        position += 4;
                        halftoneRegion.gridOffsetX = (0, _core_utils.readUint32)(data, position) & 4294967295;
                        position += 4;
                        halftoneRegion.gridOffsetY = (0, _core_utils.readUint32)(data, position) & 4294967295;
                        position += 4;
                        halftoneRegion.gridVectorX = (0, _core_utils.readUint16)(data, position);
                        position += 2;
                        halftoneRegion.gridVectorY = (0, _core_utils.readUint16)(data, position);
                        position += 2;
                        args = [halftoneRegion, header.referredTo, data, position, end];
                        break;
                      case 38:
                      case 39:
                        var genericRegion = {};
                        genericRegion.info = readRegionSegmentInformation(data, position);
                        position += RegionSegmentInformationFieldLength;
                        var genericRegionSegmentFlags = data[position++];
                        genericRegion.mmr = !!(genericRegionSegmentFlags & 1);
                        genericRegion.template = genericRegionSegmentFlags >> 1 & 3;
                        genericRegion.prediction = !!(genericRegionSegmentFlags & 8);
                        if (!genericRegion.mmr) {
                          atLength = genericRegion.template === 0 ? 4 : 1;
                          at = [];
                          for (i = 0; i < atLength; i++) {
                            at.push({ x: (0, _core_utils.readInt8)(data, position), y: (0, _core_utils.readInt8)(data, position + 1) });
                            position += 2;
                          }
                          genericRegion.at = at;
                        }
                        args = [genericRegion, data, position, end];
                        break;
                      case 48:
                        var pageInfo = { width: (0, _core_utils.readUint32)(data, position), height: (0, _core_utils.readUint32)(data, position + 4), resolutionX: (0, _core_utils.readUint32)(data, position + 8), resolutionY: (0, _core_utils.readUint32)(data, position + 12) };
                        if (pageInfo.height === 4294967295) {
                          delete pageInfo.height;
                        }
                        var pageSegmentFlags = data[position + 16];
                        (0, _core_utils.readUint16)(data, position + 17);
                        pageInfo.lossless = !!(pageSegmentFlags & 1);
                        pageInfo.refinement = !!(pageSegmentFlags & 2);
                        pageInfo.defaultPixelValue = pageSegmentFlags >> 2 & 1;
                        pageInfo.combinationOperator = pageSegmentFlags >> 3 & 3;
                        pageInfo.requiresBuffer = !!(pageSegmentFlags & 32);
                        pageInfo.combinationOperatorOverride = !!(pageSegmentFlags & 64);
                        args = [pageInfo];
                        break;
                      case 49:
                        break;
                      case 50:
                        break;
                      case 51:
                        break;
                      case 53:
                        args = [header.number, data, position, end];
                        break;
                      case 62:
                        break;
                      default:
                        throw new Jbig2Error(`segment type ${header.typeName}(${header.type}) is not implemented`);
                    }
                    var callbackName = "on" + header.typeName;
                    if (callbackName in visitor) {
                      visitor[callbackName].apply(visitor, args);
                    }
                  }
                  function processSegments(segments, visitor) {
                    for (var i = 0, ii = segments.length; i < ii; i++) {
                      processSegment(segments[i], visitor);
                    }
                  }
                  function parseJbig2Chunks(chunks) {
                    var visitor = new SimpleSegmentVisitor();
                    for (var i = 0, ii = chunks.length; i < ii; i++) {
                      var chunk = chunks[i];
                      var segments = readSegments({}, chunk.data, chunk.start, chunk.end);
                      processSegments(segments, visitor);
                    }
                    return visitor.buffer;
                  }
                  function parseJbig2(data) {
                    const end = data.length;
                    let position = 0;
                    if (data[position] !== 151 || data[position + 1] !== 74 || data[position + 2] !== 66 || data[position + 3] !== 50 || data[position + 4] !== 13 || data[position + 5] !== 10 || data[position + 6] !== 26 || data[position + 7] !== 10) {
                      throw new Jbig2Error("parseJbig2 - invalid header.");
                    }
                    const header = /* @__PURE__ */ Object.create(null);
                    position += 8;
                    const flags = data[position++];
                    header.randomAccess = !(flags & 1);
                    if (!(flags & 2)) {
                      header.numberOfPages = (0, _core_utils.readUint32)(data, position);
                      position += 4;
                    }
                    const segments = readSegments(header, data, position, end);
                    const visitor = new SimpleSegmentVisitor();
                    processSegments(segments, visitor);
                    const { width, height } = visitor.currentPageInfo;
                    const bitPacked = visitor.buffer;
                    const imgData = new Uint8ClampedArray(width * height);
                    let q = 0, k = 0;
                    for (let i = 0; i < height; i++) {
                      let mask = 0, buffer;
                      for (let j = 0; j < width; j++) {
                        if (!mask) {
                          mask = 128;
                          buffer = bitPacked[k++];
                        }
                        imgData[q++] = buffer & mask ? 0 : 255;
                        mask >>= 1;
                      }
                    }
                    return { imgData, width, height };
                  }
                  function SimpleSegmentVisitor() {
                  }
                  SimpleSegmentVisitor.prototype = { onPageInformation: function SimpleSegmentVisitor_onPageInformation(info) {
                    this.currentPageInfo = info;
                    var rowSize = info.width + 7 >> 3;
                    var buffer = new Uint8ClampedArray(rowSize * info.height);
                    if (info.defaultPixelValue) {
                      for (var i = 0, ii = buffer.length; i < ii; i++) {
                        buffer[i] = 255;
                      }
                    }
                    this.buffer = buffer;
                  }, drawBitmap: function SimpleSegmentVisitor_drawBitmap(regionInfo, bitmap) {
                    var pageInfo = this.currentPageInfo;
                    var width = regionInfo.width, height = regionInfo.height;
                    var rowSize = pageInfo.width + 7 >> 3;
                    var combinationOperator = pageInfo.combinationOperatorOverride ? regionInfo.combinationOperator : pageInfo.combinationOperator;
                    var buffer = this.buffer;
                    var mask0 = 128 >> (regionInfo.x & 7);
                    var offset0 = regionInfo.y * rowSize + (regionInfo.x >> 3);
                    var i, j, mask, offset;
                    switch (combinationOperator) {
                      case 0:
                        for (i = 0; i < height; i++) {
                          mask = mask0;
                          offset = offset0;
                          for (j = 0; j < width; j++) {
                            if (bitmap[i][j]) {
                              buffer[offset] |= mask;
                            }
                            mask >>= 1;
                            if (!mask) {
                              mask = 128;
                              offset++;
                            }
                          }
                          offset0 += rowSize;
                        }
                        break;
                      case 2:
                        for (i = 0; i < height; i++) {
                          mask = mask0;
                          offset = offset0;
                          for (j = 0; j < width; j++) {
                            if (bitmap[i][j]) {
                              buffer[offset] ^= mask;
                            }
                            mask >>= 1;
                            if (!mask) {
                              mask = 128;
                              offset++;
                            }
                          }
                          offset0 += rowSize;
                        }
                        break;
                      default:
                        throw new Jbig2Error(`operator ${combinationOperator} is not supported`);
                    }
                  }, onImmediateGenericRegion: function SimpleSegmentVisitor_onImmediateGenericRegion(region, data, start, end) {
                    var regionInfo = region.info;
                    var decodingContext = new DecodingContext(data, start, end);
                    var bitmap = decodeBitmap(region.mmr, regionInfo.width, regionInfo.height, region.template, region.prediction, null, region.at, decodingContext);
                    this.drawBitmap(regionInfo, bitmap);
                  }, onImmediateLosslessGenericRegion: function SimpleSegmentVisitor_onImmediateLosslessGenericRegion() {
                    this.onImmediateGenericRegion.apply(this, arguments);
                  }, onSymbolDictionary: function SimpleSegmentVisitor_onSymbolDictionary(dictionary, currentSegment, referredSegments, data, start, end) {
                    let huffmanTables, huffmanInput;
                    if (dictionary.huffman) {
                      huffmanTables = getSymbolDictionaryHuffmanTables(dictionary, referredSegments, this.customTables);
                      huffmanInput = new Reader(data, start, end);
                    }
                    var symbols = this.symbols;
                    if (!symbols) {
                      this.symbols = symbols = {};
                    }
                    var inputSymbols = [];
                    for (var i = 0, ii = referredSegments.length; i < ii; i++) {
                      const referredSymbols = symbols[referredSegments[i]];
                      if (referredSymbols) {
                        inputSymbols = inputSymbols.concat(referredSymbols);
                      }
                    }
                    var decodingContext = new DecodingContext(data, start, end);
                    symbols[currentSegment] = decodeSymbolDictionary(dictionary.huffman, dictionary.refinement, inputSymbols, dictionary.numberOfNewSymbols, dictionary.numberOfExportedSymbols, huffmanTables, dictionary.template, dictionary.at, dictionary.refinementTemplate, dictionary.refinementAt, decodingContext, huffmanInput);
                  }, onImmediateTextRegion: function SimpleSegmentVisitor_onImmediateTextRegion(region, referredSegments, data, start, end) {
                    var regionInfo = region.info;
                    let huffmanTables, huffmanInput;
                    var symbols = this.symbols;
                    var inputSymbols = [];
                    for (var i = 0, ii = referredSegments.length; i < ii; i++) {
                      const referredSymbols = symbols[referredSegments[i]];
                      if (referredSymbols) {
                        inputSymbols = inputSymbols.concat(referredSymbols);
                      }
                    }
                    var symbolCodeLength = (0, _core_utils.log2)(inputSymbols.length);
                    if (region.huffman) {
                      huffmanInput = new Reader(data, start, end);
                      huffmanTables = getTextRegionHuffmanTables(region, referredSegments, this.customTables, inputSymbols.length, huffmanInput);
                    }
                    var decodingContext = new DecodingContext(data, start, end);
                    var bitmap = decodeTextRegion(region.huffman, region.refinement, regionInfo.width, regionInfo.height, region.defaultPixelValue, region.numberOfSymbolInstances, region.stripSize, inputSymbols, symbolCodeLength, region.transposed, region.dsOffset, region.referenceCorner, region.combinationOperator, huffmanTables, region.refinementTemplate, region.refinementAt, decodingContext, region.logStripSize, huffmanInput);
                    this.drawBitmap(regionInfo, bitmap);
                  }, onImmediateLosslessTextRegion: function SimpleSegmentVisitor_onImmediateLosslessTextRegion() {
                    this.onImmediateTextRegion.apply(this, arguments);
                  }, onPatternDictionary(dictionary, currentSegment, data, start, end) {
                    let patterns = this.patterns;
                    if (!patterns) {
                      this.patterns = patterns = {};
                    }
                    const decodingContext = new DecodingContext(data, start, end);
                    patterns[currentSegment] = decodePatternDictionary(dictionary.mmr, dictionary.patternWidth, dictionary.patternHeight, dictionary.maxPatternIndex, dictionary.template, decodingContext);
                  }, onImmediateHalftoneRegion(region, referredSegments, data, start, end) {
                    const patterns = this.patterns[referredSegments[0]];
                    const regionInfo = region.info;
                    const decodingContext = new DecodingContext(data, start, end);
                    const bitmap = decodeHalftoneRegion(region.mmr, patterns, region.template, regionInfo.width, regionInfo.height, region.defaultPixelValue, region.enableSkip, region.combinationOperator, region.gridWidth, region.gridHeight, region.gridOffsetX, region.gridOffsetY, region.gridVectorX, region.gridVectorY, decodingContext);
                    this.drawBitmap(regionInfo, bitmap);
                  }, onImmediateLosslessHalftoneRegion() {
                    this.onImmediateHalftoneRegion.apply(this, arguments);
                  }, onTables(currentSegment, data, start, end) {
                    let customTables = this.customTables;
                    if (!customTables) {
                      this.customTables = customTables = {};
                    }
                    customTables[currentSegment] = decodeTablesSegment(data, start, end);
                  } };
                  function HuffmanLine(lineData) {
                    if (lineData.length === 2) {
                      this.isOOB = true;
                      this.rangeLow = 0;
                      this.prefixLength = lineData[0];
                      this.rangeLength = 0;
                      this.prefixCode = lineData[1];
                      this.isLowerRange = false;
                    } else {
                      this.isOOB = false;
                      this.rangeLow = lineData[0];
                      this.prefixLength = lineData[1];
                      this.rangeLength = lineData[2];
                      this.prefixCode = lineData[3];
                      this.isLowerRange = lineData[4] === "lower";
                    }
                  }
                  function HuffmanTreeNode(line) {
                    this.children = [];
                    if (line) {
                      this.isLeaf = true;
                      this.rangeLength = line.rangeLength;
                      this.rangeLow = line.rangeLow;
                      this.isLowerRange = line.isLowerRange;
                      this.isOOB = line.isOOB;
                    } else {
                      this.isLeaf = false;
                    }
                  }
                  HuffmanTreeNode.prototype = { buildTree(line, shift) {
                    const bit = line.prefixCode >> shift & 1;
                    if (shift <= 0) {
                      this.children[bit] = new HuffmanTreeNode(line);
                    } else {
                      let node = this.children[bit];
                      if (!node) {
                        this.children[bit] = node = new HuffmanTreeNode(null);
                      }
                      node.buildTree(line, shift - 1);
                    }
                  }, decodeNode(reader) {
                    if (this.isLeaf) {
                      if (this.isOOB) {
                        return null;
                      }
                      const htOffset = reader.readBits(this.rangeLength);
                      return this.rangeLow + (this.isLowerRange ? -htOffset : htOffset);
                    }
                    const node = this.children[reader.readBit()];
                    if (!node) {
                      throw new Jbig2Error("invalid Huffman data");
                    }
                    return node.decodeNode(reader);
                  } };
                  function HuffmanTable(lines, prefixCodesDone) {
                    if (!prefixCodesDone) {
                      this.assignPrefixCodes(lines);
                    }
                    this.rootNode = new HuffmanTreeNode(null);
                    for (let i = 0, ii = lines.length; i < ii; i++) {
                      const line = lines[i];
                      if (line.prefixLength > 0) {
                        this.rootNode.buildTree(line, line.prefixLength - 1);
                      }
                    }
                  }
                  HuffmanTable.prototype = { decode(reader) {
                    return this.rootNode.decodeNode(reader);
                  }, assignPrefixCodes(lines) {
                    const linesLength = lines.length;
                    let prefixLengthMax = 0;
                    for (let i = 0; i < linesLength; i++) {
                      prefixLengthMax = Math.max(prefixLengthMax, lines[i].prefixLength);
                    }
                    const histogram = new Uint32Array(prefixLengthMax + 1);
                    for (let i = 0; i < linesLength; i++) {
                      histogram[lines[i].prefixLength]++;
                    }
                    let currentLength = 1, firstCode = 0, currentCode, currentTemp, line;
                    histogram[0] = 0;
                    while (currentLength <= prefixLengthMax) {
                      firstCode = firstCode + histogram[currentLength - 1] << 1;
                      currentCode = firstCode;
                      currentTemp = 0;
                      while (currentTemp < linesLength) {
                        line = lines[currentTemp];
                        if (line.prefixLength === currentLength) {
                          line.prefixCode = currentCode;
                          currentCode++;
                        }
                        currentTemp++;
                      }
                      currentLength++;
                    }
                  } };
                  function decodeTablesSegment(data, start, end) {
                    const flags = data[start];
                    const lowestValue = (0, _core_utils.readUint32)(data, start + 1) & 4294967295;
                    const highestValue = (0, _core_utils.readUint32)(data, start + 5) & 4294967295;
                    const reader = new Reader(data, start + 9, end);
                    const prefixSizeBits = (flags >> 1 & 7) + 1;
                    const rangeSizeBits = (flags >> 4 & 7) + 1;
                    const lines = [];
                    let prefixLength, rangeLength, currentRangeLow = lowestValue;
                    do {
                      prefixLength = reader.readBits(prefixSizeBits);
                      rangeLength = reader.readBits(rangeSizeBits);
                      lines.push(new HuffmanLine([currentRangeLow, prefixLength, rangeLength, 0]));
                      currentRangeLow += 1 << rangeLength;
                    } while (currentRangeLow < highestValue);
                    prefixLength = reader.readBits(prefixSizeBits);
                    lines.push(new HuffmanLine([lowestValue - 1, prefixLength, 32, 0, "lower"]));
                    prefixLength = reader.readBits(prefixSizeBits);
                    lines.push(new HuffmanLine([highestValue, prefixLength, 32, 0]));
                    if (flags & 1) {
                      prefixLength = reader.readBits(prefixSizeBits);
                      lines.push(new HuffmanLine([prefixLength, 0]));
                    }
                    return new HuffmanTable(lines, false);
                  }
                  const standardTablesCache = {};
                  function getStandardTable(number) {
                    let table = standardTablesCache[number];
                    if (table) {
                      return table;
                    }
                    let lines;
                    switch (number) {
                      case 1:
                        lines = [[0, 1, 4, 0], [16, 2, 8, 2], [272, 3, 16, 6], [65808, 3, 32, 7]];
                        break;
                      case 2:
                        lines = [[0, 1, 0, 0], [1, 2, 0, 2], [2, 3, 0, 6], [3, 4, 3, 14], [11, 5, 6, 30], [75, 6, 32, 62], [6, 63]];
                        break;
                      case 3:
                        lines = [[-256, 8, 8, 254], [0, 1, 0, 0], [1, 2, 0, 2], [2, 3, 0, 6], [3, 4, 3, 14], [11, 5, 6, 30], [-257, 8, 32, 255, "lower"], [75, 7, 32, 126], [6, 62]];
                        break;
                      case 4:
                        lines = [[1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 0, 6], [4, 4, 3, 14], [12, 5, 6, 30], [76, 5, 32, 31]];
                        break;
                      case 5:
                        lines = [[-255, 7, 8, 126], [1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 0, 6], [4, 4, 3, 14], [12, 5, 6, 30], [-256, 7, 32, 127, "lower"], [76, 6, 32, 62]];
                        break;
                      case 6:
                        lines = [[-2048, 5, 10, 28], [-1024, 4, 9, 8], [-512, 4, 8, 9], [-256, 4, 7, 10], [-128, 5, 6, 29], [-64, 5, 5, 30], [-32, 4, 5, 11], [0, 2, 7, 0], [128, 3, 7, 2], [256, 3, 8, 3], [512, 4, 9, 12], [1024, 4, 10, 13], [-2049, 6, 32, 62, "lower"], [2048, 6, 32, 63]];
                        break;
                      case 7:
                        lines = [[-1024, 4, 9, 8], [-512, 3, 8, 0], [-256, 4, 7, 9], [-128, 5, 6, 26], [-64, 5, 5, 27], [-32, 4, 5, 10], [0, 4, 5, 11], [32, 5, 5, 28], [64, 5, 6, 29], [128, 4, 7, 12], [256, 3, 8, 1], [512, 3, 9, 2], [1024, 3, 10, 3], [-1025, 5, 32, 30, "lower"], [2048, 5, 32, 31]];
                        break;
                      case 8:
                        lines = [[-15, 8, 3, 252], [-7, 9, 1, 508], [-5, 8, 1, 253], [-3, 9, 0, 509], [-2, 7, 0, 124], [-1, 4, 0, 10], [0, 2, 1, 0], [2, 5, 0, 26], [3, 6, 0, 58], [4, 3, 4, 4], [20, 6, 1, 59], [22, 4, 4, 11], [38, 4, 5, 12], [70, 5, 6, 27], [134, 5, 7, 28], [262, 6, 7, 60], [390, 7, 8, 125], [646, 6, 10, 61], [-16, 9, 32, 510, "lower"], [1670, 9, 32, 511], [2, 1]];
                        break;
                      case 9:
                        lines = [[-31, 8, 4, 252], [-15, 9, 2, 508], [-11, 8, 2, 253], [-7, 9, 1, 509], [-5, 7, 1, 124], [-3, 4, 1, 10], [-1, 3, 1, 2], [1, 3, 1, 3], [3, 5, 1, 26], [5, 6, 1, 58], [7, 3, 5, 4], [39, 6, 2, 59], [43, 4, 5, 11], [75, 4, 6, 12], [139, 5, 7, 27], [267, 5, 8, 28], [523, 6, 8, 60], [779, 7, 9, 125], [1291, 6, 11, 61], [-32, 9, 32, 510, "lower"], [3339, 9, 32, 511], [2, 0]];
                        break;
                      case 10:
                        lines = [[-21, 7, 4, 122], [-5, 8, 0, 252], [-4, 7, 0, 123], [-3, 5, 0, 24], [-2, 2, 2, 0], [2, 5, 0, 25], [3, 6, 0, 54], [4, 7, 0, 124], [5, 8, 0, 253], [6, 2, 6, 1], [70, 5, 5, 26], [102, 6, 5, 55], [134, 6, 6, 56], [198, 6, 7, 57], [326, 6, 8, 58], [582, 6, 9, 59], [1094, 6, 10, 60], [2118, 7, 11, 125], [-22, 8, 32, 254, "lower"], [4166, 8, 32, 255], [2, 2]];
                        break;
                      case 11:
                        lines = [[1, 1, 0, 0], [2, 2, 1, 2], [4, 4, 0, 12], [5, 4, 1, 13], [7, 5, 1, 28], [9, 5, 2, 29], [13, 6, 2, 60], [17, 7, 2, 122], [21, 7, 3, 123], [29, 7, 4, 124], [45, 7, 5, 125], [77, 7, 6, 126], [141, 7, 32, 127]];
                        break;
                      case 12:
                        lines = [[1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 1, 6], [5, 5, 0, 28], [6, 5, 1, 29], [8, 6, 1, 60], [10, 7, 0, 122], [11, 7, 1, 123], [13, 7, 2, 124], [17, 7, 3, 125], [25, 7, 4, 126], [41, 8, 5, 254], [73, 8, 32, 255]];
                        break;
                      case 13:
                        lines = [[1, 1, 0, 0], [2, 3, 0, 4], [3, 4, 0, 12], [4, 5, 0, 28], [5, 4, 1, 13], [7, 3, 3, 5], [15, 6, 1, 58], [17, 6, 2, 59], [21, 6, 3, 60], [29, 6, 4, 61], [45, 6, 5, 62], [77, 7, 6, 126], [141, 7, 32, 127]];
                        break;
                      case 14:
                        lines = [[-2, 3, 0, 4], [-1, 3, 0, 5], [0, 1, 0, 0], [1, 3, 0, 6], [2, 3, 0, 7]];
                        break;
                      case 15:
                        lines = [[-24, 7, 4, 124], [-8, 6, 2, 60], [-4, 5, 1, 28], [-2, 4, 0, 12], [-1, 3, 0, 4], [0, 1, 0, 0], [1, 3, 0, 5], [2, 4, 0, 13], [3, 5, 1, 29], [5, 6, 2, 61], [9, 7, 4, 125], [-25, 7, 32, 126, "lower"], [25, 7, 32, 127]];
                        break;
                      default:
                        throw new Jbig2Error(`standard table B.${number} does not exist`);
                    }
                    for (let i = 0, ii = lines.length; i < ii; i++) {
                      lines[i] = new HuffmanLine(lines[i]);
                    }
                    table = new HuffmanTable(lines, true);
                    standardTablesCache[number] = table;
                    return table;
                  }
                  function Reader(data, start, end) {
                    this.data = data;
                    this.start = start;
                    this.end = end;
                    this.position = start;
                    this.shift = -1;
                    this.currentByte = 0;
                  }
                  Reader.prototype = { readBit() {
                    if (this.shift < 0) {
                      if (this.position >= this.end) {
                        throw new Jbig2Error("end of data while reading bit");
                      }
                      this.currentByte = this.data[this.position++];
                      this.shift = 7;
                    }
                    const bit = this.currentByte >> this.shift & 1;
                    this.shift--;
                    return bit;
                  }, readBits(numBits) {
                    let result = 0, i;
                    for (i = numBits - 1; i >= 0; i--) {
                      result |= this.readBit() << i;
                    }
                    return result;
                  }, byteAlign() {
                    this.shift = -1;
                  }, next() {
                    if (this.position >= this.end) {
                      return -1;
                    }
                    return this.data[this.position++];
                  } };
                  function getCustomHuffmanTable(index, referredTo, customTables) {
                    let currentIndex = 0;
                    for (let i = 0, ii = referredTo.length; i < ii; i++) {
                      const table = customTables[referredTo[i]];
                      if (table) {
                        if (index === currentIndex) {
                          return table;
                        }
                        currentIndex++;
                      }
                    }
                    throw new Jbig2Error("can't find custom Huffman table");
                  }
                  function getTextRegionHuffmanTables(textRegion, referredTo, customTables, numberOfSymbols, reader) {
                    const codes = [];
                    for (let i = 0; i <= 34; i++) {
                      const codeLength = reader.readBits(4);
                      codes.push(new HuffmanLine([i, codeLength, 0, 0]));
                    }
                    const runCodesTable = new HuffmanTable(codes, false);
                    codes.length = 0;
                    for (let i = 0; i < numberOfSymbols; ) {
                      const codeLength = runCodesTable.decode(reader);
                      if (codeLength >= 32) {
                        let repeatedLength, numberOfRepeats, j;
                        switch (codeLength) {
                          case 32:
                            if (i === 0) {
                              throw new Jbig2Error("no previous value in symbol ID table");
                            }
                            numberOfRepeats = reader.readBits(2) + 3;
                            repeatedLength = codes[i - 1].prefixLength;
                            break;
                          case 33:
                            numberOfRepeats = reader.readBits(3) + 3;
                            repeatedLength = 0;
                            break;
                          case 34:
                            numberOfRepeats = reader.readBits(7) + 11;
                            repeatedLength = 0;
                            break;
                          default:
                            throw new Jbig2Error("invalid code length in symbol ID table");
                        }
                        for (j = 0; j < numberOfRepeats; j++) {
                          codes.push(new HuffmanLine([i, repeatedLength, 0, 0]));
                          i++;
                        }
                      } else {
                        codes.push(new HuffmanLine([i, codeLength, 0, 0]));
                        i++;
                      }
                    }
                    reader.byteAlign();
                    const symbolIDTable = new HuffmanTable(codes, false);
                    let customIndex = 0, tableFirstS, tableDeltaS, tableDeltaT;
                    switch (textRegion.huffmanFS) {
                      case 0:
                      case 1:
                        tableFirstS = getStandardTable(textRegion.huffmanFS + 6);
                        break;
                      case 3:
                        tableFirstS = getCustomHuffmanTable(customIndex, referredTo, customTables);
                        customIndex++;
                        break;
                      default:
                        throw new Jbig2Error("invalid Huffman FS selector");
                    }
                    switch (textRegion.huffmanDS) {
                      case 0:
                      case 1:
                      case 2:
                        tableDeltaS = getStandardTable(textRegion.huffmanDS + 8);
                        break;
                      case 3:
                        tableDeltaS = getCustomHuffmanTable(customIndex, referredTo, customTables);
                        customIndex++;
                        break;
                      default:
                        throw new Jbig2Error("invalid Huffman DS selector");
                    }
                    switch (textRegion.huffmanDT) {
                      case 0:
                      case 1:
                      case 2:
                        tableDeltaT = getStandardTable(textRegion.huffmanDT + 11);
                        break;
                      case 3:
                        tableDeltaT = getCustomHuffmanTable(customIndex, referredTo, customTables);
                        customIndex++;
                        break;
                      default:
                        throw new Jbig2Error("invalid Huffman DT selector");
                    }
                    if (textRegion.refinement) {
                      throw new Jbig2Error("refinement with Huffman is not supported");
                    }
                    return { symbolIDTable, tableFirstS, tableDeltaS, tableDeltaT };
                  }
                  function getSymbolDictionaryHuffmanTables(dictionary, referredTo, customTables) {
                    let customIndex = 0, tableDeltaHeight, tableDeltaWidth;
                    switch (dictionary.huffmanDHSelector) {
                      case 0:
                      case 1:
                        tableDeltaHeight = getStandardTable(dictionary.huffmanDHSelector + 4);
                        break;
                      case 3:
                        tableDeltaHeight = getCustomHuffmanTable(customIndex, referredTo, customTables);
                        customIndex++;
                        break;
                      default:
                        throw new Jbig2Error("invalid Huffman DH selector");
                    }
                    switch (dictionary.huffmanDWSelector) {
                      case 0:
                      case 1:
                        tableDeltaWidth = getStandardTable(dictionary.huffmanDWSelector + 2);
                        break;
                      case 3:
                        tableDeltaWidth = getCustomHuffmanTable(customIndex, referredTo, customTables);
                        customIndex++;
                        break;
                      default:
                        throw new Jbig2Error("invalid Huffman DW selector");
                    }
                    let tableBitmapSize, tableAggregateInstances;
                    if (dictionary.bitmapSizeSelector) {
                      tableBitmapSize = getCustomHuffmanTable(customIndex, referredTo, customTables);
                      customIndex++;
                    } else {
                      tableBitmapSize = getStandardTable(1);
                    }
                    if (dictionary.aggregationInstancesSelector) {
                      tableAggregateInstances = getCustomHuffmanTable(customIndex, referredTo, customTables);
                    } else {
                      tableAggregateInstances = getStandardTable(1);
                    }
                    return { tableDeltaHeight, tableDeltaWidth, tableBitmapSize, tableAggregateInstances };
                  }
                  function readUncompressedBitmap(reader, width, height) {
                    const bitmap = [];
                    for (let y = 0; y < height; y++) {
                      const row = new Uint8Array(width);
                      bitmap.push(row);
                      for (let x = 0; x < width; x++) {
                        row[x] = reader.readBit();
                      }
                      reader.byteAlign();
                    }
                    return bitmap;
                  }
                  function decodeMMRBitmap(input, width, height, endOfBlock) {
                    const params = { K: -1, Columns: width, Rows: height, BlackIs1: true, EndOfBlock: endOfBlock };
                    const decoder = new _ccitt.CCITTFaxDecoder(input, params);
                    const bitmap = [];
                    let currentByte, eof = false;
                    for (let y = 0; y < height; y++) {
                      const row = new Uint8Array(width);
                      bitmap.push(row);
                      let shift = -1;
                      for (let x = 0; x < width; x++) {
                        if (shift < 0) {
                          currentByte = decoder.readNextChar();
                          if (currentByte === -1) {
                            currentByte = 0;
                            eof = true;
                          }
                          shift = 7;
                        }
                        row[x] = currentByte >> shift & 1;
                        shift--;
                      }
                    }
                    if (endOfBlock && !eof) {
                      const lookForEOFLimit = 5;
                      for (let i = 0; i < lookForEOFLimit; i++) {
                        if (decoder.readNextChar() === -1) {
                          break;
                        }
                      }
                    }
                    return bitmap;
                  }
                  function Jbig2Image2() {
                  }
                  Jbig2Image2.prototype = { parseChunks(chunks) {
                    return parseJbig2Chunks(chunks);
                  }, parse(data) {
                    const { imgData, width, height } = parseJbig2(data);
                    this.width = width;
                    this.height = height;
                    return imgData;
                  } };
                  return Jbig2Image2;
                }();
                exports2.Jbig2Image = Jbig2Image;
              }, function(module3, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.ArithmeticDecoder = void 0;
                const QeTable = [{ qe: 22017, nmps: 1, nlps: 1, switchFlag: 1 }, { qe: 13313, nmps: 2, nlps: 6, switchFlag: 0 }, { qe: 6145, nmps: 3, nlps: 9, switchFlag: 0 }, { qe: 2753, nmps: 4, nlps: 12, switchFlag: 0 }, { qe: 1313, nmps: 5, nlps: 29, switchFlag: 0 }, { qe: 545, nmps: 38, nlps: 33, switchFlag: 0 }, { qe: 22017, nmps: 7, nlps: 6, switchFlag: 1 }, { qe: 21505, nmps: 8, nlps: 14, switchFlag: 0 }, { qe: 18433, nmps: 9, nlps: 14, switchFlag: 0 }, { qe: 14337, nmps: 10, nlps: 14, switchFlag: 0 }, { qe: 12289, nmps: 11, nlps: 17, switchFlag: 0 }, { qe: 9217, nmps: 12, nlps: 18, switchFlag: 0 }, { qe: 7169, nmps: 13, nlps: 20, switchFlag: 0 }, { qe: 5633, nmps: 29, nlps: 21, switchFlag: 0 }, { qe: 22017, nmps: 15, nlps: 14, switchFlag: 1 }, { qe: 21505, nmps: 16, nlps: 14, switchFlag: 0 }, { qe: 20737, nmps: 17, nlps: 15, switchFlag: 0 }, { qe: 18433, nmps: 18, nlps: 16, switchFlag: 0 }, { qe: 14337, nmps: 19, nlps: 17, switchFlag: 0 }, { qe: 13313, nmps: 20, nlps: 18, switchFlag: 0 }, { qe: 12289, nmps: 21, nlps: 19, switchFlag: 0 }, { qe: 10241, nmps: 22, nlps: 19, switchFlag: 0 }, { qe: 9217, nmps: 23, nlps: 20, switchFlag: 0 }, { qe: 8705, nmps: 24, nlps: 21, switchFlag: 0 }, { qe: 7169, nmps: 25, nlps: 22, switchFlag: 0 }, { qe: 6145, nmps: 26, nlps: 23, switchFlag: 0 }, { qe: 5633, nmps: 27, nlps: 24, switchFlag: 0 }, { qe: 5121, nmps: 28, nlps: 25, switchFlag: 0 }, { qe: 4609, nmps: 29, nlps: 26, switchFlag: 0 }, { qe: 4353, nmps: 30, nlps: 27, switchFlag: 0 }, { qe: 2753, nmps: 31, nlps: 28, switchFlag: 0 }, { qe: 2497, nmps: 32, nlps: 29, switchFlag: 0 }, { qe: 2209, nmps: 33, nlps: 30, switchFlag: 0 }, { qe: 1313, nmps: 34, nlps: 31, switchFlag: 0 }, { qe: 1089, nmps: 35, nlps: 32, switchFlag: 0 }, { qe: 673, nmps: 36, nlps: 33, switchFlag: 0 }, { qe: 545, nmps: 37, nlps: 34, switchFlag: 0 }, { qe: 321, nmps: 38, nlps: 35, switchFlag: 0 }, { qe: 273, nmps: 39, nlps: 36, switchFlag: 0 }, { qe: 133, nmps: 40, nlps: 37, switchFlag: 0 }, { qe: 73, nmps: 41, nlps: 38, switchFlag: 0 }, { qe: 37, nmps: 42, nlps: 39, switchFlag: 0 }, { qe: 21, nmps: 43, nlps: 40, switchFlag: 0 }, { qe: 9, nmps: 44, nlps: 41, switchFlag: 0 }, { qe: 5, nmps: 45, nlps: 42, switchFlag: 0 }, { qe: 1, nmps: 45, nlps: 43, switchFlag: 0 }, { qe: 22017, nmps: 46, nlps: 46, switchFlag: 0 }];
                class ArithmeticDecoder {
                  constructor(data, start, end) {
                    this.data = data;
                    this.bp = start;
                    this.dataEnd = end;
                    this.chigh = data[start];
                    this.clow = 0;
                    this.byteIn();
                    this.chigh = this.chigh << 7 & 65535 | this.clow >> 9 & 127;
                    this.clow = this.clow << 7 & 65535;
                    this.ct -= 7;
                    this.a = 32768;
                  }
                  byteIn() {
                    const data = this.data;
                    let bp = this.bp;
                    if (data[bp] === 255) {
                      if (data[bp + 1] > 143) {
                        this.clow += 65280;
                        this.ct = 8;
                      } else {
                        bp++;
                        this.clow += data[bp] << 9;
                        this.ct = 7;
                        this.bp = bp;
                      }
                    } else {
                      bp++;
                      this.clow += bp < this.dataEnd ? data[bp] << 8 : 65280;
                      this.ct = 8;
                      this.bp = bp;
                    }
                    if (this.clow > 65535) {
                      this.chigh += this.clow >> 16;
                      this.clow &= 65535;
                    }
                  }
                  readBit(contexts, pos) {
                    let cx_index = contexts[pos] >> 1, cx_mps = contexts[pos] & 1;
                    const qeTableIcx = QeTable[cx_index];
                    const qeIcx = qeTableIcx.qe;
                    let d;
                    let a = this.a - qeIcx;
                    if (this.chigh < qeIcx) {
                      if (a < qeIcx) {
                        a = qeIcx;
                        d = cx_mps;
                        cx_index = qeTableIcx.nmps;
                      } else {
                        a = qeIcx;
                        d = 1 ^ cx_mps;
                        if (qeTableIcx.switchFlag === 1) {
                          cx_mps = d;
                        }
                        cx_index = qeTableIcx.nlps;
                      }
                    } else {
                      this.chigh -= qeIcx;
                      if ((a & 32768) !== 0) {
                        this.a = a;
                        return cx_mps;
                      }
                      if (a < qeIcx) {
                        d = 1 ^ cx_mps;
                        if (qeTableIcx.switchFlag === 1) {
                          cx_mps = d;
                        }
                        cx_index = qeTableIcx.nlps;
                      } else {
                        d = cx_mps;
                        cx_index = qeTableIcx.nmps;
                      }
                    }
                    do {
                      if (this.ct === 0) {
                        this.byteIn();
                      }
                      a <<= 1;
                      this.chigh = this.chigh << 1 & 65535 | this.clow >> 15 & 1;
                      this.clow = this.clow << 1 & 65535;
                      this.ct--;
                    } while ((a & 32768) === 0);
                    this.a = a;
                    contexts[pos] = cx_index << 1 | cx_mps;
                    return d;
                  }
                }
                exports2.ArithmeticDecoder = ArithmeticDecoder;
              }, function(module3, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.JpegStream = void 0;
                var _util2 = __w_pdfjs_require__2(2);
                var _stream = __w_pdfjs_require__2(11);
                var _primitives = __w_pdfjs_require__2(4);
                var _jpg = __w_pdfjs_require__2(18);
                const JpegStream = function JpegStreamClosure() {
                  function JpegStream2(stream, maybeLength, dict, params) {
                    let ch;
                    while ((ch = stream.getByte()) !== -1) {
                      if (ch === 255) {
                        stream.skip(-1);
                        break;
                      }
                    }
                    this.stream = stream;
                    this.maybeLength = maybeLength;
                    this.dict = dict;
                    this.params = params;
                    _stream.DecodeStream.call(this, maybeLength);
                  }
                  JpegStream2.prototype = Object.create(_stream.DecodeStream.prototype);
                  Object.defineProperty(JpegStream2.prototype, "bytes", { get: function JpegStream_bytes() {
                    return (0, _util2.shadow)(this, "bytes", this.stream.getBytes(this.maybeLength));
                  }, configurable: true });
                  JpegStream2.prototype.ensureBuffer = function(requested) {
                  };
                  JpegStream2.prototype.readBlock = function() {
                    if (this.eof) {
                      return;
                    }
                    const jpegOptions = { decodeTransform: void 0, colorTransform: void 0 };
                    const decodeArr = this.dict.getArray("Decode", "D");
                    if (this.forceRGB && Array.isArray(decodeArr)) {
                      const bitsPerComponent = this.dict.get("BitsPerComponent") || 8;
                      const decodeArrLength = decodeArr.length;
                      const transform = new Int32Array(decodeArrLength);
                      let transformNeeded = false;
                      const maxValue = (1 << bitsPerComponent) - 1;
                      for (let i = 0; i < decodeArrLength; i += 2) {
                        transform[i] = (decodeArr[i + 1] - decodeArr[i]) * 256 | 0;
                        transform[i + 1] = decodeArr[i] * maxValue | 0;
                        if (transform[i] !== 256 || transform[i + 1] !== 0) {
                          transformNeeded = true;
                        }
                      }
                      if (transformNeeded) {
                        jpegOptions.decodeTransform = transform;
                      }
                    }
                    if ((0, _primitives.isDict)(this.params)) {
                      const colorTransform = this.params.get("ColorTransform");
                      if (Number.isInteger(colorTransform)) {
                        jpegOptions.colorTransform = colorTransform;
                      }
                    }
                    const jpegImage = new _jpg.JpegImage(jpegOptions);
                    jpegImage.parse(this.bytes);
                    const data = jpegImage.getData({ width: this.drawWidth, height: this.drawHeight, forceRGB: this.forceRGB, isSourcePDF: true });
                    this.buffer = data;
                    this.bufferLength = data.length;
                    this.eof = true;
                  };
                  Object.defineProperty(JpegStream2.prototype, "maybeValidDimensions", { get: function JpegStream_maybeValidDimensions() {
                    const { dict, stream } = this;
                    const dictHeight = dict.get("Height", "H");
                    const startPos = stream.pos;
                    let validDimensions = true, foundSOF = false, b;
                    while ((b = stream.getByte()) !== -1) {
                      if (b !== 255) {
                        continue;
                      }
                      switch (stream.getByte()) {
                        case 192:
                        case 193:
                        case 194:
                          foundSOF = true;
                          stream.pos += 2;
                          stream.pos += 1;
                          const scanLines = stream.getUint16();
                          if (scanLines === dictHeight) {
                            break;
                          }
                          if (scanLines === 0) {
                            validDimensions = false;
                            break;
                          }
                          if (scanLines > dictHeight * 10) {
                            validDimensions = false;
                            break;
                          }
                          break;
                        case 195:
                        case 197:
                        case 198:
                        case 199:
                        case 201:
                        case 202:
                        case 203:
                        case 205:
                        case 206:
                        case 207:
                          foundSOF = true;
                          break;
                        case 196:
                        case 204:
                        case 218:
                        case 219:
                        case 220:
                        case 221:
                        case 222:
                        case 223:
                        case 224:
                        case 225:
                        case 226:
                        case 227:
                        case 228:
                        case 229:
                        case 230:
                        case 231:
                        case 232:
                        case 233:
                        case 234:
                        case 235:
                        case 236:
                        case 237:
                        case 238:
                        case 239:
                        case 254:
                          const markerLength = stream.getUint16();
                          if (markerLength > 2) {
                            stream.skip(markerLength - 2);
                          } else {
                            stream.skip(-2);
                          }
                          break;
                        case 255:
                          stream.skip(-1);
                          break;
                        case 217:
                          foundSOF = true;
                          break;
                      }
                      if (foundSOF) {
                        break;
                      }
                    }
                    stream.pos = startPos;
                    return (0, _util2.shadow)(this, "maybeValidDimensions", validDimensions);
                  }, configurable: true });
                  JpegStream2.prototype.getIR = function(forceDataSchema = false) {
                    return (0, _util2.createObjectURL)(this.bytes, "image/jpeg", forceDataSchema);
                  };
                  return JpegStream2;
                }();
                exports2.JpegStream = JpegStream;
              }, function(module3, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.JpegImage = void 0;
                var _util2 = __w_pdfjs_require__2(2);
                var _core_utils = __w_pdfjs_require__2(7);
                class JpegError extends _util2.BaseException {
                  constructor(msg) {
                    super(`JPEG error: ${msg}`);
                  }
                }
                class DNLMarkerError extends _util2.BaseException {
                  constructor(message, scanLines) {
                    super(message);
                    this.scanLines = scanLines;
                  }
                }
                class EOIMarkerError extends _util2.BaseException {
                }
                var JpegImage = function JpegImageClosure() {
                  var dctZigZag = new Uint8Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]);
                  var dctCos1 = 4017;
                  var dctSin1 = 799;
                  var dctCos3 = 3406;
                  var dctSin3 = 2276;
                  var dctCos6 = 1567;
                  var dctSin6 = 3784;
                  var dctSqrt2 = 5793;
                  var dctSqrt1d2 = 2896;
                  function JpegImage2({ decodeTransform = null, colorTransform = -1 } = {}) {
                    this._decodeTransform = decodeTransform;
                    this._colorTransform = colorTransform;
                  }
                  function buildHuffmanTable(codeLengths, values) {
                    var k = 0, code = [], i, j, length = 16;
                    while (length > 0 && !codeLengths[length - 1]) {
                      length--;
                    }
                    code.push({ children: [], index: 0 });
                    var p = code[0], q;
                    for (i = 0; i < length; i++) {
                      for (j = 0; j < codeLengths[i]; j++) {
                        p = code.pop();
                        p.children[p.index] = values[k];
                        while (p.index > 0) {
                          p = code.pop();
                        }
                        p.index++;
                        code.push(p);
                        while (code.length <= i) {
                          code.push(q = { children: [], index: 0 });
                          p.children[p.index] = q.children;
                          p = q;
                        }
                        k++;
                      }
                      if (i + 1 < length) {
                        code.push(q = { children: [], index: 0 });
                        p.children[p.index] = q.children;
                        p = q;
                      }
                    }
                    return code[0].children;
                  }
                  function getBlockBufferOffset(component, row, col) {
                    return 64 * ((component.blocksPerLine + 1) * row + col);
                  }
                  function decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive, parseDNLMarker = false) {
                    var mcusPerLine = frame.mcusPerLine;
                    var progressive = frame.progressive;
                    var startOffset = offset, bitsData = 0, bitsCount = 0;
                    function readBit() {
                      if (bitsCount > 0) {
                        bitsCount--;
                        return bitsData >> bitsCount & 1;
                      }
                      bitsData = data[offset++];
                      if (bitsData === 255) {
                        var nextByte = data[offset++];
                        if (nextByte) {
                          if (nextByte === 220 && parseDNLMarker) {
                            offset += 2;
                            const scanLines = (0, _core_utils.readUint16)(data, offset);
                            offset += 2;
                            if (scanLines > 0 && scanLines !== frame.scanLines) {
                              throw new DNLMarkerError("Found DNL marker (0xFFDC) while parsing scan data", scanLines);
                            }
                          } else if (nextByte === 217) {
                            if (parseDNLMarker) {
                              const maybeScanLines = blockRow * 8;
                              if (maybeScanLines > 0 && maybeScanLines < frame.scanLines / 10) {
                                throw new DNLMarkerError("Found EOI marker (0xFFD9) while parsing scan data, possibly caused by incorrect `scanLines` parameter", maybeScanLines);
                              }
                            }
                            throw new EOIMarkerError("Found EOI marker (0xFFD9) while parsing scan data");
                          }
                          throw new JpegError(`unexpected marker ${(bitsData << 8 | nextByte).toString(16)}`);
                        }
                      }
                      bitsCount = 7;
                      return bitsData >>> 7;
                    }
                    function decodeHuffman(tree) {
                      var node = tree;
                      while (true) {
                        node = node[readBit()];
                        switch (typeof node) {
                          case "number":
                            return node;
                          case "object":
                            continue;
                        }
                        throw new JpegError("invalid huffman sequence");
                      }
                    }
                    function receive(length) {
                      var n2 = 0;
                      while (length > 0) {
                        n2 = n2 << 1 | readBit();
                        length--;
                      }
                      return n2;
                    }
                    function receiveAndExtend(length) {
                      if (length === 1) {
                        return readBit() === 1 ? 1 : -1;
                      }
                      var n2 = receive(length);
                      if (n2 >= 1 << length - 1) {
                        return n2;
                      }
                      return n2 + (-1 << length) + 1;
                    }
                    function decodeBaseline(component2, offset2) {
                      var t = decodeHuffman(component2.huffmanTableDC);
                      var diff = t === 0 ? 0 : receiveAndExtend(t);
                      component2.blockData[offset2] = component2.pred += diff;
                      var k2 = 1;
                      while (k2 < 64) {
                        var rs = decodeHuffman(component2.huffmanTableAC);
                        var s = rs & 15, r = rs >> 4;
                        if (s === 0) {
                          if (r < 15) {
                            break;
                          }
                          k2 += 16;
                          continue;
                        }
                        k2 += r;
                        var z = dctZigZag[k2];
                        component2.blockData[offset2 + z] = receiveAndExtend(s);
                        k2++;
                      }
                    }
                    function decodeDCFirst(component2, offset2) {
                      var t = decodeHuffman(component2.huffmanTableDC);
                      var diff = t === 0 ? 0 : receiveAndExtend(t) << successive;
                      component2.blockData[offset2] = component2.pred += diff;
                    }
                    function decodeDCSuccessive(component2, offset2) {
                      component2.blockData[offset2] |= readBit() << successive;
                    }
                    var eobrun = 0;
                    function decodeACFirst(component2, offset2) {
                      if (eobrun > 0) {
                        eobrun--;
                        return;
                      }
                      var k2 = spectralStart, e = spectralEnd;
                      while (k2 <= e) {
                        var rs = decodeHuffman(component2.huffmanTableAC);
                        var s = rs & 15, r = rs >> 4;
                        if (s === 0) {
                          if (r < 15) {
                            eobrun = receive(r) + (1 << r) - 1;
                            break;
                          }
                          k2 += 16;
                          continue;
                        }
                        k2 += r;
                        var z = dctZigZag[k2];
                        component2.blockData[offset2 + z] = receiveAndExtend(s) * (1 << successive);
                        k2++;
                      }
                    }
                    var successiveACState = 0, successiveACNextValue;
                    function decodeACSuccessive(component2, offset2) {
                      var k2 = spectralStart;
                      var e = spectralEnd;
                      var r = 0;
                      var s;
                      var rs;
                      while (k2 <= e) {
                        const offsetZ = offset2 + dctZigZag[k2];
                        const sign = component2.blockData[offsetZ] < 0 ? -1 : 1;
                        switch (successiveACState) {
                          case 0:
                            rs = decodeHuffman(component2.huffmanTableAC);
                            s = rs & 15;
                            r = rs >> 4;
                            if (s === 0) {
                              if (r < 15) {
                                eobrun = receive(r) + (1 << r);
                                successiveACState = 4;
                              } else {
                                r = 16;
                                successiveACState = 1;
                              }
                            } else {
                              if (s !== 1) {
                                throw new JpegError("invalid ACn encoding");
                              }
                              successiveACNextValue = receiveAndExtend(s);
                              successiveACState = r ? 2 : 3;
                            }
                            continue;
                          case 1:
                          case 2:
                            if (component2.blockData[offsetZ]) {
                              component2.blockData[offsetZ] += sign * (readBit() << successive);
                            } else {
                              r--;
                              if (r === 0) {
                                successiveACState = successiveACState === 2 ? 3 : 0;
                              }
                            }
                            break;
                          case 3:
                            if (component2.blockData[offsetZ]) {
                              component2.blockData[offsetZ] += sign * (readBit() << successive);
                            } else {
                              component2.blockData[offsetZ] = successiveACNextValue << successive;
                              successiveACState = 0;
                            }
                            break;
                          case 4:
                            if (component2.blockData[offsetZ]) {
                              component2.blockData[offsetZ] += sign * (readBit() << successive);
                            }
                            break;
                        }
                        k2++;
                      }
                      if (successiveACState === 4) {
                        eobrun--;
                        if (eobrun === 0) {
                          successiveACState = 0;
                        }
                      }
                    }
                    let blockRow = 0;
                    function decodeMcu(component2, decode, mcu2, row, col) {
                      var mcuRow = mcu2 / mcusPerLine | 0;
                      var mcuCol = mcu2 % mcusPerLine;
                      blockRow = mcuRow * component2.v + row;
                      var blockCol = mcuCol * component2.h + col;
                      var offset2 = getBlockBufferOffset(component2, blockRow, blockCol);
                      decode(component2, offset2);
                    }
                    function decodeBlock(component2, decode, mcu2) {
                      blockRow = mcu2 / component2.blocksPerLine | 0;
                      var blockCol = mcu2 % component2.blocksPerLine;
                      var offset2 = getBlockBufferOffset(component2, blockRow, blockCol);
                      decode(component2, offset2);
                    }
                    var componentsLength = components.length;
                    var component, i, j, k, n;
                    var decodeFn;
                    if (progressive) {
                      if (spectralStart === 0) {
                        decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
                      } else {
                        decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
                      }
                    } else {
                      decodeFn = decodeBaseline;
                    }
                    var mcu = 0, fileMarker;
                    var mcuExpected;
                    if (componentsLength === 1) {
                      mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;
                    } else {
                      mcuExpected = mcusPerLine * frame.mcusPerColumn;
                    }
                    var h, v;
                    while (mcu < mcuExpected) {
                      var mcuToRead = resetInterval ? Math.min(mcuExpected - mcu, resetInterval) : mcuExpected;
                      for (i = 0; i < componentsLength; i++) {
                        components[i].pred = 0;
                      }
                      eobrun = 0;
                      if (componentsLength === 1) {
                        component = components[0];
                        for (n = 0; n < mcuToRead; n++) {
                          decodeBlock(component, decodeFn, mcu);
                          mcu++;
                        }
                      } else {
                        for (n = 0; n < mcuToRead; n++) {
                          for (i = 0; i < componentsLength; i++) {
                            component = components[i];
                            h = component.h;
                            v = component.v;
                            for (j = 0; j < v; j++) {
                              for (k = 0; k < h; k++) {
                                decodeMcu(component, decodeFn, mcu, j, k);
                              }
                            }
                          }
                          mcu++;
                        }
                      }
                      bitsCount = 0;
                      fileMarker = findNextFileMarker(data, offset);
                      if (!fileMarker) {
                        break;
                      } else if (fileMarker.invalid) {
                        (0, _util2.warn)("decodeScan - unexpected MCU data, current marker is: " + fileMarker.invalid);
                        offset = fileMarker.offset;
                      }
                      var marker = fileMarker && fileMarker.marker;
                      if (!marker || marker <= 65280) {
                        throw new JpegError("decodeScan - a valid marker was not found.");
                      }
                      if (marker >= 65488 && marker <= 65495) {
                        offset += 2;
                      } else {
                        break;
                      }
                    }
                    fileMarker = findNextFileMarker(data, offset);
                    if (fileMarker && fileMarker.invalid) {
                      (0, _util2.warn)("decodeScan - unexpected Scan data, current marker is: " + fileMarker.invalid);
                      offset = fileMarker.offset;
                    }
                    return offset - startOffset;
                  }
                  function quantizeAndInverse(component, blockBufferOffset, p) {
                    var qt = component.quantizationTable, blockData = component.blockData;
                    var v0, v1, v2, v3, v4, v5, v6, v7;
                    var p0, p1, p2, p3, p4, p5, p6, p7;
                    var t;
                    if (!qt) {
                      throw new JpegError("missing required Quantization Table.");
                    }
                    for (var row = 0; row < 64; row += 8) {
                      p0 = blockData[blockBufferOffset + row];
                      p1 = blockData[blockBufferOffset + row + 1];
                      p2 = blockData[blockBufferOffset + row + 2];
                      p3 = blockData[blockBufferOffset + row + 3];
                      p4 = blockData[blockBufferOffset + row + 4];
                      p5 = blockData[blockBufferOffset + row + 5];
                      p6 = blockData[blockBufferOffset + row + 6];
                      p7 = blockData[blockBufferOffset + row + 7];
                      p0 *= qt[row];
                      if ((p1 | p2 | p3 | p4 | p5 | p6 | p7) === 0) {
                        t = dctSqrt2 * p0 + 512 >> 10;
                        p[row] = t;
                        p[row + 1] = t;
                        p[row + 2] = t;
                        p[row + 3] = t;
                        p[row + 4] = t;
                        p[row + 5] = t;
                        p[row + 6] = t;
                        p[row + 7] = t;
                        continue;
                      }
                      p1 *= qt[row + 1];
                      p2 *= qt[row + 2];
                      p3 *= qt[row + 3];
                      p4 *= qt[row + 4];
                      p5 *= qt[row + 5];
                      p6 *= qt[row + 6];
                      p7 *= qt[row + 7];
                      v0 = dctSqrt2 * p0 + 128 >> 8;
                      v1 = dctSqrt2 * p4 + 128 >> 8;
                      v2 = p2;
                      v3 = p6;
                      v4 = dctSqrt1d2 * (p1 - p7) + 128 >> 8;
                      v7 = dctSqrt1d2 * (p1 + p7) + 128 >> 8;
                      v5 = p3 << 4;
                      v6 = p5 << 4;
                      v0 = v0 + v1 + 1 >> 1;
                      v1 = v0 - v1;
                      t = v2 * dctSin6 + v3 * dctCos6 + 128 >> 8;
                      v2 = v2 * dctCos6 - v3 * dctSin6 + 128 >> 8;
                      v3 = t;
                      v4 = v4 + v6 + 1 >> 1;
                      v6 = v4 - v6;
                      v7 = v7 + v5 + 1 >> 1;
                      v5 = v7 - v5;
                      v0 = v0 + v3 + 1 >> 1;
                      v3 = v0 - v3;
                      v1 = v1 + v2 + 1 >> 1;
                      v2 = v1 - v2;
                      t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
                      v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
                      v7 = t;
                      t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
                      v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
                      v6 = t;
                      p[row] = v0 + v7;
                      p[row + 7] = v0 - v7;
                      p[row + 1] = v1 + v6;
                      p[row + 6] = v1 - v6;
                      p[row + 2] = v2 + v5;
                      p[row + 5] = v2 - v5;
                      p[row + 3] = v3 + v4;
                      p[row + 4] = v3 - v4;
                    }
                    for (var col = 0; col < 8; ++col) {
                      p0 = p[col];
                      p1 = p[col + 8];
                      p2 = p[col + 16];
                      p3 = p[col + 24];
                      p4 = p[col + 32];
                      p5 = p[col + 40];
                      p6 = p[col + 48];
                      p7 = p[col + 56];
                      if ((p1 | p2 | p3 | p4 | p5 | p6 | p7) === 0) {
                        t = dctSqrt2 * p0 + 8192 >> 14;
                        if (t < -2040) {
                          t = 0;
                        } else if (t >= 2024) {
                          t = 255;
                        } else {
                          t = t + 2056 >> 4;
                        }
                        blockData[blockBufferOffset + col] = t;
                        blockData[blockBufferOffset + col + 8] = t;
                        blockData[blockBufferOffset + col + 16] = t;
                        blockData[blockBufferOffset + col + 24] = t;
                        blockData[blockBufferOffset + col + 32] = t;
                        blockData[blockBufferOffset + col + 40] = t;
                        blockData[blockBufferOffset + col + 48] = t;
                        blockData[blockBufferOffset + col + 56] = t;
                        continue;
                      }
                      v0 = dctSqrt2 * p0 + 2048 >> 12;
                      v1 = dctSqrt2 * p4 + 2048 >> 12;
                      v2 = p2;
                      v3 = p6;
                      v4 = dctSqrt1d2 * (p1 - p7) + 2048 >> 12;
                      v7 = dctSqrt1d2 * (p1 + p7) + 2048 >> 12;
                      v5 = p3;
                      v6 = p5;
                      v0 = (v0 + v1 + 1 >> 1) + 4112;
                      v1 = v0 - v1;
                      t = v2 * dctSin6 + v3 * dctCos6 + 2048 >> 12;
                      v2 = v2 * dctCos6 - v3 * dctSin6 + 2048 >> 12;
                      v3 = t;
                      v4 = v4 + v6 + 1 >> 1;
                      v6 = v4 - v6;
                      v7 = v7 + v5 + 1 >> 1;
                      v5 = v7 - v5;
                      v0 = v0 + v3 + 1 >> 1;
                      v3 = v0 - v3;
                      v1 = v1 + v2 + 1 >> 1;
                      v2 = v1 - v2;
                      t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
                      v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
                      v7 = t;
                      t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
                      v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
                      v6 = t;
                      p0 = v0 + v7;
                      p7 = v0 - v7;
                      p1 = v1 + v6;
                      p6 = v1 - v6;
                      p2 = v2 + v5;
                      p5 = v2 - v5;
                      p3 = v3 + v4;
                      p4 = v3 - v4;
                      if (p0 < 16) {
                        p0 = 0;
                      } else if (p0 >= 4080) {
                        p0 = 255;
                      } else {
                        p0 >>= 4;
                      }
                      if (p1 < 16) {
                        p1 = 0;
                      } else if (p1 >= 4080) {
                        p1 = 255;
                      } else {
                        p1 >>= 4;
                      }
                      if (p2 < 16) {
                        p2 = 0;
                      } else if (p2 >= 4080) {
                        p2 = 255;
                      } else {
                        p2 >>= 4;
                      }
                      if (p3 < 16) {
                        p3 = 0;
                      } else if (p3 >= 4080) {
                        p3 = 255;
                      } else {
                        p3 >>= 4;
                      }
                      if (p4 < 16) {
                        p4 = 0;
                      } else if (p4 >= 4080) {
                        p4 = 255;
                      } else {
                        p4 >>= 4;
                      }
                      if (p5 < 16) {
                        p5 = 0;
                      } else if (p5 >= 4080) {
                        p5 = 255;
                      } else {
                        p5 >>= 4;
                      }
                      if (p6 < 16) {
                        p6 = 0;
                      } else if (p6 >= 4080) {
                        p6 = 255;
                      } else {
                        p6 >>= 4;
                      }
                      if (p7 < 16) {
                        p7 = 0;
                      } else if (p7 >= 4080) {
                        p7 = 255;
                      } else {
                        p7 >>= 4;
                      }
                      blockData[blockBufferOffset + col] = p0;
                      blockData[blockBufferOffset + col + 8] = p1;
                      blockData[blockBufferOffset + col + 16] = p2;
                      blockData[blockBufferOffset + col + 24] = p3;
                      blockData[blockBufferOffset + col + 32] = p4;
                      blockData[blockBufferOffset + col + 40] = p5;
                      blockData[blockBufferOffset + col + 48] = p6;
                      blockData[blockBufferOffset + col + 56] = p7;
                    }
                  }
                  function buildComponentData(frame, component) {
                    var blocksPerLine = component.blocksPerLine;
                    var blocksPerColumn = component.blocksPerColumn;
                    var computationBuffer = new Int16Array(64);
                    for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
                      for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
                        var offset = getBlockBufferOffset(component, blockRow, blockCol);
                        quantizeAndInverse(component, offset, computationBuffer);
                      }
                    }
                    return component.blockData;
                  }
                  function findNextFileMarker(data, currentPos, startPos = currentPos) {
                    const maxPos = data.length - 1;
                    var newPos = startPos < currentPos ? startPos : currentPos;
                    if (currentPos >= maxPos) {
                      return null;
                    }
                    var currentMarker = (0, _core_utils.readUint16)(data, currentPos);
                    if (currentMarker >= 65472 && currentMarker <= 65534) {
                      return { invalid: null, marker: currentMarker, offset: currentPos };
                    }
                    var newMarker = (0, _core_utils.readUint16)(data, newPos);
                    while (!(newMarker >= 65472 && newMarker <= 65534)) {
                      if (++newPos >= maxPos) {
                        return null;
                      }
                      newMarker = (0, _core_utils.readUint16)(data, newPos);
                    }
                    return { invalid: currentMarker.toString(16), marker: newMarker, offset: newPos };
                  }
                  JpegImage2.prototype = { parse(data, { dnlScanLines = null } = {}) {
                    function readDataBlock() {
                      const length = (0, _core_utils.readUint16)(data, offset);
                      offset += 2;
                      let endOffset = offset + length - 2;
                      var fileMarker2 = findNextFileMarker(data, endOffset, offset);
                      if (fileMarker2 && fileMarker2.invalid) {
                        (0, _util2.warn)("readDataBlock - incorrect length, current marker is: " + fileMarker2.invalid);
                        endOffset = fileMarker2.offset;
                      }
                      var array = data.subarray(offset, endOffset);
                      offset += array.length;
                      return array;
                    }
                    function prepareComponents(frame2) {
                      var mcusPerLine = Math.ceil(frame2.samplesPerLine / 8 / frame2.maxH);
                      var mcusPerColumn = Math.ceil(frame2.scanLines / 8 / frame2.maxV);
                      for (var i2 = 0; i2 < frame2.components.length; i2++) {
                        component = frame2.components[i2];
                        var blocksPerLine = Math.ceil(Math.ceil(frame2.samplesPerLine / 8) * component.h / frame2.maxH);
                        var blocksPerColumn = Math.ceil(Math.ceil(frame2.scanLines / 8) * component.v / frame2.maxV);
                        var blocksPerLineForMcu = mcusPerLine * component.h;
                        var blocksPerColumnForMcu = mcusPerColumn * component.v;
                        var blocksBufferSize = 64 * blocksPerColumnForMcu * (blocksPerLineForMcu + 1);
                        component.blockData = new Int16Array(blocksBufferSize);
                        component.blocksPerLine = blocksPerLine;
                        component.blocksPerColumn = blocksPerColumn;
                      }
                      frame2.mcusPerLine = mcusPerLine;
                      frame2.mcusPerColumn = mcusPerColumn;
                    }
                    var offset = 0;
                    var jfif = null;
                    var adobe = null;
                    var frame, resetInterval;
                    let numSOSMarkers = 0;
                    var quantizationTables = [];
                    var huffmanTablesAC = [], huffmanTablesDC = [];
                    let fileMarker = (0, _core_utils.readUint16)(data, offset);
                    offset += 2;
                    if (fileMarker !== 65496) {
                      throw new JpegError("SOI not found");
                    }
                    fileMarker = (0, _core_utils.readUint16)(data, offset);
                    offset += 2;
                    markerLoop:
                      while (fileMarker !== 65497) {
                        var i, j, l;
                        switch (fileMarker) {
                          case 65504:
                          case 65505:
                          case 65506:
                          case 65507:
                          case 65508:
                          case 65509:
                          case 65510:
                          case 65511:
                          case 65512:
                          case 65513:
                          case 65514:
                          case 65515:
                          case 65516:
                          case 65517:
                          case 65518:
                          case 65519:
                          case 65534:
                            var appData = readDataBlock();
                            if (fileMarker === 65504) {
                              if (appData[0] === 74 && appData[1] === 70 && appData[2] === 73 && appData[3] === 70 && appData[4] === 0) {
                                jfif = { version: { major: appData[5], minor: appData[6] }, densityUnits: appData[7], xDensity: appData[8] << 8 | appData[9], yDensity: appData[10] << 8 | appData[11], thumbWidth: appData[12], thumbHeight: appData[13], thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13]) };
                              }
                            }
                            if (fileMarker === 65518) {
                              if (appData[0] === 65 && appData[1] === 100 && appData[2] === 111 && appData[3] === 98 && appData[4] === 101) {
                                adobe = { version: appData[5] << 8 | appData[6], flags0: appData[7] << 8 | appData[8], flags1: appData[9] << 8 | appData[10], transformCode: appData[11] };
                              }
                            }
                            break;
                          case 65499:
                            const quantizationTablesLength = (0, _core_utils.readUint16)(data, offset);
                            offset += 2;
                            var quantizationTablesEnd = quantizationTablesLength + offset - 2;
                            var z;
                            while (offset < quantizationTablesEnd) {
                              var quantizationTableSpec = data[offset++];
                              var tableData = new Uint16Array(64);
                              if (quantizationTableSpec >> 4 === 0) {
                                for (j = 0; j < 64; j++) {
                                  z = dctZigZag[j];
                                  tableData[z] = data[offset++];
                                }
                              } else if (quantizationTableSpec >> 4 === 1) {
                                for (j = 0; j < 64; j++) {
                                  z = dctZigZag[j];
                                  tableData[z] = (0, _core_utils.readUint16)(data, offset);
                                  offset += 2;
                                }
                              } else {
                                throw new JpegError("DQT - invalid table spec");
                              }
                              quantizationTables[quantizationTableSpec & 15] = tableData;
                            }
                            break;
                          case 65472:
                          case 65473:
                          case 65474:
                            if (frame) {
                              throw new JpegError("Only single frame JPEGs supported");
                            }
                            offset += 2;
                            frame = {};
                            frame.extended = fileMarker === 65473;
                            frame.progressive = fileMarker === 65474;
                            frame.precision = data[offset++];
                            const sofScanLines = (0, _core_utils.readUint16)(data, offset);
                            offset += 2;
                            frame.scanLines = dnlScanLines || sofScanLines;
                            frame.samplesPerLine = (0, _core_utils.readUint16)(data, offset);
                            offset += 2;
                            frame.components = [];
                            frame.componentIds = {};
                            var componentsCount = data[offset++], componentId;
                            var maxH = 0, maxV = 0;
                            for (i = 0; i < componentsCount; i++) {
                              componentId = data[offset];
                              var h = data[offset + 1] >> 4;
                              var v = data[offset + 1] & 15;
                              if (maxH < h) {
                                maxH = h;
                              }
                              if (maxV < v) {
                                maxV = v;
                              }
                              var qId = data[offset + 2];
                              l = frame.components.push({ h, v, quantizationId: qId, quantizationTable: null });
                              frame.componentIds[componentId] = l - 1;
                              offset += 3;
                            }
                            frame.maxH = maxH;
                            frame.maxV = maxV;
                            prepareComponents(frame);
                            break;
                          case 65476:
                            const huffmanLength = (0, _core_utils.readUint16)(data, offset);
                            offset += 2;
                            for (i = 2; i < huffmanLength; ) {
                              var huffmanTableSpec = data[offset++];
                              var codeLengths = new Uint8Array(16);
                              var codeLengthSum = 0;
                              for (j = 0; j < 16; j++, offset++) {
                                codeLengthSum += codeLengths[j] = data[offset];
                              }
                              var huffmanValues = new Uint8Array(codeLengthSum);
                              for (j = 0; j < codeLengthSum; j++, offset++) {
                                huffmanValues[j] = data[offset];
                              }
                              i += 17 + codeLengthSum;
                              (huffmanTableSpec >> 4 === 0 ? huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] = buildHuffmanTable(codeLengths, huffmanValues);
                            }
                            break;
                          case 65501:
                            offset += 2;
                            resetInterval = (0, _core_utils.readUint16)(data, offset);
                            offset += 2;
                            break;
                          case 65498:
                            const parseDNLMarker = ++numSOSMarkers === 1 && !dnlScanLines;
                            offset += 2;
                            var selectorsCount = data[offset++];
                            var components = [], component;
                            for (i = 0; i < selectorsCount; i++) {
                              var componentIndex = frame.componentIds[data[offset++]];
                              component = frame.components[componentIndex];
                              var tableSpec = data[offset++];
                              component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
                              component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
                              components.push(component);
                            }
                            var spectralStart = data[offset++];
                            var spectralEnd = data[offset++];
                            var successiveApproximation = data[offset++];
                            try {
                              var processed = decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successiveApproximation >> 4, successiveApproximation & 15, parseDNLMarker);
                              offset += processed;
                            } catch (ex) {
                              if (ex instanceof DNLMarkerError) {
                                (0, _util2.warn)(`${ex.message} -- attempting to re-parse the JPEG image.`);
                                return this.parse(data, { dnlScanLines: ex.scanLines });
                              } else if (ex instanceof EOIMarkerError) {
                                (0, _util2.warn)(`${ex.message} -- ignoring the rest of the image data.`);
                                break markerLoop;
                              }
                              throw ex;
                            }
                            break;
                          case 65500:
                            offset += 4;
                            break;
                          case 65535:
                            if (data[offset] !== 255) {
                              offset--;
                            }
                            break;
                          default:
                            const nextFileMarker = findNextFileMarker(data, offset - 2, offset - 3);
                            if (nextFileMarker && nextFileMarker.invalid) {
                              (0, _util2.warn)("JpegImage.parse - unexpected data, current marker is: " + nextFileMarker.invalid);
                              offset = nextFileMarker.offset;
                              break;
                            }
                            if (offset >= data.length - 1) {
                              (0, _util2.warn)("JpegImage.parse - reached the end of the image data without finding an EOI marker (0xFFD9).");
                              break markerLoop;
                            }
                            throw new JpegError("JpegImage.parse - unknown marker: " + fileMarker.toString(16));
                        }
                        fileMarker = (0, _core_utils.readUint16)(data, offset);
                        offset += 2;
                      }
                    this.width = frame.samplesPerLine;
                    this.height = frame.scanLines;
                    this.jfif = jfif;
                    this.adobe = adobe;
                    this.components = [];
                    for (i = 0; i < frame.components.length; i++) {
                      component = frame.components[i];
                      var quantizationTable = quantizationTables[component.quantizationId];
                      if (quantizationTable) {
                        component.quantizationTable = quantizationTable;
                      }
                      this.components.push({ output: buildComponentData(frame, component), scaleX: component.h / frame.maxH, scaleY: component.v / frame.maxV, blocksPerLine: component.blocksPerLine, blocksPerColumn: component.blocksPerColumn });
                    }
                    this.numComponents = this.components.length;
                    return void 0;
                  }, _getLinearizedBlockData(width, height, isSourcePDF = false) {
                    var scaleX = this.width / width, scaleY = this.height / height;
                    var component, componentScaleX, componentScaleY, blocksPerScanline;
                    var x, y, i, j, k;
                    var index;
                    var offset = 0;
                    var output;
                    var numComponents = this.components.length;
                    var dataLength = width * height * numComponents;
                    var data = new Uint8ClampedArray(dataLength);
                    var xScaleBlockOffset = new Uint32Array(width);
                    var mask3LSB = 4294967288;
                    let lastComponentScaleX;
                    for (i = 0; i < numComponents; i++) {
                      component = this.components[i];
                      componentScaleX = component.scaleX * scaleX;
                      componentScaleY = component.scaleY * scaleY;
                      offset = i;
                      output = component.output;
                      blocksPerScanline = component.blocksPerLine + 1 << 3;
                      if (componentScaleX !== lastComponentScaleX) {
                        for (x = 0; x < width; x++) {
                          j = 0 | x * componentScaleX;
                          xScaleBlockOffset[x] = (j & mask3LSB) << 3 | j & 7;
                        }
                        lastComponentScaleX = componentScaleX;
                      }
                      for (y = 0; y < height; y++) {
                        j = 0 | y * componentScaleY;
                        index = blocksPerScanline * (j & mask3LSB) | (j & 7) << 3;
                        for (x = 0; x < width; x++) {
                          data[offset] = output[index + xScaleBlockOffset[x]];
                          offset += numComponents;
                        }
                      }
                    }
                    let transform = this._decodeTransform;
                    if (!isSourcePDF && numComponents === 4 && !transform) {
                      transform = new Int32Array([-256, 255, -256, 255, -256, 255, -256, 255]);
                    }
                    if (transform) {
                      for (i = 0; i < dataLength; ) {
                        for (j = 0, k = 0; j < numComponents; j++, i++, k += 2) {
                          data[i] = (data[i] * transform[k] >> 8) + transform[k + 1];
                        }
                      }
                    }
                    return data;
                  }, get _isColorConversionNeeded() {
                    if (this.adobe) {
                      return !!this.adobe.transformCode;
                    }
                    if (this.numComponents === 3) {
                      if (this._colorTransform === 0) {
                        return false;
                      }
                      return true;
                    }
                    if (this._colorTransform === 1) {
                      return true;
                    }
                    return false;
                  }, _convertYccToRgb: function convertYccToRgb(data) {
                    var Y, Cb, Cr;
                    for (var i = 0, length = data.length; i < length; i += 3) {
                      Y = data[i];
                      Cb = data[i + 1];
                      Cr = data[i + 2];
                      data[i] = Y - 179.456 + 1.402 * Cr;
                      data[i + 1] = Y + 135.459 - 0.344 * Cb - 0.714 * Cr;
                      data[i + 2] = Y - 226.816 + 1.772 * Cb;
                    }
                    return data;
                  }, _convertYcckToRgb: function convertYcckToRgb(data) {
                    var Y, Cb, Cr, k;
                    var offset = 0;
                    for (var i = 0, length = data.length; i < length; i += 4) {
                      Y = data[i];
                      Cb = data[i + 1];
                      Cr = data[i + 2];
                      k = data[i + 3];
                      data[offset++] = -122.67195406894 + Cb * (-660635669420364e-19 * Cb + 437130475926232e-18 * Cr - 54080610064599e-18 * Y + 48449797120281e-17 * k - 0.154362151871126) + Cr * (-957964378445773e-18 * Cr + 817076911346625e-18 * Y - 0.00477271405408747 * k + 1.53380253221734) + Y * (961250184130688e-18 * Y - 0.00266257332283933 * k + 0.48357088451265) + k * (-336197177618394e-18 * k + 0.484791561490776);
                      data[offset++] = 107.268039397724 + Cb * (219927104525741e-19 * Cb - 640992018297945e-18 * Cr + 659397001245577e-18 * Y + 426105652938837e-18 * k - 0.176491792462875) + Cr * (-778269941513683e-18 * Cr + 0.00130872261408275 * Y + 770482631801132e-18 * k - 0.151051492775562) + Y * (0.00126935368114843 * Y - 0.00265090189010898 * k + 0.25802910206845) + k * (-318913117588328e-18 * k - 0.213742400323665);
                      data[offset++] = -20.810012546947 + Cb * (-570115196973677e-18 * Cb - 263409051004589e-19 * Cr + 0.0020741088115012 * Y - 0.00288260236853442 * k + 0.814272968359295) + Cr * (-153496057440975e-19 * Cr - 132689043961446e-18 * Y + 560833691242812e-18 * k - 0.195152027534049) + Y * (0.00174418132927582 * Y - 0.00255243321439347 * k + 0.116935020465145) + k * (-343531996510555e-18 * k + 0.24165260232407);
                    }
                    return data.subarray(0, offset);
                  }, _convertYcckToCmyk: function convertYcckToCmyk(data) {
                    var Y, Cb, Cr;
                    for (var i = 0, length = data.length; i < length; i += 4) {
                      Y = data[i];
                      Cb = data[i + 1];
                      Cr = data[i + 2];
                      data[i] = 434.456 - Y - 1.402 * Cr;
                      data[i + 1] = 119.541 - Y + 0.344 * Cb + 0.714 * Cr;
                      data[i + 2] = 481.816 - Y - 1.772 * Cb;
                    }
                    return data;
                  }, _convertCmykToRgb: function convertCmykToRgb(data) {
                    var c, m, y, k;
                    var offset = 0;
                    for (var i = 0, length = data.length; i < length; i += 4) {
                      c = data[i];
                      m = data[i + 1];
                      y = data[i + 2];
                      k = data[i + 3];
                      data[offset++] = 255 + c * (-6747147073602441e-20 * c + 8379262121013727e-19 * m + 2894718188643294e-19 * y + 0.003264231057537806 * k - 1.1185611867203937) + m * (26374107616089405e-21 * m - 8626949158638572e-20 * y - 2748769067499491e-19 * k - 0.02155688794978967) + y * (-3878099212869363e-20 * y - 3267808279485286e-19 * k + 0.0686742238595345) - k * (3361971776183937e-19 * k + 0.7430659151342254);
                      data[offset++] = 255 + c * (13596372813588848e-20 * c + 924537132573585e-18 * m + 10567359618683593e-20 * y + 4791864687436512e-19 * k - 0.3109689587515875) + m * (-23545346108370344e-20 * m + 2702845253534714e-19 * y + 0.0020200308977307156 * k - 0.7488052167015494) + y * (6834815998235662e-20 * y + 15168452363460973e-20 * k - 0.09751927774728933) - k * (3189131175883281e-19 * k + 0.7364883807733168);
                      data[offset++] = 255 + c * (13598650411385307e-21 * c + 12423956175490851e-20 * m + 4751985097583589e-19 * y - 36729317476630422e-22 * k - 0.05562186980264034) + m * (16141380598724676e-20 * m + 9692239130725186e-19 * y + 7782692450036253e-19 * k - 0.44015232367526463) + y * (5068882914068769e-22 * y + 0.0017778369011375071 * k - 0.7591454649749609) - k * (3435319965105553e-19 * k + 0.7063770186160144);
                    }
                    return data.subarray(0, offset);
                  }, getData({ width, height, forceRGB = false, isSourcePDF = false }) {
                    if (this.numComponents > 4) {
                      throw new JpegError("Unsupported color mode");
                    }
                    var data = this._getLinearizedBlockData(width, height, isSourcePDF);
                    if (this.numComponents === 1 && forceRGB) {
                      var dataLength = data.length;
                      var rgbData = new Uint8ClampedArray(dataLength * 3);
                      var offset = 0;
                      for (var i = 0; i < dataLength; i++) {
                        var grayColor = data[i];
                        rgbData[offset++] = grayColor;
                        rgbData[offset++] = grayColor;
                        rgbData[offset++] = grayColor;
                      }
                      return rgbData;
                    } else if (this.numComponents === 3 && this._isColorConversionNeeded) {
                      return this._convertYccToRgb(data);
                    } else if (this.numComponents === 4) {
                      if (this._isColorConversionNeeded) {
                        if (forceRGB) {
                          return this._convertYcckToRgb(data);
                        }
                        return this._convertYcckToCmyk(data);
                      } else if (forceRGB) {
                        return this._convertCmykToRgb(data);
                      }
                    }
                    return data;
                  } };
                  return JpegImage2;
                }();
                exports2.JpegImage = JpegImage;
              }, function(module3, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.JpxStream = void 0;
                var _stream = __w_pdfjs_require__2(11);
                var _jpx = __w_pdfjs_require__2(20);
                var _util2 = __w_pdfjs_require__2(2);
                const JpxStream = function JpxStreamClosure() {
                  function JpxStream2(stream, maybeLength, dict, params) {
                    this.stream = stream;
                    this.maybeLength = maybeLength;
                    this.dict = dict;
                    this.params = params;
                    _stream.DecodeStream.call(this, maybeLength);
                  }
                  JpxStream2.prototype = Object.create(_stream.DecodeStream.prototype);
                  Object.defineProperty(JpxStream2.prototype, "bytes", { get: function JpxStream_bytes() {
                    return (0, _util2.shadow)(this, "bytes", this.stream.getBytes(this.maybeLength));
                  }, configurable: true });
                  JpxStream2.prototype.ensureBuffer = function(requested) {
                  };
                  JpxStream2.prototype.readBlock = function() {
                    if (this.eof) {
                      return;
                    }
                    const jpxImage = new _jpx.JpxImage();
                    jpxImage.parse(this.bytes);
                    const width = jpxImage.width;
                    const height = jpxImage.height;
                    const componentsCount = jpxImage.componentsCount;
                    const tileCount = jpxImage.tiles.length;
                    if (tileCount === 1) {
                      this.buffer = jpxImage.tiles[0].items;
                    } else {
                      const data = new Uint8ClampedArray(width * height * componentsCount);
                      for (let k = 0; k < tileCount; k++) {
                        const tileComponents = jpxImage.tiles[k];
                        const tileWidth = tileComponents.width;
                        const tileHeight = tileComponents.height;
                        const tileLeft = tileComponents.left;
                        const tileTop = tileComponents.top;
                        const src = tileComponents.items;
                        let srcPosition = 0;
                        let dataPosition = (width * tileTop + tileLeft) * componentsCount;
                        const imgRowSize = width * componentsCount;
                        const tileRowSize = tileWidth * componentsCount;
                        for (let j = 0; j < tileHeight; j++) {
                          const rowBytes = src.subarray(srcPosition, srcPosition + tileRowSize);
                          data.set(rowBytes, dataPosition);
                          srcPosition += tileRowSize;
                          dataPosition += imgRowSize;
                        }
                      }
                      this.buffer = data;
                    }
                    this.bufferLength = this.buffer.length;
                    this.eof = true;
                  };
                  return JpxStream2;
                }();
                exports2.JpxStream = JpxStream;
              }, function(module3, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.JpxImage = void 0;
                var _util2 = __w_pdfjs_require__2(2);
                var _core_utils = __w_pdfjs_require__2(7);
                var _arithmetic_decoder = __w_pdfjs_require__2(16);
                class JpxError extends _util2.BaseException {
                  constructor(msg) {
                    super(`JPX error: ${msg}`);
                  }
                }
                var JpxImage = function JpxImageClosure() {
                  var SubbandsGainLog2 = { LL: 0, LH: 1, HL: 1, HH: 2 };
                  function JpxImage2() {
                    this.failOnCorruptedImage = false;
                  }
                  JpxImage2.prototype = { parse: function JpxImage_parse(data) {
                    var head = (0, _core_utils.readUint16)(data, 0);
                    if (head === 65359) {
                      this.parseCodestream(data, 0, data.length);
                      return;
                    }
                    var position = 0, length = data.length;
                    while (position < length) {
                      var headerSize = 8;
                      var lbox = (0, _core_utils.readUint32)(data, position);
                      var tbox = (0, _core_utils.readUint32)(data, position + 4);
                      position += headerSize;
                      if (lbox === 1) {
                        lbox = (0, _core_utils.readUint32)(data, position) * 4294967296 + (0, _core_utils.readUint32)(data, position + 4);
                        position += 8;
                        headerSize += 8;
                      }
                      if (lbox === 0) {
                        lbox = length - position + headerSize;
                      }
                      if (lbox < headerSize) {
                        throw new JpxError("Invalid box field size");
                      }
                      var dataLength = lbox - headerSize;
                      var jumpDataLength = true;
                      switch (tbox) {
                        case 1785737832:
                          jumpDataLength = false;
                          break;
                        case 1668246642:
                          var method = data[position];
                          if (method === 1) {
                            var colorspace = (0, _core_utils.readUint32)(data, position + 3);
                            switch (colorspace) {
                              case 16:
                              case 17:
                              case 18:
                                break;
                              default:
                                (0, _util2.warn)("Unknown colorspace " + colorspace);
                                break;
                            }
                          } else if (method === 2) {
                            (0, _util2.info)("ICC profile not supported");
                          }
                          break;
                        case 1785737827:
                          this.parseCodestream(data, position, position + dataLength);
                          break;
                        case 1783636e3:
                          if ((0, _core_utils.readUint32)(data, position) !== 218793738) {
                            (0, _util2.warn)("Invalid JP2 signature");
                          }
                          break;
                        case 1783634458:
                        case 1718909296:
                        case 1920099697:
                        case 1919251232:
                        case 1768449138:
                          break;
                        default:
                          var headerType = String.fromCharCode(tbox >> 24 & 255, tbox >> 16 & 255, tbox >> 8 & 255, tbox & 255);
                          (0, _util2.warn)("Unsupported header type " + tbox + " (" + headerType + ")");
                          break;
                      }
                      if (jumpDataLength) {
                        position += dataLength;
                      }
                    }
                  }, parseImageProperties: function JpxImage_parseImageProperties(stream) {
                    var newByte = stream.getByte();
                    while (newByte >= 0) {
                      var oldByte = newByte;
                      newByte = stream.getByte();
                      var code = oldByte << 8 | newByte;
                      if (code === 65361) {
                        stream.skip(4);
                        var Xsiz = stream.getInt32() >>> 0;
                        var Ysiz = stream.getInt32() >>> 0;
                        var XOsiz = stream.getInt32() >>> 0;
                        var YOsiz = stream.getInt32() >>> 0;
                        stream.skip(16);
                        var Csiz = stream.getUint16();
                        this.width = Xsiz - XOsiz;
                        this.height = Ysiz - YOsiz;
                        this.componentsCount = Csiz;
                        this.bitsPerComponent = 8;
                        return;
                      }
                    }
                    throw new JpxError("No size marker found in JPX stream");
                  }, parseCodestream: function JpxImage_parseCodestream(data, start, end) {
                    var context = {};
                    var doNotRecover = false;
                    try {
                      var position = start;
                      while (position + 1 < end) {
                        var code = (0, _core_utils.readUint16)(data, position);
                        position += 2;
                        var length = 0, j, sqcd, spqcds, spqcdSize, scalarExpounded, tile;
                        switch (code) {
                          case 65359:
                            context.mainHeader = true;
                            break;
                          case 65497:
                            break;
                          case 65361:
                            length = (0, _core_utils.readUint16)(data, position);
                            var siz = {};
                            siz.Xsiz = (0, _core_utils.readUint32)(data, position + 4);
                            siz.Ysiz = (0, _core_utils.readUint32)(data, position + 8);
                            siz.XOsiz = (0, _core_utils.readUint32)(data, position + 12);
                            siz.YOsiz = (0, _core_utils.readUint32)(data, position + 16);
                            siz.XTsiz = (0, _core_utils.readUint32)(data, position + 20);
                            siz.YTsiz = (0, _core_utils.readUint32)(data, position + 24);
                            siz.XTOsiz = (0, _core_utils.readUint32)(data, position + 28);
                            siz.YTOsiz = (0, _core_utils.readUint32)(data, position + 32);
                            var componentsCount = (0, _core_utils.readUint16)(data, position + 36);
                            siz.Csiz = componentsCount;
                            var components = [];
                            j = position + 38;
                            for (var i = 0; i < componentsCount; i++) {
                              var component = { precision: (data[j] & 127) + 1, isSigned: !!(data[j] & 128), XRsiz: data[j + 1], YRsiz: data[j + 2] };
                              j += 3;
                              calculateComponentDimensions(component, siz);
                              components.push(component);
                            }
                            context.SIZ = siz;
                            context.components = components;
                            calculateTileGrids(context, components);
                            context.QCC = [];
                            context.COC = [];
                            break;
                          case 65372:
                            length = (0, _core_utils.readUint16)(data, position);
                            var qcd = {};
                            j = position + 2;
                            sqcd = data[j++];
                            switch (sqcd & 31) {
                              case 0:
                                spqcdSize = 8;
                                scalarExpounded = true;
                                break;
                              case 1:
                                spqcdSize = 16;
                                scalarExpounded = false;
                                break;
                              case 2:
                                spqcdSize = 16;
                                scalarExpounded = true;
                                break;
                              default:
                                throw new Error("Invalid SQcd value " + sqcd);
                            }
                            qcd.noQuantization = spqcdSize === 8;
                            qcd.scalarExpounded = scalarExpounded;
                            qcd.guardBits = sqcd >> 5;
                            spqcds = [];
                            while (j < length + position) {
                              var spqcd = {};
                              if (spqcdSize === 8) {
                                spqcd.epsilon = data[j++] >> 3;
                                spqcd.mu = 0;
                              } else {
                                spqcd.epsilon = data[j] >> 3;
                                spqcd.mu = (data[j] & 7) << 8 | data[j + 1];
                                j += 2;
                              }
                              spqcds.push(spqcd);
                            }
                            qcd.SPqcds = spqcds;
                            if (context.mainHeader) {
                              context.QCD = qcd;
                            } else {
                              context.currentTile.QCD = qcd;
                              context.currentTile.QCC = [];
                            }
                            break;
                          case 65373:
                            length = (0, _core_utils.readUint16)(data, position);
                            var qcc = {};
                            j = position + 2;
                            var cqcc;
                            if (context.SIZ.Csiz < 257) {
                              cqcc = data[j++];
                            } else {
                              cqcc = (0, _core_utils.readUint16)(data, j);
                              j += 2;
                            }
                            sqcd = data[j++];
                            switch (sqcd & 31) {
                              case 0:
                                spqcdSize = 8;
                                scalarExpounded = true;
                                break;
                              case 1:
                                spqcdSize = 16;
                                scalarExpounded = false;
                                break;
                              case 2:
                                spqcdSize = 16;
                                scalarExpounded = true;
                                break;
                              default:
                                throw new Error("Invalid SQcd value " + sqcd);
                            }
                            qcc.noQuantization = spqcdSize === 8;
                            qcc.scalarExpounded = scalarExpounded;
                            qcc.guardBits = sqcd >> 5;
                            spqcds = [];
                            while (j < length + position) {
                              spqcd = {};
                              if (spqcdSize === 8) {
                                spqcd.epsilon = data[j++] >> 3;
                                spqcd.mu = 0;
                              } else {
                                spqcd.epsilon = data[j] >> 3;
                                spqcd.mu = (data[j] & 7) << 8 | data[j + 1];
                                j += 2;
                              }
                              spqcds.push(spqcd);
                            }
                            qcc.SPqcds = spqcds;
                            if (context.mainHeader) {
                              context.QCC[cqcc] = qcc;
                            } else {
                              context.currentTile.QCC[cqcc] = qcc;
                            }
                            break;
                          case 65362:
                            length = (0, _core_utils.readUint16)(data, position);
                            var cod = {};
                            j = position + 2;
                            var scod = data[j++];
                            cod.entropyCoderWithCustomPrecincts = !!(scod & 1);
                            cod.sopMarkerUsed = !!(scod & 2);
                            cod.ephMarkerUsed = !!(scod & 4);
                            cod.progressionOrder = data[j++];
                            cod.layersCount = (0, _core_utils.readUint16)(data, j);
                            j += 2;
                            cod.multipleComponentTransform = data[j++];
                            cod.decompositionLevelsCount = data[j++];
                            cod.xcb = (data[j++] & 15) + 2;
                            cod.ycb = (data[j++] & 15) + 2;
                            var blockStyle = data[j++];
                            cod.selectiveArithmeticCodingBypass = !!(blockStyle & 1);
                            cod.resetContextProbabilities = !!(blockStyle & 2);
                            cod.terminationOnEachCodingPass = !!(blockStyle & 4);
                            cod.verticallyStripe = !!(blockStyle & 8);
                            cod.predictableTermination = !!(blockStyle & 16);
                            cod.segmentationSymbolUsed = !!(blockStyle & 32);
                            cod.reversibleTransformation = data[j++];
                            if (cod.entropyCoderWithCustomPrecincts) {
                              var precinctsSizes = [];
                              while (j < length + position) {
                                var precinctsSize = data[j++];
                                precinctsSizes.push({ PPx: precinctsSize & 15, PPy: precinctsSize >> 4 });
                              }
                              cod.precinctsSizes = precinctsSizes;
                            }
                            var unsupported = [];
                            if (cod.selectiveArithmeticCodingBypass) {
                              unsupported.push("selectiveArithmeticCodingBypass");
                            }
                            if (cod.resetContextProbabilities) {
                              unsupported.push("resetContextProbabilities");
                            }
                            if (cod.terminationOnEachCodingPass) {
                              unsupported.push("terminationOnEachCodingPass");
                            }
                            if (cod.verticallyStripe) {
                              unsupported.push("verticallyStripe");
                            }
                            if (cod.predictableTermination) {
                              unsupported.push("predictableTermination");
                            }
                            if (unsupported.length > 0) {
                              doNotRecover = true;
                              throw new Error("Unsupported COD options (" + unsupported.join(", ") + ")");
                            }
                            if (context.mainHeader) {
                              context.COD = cod;
                            } else {
                              context.currentTile.COD = cod;
                              context.currentTile.COC = [];
                            }
                            break;
                          case 65424:
                            length = (0, _core_utils.readUint16)(data, position);
                            tile = {};
                            tile.index = (0, _core_utils.readUint16)(data, position + 2);
                            tile.length = (0, _core_utils.readUint32)(data, position + 4);
                            tile.dataEnd = tile.length + position - 2;
                            tile.partIndex = data[position + 8];
                            tile.partsCount = data[position + 9];
                            context.mainHeader = false;
                            if (tile.partIndex === 0) {
                              tile.COD = context.COD;
                              tile.COC = context.COC.slice(0);
                              tile.QCD = context.QCD;
                              tile.QCC = context.QCC.slice(0);
                            }
                            context.currentTile = tile;
                            break;
                          case 65427:
                            tile = context.currentTile;
                            if (tile.partIndex === 0) {
                              initializeTile(context, tile.index);
                              buildPackets(context);
                            }
                            length = tile.dataEnd - position;
                            parseTilePackets(context, data, position, length);
                            break;
                          case 65365:
                          case 65367:
                          case 65368:
                          case 65380:
                            length = (0, _core_utils.readUint16)(data, position);
                            break;
                          case 65363:
                            throw new Error("Codestream code 0xFF53 (COC) is not implemented");
                          default:
                            throw new Error("Unknown codestream code: " + code.toString(16));
                        }
                        position += length;
                      }
                    } catch (e) {
                      if (doNotRecover || this.failOnCorruptedImage) {
                        throw new JpxError(e.message);
                      } else {
                        (0, _util2.warn)("JPX: Trying to recover from: " + e.message);
                      }
                    }
                    this.tiles = transformComponents(context);
                    this.width = context.SIZ.Xsiz - context.SIZ.XOsiz;
                    this.height = context.SIZ.Ysiz - context.SIZ.YOsiz;
                    this.componentsCount = context.SIZ.Csiz;
                  } };
                  function calculateComponentDimensions(component, siz) {
                    component.x0 = Math.ceil(siz.XOsiz / component.XRsiz);
                    component.x1 = Math.ceil(siz.Xsiz / component.XRsiz);
                    component.y0 = Math.ceil(siz.YOsiz / component.YRsiz);
                    component.y1 = Math.ceil(siz.Ysiz / component.YRsiz);
                    component.width = component.x1 - component.x0;
                    component.height = component.y1 - component.y0;
                  }
                  function calculateTileGrids(context, components) {
                    var siz = context.SIZ;
                    var tile, tiles = [];
                    var numXtiles = Math.ceil((siz.Xsiz - siz.XTOsiz) / siz.XTsiz);
                    var numYtiles = Math.ceil((siz.Ysiz - siz.YTOsiz) / siz.YTsiz);
                    for (var q = 0; q < numYtiles; q++) {
                      for (var p = 0; p < numXtiles; p++) {
                        tile = {};
                        tile.tx0 = Math.max(siz.XTOsiz + p * siz.XTsiz, siz.XOsiz);
                        tile.ty0 = Math.max(siz.YTOsiz + q * siz.YTsiz, siz.YOsiz);
                        tile.tx1 = Math.min(siz.XTOsiz + (p + 1) * siz.XTsiz, siz.Xsiz);
                        tile.ty1 = Math.min(siz.YTOsiz + (q + 1) * siz.YTsiz, siz.Ysiz);
                        tile.width = tile.tx1 - tile.tx0;
                        tile.height = tile.ty1 - tile.ty0;
                        tile.components = [];
                        tiles.push(tile);
                      }
                    }
                    context.tiles = tiles;
                    var componentsCount = siz.Csiz;
                    for (var i = 0, ii = componentsCount; i < ii; i++) {
                      var component = components[i];
                      for (var j = 0, jj = tiles.length; j < jj; j++) {
                        var tileComponent = {};
                        tile = tiles[j];
                        tileComponent.tcx0 = Math.ceil(tile.tx0 / component.XRsiz);
                        tileComponent.tcy0 = Math.ceil(tile.ty0 / component.YRsiz);
                        tileComponent.tcx1 = Math.ceil(tile.tx1 / component.XRsiz);
                        tileComponent.tcy1 = Math.ceil(tile.ty1 / component.YRsiz);
                        tileComponent.width = tileComponent.tcx1 - tileComponent.tcx0;
                        tileComponent.height = tileComponent.tcy1 - tileComponent.tcy0;
                        tile.components[i] = tileComponent;
                      }
                    }
                  }
                  function getBlocksDimensions(context, component, r) {
                    var codOrCoc = component.codingStyleParameters;
                    var result = {};
                    if (!codOrCoc.entropyCoderWithCustomPrecincts) {
                      result.PPx = 15;
                      result.PPy = 15;
                    } else {
                      result.PPx = codOrCoc.precinctsSizes[r].PPx;
                      result.PPy = codOrCoc.precinctsSizes[r].PPy;
                    }
                    result.xcb_ = r > 0 ? Math.min(codOrCoc.xcb, result.PPx - 1) : Math.min(codOrCoc.xcb, result.PPx);
                    result.ycb_ = r > 0 ? Math.min(codOrCoc.ycb, result.PPy - 1) : Math.min(codOrCoc.ycb, result.PPy);
                    return result;
                  }
                  function buildPrecincts(context, resolution, dimensions) {
                    var precinctWidth = 1 << dimensions.PPx;
                    var precinctHeight = 1 << dimensions.PPy;
                    var isZeroRes = resolution.resLevel === 0;
                    var precinctWidthInSubband = 1 << dimensions.PPx + (isZeroRes ? 0 : -1);
                    var precinctHeightInSubband = 1 << dimensions.PPy + (isZeroRes ? 0 : -1);
                    var numprecinctswide = resolution.trx1 > resolution.trx0 ? Math.ceil(resolution.trx1 / precinctWidth) - Math.floor(resolution.trx0 / precinctWidth) : 0;
                    var numprecinctshigh = resolution.try1 > resolution.try0 ? Math.ceil(resolution.try1 / precinctHeight) - Math.floor(resolution.try0 / precinctHeight) : 0;
                    var numprecincts = numprecinctswide * numprecinctshigh;
                    resolution.precinctParameters = { precinctWidth, precinctHeight, numprecinctswide, numprecinctshigh, numprecincts, precinctWidthInSubband, precinctHeightInSubband };
                  }
                  function buildCodeblocks(context, subband, dimensions) {
                    var xcb_ = dimensions.xcb_;
                    var ycb_ = dimensions.ycb_;
                    var codeblockWidth = 1 << xcb_;
                    var codeblockHeight = 1 << ycb_;
                    var cbx0 = subband.tbx0 >> xcb_;
                    var cby0 = subband.tby0 >> ycb_;
                    var cbx1 = subband.tbx1 + codeblockWidth - 1 >> xcb_;
                    var cby1 = subband.tby1 + codeblockHeight - 1 >> ycb_;
                    var precinctParameters = subband.resolution.precinctParameters;
                    var codeblocks = [];
                    var precincts = [];
                    var i, j, codeblock, precinctNumber;
                    for (j = cby0; j < cby1; j++) {
                      for (i = cbx0; i < cbx1; i++) {
                        codeblock = { cbx: i, cby: j, tbx0: codeblockWidth * i, tby0: codeblockHeight * j, tbx1: codeblockWidth * (i + 1), tby1: codeblockHeight * (j + 1) };
                        codeblock.tbx0_ = Math.max(subband.tbx0, codeblock.tbx0);
                        codeblock.tby0_ = Math.max(subband.tby0, codeblock.tby0);
                        codeblock.tbx1_ = Math.min(subband.tbx1, codeblock.tbx1);
                        codeblock.tby1_ = Math.min(subband.tby1, codeblock.tby1);
                        var pi = Math.floor((codeblock.tbx0_ - subband.tbx0) / precinctParameters.precinctWidthInSubband);
                        var pj = Math.floor((codeblock.tby0_ - subband.tby0) / precinctParameters.precinctHeightInSubband);
                        precinctNumber = pi + pj * precinctParameters.numprecinctswide;
                        codeblock.precinctNumber = precinctNumber;
                        codeblock.subbandType = subband.type;
                        codeblock.Lblock = 3;
                        if (codeblock.tbx1_ <= codeblock.tbx0_ || codeblock.tby1_ <= codeblock.tby0_) {
                          continue;
                        }
                        codeblocks.push(codeblock);
                        var precinct = precincts[precinctNumber];
                        if (precinct !== void 0) {
                          if (i < precinct.cbxMin) {
                            precinct.cbxMin = i;
                          } else if (i > precinct.cbxMax) {
                            precinct.cbxMax = i;
                          }
                          if (j < precinct.cbyMin) {
                            precinct.cbxMin = j;
                          } else if (j > precinct.cbyMax) {
                            precinct.cbyMax = j;
                          }
                        } else {
                          precincts[precinctNumber] = precinct = { cbxMin: i, cbyMin: j, cbxMax: i, cbyMax: j };
                        }
                        codeblock.precinct = precinct;
                      }
                    }
                    subband.codeblockParameters = { codeblockWidth: xcb_, codeblockHeight: ycb_, numcodeblockwide: cbx1 - cbx0 + 1, numcodeblockhigh: cby1 - cby0 + 1 };
                    subband.codeblocks = codeblocks;
                    subband.precincts = precincts;
                  }
                  function createPacket(resolution, precinctNumber, layerNumber) {
                    var precinctCodeblocks = [];
                    var subbands = resolution.subbands;
                    for (var i = 0, ii = subbands.length; i < ii; i++) {
                      var subband = subbands[i];
                      var codeblocks = subband.codeblocks;
                      for (var j = 0, jj = codeblocks.length; j < jj; j++) {
                        var codeblock = codeblocks[j];
                        if (codeblock.precinctNumber !== precinctNumber) {
                          continue;
                        }
                        precinctCodeblocks.push(codeblock);
                      }
                    }
                    return { layerNumber, codeblocks: precinctCodeblocks };
                  }
                  function LayerResolutionComponentPositionIterator(context) {
                    var siz = context.SIZ;
                    var tileIndex = context.currentTile.index;
                    var tile = context.tiles[tileIndex];
                    var layersCount = tile.codingStyleDefaultParameters.layersCount;
                    var componentsCount = siz.Csiz;
                    var maxDecompositionLevelsCount = 0;
                    for (var q = 0; q < componentsCount; q++) {
                      maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount, tile.components[q].codingStyleParameters.decompositionLevelsCount);
                    }
                    var l = 0, r = 0, i = 0, k = 0;
                    this.nextPacket = function JpxImage_nextPacket() {
                      for (; l < layersCount; l++) {
                        for (; r <= maxDecompositionLevelsCount; r++) {
                          for (; i < componentsCount; i++) {
                            var component = tile.components[i];
                            if (r > component.codingStyleParameters.decompositionLevelsCount) {
                              continue;
                            }
                            var resolution = component.resolutions[r];
                            var numprecincts = resolution.precinctParameters.numprecincts;
                            for (; k < numprecincts; ) {
                              var packet = createPacket(resolution, k, l);
                              k++;
                              return packet;
                            }
                            k = 0;
                          }
                          i = 0;
                        }
                        r = 0;
                      }
                      throw new JpxError("Out of packets");
                    };
                  }
                  function ResolutionLayerComponentPositionIterator(context) {
                    var siz = context.SIZ;
                    var tileIndex = context.currentTile.index;
                    var tile = context.tiles[tileIndex];
                    var layersCount = tile.codingStyleDefaultParameters.layersCount;
                    var componentsCount = siz.Csiz;
                    var maxDecompositionLevelsCount = 0;
                    for (var q = 0; q < componentsCount; q++) {
                      maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount, tile.components[q].codingStyleParameters.decompositionLevelsCount);
                    }
                    var r = 0, l = 0, i = 0, k = 0;
                    this.nextPacket = function JpxImage_nextPacket() {
                      for (; r <= maxDecompositionLevelsCount; r++) {
                        for (; l < layersCount; l++) {
                          for (; i < componentsCount; i++) {
                            var component = tile.components[i];
                            if (r > component.codingStyleParameters.decompositionLevelsCount) {
                              continue;
                            }
                            var resolution = component.resolutions[r];
                            var numprecincts = resolution.precinctParameters.numprecincts;
                            for (; k < numprecincts; ) {
                              var packet = createPacket(resolution, k, l);
                              k++;
                              return packet;
                            }
                            k = 0;
                          }
                          i = 0;
                        }
                        l = 0;
                      }
                      throw new JpxError("Out of packets");
                    };
                  }
                  function ResolutionPositionComponentLayerIterator(context) {
                    var siz = context.SIZ;
                    var tileIndex = context.currentTile.index;
                    var tile = context.tiles[tileIndex];
                    var layersCount = tile.codingStyleDefaultParameters.layersCount;
                    var componentsCount = siz.Csiz;
                    var l, r, c, p;
                    var maxDecompositionLevelsCount = 0;
                    for (c = 0; c < componentsCount; c++) {
                      var component = tile.components[c];
                      maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount, component.codingStyleParameters.decompositionLevelsCount);
                    }
                    var maxNumPrecinctsInLevel = new Int32Array(maxDecompositionLevelsCount + 1);
                    for (r = 0; r <= maxDecompositionLevelsCount; ++r) {
                      var maxNumPrecincts = 0;
                      for (c = 0; c < componentsCount; ++c) {
                        var resolutions = tile.components[c].resolutions;
                        if (r < resolutions.length) {
                          maxNumPrecincts = Math.max(maxNumPrecincts, resolutions[r].precinctParameters.numprecincts);
                        }
                      }
                      maxNumPrecinctsInLevel[r] = maxNumPrecincts;
                    }
                    l = 0;
                    r = 0;
                    c = 0;
                    p = 0;
                    this.nextPacket = function JpxImage_nextPacket() {
                      for (; r <= maxDecompositionLevelsCount; r++) {
                        for (; p < maxNumPrecinctsInLevel[r]; p++) {
                          for (; c < componentsCount; c++) {
                            var component2 = tile.components[c];
                            if (r > component2.codingStyleParameters.decompositionLevelsCount) {
                              continue;
                            }
                            var resolution = component2.resolutions[r];
                            var numprecincts = resolution.precinctParameters.numprecincts;
                            if (p >= numprecincts) {
                              continue;
                            }
                            for (; l < layersCount; ) {
                              var packet = createPacket(resolution, p, l);
                              l++;
                              return packet;
                            }
                            l = 0;
                          }
                          c = 0;
                        }
                        p = 0;
                      }
                      throw new JpxError("Out of packets");
                    };
                  }
                  function PositionComponentResolutionLayerIterator(context) {
                    var siz = context.SIZ;
                    var tileIndex = context.currentTile.index;
                    var tile = context.tiles[tileIndex];
                    var layersCount = tile.codingStyleDefaultParameters.layersCount;
                    var componentsCount = siz.Csiz;
                    var precinctsSizes = getPrecinctSizesInImageScale(tile);
                    var precinctsIterationSizes = precinctsSizes;
                    var l = 0, r = 0, c = 0, px = 0, py = 0;
                    this.nextPacket = function JpxImage_nextPacket() {
                      for (; py < precinctsIterationSizes.maxNumHigh; py++) {
                        for (; px < precinctsIterationSizes.maxNumWide; px++) {
                          for (; c < componentsCount; c++) {
                            var component = tile.components[c];
                            var decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;
                            for (; r <= decompositionLevelsCount; r++) {
                              var resolution = component.resolutions[r];
                              var sizeInImageScale = precinctsSizes.components[c].resolutions[r];
                              var k = getPrecinctIndexIfExist(px, py, sizeInImageScale, precinctsIterationSizes, resolution);
                              if (k === null) {
                                continue;
                              }
                              for (; l < layersCount; ) {
                                var packet = createPacket(resolution, k, l);
                                l++;
                                return packet;
                              }
                              l = 0;
                            }
                            r = 0;
                          }
                          c = 0;
                        }
                        px = 0;
                      }
                      throw new JpxError("Out of packets");
                    };
                  }
                  function ComponentPositionResolutionLayerIterator(context) {
                    var siz = context.SIZ;
                    var tileIndex = context.currentTile.index;
                    var tile = context.tiles[tileIndex];
                    var layersCount = tile.codingStyleDefaultParameters.layersCount;
                    var componentsCount = siz.Csiz;
                    var precinctsSizes = getPrecinctSizesInImageScale(tile);
                    var l = 0, r = 0, c = 0, px = 0, py = 0;
                    this.nextPacket = function JpxImage_nextPacket() {
                      for (; c < componentsCount; ++c) {
                        var component = tile.components[c];
                        var precinctsIterationSizes = precinctsSizes.components[c];
                        var decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;
                        for (; py < precinctsIterationSizes.maxNumHigh; py++) {
                          for (; px < precinctsIterationSizes.maxNumWide; px++) {
                            for (; r <= decompositionLevelsCount; r++) {
                              var resolution = component.resolutions[r];
                              var sizeInImageScale = precinctsIterationSizes.resolutions[r];
                              var k = getPrecinctIndexIfExist(px, py, sizeInImageScale, precinctsIterationSizes, resolution);
                              if (k === null) {
                                continue;
                              }
                              for (; l < layersCount; ) {
                                var packet = createPacket(resolution, k, l);
                                l++;
                                return packet;
                              }
                              l = 0;
                            }
                            r = 0;
                          }
                          px = 0;
                        }
                        py = 0;
                      }
                      throw new JpxError("Out of packets");
                    };
                  }
                  function getPrecinctIndexIfExist(pxIndex, pyIndex, sizeInImageScale, precinctIterationSizes, resolution) {
                    var posX = pxIndex * precinctIterationSizes.minWidth;
                    var posY = pyIndex * precinctIterationSizes.minHeight;
                    if (posX % sizeInImageScale.width !== 0 || posY % sizeInImageScale.height !== 0) {
                      return null;
                    }
                    var startPrecinctRowIndex = posY / sizeInImageScale.width * resolution.precinctParameters.numprecinctswide;
                    return posX / sizeInImageScale.height + startPrecinctRowIndex;
                  }
                  function getPrecinctSizesInImageScale(tile) {
                    var componentsCount = tile.components.length;
                    var minWidth = Number.MAX_VALUE;
                    var minHeight = Number.MAX_VALUE;
                    var maxNumWide = 0;
                    var maxNumHigh = 0;
                    var sizePerComponent = new Array(componentsCount);
                    for (var c = 0; c < componentsCount; c++) {
                      var component = tile.components[c];
                      var decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;
                      var sizePerResolution = new Array(decompositionLevelsCount + 1);
                      var minWidthCurrentComponent = Number.MAX_VALUE;
                      var minHeightCurrentComponent = Number.MAX_VALUE;
                      var maxNumWideCurrentComponent = 0;
                      var maxNumHighCurrentComponent = 0;
                      var scale = 1;
                      for (var r = decompositionLevelsCount; r >= 0; --r) {
                        var resolution = component.resolutions[r];
                        var widthCurrentResolution = scale * resolution.precinctParameters.precinctWidth;
                        var heightCurrentResolution = scale * resolution.precinctParameters.precinctHeight;
                        minWidthCurrentComponent = Math.min(minWidthCurrentComponent, widthCurrentResolution);
                        minHeightCurrentComponent = Math.min(minHeightCurrentComponent, heightCurrentResolution);
                        maxNumWideCurrentComponent = Math.max(maxNumWideCurrentComponent, resolution.precinctParameters.numprecinctswide);
                        maxNumHighCurrentComponent = Math.max(maxNumHighCurrentComponent, resolution.precinctParameters.numprecinctshigh);
                        sizePerResolution[r] = { width: widthCurrentResolution, height: heightCurrentResolution };
                        scale <<= 1;
                      }
                      minWidth = Math.min(minWidth, minWidthCurrentComponent);
                      minHeight = Math.min(minHeight, minHeightCurrentComponent);
                      maxNumWide = Math.max(maxNumWide, maxNumWideCurrentComponent);
                      maxNumHigh = Math.max(maxNumHigh, maxNumHighCurrentComponent);
                      sizePerComponent[c] = { resolutions: sizePerResolution, minWidth: minWidthCurrentComponent, minHeight: minHeightCurrentComponent, maxNumWide: maxNumWideCurrentComponent, maxNumHigh: maxNumHighCurrentComponent };
                    }
                    return { components: sizePerComponent, minWidth, minHeight, maxNumWide, maxNumHigh };
                  }
                  function buildPackets(context) {
                    var siz = context.SIZ;
                    var tileIndex = context.currentTile.index;
                    var tile = context.tiles[tileIndex];
                    var componentsCount = siz.Csiz;
                    for (var c = 0; c < componentsCount; c++) {
                      var component = tile.components[c];
                      var decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;
                      var resolutions = [];
                      var subbands = [];
                      for (var r = 0; r <= decompositionLevelsCount; r++) {
                        var blocksDimensions = getBlocksDimensions(context, component, r);
                        var resolution = {};
                        var scale = 1 << decompositionLevelsCount - r;
                        resolution.trx0 = Math.ceil(component.tcx0 / scale);
                        resolution.try0 = Math.ceil(component.tcy0 / scale);
                        resolution.trx1 = Math.ceil(component.tcx1 / scale);
                        resolution.try1 = Math.ceil(component.tcy1 / scale);
                        resolution.resLevel = r;
                        buildPrecincts(context, resolution, blocksDimensions);
                        resolutions.push(resolution);
                        var subband;
                        if (r === 0) {
                          subband = {};
                          subband.type = "LL";
                          subband.tbx0 = Math.ceil(component.tcx0 / scale);
                          subband.tby0 = Math.ceil(component.tcy0 / scale);
                          subband.tbx1 = Math.ceil(component.tcx1 / scale);
                          subband.tby1 = Math.ceil(component.tcy1 / scale);
                          subband.resolution = resolution;
                          buildCodeblocks(context, subband, blocksDimensions);
                          subbands.push(subband);
                          resolution.subbands = [subband];
                        } else {
                          var bscale = 1 << decompositionLevelsCount - r + 1;
                          var resolutionSubbands = [];
                          subband = {};
                          subband.type = "HL";
                          subband.tbx0 = Math.ceil(component.tcx0 / bscale - 0.5);
                          subband.tby0 = Math.ceil(component.tcy0 / bscale);
                          subband.tbx1 = Math.ceil(component.tcx1 / bscale - 0.5);
                          subband.tby1 = Math.ceil(component.tcy1 / bscale);
                          subband.resolution = resolution;
                          buildCodeblocks(context, subband, blocksDimensions);
                          subbands.push(subband);
                          resolutionSubbands.push(subband);
                          subband = {};
                          subband.type = "LH";
                          subband.tbx0 = Math.ceil(component.tcx0 / bscale);
                          subband.tby0 = Math.ceil(component.tcy0 / bscale - 0.5);
                          subband.tbx1 = Math.ceil(component.tcx1 / bscale);
                          subband.tby1 = Math.ceil(component.tcy1 / bscale - 0.5);
                          subband.resolution = resolution;
                          buildCodeblocks(context, subband, blocksDimensions);
                          subbands.push(subband);
                          resolutionSubbands.push(subband);
                          subband = {};
                          subband.type = "HH";
                          subband.tbx0 = Math.ceil(component.tcx0 / bscale - 0.5);
                          subband.tby0 = Math.ceil(component.tcy0 / bscale - 0.5);
                          subband.tbx1 = Math.ceil(component.tcx1 / bscale - 0.5);
                          subband.tby1 = Math.ceil(component.tcy1 / bscale - 0.5);
                          subband.resolution = resolution;
                          buildCodeblocks(context, subband, blocksDimensions);
                          subbands.push(subband);
                          resolutionSubbands.push(subband);
                          resolution.subbands = resolutionSubbands;
                        }
                      }
                      component.resolutions = resolutions;
                      component.subbands = subbands;
                    }
                    var progressionOrder = tile.codingStyleDefaultParameters.progressionOrder;
                    switch (progressionOrder) {
                      case 0:
                        tile.packetsIterator = new LayerResolutionComponentPositionIterator(context);
                        break;
                      case 1:
                        tile.packetsIterator = new ResolutionLayerComponentPositionIterator(context);
                        break;
                      case 2:
                        tile.packetsIterator = new ResolutionPositionComponentLayerIterator(context);
                        break;
                      case 3:
                        tile.packetsIterator = new PositionComponentResolutionLayerIterator(context);
                        break;
                      case 4:
                        tile.packetsIterator = new ComponentPositionResolutionLayerIterator(context);
                        break;
                      default:
                        throw new JpxError(`Unsupported progression order ${progressionOrder}`);
                    }
                  }
                  function parseTilePackets(context, data, offset, dataLength) {
                    var position = 0;
                    var buffer, bufferSize = 0, skipNextBit = false;
                    function readBits(count) {
                      while (bufferSize < count) {
                        var b = data[offset + position];
                        position++;
                        if (skipNextBit) {
                          buffer = buffer << 7 | b;
                          bufferSize += 7;
                          skipNextBit = false;
                        } else {
                          buffer = buffer << 8 | b;
                          bufferSize += 8;
                        }
                        if (b === 255) {
                          skipNextBit = true;
                        }
                      }
                      bufferSize -= count;
                      return buffer >>> bufferSize & (1 << count) - 1;
                    }
                    function skipMarkerIfEqual(value) {
                      if (data[offset + position - 1] === 255 && data[offset + position] === value) {
                        skipBytes(1);
                        return true;
                      } else if (data[offset + position] === 255 && data[offset + position + 1] === value) {
                        skipBytes(2);
                        return true;
                      }
                      return false;
                    }
                    function skipBytes(count) {
                      position += count;
                    }
                    function alignToByte() {
                      bufferSize = 0;
                      if (skipNextBit) {
                        position++;
                        skipNextBit = false;
                      }
                    }
                    function readCodingpasses() {
                      if (readBits(1) === 0) {
                        return 1;
                      }
                      if (readBits(1) === 0) {
                        return 2;
                      }
                      var value = readBits(2);
                      if (value < 3) {
                        return value + 3;
                      }
                      value = readBits(5);
                      if (value < 31) {
                        return value + 6;
                      }
                      value = readBits(7);
                      return value + 37;
                    }
                    var tileIndex = context.currentTile.index;
                    var tile = context.tiles[tileIndex];
                    var sopMarkerUsed = context.COD.sopMarkerUsed;
                    var ephMarkerUsed = context.COD.ephMarkerUsed;
                    var packetsIterator = tile.packetsIterator;
                    while (position < dataLength) {
                      alignToByte();
                      if (sopMarkerUsed && skipMarkerIfEqual(145)) {
                        skipBytes(4);
                      }
                      var packet = packetsIterator.nextPacket();
                      if (!readBits(1)) {
                        continue;
                      }
                      var layerNumber = packet.layerNumber;
                      var queue = [], codeblock;
                      for (var i = 0, ii = packet.codeblocks.length; i < ii; i++) {
                        codeblock = packet.codeblocks[i];
                        var precinct = codeblock.precinct;
                        var codeblockColumn = codeblock.cbx - precinct.cbxMin;
                        var codeblockRow = codeblock.cby - precinct.cbyMin;
                        var codeblockIncluded = false;
                        var firstTimeInclusion = false;
                        var valueReady;
                        if (codeblock["included"] !== void 0) {
                          codeblockIncluded = !!readBits(1);
                        } else {
                          precinct = codeblock.precinct;
                          var inclusionTree, zeroBitPlanesTree;
                          if (precinct["inclusionTree"] !== void 0) {
                            inclusionTree = precinct.inclusionTree;
                          } else {
                            var width = precinct.cbxMax - precinct.cbxMin + 1;
                            var height = precinct.cbyMax - precinct.cbyMin + 1;
                            inclusionTree = new InclusionTree(width, height, layerNumber);
                            zeroBitPlanesTree = new TagTree(width, height);
                            precinct.inclusionTree = inclusionTree;
                            precinct.zeroBitPlanesTree = zeroBitPlanesTree;
                          }
                          if (inclusionTree.reset(codeblockColumn, codeblockRow, layerNumber)) {
                            while (true) {
                              if (readBits(1)) {
                                valueReady = !inclusionTree.nextLevel();
                                if (valueReady) {
                                  codeblock.included = true;
                                  codeblockIncluded = firstTimeInclusion = true;
                                  break;
                                }
                              } else {
                                inclusionTree.incrementValue(layerNumber);
                                break;
                              }
                            }
                          }
                        }
                        if (!codeblockIncluded) {
                          continue;
                        }
                        if (firstTimeInclusion) {
                          zeroBitPlanesTree = precinct.zeroBitPlanesTree;
                          zeroBitPlanesTree.reset(codeblockColumn, codeblockRow);
                          while (true) {
                            if (readBits(1)) {
                              valueReady = !zeroBitPlanesTree.nextLevel();
                              if (valueReady) {
                                break;
                              }
                            } else {
                              zeroBitPlanesTree.incrementValue();
                            }
                          }
                          codeblock.zeroBitPlanes = zeroBitPlanesTree.value;
                        }
                        var codingpasses = readCodingpasses();
                        while (readBits(1)) {
                          codeblock.Lblock++;
                        }
                        var codingpassesLog2 = (0, _core_utils.log2)(codingpasses);
                        var bits = (codingpasses < 1 << codingpassesLog2 ? codingpassesLog2 - 1 : codingpassesLog2) + codeblock.Lblock;
                        var codedDataLength = readBits(bits);
                        queue.push({ codeblock, codingpasses, dataLength: codedDataLength });
                      }
                      alignToByte();
                      if (ephMarkerUsed) {
                        skipMarkerIfEqual(146);
                      }
                      while (queue.length > 0) {
                        var packetItem = queue.shift();
                        codeblock = packetItem.codeblock;
                        if (codeblock["data"] === void 0) {
                          codeblock.data = [];
                        }
                        codeblock.data.push({ data, start: offset + position, end: offset + position + packetItem.dataLength, codingpasses: packetItem.codingpasses });
                        position += packetItem.dataLength;
                      }
                    }
                    return position;
                  }
                  function copyCoefficients(coefficients, levelWidth, levelHeight, subband, delta, mb, reversible, segmentationSymbolUsed) {
                    var x0 = subband.tbx0;
                    var y0 = subband.tby0;
                    var width = subband.tbx1 - subband.tbx0;
                    var codeblocks = subband.codeblocks;
                    var right = subband.type.charAt(0) === "H" ? 1 : 0;
                    var bottom = subband.type.charAt(1) === "H" ? levelWidth : 0;
                    for (var i = 0, ii = codeblocks.length; i < ii; ++i) {
                      var codeblock = codeblocks[i];
                      var blockWidth = codeblock.tbx1_ - codeblock.tbx0_;
                      var blockHeight = codeblock.tby1_ - codeblock.tby0_;
                      if (blockWidth === 0 || blockHeight === 0) {
                        continue;
                      }
                      if (codeblock["data"] === void 0) {
                        continue;
                      }
                      var bitModel, currentCodingpassType;
                      bitModel = new BitModel(blockWidth, blockHeight, codeblock.subbandType, codeblock.zeroBitPlanes, mb);
                      currentCodingpassType = 2;
                      var data = codeblock.data, totalLength = 0, codingpasses = 0;
                      var j, jj, dataItem;
                      for (j = 0, jj = data.length; j < jj; j++) {
                        dataItem = data[j];
                        totalLength += dataItem.end - dataItem.start;
                        codingpasses += dataItem.codingpasses;
                      }
                      var encodedData = new Uint8Array(totalLength);
                      var position = 0;
                      for (j = 0, jj = data.length; j < jj; j++) {
                        dataItem = data[j];
                        var chunk = dataItem.data.subarray(dataItem.start, dataItem.end);
                        encodedData.set(chunk, position);
                        position += chunk.length;
                      }
                      var decoder = new _arithmetic_decoder.ArithmeticDecoder(encodedData, 0, totalLength);
                      bitModel.setDecoder(decoder);
                      for (j = 0; j < codingpasses; j++) {
                        switch (currentCodingpassType) {
                          case 0:
                            bitModel.runSignificancePropagationPass();
                            break;
                          case 1:
                            bitModel.runMagnitudeRefinementPass();
                            break;
                          case 2:
                            bitModel.runCleanupPass();
                            if (segmentationSymbolUsed) {
                              bitModel.checkSegmentationSymbol();
                            }
                            break;
                        }
                        currentCodingpassType = (currentCodingpassType + 1) % 3;
                      }
                      var offset = codeblock.tbx0_ - x0 + (codeblock.tby0_ - y0) * width;
                      var sign = bitModel.coefficentsSign;
                      var magnitude = bitModel.coefficentsMagnitude;
                      var bitsDecoded = bitModel.bitsDecoded;
                      var magnitudeCorrection = reversible ? 0 : 0.5;
                      var k, n, nb;
                      position = 0;
                      var interleave = subband.type !== "LL";
                      for (j = 0; j < blockHeight; j++) {
                        var row = offset / width | 0;
                        var levelOffset = 2 * row * (levelWidth - width) + right + bottom;
                        for (k = 0; k < blockWidth; k++) {
                          n = magnitude[position];
                          if (n !== 0) {
                            n = (n + magnitudeCorrection) * delta;
                            if (sign[position] !== 0) {
                              n = -n;
                            }
                            nb = bitsDecoded[position];
                            var pos = interleave ? levelOffset + (offset << 1) : offset;
                            if (reversible && nb >= mb) {
                              coefficients[pos] = n;
                            } else {
                              coefficients[pos] = n * (1 << mb - nb);
                            }
                          }
                          offset++;
                          position++;
                        }
                        offset += width - blockWidth;
                      }
                    }
                  }
                  function transformTile(context, tile, c) {
                    var component = tile.components[c];
                    var codingStyleParameters = component.codingStyleParameters;
                    var quantizationParameters = component.quantizationParameters;
                    var decompositionLevelsCount = codingStyleParameters.decompositionLevelsCount;
                    var spqcds = quantizationParameters.SPqcds;
                    var scalarExpounded = quantizationParameters.scalarExpounded;
                    var guardBits = quantizationParameters.guardBits;
                    var segmentationSymbolUsed = codingStyleParameters.segmentationSymbolUsed;
                    var precision = context.components[c].precision;
                    var reversible = codingStyleParameters.reversibleTransformation;
                    var transform = reversible ? new ReversibleTransform() : new IrreversibleTransform();
                    var subbandCoefficients = [];
                    var b = 0;
                    for (var i = 0; i <= decompositionLevelsCount; i++) {
                      var resolution = component.resolutions[i];
                      var width = resolution.trx1 - resolution.trx0;
                      var height = resolution.try1 - resolution.try0;
                      var coefficients = new Float32Array(width * height);
                      for (var j = 0, jj = resolution.subbands.length; j < jj; j++) {
                        var mu, epsilon;
                        if (!scalarExpounded) {
                          mu = spqcds[0].mu;
                          epsilon = spqcds[0].epsilon + (i > 0 ? 1 - i : 0);
                        } else {
                          mu = spqcds[b].mu;
                          epsilon = spqcds[b].epsilon;
                          b++;
                        }
                        var subband = resolution.subbands[j];
                        var gainLog2 = SubbandsGainLog2[subband.type];
                        var delta = reversible ? 1 : 2 ** (precision + gainLog2 - epsilon) * (1 + mu / 2048);
                        var mb = guardBits + epsilon - 1;
                        copyCoefficients(coefficients, width, height, subband, delta, mb, reversible, segmentationSymbolUsed);
                      }
                      subbandCoefficients.push({ width, height, items: coefficients });
                    }
                    var result = transform.calculate(subbandCoefficients, component.tcx0, component.tcy0);
                    return { left: component.tcx0, top: component.tcy0, width: result.width, height: result.height, items: result.items };
                  }
                  function transformComponents(context) {
                    var siz = context.SIZ;
                    var components = context.components;
                    var componentsCount = siz.Csiz;
                    var resultImages = [];
                    for (var i = 0, ii = context.tiles.length; i < ii; i++) {
                      var tile = context.tiles[i];
                      var transformedTiles = [];
                      var c;
                      for (c = 0; c < componentsCount; c++) {
                        transformedTiles[c] = transformTile(context, tile, c);
                      }
                      var tile0 = transformedTiles[0];
                      var out = new Uint8ClampedArray(tile0.items.length * componentsCount);
                      var result = { left: tile0.left, top: tile0.top, width: tile0.width, height: tile0.height, items: out };
                      var shift, offset;
                      var pos = 0, j, jj, y0, y1, y2;
                      if (tile.codingStyleDefaultParameters.multipleComponentTransform) {
                        var fourComponents = componentsCount === 4;
                        var y0items = transformedTiles[0].items;
                        var y1items = transformedTiles[1].items;
                        var y2items = transformedTiles[2].items;
                        var y3items = fourComponents ? transformedTiles[3].items : null;
                        shift = components[0].precision - 8;
                        offset = (128 << shift) + 0.5;
                        var component0 = tile.components[0];
                        var alpha01 = componentsCount - 3;
                        jj = y0items.length;
                        if (!component0.codingStyleParameters.reversibleTransformation) {
                          for (j = 0; j < jj; j++, pos += alpha01) {
                            y0 = y0items[j] + offset;
                            y1 = y1items[j];
                            y2 = y2items[j];
                            out[pos++] = y0 + 1.402 * y2 >> shift;
                            out[pos++] = y0 - 0.34413 * y1 - 0.71414 * y2 >> shift;
                            out[pos++] = y0 + 1.772 * y1 >> shift;
                          }
                        } else {
                          for (j = 0; j < jj; j++, pos += alpha01) {
                            y0 = y0items[j] + offset;
                            y1 = y1items[j];
                            y2 = y2items[j];
                            const g = y0 - (y2 + y1 >> 2);
                            out[pos++] = g + y2 >> shift;
                            out[pos++] = g >> shift;
                            out[pos++] = g + y1 >> shift;
                          }
                        }
                        if (fourComponents) {
                          for (j = 0, pos = 3; j < jj; j++, pos += 4) {
                            out[pos] = y3items[j] + offset >> shift;
                          }
                        }
                      } else {
                        for (c = 0; c < componentsCount; c++) {
                          var items = transformedTiles[c].items;
                          shift = components[c].precision - 8;
                          offset = (128 << shift) + 0.5;
                          for (pos = c, j = 0, jj = items.length; j < jj; j++) {
                            out[pos] = items[j] + offset >> shift;
                            pos += componentsCount;
                          }
                        }
                      }
                      resultImages.push(result);
                    }
                    return resultImages;
                  }
                  function initializeTile(context, tileIndex) {
                    var siz = context.SIZ;
                    var componentsCount = siz.Csiz;
                    var tile = context.tiles[tileIndex];
                    for (var c = 0; c < componentsCount; c++) {
                      var component = tile.components[c];
                      var qcdOrQcc = context.currentTile.QCC[c] !== void 0 ? context.currentTile.QCC[c] : context.currentTile.QCD;
                      component.quantizationParameters = qcdOrQcc;
                      var codOrCoc = context.currentTile.COC[c] !== void 0 ? context.currentTile.COC[c] : context.currentTile.COD;
                      component.codingStyleParameters = codOrCoc;
                    }
                    tile.codingStyleDefaultParameters = context.currentTile.COD;
                  }
                  var TagTree = function TagTreeClosure() {
                    function TagTree2(width, height) {
                      var levelsLength = (0, _core_utils.log2)(Math.max(width, height)) + 1;
                      this.levels = [];
                      for (var i = 0; i < levelsLength; i++) {
                        var level = { width, height, items: [] };
                        this.levels.push(level);
                        width = Math.ceil(width / 2);
                        height = Math.ceil(height / 2);
                      }
                    }
                    TagTree2.prototype = { reset: function TagTree_reset(i, j) {
                      var currentLevel = 0, value = 0, level;
                      while (currentLevel < this.levels.length) {
                        level = this.levels[currentLevel];
                        var index = i + j * level.width;
                        if (level.items[index] !== void 0) {
                          value = level.items[index];
                          break;
                        }
                        level.index = index;
                        i >>= 1;
                        j >>= 1;
                        currentLevel++;
                      }
                      currentLevel--;
                      level = this.levels[currentLevel];
                      level.items[level.index] = value;
                      this.currentLevel = currentLevel;
                      delete this.value;
                    }, incrementValue: function TagTree_incrementValue() {
                      var level = this.levels[this.currentLevel];
                      level.items[level.index]++;
                    }, nextLevel: function TagTree_nextLevel() {
                      var currentLevel = this.currentLevel;
                      var level = this.levels[currentLevel];
                      var value = level.items[level.index];
                      currentLevel--;
                      if (currentLevel < 0) {
                        this.value = value;
                        return false;
                      }
                      this.currentLevel = currentLevel;
                      level = this.levels[currentLevel];
                      level.items[level.index] = value;
                      return true;
                    } };
                    return TagTree2;
                  }();
                  var InclusionTree = function InclusionTreeClosure() {
                    function InclusionTree2(width, height, defaultValue) {
                      var levelsLength = (0, _core_utils.log2)(Math.max(width, height)) + 1;
                      this.levels = [];
                      for (var i = 0; i < levelsLength; i++) {
                        var items = new Uint8Array(width * height);
                        for (var j = 0, jj = items.length; j < jj; j++) {
                          items[j] = defaultValue;
                        }
                        var level = { width, height, items };
                        this.levels.push(level);
                        width = Math.ceil(width / 2);
                        height = Math.ceil(height / 2);
                      }
                    }
                    InclusionTree2.prototype = { reset: function InclusionTree_reset(i, j, stopValue) {
                      var currentLevel = 0;
                      while (currentLevel < this.levels.length) {
                        var level = this.levels[currentLevel];
                        var index = i + j * level.width;
                        level.index = index;
                        var value = level.items[index];
                        if (value === 255) {
                          break;
                        }
                        if (value > stopValue) {
                          this.currentLevel = currentLevel;
                          this.propagateValues();
                          return false;
                        }
                        i >>= 1;
                        j >>= 1;
                        currentLevel++;
                      }
                      this.currentLevel = currentLevel - 1;
                      return true;
                    }, incrementValue: function InclusionTree_incrementValue(stopValue) {
                      var level = this.levels[this.currentLevel];
                      level.items[level.index] = stopValue + 1;
                      this.propagateValues();
                    }, propagateValues: function InclusionTree_propagateValues() {
                      var levelIndex = this.currentLevel;
                      var level = this.levels[levelIndex];
                      var currentValue = level.items[level.index];
                      while (--levelIndex >= 0) {
                        level = this.levels[levelIndex];
                        level.items[level.index] = currentValue;
                      }
                    }, nextLevel: function InclusionTree_nextLevel() {
                      var currentLevel = this.currentLevel;
                      var level = this.levels[currentLevel];
                      var value = level.items[level.index];
                      level.items[level.index] = 255;
                      currentLevel--;
                      if (currentLevel < 0) {
                        return false;
                      }
                      this.currentLevel = currentLevel;
                      level = this.levels[currentLevel];
                      level.items[level.index] = value;
                      return true;
                    } };
                    return InclusionTree2;
                  }();
                  var BitModel = function BitModelClosure() {
                    var UNIFORM_CONTEXT = 17;
                    var RUNLENGTH_CONTEXT = 18;
                    var LLAndLHContextsLabel = new Uint8Array([0, 5, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 1, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8]);
                    var HLContextLabel = new Uint8Array([0, 3, 4, 0, 5, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 1, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8]);
                    var HHContextLabel = new Uint8Array([0, 1, 2, 0, 1, 2, 2, 0, 2, 2, 2, 0, 0, 0, 0, 0, 3, 4, 5, 0, 4, 5, 5, 0, 5, 5, 5, 0, 0, 0, 0, 0, 6, 7, 7, 0, 7, 7, 7, 0, 7, 7, 7, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8]);
                    function BitModel2(width, height, subband, zeroBitPlanes, mb) {
                      this.width = width;
                      this.height = height;
                      let contextLabelTable;
                      if (subband === "HH") {
                        contextLabelTable = HHContextLabel;
                      } else if (subband === "HL") {
                        contextLabelTable = HLContextLabel;
                      } else {
                        contextLabelTable = LLAndLHContextsLabel;
                      }
                      this.contextLabelTable = contextLabelTable;
                      var coefficientCount = width * height;
                      this.neighborsSignificance = new Uint8Array(coefficientCount);
                      this.coefficentsSign = new Uint8Array(coefficientCount);
                      let coefficentsMagnitude;
                      if (mb > 14) {
                        coefficentsMagnitude = new Uint32Array(coefficientCount);
                      } else if (mb > 6) {
                        coefficentsMagnitude = new Uint16Array(coefficientCount);
                      } else {
                        coefficentsMagnitude = new Uint8Array(coefficientCount);
                      }
                      this.coefficentsMagnitude = coefficentsMagnitude;
                      this.processingFlags = new Uint8Array(coefficientCount);
                      var bitsDecoded = new Uint8Array(coefficientCount);
                      if (zeroBitPlanes !== 0) {
                        for (var i = 0; i < coefficientCount; i++) {
                          bitsDecoded[i] = zeroBitPlanes;
                        }
                      }
                      this.bitsDecoded = bitsDecoded;
                      this.reset();
                    }
                    BitModel2.prototype = { setDecoder: function BitModel_setDecoder(decoder) {
                      this.decoder = decoder;
                    }, reset: function BitModel_reset() {
                      this.contexts = new Int8Array(19);
                      this.contexts[0] = 4 << 1 | 0;
                      this.contexts[UNIFORM_CONTEXT] = 46 << 1 | 0;
                      this.contexts[RUNLENGTH_CONTEXT] = 3 << 1 | 0;
                    }, setNeighborsSignificance: function BitModel_setNeighborsSignificance(row, column, index) {
                      var neighborsSignificance = this.neighborsSignificance;
                      var width = this.width, height = this.height;
                      var left = column > 0;
                      var right = column + 1 < width;
                      var i;
                      if (row > 0) {
                        i = index - width;
                        if (left) {
                          neighborsSignificance[i - 1] += 16;
                        }
                        if (right) {
                          neighborsSignificance[i + 1] += 16;
                        }
                        neighborsSignificance[i] += 4;
                      }
                      if (row + 1 < height) {
                        i = index + width;
                        if (left) {
                          neighborsSignificance[i - 1] += 16;
                        }
                        if (right) {
                          neighborsSignificance[i + 1] += 16;
                        }
                        neighborsSignificance[i] += 4;
                      }
                      if (left) {
                        neighborsSignificance[index - 1] += 1;
                      }
                      if (right) {
                        neighborsSignificance[index + 1] += 1;
                      }
                      neighborsSignificance[index] |= 128;
                    }, runSignificancePropagationPass: function BitModel_runSignificancePropagationPass() {
                      var decoder = this.decoder;
                      var width = this.width, height = this.height;
                      var coefficentsMagnitude = this.coefficentsMagnitude;
                      var coefficentsSign = this.coefficentsSign;
                      var neighborsSignificance = this.neighborsSignificance;
                      var processingFlags = this.processingFlags;
                      var contexts = this.contexts;
                      var labels = this.contextLabelTable;
                      var bitsDecoded = this.bitsDecoded;
                      var processedInverseMask = ~1;
                      var processedMask = 1;
                      var firstMagnitudeBitMask = 2;
                      for (var i0 = 0; i0 < height; i0 += 4) {
                        for (var j = 0; j < width; j++) {
                          var index = i0 * width + j;
                          for (var i1 = 0; i1 < 4; i1++, index += width) {
                            var i = i0 + i1;
                            if (i >= height) {
                              break;
                            }
                            processingFlags[index] &= processedInverseMask;
                            if (coefficentsMagnitude[index] || !neighborsSignificance[index]) {
                              continue;
                            }
                            var contextLabel = labels[neighborsSignificance[index]];
                            var decision = decoder.readBit(contexts, contextLabel);
                            if (decision) {
                              var sign = this.decodeSignBit(i, j, index);
                              coefficentsSign[index] = sign;
                              coefficentsMagnitude[index] = 1;
                              this.setNeighborsSignificance(i, j, index);
                              processingFlags[index] |= firstMagnitudeBitMask;
                            }
                            bitsDecoded[index]++;
                            processingFlags[index] |= processedMask;
                          }
                        }
                      }
                    }, decodeSignBit: function BitModel_decodeSignBit(row, column, index) {
                      var width = this.width, height = this.height;
                      var coefficentsMagnitude = this.coefficentsMagnitude;
                      var coefficentsSign = this.coefficentsSign;
                      var contribution, sign0, sign1, significance1;
                      var contextLabel, decoded;
                      significance1 = column > 0 && coefficentsMagnitude[index - 1] !== 0;
                      if (column + 1 < width && coefficentsMagnitude[index + 1] !== 0) {
                        sign1 = coefficentsSign[index + 1];
                        if (significance1) {
                          sign0 = coefficentsSign[index - 1];
                          contribution = 1 - sign1 - sign0;
                        } else {
                          contribution = 1 - sign1 - sign1;
                        }
                      } else if (significance1) {
                        sign0 = coefficentsSign[index - 1];
                        contribution = 1 - sign0 - sign0;
                      } else {
                        contribution = 0;
                      }
                      var horizontalContribution = 3 * contribution;
                      significance1 = row > 0 && coefficentsMagnitude[index - width] !== 0;
                      if (row + 1 < height && coefficentsMagnitude[index + width] !== 0) {
                        sign1 = coefficentsSign[index + width];
                        if (significance1) {
                          sign0 = coefficentsSign[index - width];
                          contribution = 1 - sign1 - sign0 + horizontalContribution;
                        } else {
                          contribution = 1 - sign1 - sign1 + horizontalContribution;
                        }
                      } else if (significance1) {
                        sign0 = coefficentsSign[index - width];
                        contribution = 1 - sign0 - sign0 + horizontalContribution;
                      } else {
                        contribution = horizontalContribution;
                      }
                      if (contribution >= 0) {
                        contextLabel = 9 + contribution;
                        decoded = this.decoder.readBit(this.contexts, contextLabel);
                      } else {
                        contextLabel = 9 - contribution;
                        decoded = this.decoder.readBit(this.contexts, contextLabel) ^ 1;
                      }
                      return decoded;
                    }, runMagnitudeRefinementPass: function BitModel_runMagnitudeRefinementPass() {
                      var decoder = this.decoder;
                      var width = this.width, height = this.height;
                      var coefficentsMagnitude = this.coefficentsMagnitude;
                      var neighborsSignificance = this.neighborsSignificance;
                      var contexts = this.contexts;
                      var bitsDecoded = this.bitsDecoded;
                      var processingFlags = this.processingFlags;
                      var processedMask = 1;
                      var firstMagnitudeBitMask = 2;
                      var length = width * height;
                      var width4 = width * 4;
                      for (var index0 = 0, indexNext; index0 < length; index0 = indexNext) {
                        indexNext = Math.min(length, index0 + width4);
                        for (var j = 0; j < width; j++) {
                          for (var index = index0 + j; index < indexNext; index += width) {
                            if (!coefficentsMagnitude[index] || (processingFlags[index] & processedMask) !== 0) {
                              continue;
                            }
                            var contextLabel = 16;
                            if ((processingFlags[index] & firstMagnitudeBitMask) !== 0) {
                              processingFlags[index] ^= firstMagnitudeBitMask;
                              var significance = neighborsSignificance[index] & 127;
                              contextLabel = significance === 0 ? 15 : 14;
                            }
                            var bit = decoder.readBit(contexts, contextLabel);
                            coefficentsMagnitude[index] = coefficentsMagnitude[index] << 1 | bit;
                            bitsDecoded[index]++;
                            processingFlags[index] |= processedMask;
                          }
                        }
                      }
                    }, runCleanupPass: function BitModel_runCleanupPass() {
                      var decoder = this.decoder;
                      var width = this.width, height = this.height;
                      var neighborsSignificance = this.neighborsSignificance;
                      var coefficentsMagnitude = this.coefficentsMagnitude;
                      var coefficentsSign = this.coefficentsSign;
                      var contexts = this.contexts;
                      var labels = this.contextLabelTable;
                      var bitsDecoded = this.bitsDecoded;
                      var processingFlags = this.processingFlags;
                      var processedMask = 1;
                      var firstMagnitudeBitMask = 2;
                      var oneRowDown = width;
                      var twoRowsDown = width * 2;
                      var threeRowsDown = width * 3;
                      var iNext;
                      for (var i0 = 0; i0 < height; i0 = iNext) {
                        iNext = Math.min(i0 + 4, height);
                        var indexBase = i0 * width;
                        var checkAllEmpty = i0 + 3 < height;
                        for (var j = 0; j < width; j++) {
                          var index0 = indexBase + j;
                          var allEmpty = checkAllEmpty && processingFlags[index0] === 0 && processingFlags[index0 + oneRowDown] === 0 && processingFlags[index0 + twoRowsDown] === 0 && processingFlags[index0 + threeRowsDown] === 0 && neighborsSignificance[index0] === 0 && neighborsSignificance[index0 + oneRowDown] === 0 && neighborsSignificance[index0 + twoRowsDown] === 0 && neighborsSignificance[index0 + threeRowsDown] === 0;
                          var i1 = 0, index = index0;
                          var i = i0, sign;
                          if (allEmpty) {
                            var hasSignificantCoefficent = decoder.readBit(contexts, RUNLENGTH_CONTEXT);
                            if (!hasSignificantCoefficent) {
                              bitsDecoded[index0]++;
                              bitsDecoded[index0 + oneRowDown]++;
                              bitsDecoded[index0 + twoRowsDown]++;
                              bitsDecoded[index0 + threeRowsDown]++;
                              continue;
                            }
                            i1 = decoder.readBit(contexts, UNIFORM_CONTEXT) << 1 | decoder.readBit(contexts, UNIFORM_CONTEXT);
                            if (i1 !== 0) {
                              i = i0 + i1;
                              index += i1 * width;
                            }
                            sign = this.decodeSignBit(i, j, index);
                            coefficentsSign[index] = sign;
                            coefficentsMagnitude[index] = 1;
                            this.setNeighborsSignificance(i, j, index);
                            processingFlags[index] |= firstMagnitudeBitMask;
                            index = index0;
                            for (var i2 = i0; i2 <= i; i2++, index += width) {
                              bitsDecoded[index]++;
                            }
                            i1++;
                          }
                          for (i = i0 + i1; i < iNext; i++, index += width) {
                            if (coefficentsMagnitude[index] || (processingFlags[index] & processedMask) !== 0) {
                              continue;
                            }
                            var contextLabel = labels[neighborsSignificance[index]];
                            var decision = decoder.readBit(contexts, contextLabel);
                            if (decision === 1) {
                              sign = this.decodeSignBit(i, j, index);
                              coefficentsSign[index] = sign;
                              coefficentsMagnitude[index] = 1;
                              this.setNeighborsSignificance(i, j, index);
                              processingFlags[index] |= firstMagnitudeBitMask;
                            }
                            bitsDecoded[index]++;
                          }
                        }
                      }
                    }, checkSegmentationSymbol: function BitModel_checkSegmentationSymbol() {
                      var decoder = this.decoder;
                      var contexts = this.contexts;
                      var symbol = decoder.readBit(contexts, UNIFORM_CONTEXT) << 3 | decoder.readBit(contexts, UNIFORM_CONTEXT) << 2 | decoder.readBit(contexts, UNIFORM_CONTEXT) << 1 | decoder.readBit(contexts, UNIFORM_CONTEXT);
                      if (symbol !== 10) {
                        throw new JpxError("Invalid segmentation symbol");
                      }
                    } };
                    return BitModel2;
                  }();
                  var Transform = function TransformClosure() {
                    function Transform2() {
                    }
                    Transform2.prototype.calculate = function transformCalculate(subbands, u0, v0) {
                      var ll = subbands[0];
                      for (var i = 1, ii = subbands.length; i < ii; i++) {
                        ll = this.iterate(ll, subbands[i], u0, v0);
                      }
                      return ll;
                    };
                    Transform2.prototype.extend = function extend(buffer, offset, size) {
                      var i1 = offset - 1, j1 = offset + 1;
                      var i2 = offset + size - 2, j2 = offset + size;
                      buffer[i1--] = buffer[j1++];
                      buffer[j2++] = buffer[i2--];
                      buffer[i1--] = buffer[j1++];
                      buffer[j2++] = buffer[i2--];
                      buffer[i1--] = buffer[j1++];
                      buffer[j2++] = buffer[i2--];
                      buffer[i1] = buffer[j1];
                      buffer[j2] = buffer[i2];
                    };
                    Transform2.prototype.iterate = function Transform_iterate(ll, hl_lh_hh, u0, v0) {
                      var llWidth = ll.width, llHeight = ll.height, llItems = ll.items;
                      var width = hl_lh_hh.width;
                      var height = hl_lh_hh.height;
                      var items = hl_lh_hh.items;
                      var i, j, k, l, u, v;
                      for (k = 0, i = 0; i < llHeight; i++) {
                        l = i * 2 * width;
                        for (j = 0; j < llWidth; j++, k++, l += 2) {
                          items[l] = llItems[k];
                        }
                      }
                      llItems = ll.items = null;
                      var bufferPadding = 4;
                      var rowBuffer = new Float32Array(width + 2 * bufferPadding);
                      if (width === 1) {
                        if ((u0 & 1) !== 0) {
                          for (v = 0, k = 0; v < height; v++, k += width) {
                            items[k] *= 0.5;
                          }
                        }
                      } else {
                        for (v = 0, k = 0; v < height; v++, k += width) {
                          rowBuffer.set(items.subarray(k, k + width), bufferPadding);
                          this.extend(rowBuffer, bufferPadding, width);
                          this.filter(rowBuffer, bufferPadding, width);
                          items.set(rowBuffer.subarray(bufferPadding, bufferPadding + width), k);
                        }
                      }
                      var numBuffers = 16;
                      var colBuffers = [];
                      for (i = 0; i < numBuffers; i++) {
                        colBuffers.push(new Float32Array(height + 2 * bufferPadding));
                      }
                      var b, currentBuffer = 0;
                      ll = bufferPadding + height;
                      if (height === 1) {
                        if ((v0 & 1) !== 0) {
                          for (u = 0; u < width; u++) {
                            items[u] *= 0.5;
                          }
                        }
                      } else {
                        for (u = 0; u < width; u++) {
                          if (currentBuffer === 0) {
                            numBuffers = Math.min(width - u, numBuffers);
                            for (k = u, l = bufferPadding; l < ll; k += width, l++) {
                              for (b = 0; b < numBuffers; b++) {
                                colBuffers[b][l] = items[k + b];
                              }
                            }
                            currentBuffer = numBuffers;
                          }
                          currentBuffer--;
                          var buffer = colBuffers[currentBuffer];
                          this.extend(buffer, bufferPadding, height);
                          this.filter(buffer, bufferPadding, height);
                          if (currentBuffer === 0) {
                            k = u - numBuffers + 1;
                            for (l = bufferPadding; l < ll; k += width, l++) {
                              for (b = 0; b < numBuffers; b++) {
                                items[k + b] = colBuffers[b][l];
                              }
                            }
                          }
                        }
                      }
                      return { width, height, items };
                    };
                    return Transform2;
                  }();
                  var IrreversibleTransform = function IrreversibleTransformClosure() {
                    function IrreversibleTransform2() {
                      Transform.call(this);
                    }
                    IrreversibleTransform2.prototype = Object.create(Transform.prototype);
                    IrreversibleTransform2.prototype.filter = function irreversibleTransformFilter(x, offset, length) {
                      var len = length >> 1;
                      offset = offset | 0;
                      var j, n, current, next;
                      var alpha = -1.586134342059924;
                      var beta = -0.052980118572961;
                      var gamma = 0.882911075530934;
                      var delta = 0.443506852043971;
                      var K = 1.230174104914001;
                      var K_ = 1 / K;
                      j = offset - 3;
                      for (n = len + 4; n--; j += 2) {
                        x[j] *= K_;
                      }
                      j = offset - 2;
                      current = delta * x[j - 1];
                      for (n = len + 3; n--; j += 2) {
                        next = delta * x[j + 1];
                        x[j] = K * x[j] - current - next;
                        if (n--) {
                          j += 2;
                          current = delta * x[j + 1];
                          x[j] = K * x[j] - current - next;
                        } else {
                          break;
                        }
                      }
                      j = offset - 1;
                      current = gamma * x[j - 1];
                      for (n = len + 2; n--; j += 2) {
                        next = gamma * x[j + 1];
                        x[j] -= current + next;
                        if (n--) {
                          j += 2;
                          current = gamma * x[j + 1];
                          x[j] -= current + next;
                        } else {
                          break;
                        }
                      }
                      j = offset;
                      current = beta * x[j - 1];
                      for (n = len + 1; n--; j += 2) {
                        next = beta * x[j + 1];
                        x[j] -= current + next;
                        if (n--) {
                          j += 2;
                          current = beta * x[j + 1];
                          x[j] -= current + next;
                        } else {
                          break;
                        }
                      }
                      if (len !== 0) {
                        j = offset + 1;
                        current = alpha * x[j - 1];
                        for (n = len; n--; j += 2) {
                          next = alpha * x[j + 1];
                          x[j] -= current + next;
                          if (n--) {
                            j += 2;
                            current = alpha * x[j + 1];
                            x[j] -= current + next;
                          } else {
                            break;
                          }
                        }
                      }
                    };
                    return IrreversibleTransform2;
                  }();
                  var ReversibleTransform = function ReversibleTransformClosure() {
                    function ReversibleTransform2() {
                      Transform.call(this);
                    }
                    ReversibleTransform2.prototype = Object.create(Transform.prototype);
                    ReversibleTransform2.prototype.filter = function reversibleTransformFilter(x, offset, length) {
                      var len = length >> 1;
                      offset = offset | 0;
                      var j, n;
                      for (j = offset, n = len + 1; n--; j += 2) {
                        x[j] -= x[j - 1] + x[j + 1] + 2 >> 2;
                      }
                      for (j = offset + 1, n = len; n--; j += 2) {
                        x[j] += x[j - 1] + x[j + 1] >> 1;
                      }
                    };
                    return ReversibleTransform2;
                  }();
                  return JpxImage2;
                }();
                exports2.JpxImage = JpxImage;
              }, function(module3, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.calculateSHA512 = exports2.calculateSHA384 = exports2.calculateSHA256 = exports2.calculateMD5 = exports2.PDF20 = exports2.PDF17 = exports2.CipherTransformFactory = exports2.ARCFourCipher = exports2.AES256Cipher = exports2.AES128Cipher = void 0;
                var _util2 = __w_pdfjs_require__2(2);
                var _primitives = __w_pdfjs_require__2(4);
                var _stream = __w_pdfjs_require__2(11);
                var ARCFourCipher = function ARCFourCipherClosure() {
                  function ARCFourCipher2(key) {
                    this.a = 0;
                    this.b = 0;
                    var s = new Uint8Array(256);
                    var i, j = 0, tmp, keyLength = key.length;
                    for (i = 0; i < 256; ++i) {
                      s[i] = i;
                    }
                    for (i = 0; i < 256; ++i) {
                      tmp = s[i];
                      j = j + tmp + key[i % keyLength] & 255;
                      s[i] = s[j];
                      s[j] = tmp;
                    }
                    this.s = s;
                  }
                  ARCFourCipher2.prototype = { encryptBlock: function ARCFourCipher_encryptBlock(data) {
                    var i, n = data.length, tmp, tmp2;
                    var a = this.a, b = this.b, s = this.s;
                    var output = new Uint8Array(n);
                    for (i = 0; i < n; ++i) {
                      a = a + 1 & 255;
                      tmp = s[a];
                      b = b + tmp & 255;
                      tmp2 = s[b];
                      s[a] = tmp2;
                      s[b] = tmp;
                      output[i] = data[i] ^ s[tmp + tmp2 & 255];
                    }
                    this.a = a;
                    this.b = b;
                    return output;
                  } };
                  ARCFourCipher2.prototype.decryptBlock = ARCFourCipher2.prototype.encryptBlock;
                  return ARCFourCipher2;
                }();
                exports2.ARCFourCipher = ARCFourCipher;
                var calculateMD5 = function calculateMD5Closure() {
                  var r = new Uint8Array([7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]);
                  var k = new Int32Array([-680876936, -389564586, 606105819, -1044525330, -176418897, 1200080426, -1473231341, -45705983, 1770035416, -1958414417, -42063, -1990404162, 1804603682, -40341101, -1502002290, 1236535329, -165796510, -1069501632, 643717713, -373897302, -701558691, 38016083, -660478335, -405537848, 568446438, -1019803690, -187363961, 1163531501, -1444681467, -51403784, 1735328473, -1926607734, -378558, -2022574463, 1839030562, -35309556, -1530992060, 1272893353, -155497632, -1094730640, 681279174, -358537222, -722521979, 76029189, -640364487, -421815835, 530742520, -995338651, -198630844, 1126891415, -1416354905, -57434055, 1700485571, -1894986606, -1051523, -2054922799, 1873313359, -30611744, -1560198380, 1309151649, -145523070, -1120210379, 718787259, -343485551]);
                  function hash(data, offset, length) {
                    var h0 = 1732584193, h1 = -271733879, h2 = -1732584194, h3 = 271733878;
                    var paddedLength = length + 72 & ~63;
                    var padded = new Uint8Array(paddedLength);
                    var i, j, n;
                    for (i = 0; i < length; ++i) {
                      padded[i] = data[offset++];
                    }
                    padded[i++] = 128;
                    n = paddedLength - 8;
                    while (i < n) {
                      padded[i++] = 0;
                    }
                    padded[i++] = length << 3 & 255;
                    padded[i++] = length >> 5 & 255;
                    padded[i++] = length >> 13 & 255;
                    padded[i++] = length >> 21 & 255;
                    padded[i++] = length >>> 29 & 255;
                    padded[i++] = 0;
                    padded[i++] = 0;
                    padded[i++] = 0;
                    var w = new Int32Array(16);
                    for (i = 0; i < paddedLength; ) {
                      for (j = 0; j < 16; ++j, i += 4) {
                        w[j] = padded[i] | padded[i + 1] << 8 | padded[i + 2] << 16 | padded[i + 3] << 24;
                      }
                      var a = h0, b = h1, c = h2, d = h3, f, g;
                      for (j = 0; j < 64; ++j) {
                        if (j < 16) {
                          f = b & c | ~b & d;
                          g = j;
                        } else if (j < 32) {
                          f = d & b | ~d & c;
                          g = 5 * j + 1 & 15;
                        } else if (j < 48) {
                          f = b ^ c ^ d;
                          g = 3 * j + 5 & 15;
                        } else {
                          f = c ^ (b | ~d);
                          g = 7 * j & 15;
                        }
                        var tmp = d, rotateArg = a + f + k[j] + w[g] | 0, rotate = r[j];
                        d = c;
                        c = b;
                        b = b + (rotateArg << rotate | rotateArg >>> 32 - rotate) | 0;
                        a = tmp;
                      }
                      h0 = h0 + a | 0;
                      h1 = h1 + b | 0;
                      h2 = h2 + c | 0;
                      h3 = h3 + d | 0;
                    }
                    return new Uint8Array([h0 & 255, h0 >> 8 & 255, h0 >> 16 & 255, h0 >>> 24 & 255, h1 & 255, h1 >> 8 & 255, h1 >> 16 & 255, h1 >>> 24 & 255, h2 & 255, h2 >> 8 & 255, h2 >> 16 & 255, h2 >>> 24 & 255, h3 & 255, h3 >> 8 & 255, h3 >> 16 & 255, h3 >>> 24 & 255]);
                  }
                  return hash;
                }();
                exports2.calculateMD5 = calculateMD5;
                var Word64 = function Word64Closure() {
                  function Word642(highInteger, lowInteger) {
                    this.high = highInteger | 0;
                    this.low = lowInteger | 0;
                  }
                  Word642.prototype = { and: function Word64_and(word) {
                    this.high &= word.high;
                    this.low &= word.low;
                  }, xor: function Word64_xor(word) {
                    this.high ^= word.high;
                    this.low ^= word.low;
                  }, or: function Word64_or(word) {
                    this.high |= word.high;
                    this.low |= word.low;
                  }, shiftRight: function Word64_shiftRight(places) {
                    if (places >= 32) {
                      this.low = this.high >>> places - 32 | 0;
                      this.high = 0;
                    } else {
                      this.low = this.low >>> places | this.high << 32 - places;
                      this.high = this.high >>> places | 0;
                    }
                  }, shiftLeft: function Word64_shiftLeft(places) {
                    if (places >= 32) {
                      this.high = this.low << places - 32;
                      this.low = 0;
                    } else {
                      this.high = this.high << places | this.low >>> 32 - places;
                      this.low = this.low << places;
                    }
                  }, rotateRight: function Word64_rotateRight(places) {
                    var low, high;
                    if (places & 32) {
                      high = this.low;
                      low = this.high;
                    } else {
                      low = this.low;
                      high = this.high;
                    }
                    places &= 31;
                    this.low = low >>> places | high << 32 - places;
                    this.high = high >>> places | low << 32 - places;
                  }, not: function Word64_not() {
                    this.high = ~this.high;
                    this.low = ~this.low;
                  }, add: function Word64_add(word) {
                    var lowAdd = (this.low >>> 0) + (word.low >>> 0);
                    var highAdd = (this.high >>> 0) + (word.high >>> 0);
                    if (lowAdd > 4294967295) {
                      highAdd += 1;
                    }
                    this.low = lowAdd | 0;
                    this.high = highAdd | 0;
                  }, copyTo: function Word64_copyTo(bytes, offset) {
                    bytes[offset] = this.high >>> 24 & 255;
                    bytes[offset + 1] = this.high >> 16 & 255;
                    bytes[offset + 2] = this.high >> 8 & 255;
                    bytes[offset + 3] = this.high & 255;
                    bytes[offset + 4] = this.low >>> 24 & 255;
                    bytes[offset + 5] = this.low >> 16 & 255;
                    bytes[offset + 6] = this.low >> 8 & 255;
                    bytes[offset + 7] = this.low & 255;
                  }, assign: function Word64_assign(word) {
                    this.high = word.high;
                    this.low = word.low;
                  } };
                  return Word642;
                }();
                var calculateSHA256 = function calculateSHA256Closure() {
                  function rotr(x, n) {
                    return x >>> n | x << 32 - n;
                  }
                  function ch(x, y, z) {
                    return x & y ^ ~x & z;
                  }
                  function maj(x, y, z) {
                    return x & y ^ x & z ^ y & z;
                  }
                  function sigma(x) {
                    return rotr(x, 2) ^ rotr(x, 13) ^ rotr(x, 22);
                  }
                  function sigmaPrime(x) {
                    return rotr(x, 6) ^ rotr(x, 11) ^ rotr(x, 25);
                  }
                  function littleSigma(x) {
                    return rotr(x, 7) ^ rotr(x, 18) ^ x >>> 3;
                  }
                  function littleSigmaPrime(x) {
                    return rotr(x, 17) ^ rotr(x, 19) ^ x >>> 10;
                  }
                  var k = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
                  function hash(data, offset, length) {
                    var h0 = 1779033703, h1 = 3144134277, h2 = 1013904242, h3 = 2773480762, h4 = 1359893119, h5 = 2600822924, h6 = 528734635, h7 = 1541459225;
                    var paddedLength = Math.ceil((length + 9) / 64) * 64;
                    var padded = new Uint8Array(paddedLength);
                    var i, j, n;
                    for (i = 0; i < length; ++i) {
                      padded[i] = data[offset++];
                    }
                    padded[i++] = 128;
                    n = paddedLength - 8;
                    while (i < n) {
                      padded[i++] = 0;
                    }
                    padded[i++] = 0;
                    padded[i++] = 0;
                    padded[i++] = 0;
                    padded[i++] = length >>> 29 & 255;
                    padded[i++] = length >> 21 & 255;
                    padded[i++] = length >> 13 & 255;
                    padded[i++] = length >> 5 & 255;
                    padded[i++] = length << 3 & 255;
                    var w = new Uint32Array(64);
                    for (i = 0; i < paddedLength; ) {
                      for (j = 0; j < 16; ++j) {
                        w[j] = padded[i] << 24 | padded[i + 1] << 16 | padded[i + 2] << 8 | padded[i + 3];
                        i += 4;
                      }
                      for (j = 16; j < 64; ++j) {
                        w[j] = littleSigmaPrime(w[j - 2]) + w[j - 7] + littleSigma(w[j - 15]) + w[j - 16] | 0;
                      }
                      var a = h0, b = h1, c = h2, d = h3, e = h4, f = h5, g = h6, h = h7, t1, t2;
                      for (j = 0; j < 64; ++j) {
                        t1 = h + sigmaPrime(e) + ch(e, f, g) + k[j] + w[j];
                        t2 = sigma(a) + maj(a, b, c);
                        h = g;
                        g = f;
                        f = e;
                        e = d + t1 | 0;
                        d = c;
                        c = b;
                        b = a;
                        a = t1 + t2 | 0;
                      }
                      h0 = h0 + a | 0;
                      h1 = h1 + b | 0;
                      h2 = h2 + c | 0;
                      h3 = h3 + d | 0;
                      h4 = h4 + e | 0;
                      h5 = h5 + f | 0;
                      h6 = h6 + g | 0;
                      h7 = h7 + h | 0;
                    }
                    return new Uint8Array([h0 >> 24 & 255, h0 >> 16 & 255, h0 >> 8 & 255, h0 & 255, h1 >> 24 & 255, h1 >> 16 & 255, h1 >> 8 & 255, h1 & 255, h2 >> 24 & 255, h2 >> 16 & 255, h2 >> 8 & 255, h2 & 255, h3 >> 24 & 255, h3 >> 16 & 255, h3 >> 8 & 255, h3 & 255, h4 >> 24 & 255, h4 >> 16 & 255, h4 >> 8 & 255, h4 & 255, h5 >> 24 & 255, h5 >> 16 & 255, h5 >> 8 & 255, h5 & 255, h6 >> 24 & 255, h6 >> 16 & 255, h6 >> 8 & 255, h6 & 255, h7 >> 24 & 255, h7 >> 16 & 255, h7 >> 8 & 255, h7 & 255]);
                  }
                  return hash;
                }();
                exports2.calculateSHA256 = calculateSHA256;
                var calculateSHA512 = function calculateSHA512Closure() {
                  function ch(result, x, y, z, tmp) {
                    result.assign(x);
                    result.and(y);
                    tmp.assign(x);
                    tmp.not();
                    tmp.and(z);
                    result.xor(tmp);
                  }
                  function maj(result, x, y, z, tmp) {
                    result.assign(x);
                    result.and(y);
                    tmp.assign(x);
                    tmp.and(z);
                    result.xor(tmp);
                    tmp.assign(y);
                    tmp.and(z);
                    result.xor(tmp);
                  }
                  function sigma(result, x, tmp) {
                    result.assign(x);
                    result.rotateRight(28);
                    tmp.assign(x);
                    tmp.rotateRight(34);
                    result.xor(tmp);
                    tmp.assign(x);
                    tmp.rotateRight(39);
                    result.xor(tmp);
                  }
                  function sigmaPrime(result, x, tmp) {
                    result.assign(x);
                    result.rotateRight(14);
                    tmp.assign(x);
                    tmp.rotateRight(18);
                    result.xor(tmp);
                    tmp.assign(x);
                    tmp.rotateRight(41);
                    result.xor(tmp);
                  }
                  function littleSigma(result, x, tmp) {
                    result.assign(x);
                    result.rotateRight(1);
                    tmp.assign(x);
                    tmp.rotateRight(8);
                    result.xor(tmp);
                    tmp.assign(x);
                    tmp.shiftRight(7);
                    result.xor(tmp);
                  }
                  function littleSigmaPrime(result, x, tmp) {
                    result.assign(x);
                    result.rotateRight(19);
                    tmp.assign(x);
                    tmp.rotateRight(61);
                    result.xor(tmp);
                    tmp.assign(x);
                    tmp.shiftRight(6);
                    result.xor(tmp);
                  }
                  var k = [new Word64(1116352408, 3609767458), new Word64(1899447441, 602891725), new Word64(3049323471, 3964484399), new Word64(3921009573, 2173295548), new Word64(961987163, 4081628472), new Word64(1508970993, 3053834265), new Word64(2453635748, 2937671579), new Word64(2870763221, 3664609560), new Word64(3624381080, 2734883394), new Word64(310598401, 1164996542), new Word64(607225278, 1323610764), new Word64(1426881987, 3590304994), new Word64(1925078388, 4068182383), new Word64(2162078206, 991336113), new Word64(2614888103, 633803317), new Word64(3248222580, 3479774868), new Word64(3835390401, 2666613458), new Word64(4022224774, 944711139), new Word64(264347078, 2341262773), new Word64(604807628, 2007800933), new Word64(770255983, 1495990901), new Word64(1249150122, 1856431235), new Word64(1555081692, 3175218132), new Word64(1996064986, 2198950837), new Word64(2554220882, 3999719339), new Word64(2821834349, 766784016), new Word64(2952996808, 2566594879), new Word64(3210313671, 3203337956), new Word64(3336571891, 1034457026), new Word64(3584528711, 2466948901), new Word64(113926993, 3758326383), new Word64(338241895, 168717936), new Word64(666307205, 1188179964), new Word64(773529912, 1546045734), new Word64(1294757372, 1522805485), new Word64(1396182291, 2643833823), new Word64(1695183700, 2343527390), new Word64(1986661051, 1014477480), new Word64(2177026350, 1206759142), new Word64(2456956037, 344077627), new Word64(2730485921, 1290863460), new Word64(2820302411, 3158454273), new Word64(3259730800, 3505952657), new Word64(3345764771, 106217008), new Word64(3516065817, 3606008344), new Word64(3600352804, 1432725776), new Word64(4094571909, 1467031594), new Word64(275423344, 851169720), new Word64(430227734, 3100823752), new Word64(506948616, 1363258195), new Word64(659060556, 3750685593), new Word64(883997877, 3785050280), new Word64(958139571, 3318307427), new Word64(1322822218, 3812723403), new Word64(1537002063, 2003034995), new Word64(1747873779, 3602036899), new Word64(1955562222, 1575990012), new Word64(2024104815, 1125592928), new Word64(2227730452, 2716904306), new Word64(2361852424, 442776044), new Word64(2428436474, 593698344), new Word64(2756734187, 3733110249), new Word64(3204031479, 2999351573), new Word64(3329325298, 3815920427), new Word64(3391569614, 3928383900), new Word64(3515267271, 566280711), new Word64(3940187606, 3454069534), new Word64(4118630271, 4000239992), new Word64(116418474, 1914138554), new Word64(174292421, 2731055270), new Word64(289380356, 3203993006), new Word64(460393269, 320620315), new Word64(685471733, 587496836), new Word64(852142971, 1086792851), new Word64(1017036298, 365543100), new Word64(1126000580, 2618297676), new Word64(1288033470, 3409855158), new Word64(1501505948, 4234509866), new Word64(1607167915, 987167468), new Word64(1816402316, 1246189591)];
                  function hash(data, offset, length, mode384) {
                    mode384 = !!mode384;
                    var h0, h1, h2, h3, h4, h5, h6, h7;
                    if (!mode384) {
                      h0 = new Word64(1779033703, 4089235720);
                      h1 = new Word64(3144134277, 2227873595);
                      h2 = new Word64(1013904242, 4271175723);
                      h3 = new Word64(2773480762, 1595750129);
                      h4 = new Word64(1359893119, 2917565137);
                      h5 = new Word64(2600822924, 725511199);
                      h6 = new Word64(528734635, 4215389547);
                      h7 = new Word64(1541459225, 327033209);
                    } else {
                      h0 = new Word64(3418070365, 3238371032);
                      h1 = new Word64(1654270250, 914150663);
                      h2 = new Word64(2438529370, 812702999);
                      h3 = new Word64(355462360, 4144912697);
                      h4 = new Word64(1731405415, 4290775857);
                      h5 = new Word64(2394180231, 1750603025);
                      h6 = new Word64(3675008525, 1694076839);
                      h7 = new Word64(1203062813, 3204075428);
                    }
                    var paddedLength = Math.ceil((length + 17) / 128) * 128;
                    var padded = new Uint8Array(paddedLength);
                    var i, j, n;
                    for (i = 0; i < length; ++i) {
                      padded[i] = data[offset++];
                    }
                    padded[i++] = 128;
                    n = paddedLength - 16;
                    while (i < n) {
                      padded[i++] = 0;
                    }
                    padded[i++] = 0;
                    padded[i++] = 0;
                    padded[i++] = 0;
                    padded[i++] = 0;
                    padded[i++] = 0;
                    padded[i++] = 0;
                    padded[i++] = 0;
                    padded[i++] = 0;
                    padded[i++] = 0;
                    padded[i++] = 0;
                    padded[i++] = 0;
                    padded[i++] = length >>> 29 & 255;
                    padded[i++] = length >> 21 & 255;
                    padded[i++] = length >> 13 & 255;
                    padded[i++] = length >> 5 & 255;
                    padded[i++] = length << 3 & 255;
                    var w = new Array(80);
                    for (i = 0; i < 80; i++) {
                      w[i] = new Word64(0, 0);
                    }
                    var a = new Word64(0, 0), b = new Word64(0, 0), c = new Word64(0, 0);
                    var d = new Word64(0, 0), e = new Word64(0, 0), f = new Word64(0, 0);
                    var g = new Word64(0, 0), h = new Word64(0, 0);
                    var t1 = new Word64(0, 0), t2 = new Word64(0, 0);
                    var tmp1 = new Word64(0, 0), tmp2 = new Word64(0, 0), tmp3;
                    for (i = 0; i < paddedLength; ) {
                      for (j = 0; j < 16; ++j) {
                        w[j].high = padded[i] << 24 | padded[i + 1] << 16 | padded[i + 2] << 8 | padded[i + 3];
                        w[j].low = padded[i + 4] << 24 | padded[i + 5] << 16 | padded[i + 6] << 8 | padded[i + 7];
                        i += 8;
                      }
                      for (j = 16; j < 80; ++j) {
                        tmp3 = w[j];
                        littleSigmaPrime(tmp3, w[j - 2], tmp2);
                        tmp3.add(w[j - 7]);
                        littleSigma(tmp1, w[j - 15], tmp2);
                        tmp3.add(tmp1);
                        tmp3.add(w[j - 16]);
                      }
                      a.assign(h0);
                      b.assign(h1);
                      c.assign(h2);
                      d.assign(h3);
                      e.assign(h4);
                      f.assign(h5);
                      g.assign(h6);
                      h.assign(h7);
                      for (j = 0; j < 80; ++j) {
                        t1.assign(h);
                        sigmaPrime(tmp1, e, tmp2);
                        t1.add(tmp1);
                        ch(tmp1, e, f, g, tmp2);
                        t1.add(tmp1);
                        t1.add(k[j]);
                        t1.add(w[j]);
                        sigma(t2, a, tmp2);
                        maj(tmp1, a, b, c, tmp2);
                        t2.add(tmp1);
                        tmp3 = h;
                        h = g;
                        g = f;
                        f = e;
                        d.add(t1);
                        e = d;
                        d = c;
                        c = b;
                        b = a;
                        tmp3.assign(t1);
                        tmp3.add(t2);
                        a = tmp3;
                      }
                      h0.add(a);
                      h1.add(b);
                      h2.add(c);
                      h3.add(d);
                      h4.add(e);
                      h5.add(f);
                      h6.add(g);
                      h7.add(h);
                    }
                    var result;
                    if (!mode384) {
                      result = new Uint8Array(64);
                      h0.copyTo(result, 0);
                      h1.copyTo(result, 8);
                      h2.copyTo(result, 16);
                      h3.copyTo(result, 24);
                      h4.copyTo(result, 32);
                      h5.copyTo(result, 40);
                      h6.copyTo(result, 48);
                      h7.copyTo(result, 56);
                    } else {
                      result = new Uint8Array(48);
                      h0.copyTo(result, 0);
                      h1.copyTo(result, 8);
                      h2.copyTo(result, 16);
                      h3.copyTo(result, 24);
                      h4.copyTo(result, 32);
                      h5.copyTo(result, 40);
                    }
                    return result;
                  }
                  return hash;
                }();
                exports2.calculateSHA512 = calculateSHA512;
                var calculateSHA384 = function calculateSHA384Closure() {
                  function hash(data, offset, length) {
                    return calculateSHA512(data, offset, length, true);
                  }
                  return hash;
                }();
                exports2.calculateSHA384 = calculateSHA384;
                var NullCipher = function NullCipherClosure() {
                  function NullCipher2() {
                  }
                  NullCipher2.prototype = { decryptBlock: function NullCipher_decryptBlock(data) {
                    return data;
                  } };
                  return NullCipher2;
                }();
                class AESBaseCipher {
                  constructor() {
                    if (this.constructor === AESBaseCipher) {
                      (0, _util2.unreachable)("Cannot initialize AESBaseCipher.");
                    }
                    this._s = new Uint8Array([99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22]);
                    this._inv_s = new Uint8Array([82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125]);
                    this._mix = new Uint32Array([0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795]);
                    this._mixCol = new Uint8Array(256);
                    for (let i = 0; i < 256; i++) {
                      if (i < 128) {
                        this._mixCol[i] = i << 1;
                      } else {
                        this._mixCol[i] = i << 1 ^ 27;
                      }
                    }
                    this.buffer = new Uint8Array(16);
                    this.bufferPosition = 0;
                  }
                  _expandKey(cipherKey) {
                    (0, _util2.unreachable)("Cannot call `_expandKey` on the base class");
                  }
                  _decrypt(input, key) {
                    let t, u, v;
                    const state = new Uint8Array(16);
                    state.set(input);
                    for (let j = 0, k = this._keySize; j < 16; ++j, ++k) {
                      state[j] ^= key[k];
                    }
                    for (let i = this._cyclesOfRepetition - 1; i >= 1; --i) {
                      t = state[13];
                      state[13] = state[9];
                      state[9] = state[5];
                      state[5] = state[1];
                      state[1] = t;
                      t = state[14];
                      u = state[10];
                      state[14] = state[6];
                      state[10] = state[2];
                      state[6] = t;
                      state[2] = u;
                      t = state[15];
                      u = state[11];
                      v = state[7];
                      state[15] = state[3];
                      state[11] = t;
                      state[7] = u;
                      state[3] = v;
                      for (let j = 0; j < 16; ++j) {
                        state[j] = this._inv_s[state[j]];
                      }
                      for (let j = 0, k = i * 16; j < 16; ++j, ++k) {
                        state[j] ^= key[k];
                      }
                      for (let j = 0; j < 16; j += 4) {
                        const s0 = this._mix[state[j]];
                        const s1 = this._mix[state[j + 1]];
                        const s2 = this._mix[state[j + 2]];
                        const s3 = this._mix[state[j + 3]];
                        t = s0 ^ s1 >>> 8 ^ s1 << 24 ^ s2 >>> 16 ^ s2 << 16 ^ s3 >>> 24 ^ s3 << 8;
                        state[j] = t >>> 24 & 255;
                        state[j + 1] = t >> 16 & 255;
                        state[j + 2] = t >> 8 & 255;
                        state[j + 3] = t & 255;
                      }
                    }
                    t = state[13];
                    state[13] = state[9];
                    state[9] = state[5];
                    state[5] = state[1];
                    state[1] = t;
                    t = state[14];
                    u = state[10];
                    state[14] = state[6];
                    state[10] = state[2];
                    state[6] = t;
                    state[2] = u;
                    t = state[15];
                    u = state[11];
                    v = state[7];
                    state[15] = state[3];
                    state[11] = t;
                    state[7] = u;
                    state[3] = v;
                    for (let j = 0; j < 16; ++j) {
                      state[j] = this._inv_s[state[j]];
                      state[j] ^= key[j];
                    }
                    return state;
                  }
                  _encrypt(input, key) {
                    const s = this._s;
                    let t, u, v;
                    const state = new Uint8Array(16);
                    state.set(input);
                    for (let j = 0; j < 16; ++j) {
                      state[j] ^= key[j];
                    }
                    for (let i = 1; i < this._cyclesOfRepetition; i++) {
                      for (let j = 0; j < 16; ++j) {
                        state[j] = s[state[j]];
                      }
                      v = state[1];
                      state[1] = state[5];
                      state[5] = state[9];
                      state[9] = state[13];
                      state[13] = v;
                      v = state[2];
                      u = state[6];
                      state[2] = state[10];
                      state[6] = state[14];
                      state[10] = v;
                      state[14] = u;
                      v = state[3];
                      u = state[7];
                      t = state[11];
                      state[3] = state[15];
                      state[7] = v;
                      state[11] = u;
                      state[15] = t;
                      for (let j = 0; j < 16; j += 4) {
                        const s0 = state[j + 0];
                        const s1 = state[j + 1];
                        const s2 = state[j + 2];
                        const s3 = state[j + 3];
                        t = s0 ^ s1 ^ s2 ^ s3;
                        state[j + 0] ^= t ^ this._mixCol[s0 ^ s1];
                        state[j + 1] ^= t ^ this._mixCol[s1 ^ s2];
                        state[j + 2] ^= t ^ this._mixCol[s2 ^ s3];
                        state[j + 3] ^= t ^ this._mixCol[s3 ^ s0];
                      }
                      for (let j = 0, k = i * 16; j < 16; ++j, ++k) {
                        state[j] ^= key[k];
                      }
                    }
                    for (let j = 0; j < 16; ++j) {
                      state[j] = s[state[j]];
                    }
                    v = state[1];
                    state[1] = state[5];
                    state[5] = state[9];
                    state[9] = state[13];
                    state[13] = v;
                    v = state[2];
                    u = state[6];
                    state[2] = state[10];
                    state[6] = state[14];
                    state[10] = v;
                    state[14] = u;
                    v = state[3];
                    u = state[7];
                    t = state[11];
                    state[3] = state[15];
                    state[7] = v;
                    state[11] = u;
                    state[15] = t;
                    for (let j = 0, k = this._keySize; j < 16; ++j, ++k) {
                      state[j] ^= key[k];
                    }
                    return state;
                  }
                  _decryptBlock2(data, finalize) {
                    const sourceLength = data.length;
                    let buffer = this.buffer, bufferLength = this.bufferPosition;
                    const result = [];
                    let iv = this.iv;
                    for (let i = 0; i < sourceLength; ++i) {
                      buffer[bufferLength] = data[i];
                      ++bufferLength;
                      if (bufferLength < 16) {
                        continue;
                      }
                      const plain = this._decrypt(buffer, this._key);
                      for (let j = 0; j < 16; ++j) {
                        plain[j] ^= iv[j];
                      }
                      iv = buffer;
                      result.push(plain);
                      buffer = new Uint8Array(16);
                      bufferLength = 0;
                    }
                    this.buffer = buffer;
                    this.bufferLength = bufferLength;
                    this.iv = iv;
                    if (result.length === 0) {
                      return new Uint8Array(0);
                    }
                    let outputLength = 16 * result.length;
                    if (finalize) {
                      const lastBlock = result[result.length - 1];
                      let psLen = lastBlock[15];
                      if (psLen <= 16) {
                        for (let i = 15, ii = 16 - psLen; i >= ii; --i) {
                          if (lastBlock[i] !== psLen) {
                            psLen = 0;
                            break;
                          }
                        }
                        outputLength -= psLen;
                        result[result.length - 1] = lastBlock.subarray(0, 16 - psLen);
                      }
                    }
                    const output = new Uint8Array(outputLength);
                    for (let i = 0, j = 0, ii = result.length; i < ii; ++i, j += 16) {
                      output.set(result[i], j);
                    }
                    return output;
                  }
                  decryptBlock(data, finalize, iv = null) {
                    const sourceLength = data.length;
                    const buffer = this.buffer;
                    let bufferLength = this.bufferPosition;
                    if (iv) {
                      this.iv = iv;
                    } else {
                      for (let i = 0; bufferLength < 16 && i < sourceLength; ++i, ++bufferLength) {
                        buffer[bufferLength] = data[i];
                      }
                      if (bufferLength < 16) {
                        this.bufferLength = bufferLength;
                        return new Uint8Array(0);
                      }
                      this.iv = buffer;
                      data = data.subarray(16);
                    }
                    this.buffer = new Uint8Array(16);
                    this.bufferLength = 0;
                    this.decryptBlock = this._decryptBlock2;
                    return this.decryptBlock(data, finalize);
                  }
                  encrypt(data, iv) {
                    const sourceLength = data.length;
                    let buffer = this.buffer, bufferLength = this.bufferPosition;
                    const result = [];
                    if (!iv) {
                      iv = new Uint8Array(16);
                    }
                    for (let i = 0; i < sourceLength; ++i) {
                      buffer[bufferLength] = data[i];
                      ++bufferLength;
                      if (bufferLength < 16) {
                        continue;
                      }
                      for (let j = 0; j < 16; ++j) {
                        buffer[j] ^= iv[j];
                      }
                      const cipher = this._encrypt(buffer, this._key);
                      iv = cipher;
                      result.push(cipher);
                      buffer = new Uint8Array(16);
                      bufferLength = 0;
                    }
                    this.buffer = buffer;
                    this.bufferLength = bufferLength;
                    this.iv = iv;
                    if (result.length === 0) {
                      return new Uint8Array(0);
                    }
                    const outputLength = 16 * result.length;
                    const output = new Uint8Array(outputLength);
                    for (let i = 0, j = 0, ii = result.length; i < ii; ++i, j += 16) {
                      output.set(result[i], j);
                    }
                    return output;
                  }
                }
                class AES128Cipher extends AESBaseCipher {
                  constructor(key) {
                    super();
                    this._cyclesOfRepetition = 10;
                    this._keySize = 160;
                    this._rcon = new Uint8Array([141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141]);
                    this._key = this._expandKey(key);
                  }
                  _expandKey(cipherKey) {
                    const b = 176;
                    const s = this._s;
                    const rcon = this._rcon;
                    const result = new Uint8Array(b);
                    result.set(cipherKey);
                    for (let j = 16, i = 1; j < b; ++i) {
                      let t1 = result[j - 3];
                      let t2 = result[j - 2];
                      let t3 = result[j - 1];
                      let t4 = result[j - 4];
                      t1 = s[t1];
                      t2 = s[t2];
                      t3 = s[t3];
                      t4 = s[t4];
                      t1 = t1 ^ rcon[i];
                      for (let n = 0; n < 4; ++n) {
                        result[j] = t1 ^= result[j - 16];
                        j++;
                        result[j] = t2 ^= result[j - 16];
                        j++;
                        result[j] = t3 ^= result[j - 16];
                        j++;
                        result[j] = t4 ^= result[j - 16];
                        j++;
                      }
                    }
                    return result;
                  }
                }
                exports2.AES128Cipher = AES128Cipher;
                class AES256Cipher extends AESBaseCipher {
                  constructor(key) {
                    super();
                    this._cyclesOfRepetition = 14;
                    this._keySize = 224;
                    this._key = this._expandKey(key);
                  }
                  _expandKey(cipherKey) {
                    const b = 240;
                    const s = this._s;
                    const result = new Uint8Array(b);
                    result.set(cipherKey);
                    let r = 1;
                    let t1, t2, t3, t4;
                    for (let j = 32, i = 1; j < b; ++i) {
                      if (j % 32 === 16) {
                        t1 = s[t1];
                        t2 = s[t2];
                        t3 = s[t3];
                        t4 = s[t4];
                      } else if (j % 32 === 0) {
                        t1 = result[j - 3];
                        t2 = result[j - 2];
                        t3 = result[j - 1];
                        t4 = result[j - 4];
                        t1 = s[t1];
                        t2 = s[t2];
                        t3 = s[t3];
                        t4 = s[t4];
                        t1 = t1 ^ r;
                        if ((r <<= 1) >= 256) {
                          r = (r ^ 27) & 255;
                        }
                      }
                      for (let n = 0; n < 4; ++n) {
                        result[j] = t1 ^= result[j - 32];
                        j++;
                        result[j] = t2 ^= result[j - 32];
                        j++;
                        result[j] = t3 ^= result[j - 32];
                        j++;
                        result[j] = t4 ^= result[j - 32];
                        j++;
                      }
                    }
                    return result;
                  }
                }
                exports2.AES256Cipher = AES256Cipher;
                var PDF17 = function PDF17Closure() {
                  function compareByteArrays(array1, array2) {
                    if (array1.length !== array2.length) {
                      return false;
                    }
                    for (var i = 0; i < array1.length; i++) {
                      if (array1[i] !== array2[i]) {
                        return false;
                      }
                    }
                    return true;
                  }
                  function PDF172() {
                  }
                  PDF172.prototype = { checkOwnerPassword: function PDF17_checkOwnerPassword(password, ownerValidationSalt, userBytes, ownerPassword) {
                    var hashData = new Uint8Array(password.length + 56);
                    hashData.set(password, 0);
                    hashData.set(ownerValidationSalt, password.length);
                    hashData.set(userBytes, password.length + ownerValidationSalt.length);
                    var result = calculateSHA256(hashData, 0, hashData.length);
                    return compareByteArrays(result, ownerPassword);
                  }, checkUserPassword: function PDF17_checkUserPassword(password, userValidationSalt, userPassword) {
                    var hashData = new Uint8Array(password.length + 8);
                    hashData.set(password, 0);
                    hashData.set(userValidationSalt, password.length);
                    var result = calculateSHA256(hashData, 0, hashData.length);
                    return compareByteArrays(result, userPassword);
                  }, getOwnerKey: function PDF17_getOwnerKey(password, ownerKeySalt, userBytes, ownerEncryption) {
                    var hashData = new Uint8Array(password.length + 56);
                    hashData.set(password, 0);
                    hashData.set(ownerKeySalt, password.length);
                    hashData.set(userBytes, password.length + ownerKeySalt.length);
                    var key = calculateSHA256(hashData, 0, hashData.length);
                    var cipher = new AES256Cipher(key);
                    return cipher.decryptBlock(ownerEncryption, false, new Uint8Array(16));
                  }, getUserKey: function PDF17_getUserKey(password, userKeySalt, userEncryption) {
                    var hashData = new Uint8Array(password.length + 8);
                    hashData.set(password, 0);
                    hashData.set(userKeySalt, password.length);
                    var key = calculateSHA256(hashData, 0, hashData.length);
                    var cipher = new AES256Cipher(key);
                    return cipher.decryptBlock(userEncryption, false, new Uint8Array(16));
                  } };
                  return PDF172;
                }();
                exports2.PDF17 = PDF17;
                var PDF20 = function PDF20Closure() {
                  function concatArrays(array1, array2) {
                    var t = new Uint8Array(array1.length + array2.length);
                    t.set(array1, 0);
                    t.set(array2, array1.length);
                    return t;
                  }
                  function calculatePDF20Hash(password, input, userBytes) {
                    var k = calculateSHA256(input, 0, input.length).subarray(0, 32);
                    var e = [0];
                    var i = 0;
                    while (i < 64 || e[e.length - 1] > i - 32) {
                      var arrayLength = password.length + k.length + userBytes.length;
                      var k1 = new Uint8Array(arrayLength * 64);
                      var array = concatArrays(password, k);
                      array = concatArrays(array, userBytes);
                      for (var j = 0, pos = 0; j < 64; j++, pos += arrayLength) {
                        k1.set(array, pos);
                      }
                      var cipher = new AES128Cipher(k.subarray(0, 16));
                      e = cipher.encrypt(k1, k.subarray(16, 32));
                      var remainder = 0;
                      for (var z = 0; z < 16; z++) {
                        remainder *= 256 % 3;
                        remainder %= 3;
                        remainder += (e[z] >>> 0) % 3;
                        remainder %= 3;
                      }
                      if (remainder === 0) {
                        k = calculateSHA256(e, 0, e.length);
                      } else if (remainder === 1) {
                        k = calculateSHA384(e, 0, e.length);
                      } else if (remainder === 2) {
                        k = calculateSHA512(e, 0, e.length);
                      }
                      i++;
                    }
                    return k.subarray(0, 32);
                  }
                  function PDF202() {
                  }
                  function compareByteArrays(array1, array2) {
                    if (array1.length !== array2.length) {
                      return false;
                    }
                    for (var i = 0; i < array1.length; i++) {
                      if (array1[i] !== array2[i]) {
                        return false;
                      }
                    }
                    return true;
                  }
                  PDF202.prototype = { hash: function PDF20_hash(password, concatBytes, userBytes) {
                    return calculatePDF20Hash(password, concatBytes, userBytes);
                  }, checkOwnerPassword: function PDF20_checkOwnerPassword(password, ownerValidationSalt, userBytes, ownerPassword) {
                    var hashData = new Uint8Array(password.length + 56);
                    hashData.set(password, 0);
                    hashData.set(ownerValidationSalt, password.length);
                    hashData.set(userBytes, password.length + ownerValidationSalt.length);
                    var result = calculatePDF20Hash(password, hashData, userBytes);
                    return compareByteArrays(result, ownerPassword);
                  }, checkUserPassword: function PDF20_checkUserPassword(password, userValidationSalt, userPassword) {
                    var hashData = new Uint8Array(password.length + 8);
                    hashData.set(password, 0);
                    hashData.set(userValidationSalt, password.length);
                    var result = calculatePDF20Hash(password, hashData, []);
                    return compareByteArrays(result, userPassword);
                  }, getOwnerKey: function PDF20_getOwnerKey(password, ownerKeySalt, userBytes, ownerEncryption) {
                    var hashData = new Uint8Array(password.length + 56);
                    hashData.set(password, 0);
                    hashData.set(ownerKeySalt, password.length);
                    hashData.set(userBytes, password.length + ownerKeySalt.length);
                    var key = calculatePDF20Hash(password, hashData, userBytes);
                    var cipher = new AES256Cipher(key);
                    return cipher.decryptBlock(ownerEncryption, false, new Uint8Array(16));
                  }, getUserKey: function PDF20_getUserKey(password, userKeySalt, userEncryption) {
                    var hashData = new Uint8Array(password.length + 8);
                    hashData.set(password, 0);
                    hashData.set(userKeySalt, password.length);
                    var key = calculatePDF20Hash(password, hashData, []);
                    var cipher = new AES256Cipher(key);
                    return cipher.decryptBlock(userEncryption, false, new Uint8Array(16));
                  } };
                  return PDF202;
                }();
                exports2.PDF20 = PDF20;
                var CipherTransform = function CipherTransformClosure() {
                  function CipherTransform2(stringCipherConstructor, streamCipherConstructor) {
                    this.StringCipherConstructor = stringCipherConstructor;
                    this.StreamCipherConstructor = streamCipherConstructor;
                  }
                  CipherTransform2.prototype = { createStream: function CipherTransform_createStream(stream, length) {
                    var cipher = new this.StreamCipherConstructor();
                    return new _stream.DecryptStream(stream, length, function cipherTransformDecryptStream(data, finalize) {
                      return cipher.decryptBlock(data, finalize);
                    });
                  }, decryptString: function CipherTransform_decryptString(s) {
                    var cipher = new this.StringCipherConstructor();
                    var data = (0, _util2.stringToBytes)(s);
                    data = cipher.decryptBlock(data, true);
                    return (0, _util2.bytesToString)(data);
                  } };
                  return CipherTransform2;
                }();
                var CipherTransformFactory = function CipherTransformFactoryClosure() {
                  var defaultPasswordBytes = new Uint8Array([40, 191, 78, 94, 78, 117, 138, 65, 100, 0, 78, 86, 255, 250, 1, 8, 46, 46, 0, 182, 208, 104, 62, 128, 47, 12, 169, 254, 100, 83, 105, 122]);
                  function createEncryptionKey20(revision, password, ownerPassword, ownerValidationSalt, ownerKeySalt, uBytes, userPassword, userValidationSalt, userKeySalt, ownerEncryption, userEncryption, perms) {
                    if (password) {
                      var passwordLength = Math.min(127, password.length);
                      password = password.subarray(0, passwordLength);
                    } else {
                      password = [];
                    }
                    var pdfAlgorithm;
                    if (revision === 6) {
                      pdfAlgorithm = new PDF20();
                    } else {
                      pdfAlgorithm = new PDF17();
                    }
                    if (pdfAlgorithm.checkUserPassword(password, userValidationSalt, userPassword)) {
                      return pdfAlgorithm.getUserKey(password, userKeySalt, userEncryption);
                    } else if (password.length && pdfAlgorithm.checkOwnerPassword(password, ownerValidationSalt, uBytes, ownerPassword)) {
                      return pdfAlgorithm.getOwnerKey(password, ownerKeySalt, uBytes, ownerEncryption);
                    }
                    return null;
                  }
                  function prepareKeyData(fileId, password, ownerPassword, userPassword, flags, revision, keyLength, encryptMetadata) {
                    var hashDataSize = 40 + ownerPassword.length + fileId.length;
                    var hashData = new Uint8Array(hashDataSize), i = 0, j, n;
                    if (password) {
                      n = Math.min(32, password.length);
                      for (; i < n; ++i) {
                        hashData[i] = password[i];
                      }
                    }
                    j = 0;
                    while (i < 32) {
                      hashData[i++] = defaultPasswordBytes[j++];
                    }
                    for (j = 0, n = ownerPassword.length; j < n; ++j) {
                      hashData[i++] = ownerPassword[j];
                    }
                    hashData[i++] = flags & 255;
                    hashData[i++] = flags >> 8 & 255;
                    hashData[i++] = flags >> 16 & 255;
                    hashData[i++] = flags >>> 24 & 255;
                    for (j = 0, n = fileId.length; j < n; ++j) {
                      hashData[i++] = fileId[j];
                    }
                    if (revision >= 4 && !encryptMetadata) {
                      hashData[i++] = 255;
                      hashData[i++] = 255;
                      hashData[i++] = 255;
                      hashData[i++] = 255;
                    }
                    var hash = calculateMD5(hashData, 0, i);
                    var keyLengthInBytes = keyLength >> 3;
                    if (revision >= 3) {
                      for (j = 0; j < 50; ++j) {
                        hash = calculateMD5(hash, 0, keyLengthInBytes);
                      }
                    }
                    var encryptionKey = hash.subarray(0, keyLengthInBytes);
                    var cipher, checkData;
                    if (revision >= 3) {
                      for (i = 0; i < 32; ++i) {
                        hashData[i] = defaultPasswordBytes[i];
                      }
                      for (j = 0, n = fileId.length; j < n; ++j) {
                        hashData[i++] = fileId[j];
                      }
                      cipher = new ARCFourCipher(encryptionKey);
                      checkData = cipher.encryptBlock(calculateMD5(hashData, 0, i));
                      n = encryptionKey.length;
                      var derivedKey = new Uint8Array(n), k;
                      for (j = 1; j <= 19; ++j) {
                        for (k = 0; k < n; ++k) {
                          derivedKey[k] = encryptionKey[k] ^ j;
                        }
                        cipher = new ARCFourCipher(derivedKey);
                        checkData = cipher.encryptBlock(checkData);
                      }
                      for (j = 0, n = checkData.length; j < n; ++j) {
                        if (userPassword[j] !== checkData[j]) {
                          return null;
                        }
                      }
                    } else {
                      cipher = new ARCFourCipher(encryptionKey);
                      checkData = cipher.encryptBlock(defaultPasswordBytes);
                      for (j = 0, n = checkData.length; j < n; ++j) {
                        if (userPassword[j] !== checkData[j]) {
                          return null;
                        }
                      }
                    }
                    return encryptionKey;
                  }
                  function decodeUserPassword(password, ownerPassword, revision, keyLength) {
                    var hashData = new Uint8Array(32), i = 0, j, n;
                    n = Math.min(32, password.length);
                    for (; i < n; ++i) {
                      hashData[i] = password[i];
                    }
                    j = 0;
                    while (i < 32) {
                      hashData[i++] = defaultPasswordBytes[j++];
                    }
                    var hash = calculateMD5(hashData, 0, i);
                    var keyLengthInBytes = keyLength >> 3;
                    if (revision >= 3) {
                      for (j = 0; j < 50; ++j) {
                        hash = calculateMD5(hash, 0, hash.length);
                      }
                    }
                    var cipher, userPassword;
                    if (revision >= 3) {
                      userPassword = ownerPassword;
                      var derivedKey = new Uint8Array(keyLengthInBytes), k;
                      for (j = 19; j >= 0; j--) {
                        for (k = 0; k < keyLengthInBytes; ++k) {
                          derivedKey[k] = hash[k] ^ j;
                        }
                        cipher = new ARCFourCipher(derivedKey);
                        userPassword = cipher.encryptBlock(userPassword);
                      }
                    } else {
                      cipher = new ARCFourCipher(hash.subarray(0, keyLengthInBytes));
                      userPassword = cipher.encryptBlock(ownerPassword);
                    }
                    return userPassword;
                  }
                  var identityName = _primitives.Name.get("Identity");
                  function CipherTransformFactory2(dict, fileId, password) {
                    var filter = dict.get("Filter");
                    if (!(0, _primitives.isName)(filter, "Standard")) {
                      throw new _util2.FormatError("unknown encryption method");
                    }
                    this.dict = dict;
                    var algorithm = dict.get("V");
                    if (!Number.isInteger(algorithm) || algorithm !== 1 && algorithm !== 2 && algorithm !== 4 && algorithm !== 5) {
                      throw new _util2.FormatError("unsupported encryption algorithm");
                    }
                    this.algorithm = algorithm;
                    var keyLength = dict.get("Length");
                    if (!keyLength) {
                      if (algorithm <= 3) {
                        keyLength = 40;
                      } else {
                        var cfDict = dict.get("CF");
                        var streamCryptoName = dict.get("StmF");
                        if ((0, _primitives.isDict)(cfDict) && (0, _primitives.isName)(streamCryptoName)) {
                          cfDict.suppressEncryption = true;
                          var handlerDict = cfDict.get(streamCryptoName.name);
                          keyLength = handlerDict && handlerDict.get("Length") || 128;
                          if (keyLength < 40) {
                            keyLength <<= 3;
                          }
                        }
                      }
                    }
                    if (!Number.isInteger(keyLength) || keyLength < 40 || keyLength % 8 !== 0) {
                      throw new _util2.FormatError("invalid key length");
                    }
                    var ownerPassword = (0, _util2.stringToBytes)(dict.get("O")).subarray(0, 32);
                    var userPassword = (0, _util2.stringToBytes)(dict.get("U")).subarray(0, 32);
                    var flags = dict.get("P");
                    var revision = dict.get("R");
                    var encryptMetadata = (algorithm === 4 || algorithm === 5) && dict.get("EncryptMetadata") !== false;
                    this.encryptMetadata = encryptMetadata;
                    var fileIdBytes = (0, _util2.stringToBytes)(fileId);
                    var passwordBytes;
                    if (password) {
                      if (revision === 6) {
                        try {
                          password = (0, _util2.utf8StringToString)(password);
                        } catch (ex) {
                          (0, _util2.warn)("CipherTransformFactory: Unable to convert UTF8 encoded password.");
                        }
                      }
                      passwordBytes = (0, _util2.stringToBytes)(password);
                    }
                    var encryptionKey;
                    if (algorithm !== 5) {
                      encryptionKey = prepareKeyData(fileIdBytes, passwordBytes, ownerPassword, userPassword, flags, revision, keyLength, encryptMetadata);
                    } else {
                      var ownerValidationSalt = (0, _util2.stringToBytes)(dict.get("O")).subarray(32, 40);
                      var ownerKeySalt = (0, _util2.stringToBytes)(dict.get("O")).subarray(40, 48);
                      var uBytes = (0, _util2.stringToBytes)(dict.get("U")).subarray(0, 48);
                      var userValidationSalt = (0, _util2.stringToBytes)(dict.get("U")).subarray(32, 40);
                      var userKeySalt = (0, _util2.stringToBytes)(dict.get("U")).subarray(40, 48);
                      var ownerEncryption = (0, _util2.stringToBytes)(dict.get("OE"));
                      var userEncryption = (0, _util2.stringToBytes)(dict.get("UE"));
                      var perms = (0, _util2.stringToBytes)(dict.get("Perms"));
                      encryptionKey = createEncryptionKey20(revision, passwordBytes, ownerPassword, ownerValidationSalt, ownerKeySalt, uBytes, userPassword, userValidationSalt, userKeySalt, ownerEncryption, userEncryption, perms);
                    }
                    if (!encryptionKey && !password) {
                      throw new _util2.PasswordException("No password given", _util2.PasswordResponses.NEED_PASSWORD);
                    } else if (!encryptionKey && password) {
                      var decodedPassword = decodeUserPassword(passwordBytes, ownerPassword, revision, keyLength);
                      encryptionKey = prepareKeyData(fileIdBytes, decodedPassword, ownerPassword, userPassword, flags, revision, keyLength, encryptMetadata);
                    }
                    if (!encryptionKey) {
                      throw new _util2.PasswordException("Incorrect Password", _util2.PasswordResponses.INCORRECT_PASSWORD);
                    }
                    this.encryptionKey = encryptionKey;
                    if (algorithm >= 4) {
                      var cf = dict.get("CF");
                      if ((0, _primitives.isDict)(cf)) {
                        cf.suppressEncryption = true;
                      }
                      this.cf = cf;
                      this.stmf = dict.get("StmF") || identityName;
                      this.strf = dict.get("StrF") || identityName;
                      this.eff = dict.get("EFF") || this.stmf;
                    }
                  }
                  function buildObjectKey(num, gen, encryptionKey, isAes) {
                    var key = new Uint8Array(encryptionKey.length + 9), i, n;
                    for (i = 0, n = encryptionKey.length; i < n; ++i) {
                      key[i] = encryptionKey[i];
                    }
                    key[i++] = num & 255;
                    key[i++] = num >> 8 & 255;
                    key[i++] = num >> 16 & 255;
                    key[i++] = gen & 255;
                    key[i++] = gen >> 8 & 255;
                    if (isAes) {
                      key[i++] = 115;
                      key[i++] = 65;
                      key[i++] = 108;
                      key[i++] = 84;
                    }
                    var hash = calculateMD5(key, 0, i);
                    return hash.subarray(0, Math.min(encryptionKey.length + 5, 16));
                  }
                  function buildCipherConstructor(cf, name, num, gen, key) {
                    if (!(0, _primitives.isName)(name)) {
                      throw new _util2.FormatError("Invalid crypt filter name.");
                    }
                    var cryptFilter = cf.get(name.name);
                    var cfm;
                    if (cryptFilter !== null && cryptFilter !== void 0) {
                      cfm = cryptFilter.get("CFM");
                    }
                    if (!cfm || cfm.name === "None") {
                      return function cipherTransformFactoryBuildCipherConstructorNone() {
                        return new NullCipher();
                      };
                    }
                    if (cfm.name === "V2") {
                      return function cipherTransformFactoryBuildCipherConstructorV2() {
                        return new ARCFourCipher(buildObjectKey(num, gen, key, false));
                      };
                    }
                    if (cfm.name === "AESV2") {
                      return function cipherTransformFactoryBuildCipherConstructorAESV2() {
                        return new AES128Cipher(buildObjectKey(num, gen, key, true));
                      };
                    }
                    if (cfm.name === "AESV3") {
                      return function cipherTransformFactoryBuildCipherConstructorAESV3() {
                        return new AES256Cipher(key);
                      };
                    }
                    throw new _util2.FormatError("Unknown crypto method");
                  }
                  CipherTransformFactory2.prototype = { createCipherTransform: function CipherTransformFactory_createCipherTransform(num, gen) {
                    if (this.algorithm === 4 || this.algorithm === 5) {
                      return new CipherTransform(buildCipherConstructor(this.cf, this.stmf, num, gen, this.encryptionKey), buildCipherConstructor(this.cf, this.strf, num, gen, this.encryptionKey));
                    }
                    var key = buildObjectKey(num, gen, this.encryptionKey, false);
                    var cipherConstructor = function buildCipherCipherConstructor() {
                      return new ARCFourCipher(key);
                    };
                    return new CipherTransform(cipherConstructor, cipherConstructor);
                  } };
                  return CipherTransformFactory2;
                }();
                exports2.CipherTransformFactory = CipherTransformFactory;
              }, function(module3, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.ColorSpace = void 0;
                var _util2 = __w_pdfjs_require__2(2);
                var _primitives = __w_pdfjs_require__2(4);
                function resizeRgbImage(src, dest, w1, h1, w2, h2, alpha01) {
                  const COMPONENTS = 3;
                  alpha01 = alpha01 !== 1 ? 0 : alpha01;
                  const xRatio = w1 / w2;
                  const yRatio = h1 / h2;
                  let newIndex = 0, oldIndex;
                  const xScaled = new Uint16Array(w2);
                  const w1Scanline = w1 * COMPONENTS;
                  for (let i = 0; i < w2; i++) {
                    xScaled[i] = Math.floor(i * xRatio) * COMPONENTS;
                  }
                  for (let i = 0; i < h2; i++) {
                    const py = Math.floor(i * yRatio) * w1Scanline;
                    for (let j = 0; j < w2; j++) {
                      oldIndex = py + xScaled[j];
                      dest[newIndex++] = src[oldIndex++];
                      dest[newIndex++] = src[oldIndex++];
                      dest[newIndex++] = src[oldIndex++];
                      newIndex += alpha01;
                    }
                  }
                }
                class ColorSpace {
                  constructor(name, numComps) {
                    if (this.constructor === ColorSpace) {
                      (0, _util2.unreachable)("Cannot initialize ColorSpace.");
                    }
                    this.name = name;
                    this.numComps = numComps;
                  }
                  getRgb(src, srcOffset) {
                    const rgb = new Uint8ClampedArray(3);
                    this.getRgbItem(src, srcOffset, rgb, 0);
                    return rgb;
                  }
                  getRgbItem(src, srcOffset, dest, destOffset) {
                    (0, _util2.unreachable)("Should not call ColorSpace.getRgbItem");
                  }
                  getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                    (0, _util2.unreachable)("Should not call ColorSpace.getRgbBuffer");
                  }
                  getOutputLength(inputLength, alpha01) {
                    (0, _util2.unreachable)("Should not call ColorSpace.getOutputLength");
                  }
                  isPassthrough(bits) {
                    return false;
                  }
                  isDefaultDecode(decodeMap, bpc) {
                    return ColorSpace.isDefaultDecode(decodeMap, this.numComps);
                  }
                  fillRgb(dest, originalWidth, originalHeight, width, height, actualHeight, bpc, comps, alpha01) {
                    const count = originalWidth * originalHeight;
                    let rgbBuf = null;
                    const numComponentColors = 1 << bpc;
                    const needsResizing = originalHeight !== height || originalWidth !== width;
                    if (this.isPassthrough(bpc)) {
                      rgbBuf = comps;
                    } else if (this.numComps === 1 && count > numComponentColors && this.name !== "DeviceGray" && this.name !== "DeviceRGB") {
                      const allColors = bpc <= 8 ? new Uint8Array(numComponentColors) : new Uint16Array(numComponentColors);
                      for (let i = 0; i < numComponentColors; i++) {
                        allColors[i] = i;
                      }
                      const colorMap = new Uint8ClampedArray(numComponentColors * 3);
                      this.getRgbBuffer(allColors, 0, numComponentColors, colorMap, 0, bpc, 0);
                      if (!needsResizing) {
                        let destPos = 0;
                        for (let i = 0; i < count; ++i) {
                          const key = comps[i] * 3;
                          dest[destPos++] = colorMap[key];
                          dest[destPos++] = colorMap[key + 1];
                          dest[destPos++] = colorMap[key + 2];
                          destPos += alpha01;
                        }
                      } else {
                        rgbBuf = new Uint8Array(count * 3);
                        let rgbPos = 0;
                        for (let i = 0; i < count; ++i) {
                          const key = comps[i] * 3;
                          rgbBuf[rgbPos++] = colorMap[key];
                          rgbBuf[rgbPos++] = colorMap[key + 1];
                          rgbBuf[rgbPos++] = colorMap[key + 2];
                        }
                      }
                    } else {
                      if (!needsResizing) {
                        this.getRgbBuffer(comps, 0, width * actualHeight, dest, 0, bpc, alpha01);
                      } else {
                        rgbBuf = new Uint8ClampedArray(count * 3);
                        this.getRgbBuffer(comps, 0, count, rgbBuf, 0, bpc, 0);
                      }
                    }
                    if (rgbBuf) {
                      if (needsResizing) {
                        resizeRgbImage(rgbBuf, dest, originalWidth, originalHeight, width, height, alpha01);
                      } else {
                        let destPos = 0, rgbPos = 0;
                        for (let i = 0, ii = width * actualHeight; i < ii; i++) {
                          dest[destPos++] = rgbBuf[rgbPos++];
                          dest[destPos++] = rgbBuf[rgbPos++];
                          dest[destPos++] = rgbBuf[rgbPos++];
                          destPos += alpha01;
                        }
                      }
                    }
                  }
                  get usesZeroToOneRange() {
                    return (0, _util2.shadow)(this, "usesZeroToOneRange", true);
                  }
                  static parse(cs, xref, res, pdfFunctionFactory) {
                    const IR = this.parseToIR(cs, xref, res, pdfFunctionFactory);
                    return this.fromIR(IR);
                  }
                  static fromIR(IR) {
                    const name = Array.isArray(IR) ? IR[0] : IR;
                    let whitePoint, blackPoint, gamma;
                    switch (name) {
                      case "DeviceGrayCS":
                        return this.singletons.gray;
                      case "DeviceRgbCS":
                        return this.singletons.rgb;
                      case "DeviceCmykCS":
                        return this.singletons.cmyk;
                      case "CalGrayCS":
                        whitePoint = IR[1];
                        blackPoint = IR[2];
                        gamma = IR[3];
                        return new CalGrayCS(whitePoint, blackPoint, gamma);
                      case "CalRGBCS":
                        whitePoint = IR[1];
                        blackPoint = IR[2];
                        gamma = IR[3];
                        const matrix = IR[4];
                        return new CalRGBCS(whitePoint, blackPoint, gamma, matrix);
                      case "PatternCS":
                        let basePatternCS = IR[1];
                        if (basePatternCS) {
                          basePatternCS = this.fromIR(basePatternCS);
                        }
                        return new PatternCS(basePatternCS);
                      case "IndexedCS":
                        const baseIndexedCS = IR[1];
                        const hiVal = IR[2];
                        const lookup = IR[3];
                        return new IndexedCS(this.fromIR(baseIndexedCS), hiVal, lookup);
                      case "AlternateCS":
                        const numComps = IR[1];
                        const alt = IR[2];
                        const tintFn = IR[3];
                        return new AlternateCS(numComps, this.fromIR(alt), tintFn);
                      case "LabCS":
                        whitePoint = IR[1];
                        blackPoint = IR[2];
                        const range = IR[3];
                        return new LabCS(whitePoint, blackPoint, range);
                      default:
                        throw new _util2.FormatError(`Unknown colorspace name: ${name}`);
                    }
                  }
                  static parseToIR(cs, xref, res = null, pdfFunctionFactory) {
                    cs = xref.fetchIfRef(cs);
                    if ((0, _primitives.isName)(cs)) {
                      switch (cs.name) {
                        case "DeviceGray":
                        case "G":
                          return "DeviceGrayCS";
                        case "DeviceRGB":
                        case "RGB":
                          return "DeviceRgbCS";
                        case "DeviceCMYK":
                        case "CMYK":
                          return "DeviceCmykCS";
                        case "Pattern":
                          return ["PatternCS", null];
                        default:
                          if ((0, _primitives.isDict)(res)) {
                            const colorSpaces = res.get("ColorSpace");
                            if ((0, _primitives.isDict)(colorSpaces)) {
                              const resCS = colorSpaces.get(cs.name);
                              if (resCS) {
                                if ((0, _primitives.isName)(resCS)) {
                                  return this.parseToIR(resCS, xref, res, pdfFunctionFactory);
                                }
                                cs = resCS;
                                break;
                              }
                            }
                          }
                          throw new _util2.FormatError(`unrecognized colorspace ${cs.name}`);
                      }
                    }
                    if (Array.isArray(cs)) {
                      const mode = xref.fetchIfRef(cs[0]).name;
                      let numComps, params, alt, whitePoint, blackPoint, gamma;
                      switch (mode) {
                        case "DeviceGray":
                        case "G":
                          return "DeviceGrayCS";
                        case "DeviceRGB":
                        case "RGB":
                          return "DeviceRgbCS";
                        case "DeviceCMYK":
                        case "CMYK":
                          return "DeviceCmykCS";
                        case "CalGray":
                          params = xref.fetchIfRef(cs[1]);
                          whitePoint = params.getArray("WhitePoint");
                          blackPoint = params.getArray("BlackPoint");
                          gamma = params.get("Gamma");
                          return ["CalGrayCS", whitePoint, blackPoint, gamma];
                        case "CalRGB":
                          params = xref.fetchIfRef(cs[1]);
                          whitePoint = params.getArray("WhitePoint");
                          blackPoint = params.getArray("BlackPoint");
                          gamma = params.getArray("Gamma");
                          const matrix = params.getArray("Matrix");
                          return ["CalRGBCS", whitePoint, blackPoint, gamma, matrix];
                        case "ICCBased":
                          const stream = xref.fetchIfRef(cs[1]);
                          const dict = stream.dict;
                          numComps = dict.get("N");
                          alt = dict.get("Alternate");
                          if (alt) {
                            const altIR = this.parseToIR(alt, xref, res, pdfFunctionFactory);
                            const altCS = this.fromIR(altIR, pdfFunctionFactory);
                            if (altCS.numComps === numComps) {
                              return altIR;
                            }
                            (0, _util2.warn)("ICCBased color space: Ignoring incorrect /Alternate entry.");
                          }
                          if (numComps === 1) {
                            return "DeviceGrayCS";
                          } else if (numComps === 3) {
                            return "DeviceRgbCS";
                          } else if (numComps === 4) {
                            return "DeviceCmykCS";
                          }
                          break;
                        case "Pattern":
                          let basePatternCS = cs[1] || null;
                          if (basePatternCS) {
                            basePatternCS = this.parseToIR(basePatternCS, xref, res, pdfFunctionFactory);
                          }
                          return ["PatternCS", basePatternCS];
                        case "Indexed":
                        case "I":
                          const baseIndexedCS = this.parseToIR(cs[1], xref, res, pdfFunctionFactory);
                          const hiVal = xref.fetchIfRef(cs[2]) + 1;
                          let lookup = xref.fetchIfRef(cs[3]);
                          if ((0, _primitives.isStream)(lookup)) {
                            lookup = lookup.getBytes();
                          }
                          return ["IndexedCS", baseIndexedCS, hiVal, lookup];
                        case "Separation":
                        case "DeviceN":
                          const name = xref.fetchIfRef(cs[1]);
                          numComps = Array.isArray(name) ? name.length : 1;
                          alt = this.parseToIR(cs[2], xref, res, pdfFunctionFactory);
                          const tintFn = pdfFunctionFactory.create(xref.fetchIfRef(cs[3]));
                          return ["AlternateCS", numComps, alt, tintFn];
                        case "Lab":
                          params = xref.fetchIfRef(cs[1]);
                          whitePoint = params.getArray("WhitePoint");
                          blackPoint = params.getArray("BlackPoint");
                          const range = params.getArray("Range");
                          return ["LabCS", whitePoint, blackPoint, range];
                        default:
                          throw new _util2.FormatError(`unimplemented color space object "${mode}"`);
                      }
                    }
                    throw new _util2.FormatError(`unrecognized color space object: "${cs}"`);
                  }
                  static isDefaultDecode(decode, numComps) {
                    if (!Array.isArray(decode)) {
                      return true;
                    }
                    if (numComps * 2 !== decode.length) {
                      (0, _util2.warn)("The decode map is not the correct length");
                      return true;
                    }
                    for (let i = 0, ii = decode.length; i < ii; i += 2) {
                      if (decode[i] !== 0 || decode[i + 1] !== 1) {
                        return false;
                      }
                    }
                    return true;
                  }
                  static get singletons() {
                    return (0, _util2.shadow)(this, "singletons", { get gray() {
                      return (0, _util2.shadow)(this, "gray", new DeviceGrayCS());
                    }, get rgb() {
                      return (0, _util2.shadow)(this, "rgb", new DeviceRgbCS());
                    }, get cmyk() {
                      return (0, _util2.shadow)(this, "cmyk", new DeviceCmykCS());
                    } });
                  }
                }
                exports2.ColorSpace = ColorSpace;
                class AlternateCS extends ColorSpace {
                  constructor(numComps, base, tintFn) {
                    super("Alternate", numComps);
                    this.base = base;
                    this.tintFn = tintFn;
                    this.tmpBuf = new Float32Array(base.numComps);
                  }
                  getRgbItem(src, srcOffset, dest, destOffset) {
                    const tmpBuf = this.tmpBuf;
                    this.tintFn(src, srcOffset, tmpBuf, 0);
                    this.base.getRgbItem(tmpBuf, 0, dest, destOffset);
                  }
                  getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                    const tintFn = this.tintFn;
                    const base = this.base;
                    const scale = 1 / ((1 << bits) - 1);
                    const baseNumComps = base.numComps;
                    const usesZeroToOneRange = base.usesZeroToOneRange;
                    const isPassthrough = (base.isPassthrough(8) || !usesZeroToOneRange) && alpha01 === 0;
                    let pos = isPassthrough ? destOffset : 0;
                    const baseBuf = isPassthrough ? dest : new Uint8ClampedArray(baseNumComps * count);
                    const numComps = this.numComps;
                    const scaled = new Float32Array(numComps);
                    const tinted = new Float32Array(baseNumComps);
                    let i, j;
                    for (i = 0; i < count; i++) {
                      for (j = 0; j < numComps; j++) {
                        scaled[j] = src[srcOffset++] * scale;
                      }
                      tintFn(scaled, 0, tinted, 0);
                      if (usesZeroToOneRange) {
                        for (j = 0; j < baseNumComps; j++) {
                          baseBuf[pos++] = tinted[j] * 255;
                        }
                      } else {
                        base.getRgbItem(tinted, 0, baseBuf, pos);
                        pos += baseNumComps;
                      }
                    }
                    if (!isPassthrough) {
                      base.getRgbBuffer(baseBuf, 0, count, dest, destOffset, 8, alpha01);
                    }
                  }
                  getOutputLength(inputLength, alpha01) {
                    return this.base.getOutputLength(inputLength * this.base.numComps / this.numComps, alpha01);
                  }
                }
                class PatternCS extends ColorSpace {
                  constructor(baseCS) {
                    super("Pattern", null);
                    this.base = baseCS;
                  }
                  isDefaultDecode(decodeMap, bpc) {
                    (0, _util2.unreachable)("Should not call PatternCS.isDefaultDecode");
                  }
                }
                class IndexedCS extends ColorSpace {
                  constructor(base, highVal, lookup) {
                    super("Indexed", 1);
                    this.base = base;
                    this.highVal = highVal;
                    const baseNumComps = base.numComps;
                    const length = baseNumComps * highVal;
                    if ((0, _primitives.isStream)(lookup)) {
                      this.lookup = new Uint8Array(length);
                      const bytes = lookup.getBytes(length);
                      this.lookup.set(bytes);
                    } else if ((0, _util2.isString)(lookup)) {
                      this.lookup = new Uint8Array(length);
                      for (let i = 0; i < length; ++i) {
                        this.lookup[i] = lookup.charCodeAt(i);
                      }
                    } else if (lookup instanceof Uint8Array) {
                      this.lookup = lookup;
                    } else {
                      throw new _util2.FormatError(`Unrecognized lookup table: ${lookup}`);
                    }
                  }
                  getRgbItem(src, srcOffset, dest, destOffset) {
                    const numComps = this.base.numComps;
                    const start = src[srcOffset] * numComps;
                    this.base.getRgbBuffer(this.lookup, start, 1, dest, destOffset, 8, 0);
                  }
                  getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                    const base = this.base;
                    const numComps = base.numComps;
                    const outputDelta = base.getOutputLength(numComps, alpha01);
                    const lookup = this.lookup;
                    for (let i = 0; i < count; ++i) {
                      const lookupPos = src[srcOffset++] * numComps;
                      base.getRgbBuffer(lookup, lookupPos, 1, dest, destOffset, 8, alpha01);
                      destOffset += outputDelta;
                    }
                  }
                  getOutputLength(inputLength, alpha01) {
                    return this.base.getOutputLength(inputLength * this.base.numComps, alpha01);
                  }
                  isDefaultDecode(decodeMap, bpc) {
                    if (!Array.isArray(decodeMap)) {
                      return true;
                    }
                    if (decodeMap.length !== 2) {
                      (0, _util2.warn)("Decode map length is not correct");
                      return true;
                    }
                    if (!Number.isInteger(bpc) || bpc < 1) {
                      (0, _util2.warn)("Bits per component is not correct");
                      return true;
                    }
                    return decodeMap[0] === 0 && decodeMap[1] === (1 << bpc) - 1;
                  }
                }
                class DeviceGrayCS extends ColorSpace {
                  constructor() {
                    super("DeviceGray", 1);
                  }
                  getRgbItem(src, srcOffset, dest, destOffset) {
                    const c = src[srcOffset] * 255;
                    dest[destOffset] = dest[destOffset + 1] = dest[destOffset + 2] = c;
                  }
                  getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                    const scale = 255 / ((1 << bits) - 1);
                    let j = srcOffset, q = destOffset;
                    for (let i = 0; i < count; ++i) {
                      const c = scale * src[j++];
                      dest[q++] = c;
                      dest[q++] = c;
                      dest[q++] = c;
                      q += alpha01;
                    }
                  }
                  getOutputLength(inputLength, alpha01) {
                    return inputLength * (3 + alpha01);
                  }
                }
                class DeviceRgbCS extends ColorSpace {
                  constructor() {
                    super("DeviceRGB", 3);
                  }
                  getRgbItem(src, srcOffset, dest, destOffset) {
                    dest[destOffset] = src[srcOffset] * 255;
                    dest[destOffset + 1] = src[srcOffset + 1] * 255;
                    dest[destOffset + 2] = src[srcOffset + 2] * 255;
                  }
                  getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                    if (bits === 8 && alpha01 === 0) {
                      dest.set(src.subarray(srcOffset, srcOffset + count * 3), destOffset);
                      return;
                    }
                    const scale = 255 / ((1 << bits) - 1);
                    let j = srcOffset, q = destOffset;
                    for (let i = 0; i < count; ++i) {
                      dest[q++] = scale * src[j++];
                      dest[q++] = scale * src[j++];
                      dest[q++] = scale * src[j++];
                      q += alpha01;
                    }
                  }
                  getOutputLength(inputLength, alpha01) {
                    return inputLength * (3 + alpha01) / 3 | 0;
                  }
                  isPassthrough(bits) {
                    return bits === 8;
                  }
                }
                const DeviceCmykCS = function DeviceCmykCSClosure() {
                  function convertToRgb(src, srcOffset, srcScale, dest, destOffset) {
                    const c = src[srcOffset] * srcScale;
                    const m = src[srcOffset + 1] * srcScale;
                    const y = src[srcOffset + 2] * srcScale;
                    const k = src[srcOffset + 3] * srcScale;
                    dest[destOffset] = 255 + c * (-4.387332384609988 * c + 54.48615194189176 * m + 18.82290502165302 * y + 212.25662451639585 * k + -285.2331026137004) + m * (1.7149763477362134 * m - 5.6096736904047315 * y + -17.873870861415444 * k - 5.497006427196366) + y * (-2.5217340131683033 * y - 21.248923337353073 * k + 17.5119270841813) + k * (-21.86122147463605 * k - 189.48180835922747);
                    dest[destOffset + 1] = 255 + c * (8.841041422036149 * c + 60.118027045597366 * m + 6.871425592049007 * y + 31.159100130055922 * k + -79.2970844816548) + m * (-15.310361306967817 * m + 17.575251261109482 * y + 131.35250912493976 * k - 190.9453302588951) + y * (4.444339102852739 * y + 9.8632861493405 * k - 24.86741582555878) + k * (-20.737325471181034 * k - 187.80453709719578);
                    dest[destOffset + 2] = 255 + c * (0.8842522430003296 * c + 8.078677503112928 * m + 30.89978309703729 * y - 0.23883238689178934 * k + -14.183576799673286) + m * (10.49593273432072 * m + 63.02378494754052 * y + 50.606957656360734 * k - 112.23884253719248) + y * (0.03296041114873217 * y + 115.60384449646641 * k + -193.58209356861505) + k * (-22.33816807309886 * k - 180.12613974708367);
                  }
                  class DeviceCmykCS2 extends ColorSpace {
                    constructor() {
                      super("DeviceCMYK", 4);
                    }
                    getRgbItem(src, srcOffset, dest, destOffset) {
                      convertToRgb(src, srcOffset, 1, dest, destOffset);
                    }
                    getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                      const scale = 1 / ((1 << bits) - 1);
                      for (let i = 0; i < count; i++) {
                        convertToRgb(src, srcOffset, scale, dest, destOffset);
                        srcOffset += 4;
                        destOffset += 3 + alpha01;
                      }
                    }
                    getOutputLength(inputLength, alpha01) {
                      return inputLength / 4 * (3 + alpha01) | 0;
                    }
                  }
                  return DeviceCmykCS2;
                }();
                const CalGrayCS = function CalGrayCSClosure() {
                  function convertToRgb(cs, src, srcOffset, dest, destOffset, scale) {
                    const A = src[srcOffset] * scale;
                    const AG = A ** cs.G;
                    const L = cs.YW * AG;
                    const val = Math.max(295.8 * L ** 0.3333333333333333 - 40.8, 0);
                    dest[destOffset] = val;
                    dest[destOffset + 1] = val;
                    dest[destOffset + 2] = val;
                  }
                  class CalGrayCS2 extends ColorSpace {
                    constructor(whitePoint, blackPoint, gamma) {
                      super("CalGray", 1);
                      if (!whitePoint) {
                        throw new _util2.FormatError("WhitePoint missing - required for color space CalGray");
                      }
                      blackPoint = blackPoint || [0, 0, 0];
                      gamma = gamma || 1;
                      this.XW = whitePoint[0];
                      this.YW = whitePoint[1];
                      this.ZW = whitePoint[2];
                      this.XB = blackPoint[0];
                      this.YB = blackPoint[1];
                      this.ZB = blackPoint[2];
                      this.G = gamma;
                      if (this.XW < 0 || this.ZW < 0 || this.YW !== 1) {
                        throw new _util2.FormatError(`Invalid WhitePoint components for ${this.name}, no fallback available`);
                      }
                      if (this.XB < 0 || this.YB < 0 || this.ZB < 0) {
                        (0, _util2.info)(`Invalid BlackPoint for ${this.name}, falling back to default.`);
                        this.XB = this.YB = this.ZB = 0;
                      }
                      if (this.XB !== 0 || this.YB !== 0 || this.ZB !== 0) {
                        (0, _util2.warn)(`${this.name}, BlackPoint: XB: ${this.XB}, YB: ${this.YB}, ZB: ${this.ZB}, only default values are supported.`);
                      }
                      if (this.G < 1) {
                        (0, _util2.info)(`Invalid Gamma: ${this.G} for ${this.name}, falling back to default.`);
                        this.G = 1;
                      }
                    }
                    getRgbItem(src, srcOffset, dest, destOffset) {
                      convertToRgb(this, src, srcOffset, dest, destOffset, 1);
                    }
                    getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                      const scale = 1 / ((1 << bits) - 1);
                      for (let i = 0; i < count; ++i) {
                        convertToRgb(this, src, srcOffset, dest, destOffset, scale);
                        srcOffset += 1;
                        destOffset += 3 + alpha01;
                      }
                    }
                    getOutputLength(inputLength, alpha01) {
                      return inputLength * (3 + alpha01);
                    }
                  }
                  return CalGrayCS2;
                }();
                const CalRGBCS = function CalRGBCSClosure() {
                  const BRADFORD_SCALE_MATRIX = new Float32Array([0.8951, 0.2664, -0.1614, -0.7502, 1.7135, 0.0367, 0.0389, -0.0685, 1.0296]);
                  const BRADFORD_SCALE_INVERSE_MATRIX = new Float32Array([0.9869929, -0.1470543, 0.1599627, 0.4323053, 0.5183603, 0.0492912, -85287e-7, 0.0400428, 0.9684867]);
                  const SRGB_D65_XYZ_TO_RGB_MATRIX = new Float32Array([3.2404542, -1.5371385, -0.4985314, -0.969266, 1.8760108, 0.041556, 0.0556434, -0.2040259, 1.0572252]);
                  const FLAT_WHITEPOINT_MATRIX = new Float32Array([1, 1, 1]);
                  const tempNormalizeMatrix = new Float32Array(3);
                  const tempConvertMatrix1 = new Float32Array(3);
                  const tempConvertMatrix2 = new Float32Array(3);
                  const DECODE_L_CONSTANT = ((8 + 16) / 116) ** 3 / 8;
                  function matrixProduct(a, b, result) {
                    result[0] = a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
                    result[1] = a[3] * b[0] + a[4] * b[1] + a[5] * b[2];
                    result[2] = a[6] * b[0] + a[7] * b[1] + a[8] * b[2];
                  }
                  function convertToFlat(sourceWhitePoint, LMS, result) {
                    result[0] = LMS[0] * 1 / sourceWhitePoint[0];
                    result[1] = LMS[1] * 1 / sourceWhitePoint[1];
                    result[2] = LMS[2] * 1 / sourceWhitePoint[2];
                  }
                  function convertToD65(sourceWhitePoint, LMS, result) {
                    const D65X = 0.95047;
                    const D65Y = 1;
                    const D65Z = 1.08883;
                    result[0] = LMS[0] * D65X / sourceWhitePoint[0];
                    result[1] = LMS[1] * D65Y / sourceWhitePoint[1];
                    result[2] = LMS[2] * D65Z / sourceWhitePoint[2];
                  }
                  function sRGBTransferFunction(color) {
                    if (color <= 31308e-7) {
                      return adjustToRange(0, 1, 12.92 * color);
                    }
                    return adjustToRange(0, 1, (1 + 0.055) * color ** (1 / 2.4) - 0.055);
                  }
                  function adjustToRange(min, max, value) {
                    return Math.max(min, Math.min(max, value));
                  }
                  function decodeL(L) {
                    if (L < 0) {
                      return -decodeL(-L);
                    }
                    if (L > 8) {
                      return ((L + 16) / 116) ** 3;
                    }
                    return L * DECODE_L_CONSTANT;
                  }
                  function compensateBlackPoint(sourceBlackPoint, XYZ_Flat, result) {
                    if (sourceBlackPoint[0] === 0 && sourceBlackPoint[1] === 0 && sourceBlackPoint[2] === 0) {
                      result[0] = XYZ_Flat[0];
                      result[1] = XYZ_Flat[1];
                      result[2] = XYZ_Flat[2];
                      return;
                    }
                    const zeroDecodeL = decodeL(0);
                    const X_DST = zeroDecodeL;
                    const X_SRC = decodeL(sourceBlackPoint[0]);
                    const Y_DST = zeroDecodeL;
                    const Y_SRC = decodeL(sourceBlackPoint[1]);
                    const Z_DST = zeroDecodeL;
                    const Z_SRC = decodeL(sourceBlackPoint[2]);
                    const X_Scale = (1 - X_DST) / (1 - X_SRC);
                    const X_Offset = 1 - X_Scale;
                    const Y_Scale = (1 - Y_DST) / (1 - Y_SRC);
                    const Y_Offset = 1 - Y_Scale;
                    const Z_Scale = (1 - Z_DST) / (1 - Z_SRC);
                    const Z_Offset = 1 - Z_Scale;
                    result[0] = XYZ_Flat[0] * X_Scale + X_Offset;
                    result[1] = XYZ_Flat[1] * Y_Scale + Y_Offset;
                    result[2] = XYZ_Flat[2] * Z_Scale + Z_Offset;
                  }
                  function normalizeWhitePointToFlat(sourceWhitePoint, XYZ_In, result) {
                    if (sourceWhitePoint[0] === 1 && sourceWhitePoint[2] === 1) {
                      result[0] = XYZ_In[0];
                      result[1] = XYZ_In[1];
                      result[2] = XYZ_In[2];
                      return;
                    }
                    const LMS = result;
                    matrixProduct(BRADFORD_SCALE_MATRIX, XYZ_In, LMS);
                    const LMS_Flat = tempNormalizeMatrix;
                    convertToFlat(sourceWhitePoint, LMS, LMS_Flat);
                    matrixProduct(BRADFORD_SCALE_INVERSE_MATRIX, LMS_Flat, result);
                  }
                  function normalizeWhitePointToD65(sourceWhitePoint, XYZ_In, result) {
                    const LMS = result;
                    matrixProduct(BRADFORD_SCALE_MATRIX, XYZ_In, LMS);
                    const LMS_D65 = tempNormalizeMatrix;
                    convertToD65(sourceWhitePoint, LMS, LMS_D65);
                    matrixProduct(BRADFORD_SCALE_INVERSE_MATRIX, LMS_D65, result);
                  }
                  function convertToRgb(cs, src, srcOffset, dest, destOffset, scale) {
                    const A = adjustToRange(0, 1, src[srcOffset] * scale);
                    const B = adjustToRange(0, 1, src[srcOffset + 1] * scale);
                    const C = adjustToRange(0, 1, src[srcOffset + 2] * scale);
                    const AGR = A ** cs.GR;
                    const BGG = B ** cs.GG;
                    const CGB = C ** cs.GB;
                    const X = cs.MXA * AGR + cs.MXB * BGG + cs.MXC * CGB;
                    const Y = cs.MYA * AGR + cs.MYB * BGG + cs.MYC * CGB;
                    const Z = cs.MZA * AGR + cs.MZB * BGG + cs.MZC * CGB;
                    const XYZ = tempConvertMatrix1;
                    XYZ[0] = X;
                    XYZ[1] = Y;
                    XYZ[2] = Z;
                    const XYZ_Flat = tempConvertMatrix2;
                    normalizeWhitePointToFlat(cs.whitePoint, XYZ, XYZ_Flat);
                    const XYZ_Black = tempConvertMatrix1;
                    compensateBlackPoint(cs.blackPoint, XYZ_Flat, XYZ_Black);
                    const XYZ_D65 = tempConvertMatrix2;
                    normalizeWhitePointToD65(FLAT_WHITEPOINT_MATRIX, XYZ_Black, XYZ_D65);
                    const SRGB = tempConvertMatrix1;
                    matrixProduct(SRGB_D65_XYZ_TO_RGB_MATRIX, XYZ_D65, SRGB);
                    dest[destOffset] = sRGBTransferFunction(SRGB[0]) * 255;
                    dest[destOffset + 1] = sRGBTransferFunction(SRGB[1]) * 255;
                    dest[destOffset + 2] = sRGBTransferFunction(SRGB[2]) * 255;
                  }
                  class CalRGBCS2 extends ColorSpace {
                    constructor(whitePoint, blackPoint, gamma, matrix) {
                      super("CalRGB", 3);
                      if (!whitePoint) {
                        throw new _util2.FormatError("WhitePoint missing - required for color space CalRGB");
                      }
                      blackPoint = blackPoint || new Float32Array(3);
                      gamma = gamma || new Float32Array([1, 1, 1]);
                      matrix = matrix || new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
                      const XW = whitePoint[0];
                      const YW = whitePoint[1];
                      const ZW = whitePoint[2];
                      this.whitePoint = whitePoint;
                      const XB = blackPoint[0];
                      const YB = blackPoint[1];
                      const ZB = blackPoint[2];
                      this.blackPoint = blackPoint;
                      this.GR = gamma[0];
                      this.GG = gamma[1];
                      this.GB = gamma[2];
                      this.MXA = matrix[0];
                      this.MYA = matrix[1];
                      this.MZA = matrix[2];
                      this.MXB = matrix[3];
                      this.MYB = matrix[4];
                      this.MZB = matrix[5];
                      this.MXC = matrix[6];
                      this.MYC = matrix[7];
                      this.MZC = matrix[8];
                      if (XW < 0 || ZW < 0 || YW !== 1) {
                        throw new _util2.FormatError(`Invalid WhitePoint components for ${this.name}, no fallback available`);
                      }
                      if (XB < 0 || YB < 0 || ZB < 0) {
                        (0, _util2.info)(`Invalid BlackPoint for ${this.name} [${XB}, ${YB}, ${ZB}], falling back to default.`);
                        this.blackPoint = new Float32Array(3);
                      }
                      if (this.GR < 0 || this.GG < 0 || this.GB < 0) {
                        (0, _util2.info)(`Invalid Gamma [${this.GR}, ${this.GG}, ${this.GB}] for ${this.name}, falling back to default.`);
                        this.GR = this.GG = this.GB = 1;
                      }
                    }
                    getRgbItem(src, srcOffset, dest, destOffset) {
                      convertToRgb(this, src, srcOffset, dest, destOffset, 1);
                    }
                    getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                      const scale = 1 / ((1 << bits) - 1);
                      for (let i = 0; i < count; ++i) {
                        convertToRgb(this, src, srcOffset, dest, destOffset, scale);
                        srcOffset += 3;
                        destOffset += 3 + alpha01;
                      }
                    }
                    getOutputLength(inputLength, alpha01) {
                      return inputLength * (3 + alpha01) / 3 | 0;
                    }
                  }
                  return CalRGBCS2;
                }();
                const LabCS = function LabCSClosure() {
                  function fn_g(x) {
                    let result;
                    if (x >= 6 / 29) {
                      result = x * x * x;
                    } else {
                      result = 108 / 841 * (x - 4 / 29);
                    }
                    return result;
                  }
                  function decode(value, high1, low2, high2) {
                    return low2 + value * (high2 - low2) / high1;
                  }
                  function convertToRgb(cs, src, srcOffset, maxVal, dest, destOffset) {
                    let Ls = src[srcOffset];
                    let as = src[srcOffset + 1];
                    let bs = src[srcOffset + 2];
                    if (maxVal !== false) {
                      Ls = decode(Ls, maxVal, 0, 100);
                      as = decode(as, maxVal, cs.amin, cs.amax);
                      bs = decode(bs, maxVal, cs.bmin, cs.bmax);
                    }
                    if (as > cs.amax) {
                      as = cs.amax;
                    } else if (as < cs.amin) {
                      as = cs.amin;
                    }
                    if (bs > cs.bmax) {
                      bs = cs.bmax;
                    } else if (bs < cs.bmin) {
                      bs = cs.bmin;
                    }
                    const M = (Ls + 16) / 116;
                    const L = M + as / 500;
                    const N = M - bs / 200;
                    const X = cs.XW * fn_g(L);
                    const Y = cs.YW * fn_g(M);
                    const Z = cs.ZW * fn_g(N);
                    let r, g, b;
                    if (cs.ZW < 1) {
                      r = X * 3.1339 + Y * -1.617 + Z * -0.4906;
                      g = X * -0.9785 + Y * 1.916 + Z * 0.0333;
                      b = X * 0.072 + Y * -0.229 + Z * 1.4057;
                    } else {
                      r = X * 3.2406 + Y * -1.5372 + Z * -0.4986;
                      g = X * -0.9689 + Y * 1.8758 + Z * 0.0415;
                      b = X * 0.0557 + Y * -0.204 + Z * 1.057;
                    }
                    dest[destOffset] = Math.sqrt(r) * 255;
                    dest[destOffset + 1] = Math.sqrt(g) * 255;
                    dest[destOffset + 2] = Math.sqrt(b) * 255;
                  }
                  class LabCS2 extends ColorSpace {
                    constructor(whitePoint, blackPoint, range) {
                      super("Lab", 3);
                      if (!whitePoint) {
                        throw new _util2.FormatError("WhitePoint missing - required for color space Lab");
                      }
                      blackPoint = blackPoint || [0, 0, 0];
                      range = range || [-100, 100, -100, 100];
                      this.XW = whitePoint[0];
                      this.YW = whitePoint[1];
                      this.ZW = whitePoint[2];
                      this.amin = range[0];
                      this.amax = range[1];
                      this.bmin = range[2];
                      this.bmax = range[3];
                      this.XB = blackPoint[0];
                      this.YB = blackPoint[1];
                      this.ZB = blackPoint[2];
                      if (this.XW < 0 || this.ZW < 0 || this.YW !== 1) {
                        throw new _util2.FormatError("Invalid WhitePoint components, no fallback available");
                      }
                      if (this.XB < 0 || this.YB < 0 || this.ZB < 0) {
                        (0, _util2.info)("Invalid BlackPoint, falling back to default");
                        this.XB = this.YB = this.ZB = 0;
                      }
                      if (this.amin > this.amax || this.bmin > this.bmax) {
                        (0, _util2.info)("Invalid Range, falling back to defaults");
                        this.amin = -100;
                        this.amax = 100;
                        this.bmin = -100;
                        this.bmax = 100;
                      }
                    }
                    getRgbItem(src, srcOffset, dest, destOffset) {
                      convertToRgb(this, src, srcOffset, false, dest, destOffset);
                    }
                    getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                      const maxVal = (1 << bits) - 1;
                      for (let i = 0; i < count; i++) {
                        convertToRgb(this, src, srcOffset, maxVal, dest, destOffset);
                        srcOffset += 3;
                        destOffset += 3 + alpha01;
                      }
                    }
                    getOutputLength(inputLength, alpha01) {
                      return inputLength * (3 + alpha01) / 3 | 0;
                    }
                    isDefaultDecode(decodeMap, bpc) {
                      return true;
                    }
                    get usesZeroToOneRange() {
                      return (0, _util2.shadow)(this, "usesZeroToOneRange", false);
                    }
                  }
                  return LabCS2;
                }();
              }, function(module3, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.getQuadPoints = getQuadPoints;
                exports2.MarkupAnnotation = exports2.AnnotationFactory = exports2.AnnotationBorderStyle = exports2.Annotation = void 0;
                var _util2 = __w_pdfjs_require__2(2);
                var _obj = __w_pdfjs_require__2(9);
                var _primitives = __w_pdfjs_require__2(4);
                var _colorspace = __w_pdfjs_require__2(22);
                var _core_utils = __w_pdfjs_require__2(7);
                var _operator_list = __w_pdfjs_require__2(24);
                var _stream = __w_pdfjs_require__2(11);
                class AnnotationFactory {
                  static create(xref, ref, pdfManager, idFactory) {
                    return pdfManager.ensure(this, "_create", [xref, ref, pdfManager, idFactory]);
                  }
                  static _create(xref, ref, pdfManager, idFactory) {
                    const dict = xref.fetchIfRef(ref);
                    if (!(0, _primitives.isDict)(dict)) {
                      return void 0;
                    }
                    const id = (0, _primitives.isRef)(ref) ? ref.toString() : `annot_${idFactory.createObjId()}`;
                    let subtype = dict.get("Subtype");
                    subtype = (0, _primitives.isName)(subtype) ? subtype.name : null;
                    const parameters = { xref, dict, subtype, id, pdfManager };
                    switch (subtype) {
                      case "Link":
                        return new LinkAnnotation(parameters);
                      case "Text":
                        return new TextAnnotation(parameters);
                      case "Widget":
                        let fieldType = (0, _core_utils.getInheritableProperty)({ dict, key: "FT" });
                        fieldType = (0, _primitives.isName)(fieldType) ? fieldType.name : null;
                        switch (fieldType) {
                          case "Tx":
                            return new TextWidgetAnnotation(parameters);
                          case "Btn":
                            return new ButtonWidgetAnnotation(parameters);
                          case "Ch":
                            return new ChoiceWidgetAnnotation(parameters);
                        }
                        (0, _util2.warn)('Unimplemented widget field type "' + fieldType + '", falling back to base field type.');
                        return new WidgetAnnotation(parameters);
                      case "Popup":
                        return new PopupAnnotation(parameters);
                      case "FreeText":
                        return new FreeTextAnnotation(parameters);
                      case "Line":
                        return new LineAnnotation(parameters);
                      case "Square":
                        return new SquareAnnotation(parameters);
                      case "Circle":
                        return new CircleAnnotation(parameters);
                      case "PolyLine":
                        return new PolylineAnnotation(parameters);
                      case "Polygon":
                        return new PolygonAnnotation(parameters);
                      case "Caret":
                        return new CaretAnnotation(parameters);
                      case "Ink":
                        return new InkAnnotation(parameters);
                      case "Highlight":
                        return new HighlightAnnotation(parameters);
                      case "Underline":
                        return new UnderlineAnnotation(parameters);
                      case "Squiggly":
                        return new SquigglyAnnotation(parameters);
                      case "StrikeOut":
                        return new StrikeOutAnnotation(parameters);
                      case "Stamp":
                        return new StampAnnotation(parameters);
                      case "FileAttachment":
                        return new FileAttachmentAnnotation(parameters);
                      default:
                        if (!subtype) {
                          (0, _util2.warn)("Annotation is missing the required /Subtype.");
                        } else {
                          (0, _util2.warn)('Unimplemented annotation type "' + subtype + '", falling back to base annotation.');
                        }
                        return new Annotation(parameters);
                    }
                  }
                }
                exports2.AnnotationFactory = AnnotationFactory;
                function getQuadPoints(dict, rect) {
                  if (!dict.has("QuadPoints")) {
                    return null;
                  }
                  const quadPoints = dict.getArray("QuadPoints");
                  if (!Array.isArray(quadPoints) || quadPoints.length % 8 > 0) {
                    return null;
                  }
                  const quadPointsLists = [];
                  for (let i = 0, ii = quadPoints.length / 8; i < ii; i++) {
                    quadPointsLists.push([]);
                    for (let j = i * 8, jj = i * 8 + 8; j < jj; j += 2) {
                      const x = quadPoints[j];
                      const y = quadPoints[j + 1];
                      if (x < rect[0] || x > rect[2] || y < rect[1] || y > rect[3]) {
                        return null;
                      }
                      quadPointsLists[i].push({ x, y });
                    }
                  }
                  return quadPointsLists;
                }
                function getTransformMatrix(rect, bbox, matrix) {
                  const [minX, minY, maxX, maxY] = _util2.Util.getAxialAlignedBoundingBox(bbox, matrix);
                  if (minX === maxX || minY === maxY) {
                    return [1, 0, 0, 1, rect[0], rect[1]];
                  }
                  const xRatio = (rect[2] - rect[0]) / (maxX - minX);
                  const yRatio = (rect[3] - rect[1]) / (maxY - minY);
                  return [xRatio, 0, 0, yRatio, rect[0] - minX * xRatio, rect[1] - minY * yRatio];
                }
                class Annotation {
                  constructor(params) {
                    const dict = params.dict;
                    this.setContents(dict.get("Contents"));
                    this.setModificationDate(dict.get("M"));
                    this.setFlags(dict.get("F"));
                    this.setRectangle(dict.getArray("Rect"));
                    this.setColor(dict.getArray("C"));
                    this.setBorderStyle(dict);
                    this.setAppearance(dict);
                    this.data = { annotationFlags: this.flags, borderStyle: this.borderStyle, color: this.color, contents: this.contents, hasAppearance: !!this.appearance, id: params.id, modificationDate: this.modificationDate, rect: this.rectangle, subtype: params.subtype };
                  }
                  _hasFlag(flags, flag) {
                    return !!(flags & flag);
                  }
                  _isViewable(flags) {
                    return !this._hasFlag(flags, _util2.AnnotationFlag.INVISIBLE) && !this._hasFlag(flags, _util2.AnnotationFlag.HIDDEN) && !this._hasFlag(flags, _util2.AnnotationFlag.NOVIEW);
                  }
                  _isPrintable(flags) {
                    return this._hasFlag(flags, _util2.AnnotationFlag.PRINT) && !this._hasFlag(flags, _util2.AnnotationFlag.INVISIBLE) && !this._hasFlag(flags, _util2.AnnotationFlag.HIDDEN);
                  }
                  get viewable() {
                    if (this.flags === 0) {
                      return true;
                    }
                    return this._isViewable(this.flags);
                  }
                  get printable() {
                    if (this.flags === 0) {
                      return false;
                    }
                    return this._isPrintable(this.flags);
                  }
                  setContents(contents) {
                    this.contents = (0, _util2.stringToPDFString)(contents || "");
                  }
                  setModificationDate(modificationDate) {
                    this.modificationDate = (0, _util2.isString)(modificationDate) ? modificationDate : null;
                  }
                  setFlags(flags) {
                    this.flags = Number.isInteger(flags) && flags > 0 ? flags : 0;
                  }
                  hasFlag(flag) {
                    return this._hasFlag(this.flags, flag);
                  }
                  setRectangle(rectangle) {
                    if (Array.isArray(rectangle) && rectangle.length === 4) {
                      this.rectangle = _util2.Util.normalizeRect(rectangle);
                    } else {
                      this.rectangle = [0, 0, 0, 0];
                    }
                  }
                  setColor(color) {
                    const rgbColor = new Uint8ClampedArray(3);
                    if (!Array.isArray(color)) {
                      this.color = rgbColor;
                      return;
                    }
                    switch (color.length) {
                      case 0:
                        this.color = null;
                        break;
                      case 1:
                        _colorspace.ColorSpace.singletons.gray.getRgbItem(color, 0, rgbColor, 0);
                        this.color = rgbColor;
                        break;
                      case 3:
                        _colorspace.ColorSpace.singletons.rgb.getRgbItem(color, 0, rgbColor, 0);
                        this.color = rgbColor;
                        break;
                      case 4:
                        _colorspace.ColorSpace.singletons.cmyk.getRgbItem(color, 0, rgbColor, 0);
                        this.color = rgbColor;
                        break;
                      default:
                        this.color = rgbColor;
                        break;
                    }
                  }
                  setBorderStyle(borderStyle) {
                    this.borderStyle = new AnnotationBorderStyle();
                    if (!(0, _primitives.isDict)(borderStyle)) {
                      return;
                    }
                    if (borderStyle.has("BS")) {
                      const dict = borderStyle.get("BS");
                      const dictType = dict.get("Type");
                      if (!dictType || (0, _primitives.isName)(dictType, "Border")) {
                        this.borderStyle.setWidth(dict.get("W"), this.rectangle);
                        this.borderStyle.setStyle(dict.get("S"));
                        this.borderStyle.setDashArray(dict.getArray("D"));
                      }
                    } else if (borderStyle.has("Border")) {
                      const array = borderStyle.getArray("Border");
                      if (Array.isArray(array) && array.length >= 3) {
                        this.borderStyle.setHorizontalCornerRadius(array[0]);
                        this.borderStyle.setVerticalCornerRadius(array[1]);
                        this.borderStyle.setWidth(array[2], this.rectangle);
                        if (array.length === 4) {
                          this.borderStyle.setDashArray(array[3]);
                        }
                      }
                    } else {
                      this.borderStyle.setWidth(0);
                    }
                  }
                  setAppearance(dict) {
                    this.appearance = null;
                    const appearanceStates = dict.get("AP");
                    if (!(0, _primitives.isDict)(appearanceStates)) {
                      return;
                    }
                    const normalAppearanceState = appearanceStates.get("N");
                    if ((0, _primitives.isStream)(normalAppearanceState)) {
                      this.appearance = normalAppearanceState;
                      return;
                    }
                    if (!(0, _primitives.isDict)(normalAppearanceState)) {
                      return;
                    }
                    const as = dict.get("AS");
                    if (!(0, _primitives.isName)(as) || !normalAppearanceState.has(as.name)) {
                      return;
                    }
                    this.appearance = normalAppearanceState.get(as.name);
                  }
                  loadResources(keys) {
                    return this.appearance.dict.getAsync("Resources").then((resources) => {
                      if (!resources) {
                        return void 0;
                      }
                      const objectLoader = new _obj.ObjectLoader(resources, keys, resources.xref);
                      return objectLoader.load().then(function() {
                        return resources;
                      });
                    });
                  }
                  getOperatorList(evaluator, task, renderForms) {
                    if (!this.appearance) {
                      return Promise.resolve(new _operator_list.OperatorList());
                    }
                    const data = this.data;
                    const appearanceDict = this.appearance.dict;
                    const resourcesPromise = this.loadResources(["ExtGState", "ColorSpace", "Pattern", "Shading", "XObject", "Font"]);
                    const bbox = appearanceDict.getArray("BBox") || [0, 0, 1, 1];
                    const matrix = appearanceDict.getArray("Matrix") || [1, 0, 0, 1, 0, 0];
                    const transform = getTransformMatrix(data.rect, bbox, matrix);
                    return resourcesPromise.then((resources) => {
                      const opList = new _operator_list.OperatorList();
                      opList.addOp(_util2.OPS.beginAnnotation, [data.rect, transform, matrix]);
                      return evaluator.getOperatorList({ stream: this.appearance, task, resources, operatorList: opList }).then(() => {
                        opList.addOp(_util2.OPS.endAnnotation, []);
                        this.appearance.reset();
                        return opList;
                      });
                    });
                  }
                }
                exports2.Annotation = Annotation;
                class AnnotationBorderStyle {
                  constructor() {
                    this.width = 1;
                    this.style = _util2.AnnotationBorderStyleType.SOLID;
                    this.dashArray = [3];
                    this.horizontalCornerRadius = 0;
                    this.verticalCornerRadius = 0;
                  }
                  setWidth(width, rect = [0, 0, 0, 0]) {
                    if ((0, _primitives.isName)(width)) {
                      this.width = 0;
                      return;
                    }
                    if (Number.isInteger(width)) {
                      if (width > 0) {
                        const maxWidth = (rect[2] - rect[0]) / 2;
                        const maxHeight = (rect[3] - rect[1]) / 2;
                        if (maxWidth > 0 && maxHeight > 0 && (width > maxWidth || width > maxHeight)) {
                          (0, _util2.warn)(`AnnotationBorderStyle.setWidth - ignoring width: ${width}`);
                          width = 1;
                        }
                      }
                      this.width = width;
                    }
                  }
                  setStyle(style) {
                    if (!(0, _primitives.isName)(style)) {
                      return;
                    }
                    switch (style.name) {
                      case "S":
                        this.style = _util2.AnnotationBorderStyleType.SOLID;
                        break;
                      case "D":
                        this.style = _util2.AnnotationBorderStyleType.DASHED;
                        break;
                      case "B":
                        this.style = _util2.AnnotationBorderStyleType.BEVELED;
                        break;
                      case "I":
                        this.style = _util2.AnnotationBorderStyleType.INSET;
                        break;
                      case "U":
                        this.style = _util2.AnnotationBorderStyleType.UNDERLINE;
                        break;
                      default:
                        break;
                    }
                  }
                  setDashArray(dashArray) {
                    if (Array.isArray(dashArray) && dashArray.length > 0) {
                      let isValid = true;
                      let allZeros = true;
                      for (const element of dashArray) {
                        const validNumber = +element >= 0;
                        if (!validNumber) {
                          isValid = false;
                          break;
                        } else if (element > 0) {
                          allZeros = false;
                        }
                      }
                      if (isValid && !allZeros) {
                        this.dashArray = dashArray;
                      } else {
                        this.width = 0;
                      }
                    } else if (dashArray) {
                      this.width = 0;
                    }
                  }
                  setHorizontalCornerRadius(radius) {
                    if (Number.isInteger(radius)) {
                      this.horizontalCornerRadius = radius;
                    }
                  }
                  setVerticalCornerRadius(radius) {
                    if (Number.isInteger(radius)) {
                      this.verticalCornerRadius = radius;
                    }
                  }
                }
                exports2.AnnotationBorderStyle = AnnotationBorderStyle;
                class MarkupAnnotation extends Annotation {
                  constructor(parameters) {
                    super(parameters);
                    const dict = parameters.dict;
                    if (dict.has("IRT")) {
                      const rawIRT = dict.getRaw("IRT");
                      this.data.inReplyTo = (0, _primitives.isRef)(rawIRT) ? rawIRT.toString() : null;
                      const rt = dict.get("RT");
                      this.data.replyType = (0, _primitives.isName)(rt) ? rt.name : _util2.AnnotationReplyType.REPLY;
                    }
                    if (this.data.replyType === _util2.AnnotationReplyType.GROUP) {
                      const parent = dict.get("IRT");
                      this.data.title = (0, _util2.stringToPDFString)(parent.get("T") || "");
                      this.setContents(parent.get("Contents"));
                      this.data.contents = this.contents;
                      if (!parent.has("CreationDate")) {
                        this.data.creationDate = null;
                      } else {
                        this.setCreationDate(parent.get("CreationDate"));
                        this.data.creationDate = this.creationDate;
                      }
                      if (!parent.has("M")) {
                        this.data.modificationDate = null;
                      } else {
                        this.setModificationDate(parent.get("M"));
                        this.data.modificationDate = this.modificationDate;
                      }
                      this.data.hasPopup = parent.has("Popup");
                      if (!parent.has("C")) {
                        this.data.color = null;
                      } else {
                        this.setColor(parent.getArray("C"));
                        this.data.color = this.color;
                      }
                    } else {
                      this.data.title = (0, _util2.stringToPDFString)(dict.get("T") || "");
                      this.setCreationDate(dict.get("CreationDate"));
                      this.data.creationDate = this.creationDate;
                      this.data.hasPopup = dict.has("Popup");
                      if (!dict.has("C")) {
                        this.data.color = null;
                      }
                    }
                  }
                  setCreationDate(creationDate) {
                    this.creationDate = (0, _util2.isString)(creationDate) ? creationDate : null;
                  }
                }
                exports2.MarkupAnnotation = MarkupAnnotation;
                class WidgetAnnotation extends Annotation {
                  constructor(params) {
                    super(params);
                    const dict = params.dict;
                    const data = this.data;
                    data.annotationType = _util2.AnnotationType.WIDGET;
                    data.fieldName = this._constructFieldName(dict);
                    data.fieldValue = (0, _core_utils.getInheritableProperty)({ dict, key: "V", getArray: true });
                    data.alternativeText = (0, _util2.stringToPDFString)(dict.get("TU") || "");
                    data.defaultAppearance = (0, _core_utils.getInheritableProperty)({ dict, key: "DA" }) || "";
                    const fieldType = (0, _core_utils.getInheritableProperty)({ dict, key: "FT" });
                    data.fieldType = (0, _primitives.isName)(fieldType) ? fieldType.name : null;
                    this.fieldResources = (0, _core_utils.getInheritableProperty)({ dict, key: "DR" }) || _primitives.Dict.empty;
                    data.fieldFlags = (0, _core_utils.getInheritableProperty)({ dict, key: "Ff" });
                    if (!Number.isInteger(data.fieldFlags) || data.fieldFlags < 0) {
                      data.fieldFlags = 0;
                    }
                    data.readOnly = this.hasFieldFlag(_util2.AnnotationFieldFlag.READONLY);
                    if (data.fieldType === "Sig") {
                      data.fieldValue = null;
                      this.setFlags(_util2.AnnotationFlag.HIDDEN);
                    }
                  }
                  _constructFieldName(dict) {
                    if (!dict.has("T") && !dict.has("Parent")) {
                      (0, _util2.warn)("Unknown field name, falling back to empty field name.");
                      return "";
                    }
                    if (!dict.has("Parent")) {
                      return (0, _util2.stringToPDFString)(dict.get("T"));
                    }
                    const fieldName = [];
                    if (dict.has("T")) {
                      fieldName.unshift((0, _util2.stringToPDFString)(dict.get("T")));
                    }
                    let loopDict = dict;
                    while (loopDict.has("Parent")) {
                      loopDict = loopDict.get("Parent");
                      if (!(0, _primitives.isDict)(loopDict)) {
                        break;
                      }
                      if (loopDict.has("T")) {
                        fieldName.unshift((0, _util2.stringToPDFString)(loopDict.get("T")));
                      }
                    }
                    return fieldName.join(".");
                  }
                  hasFieldFlag(flag) {
                    return !!(this.data.fieldFlags & flag);
                  }
                  getOperatorList(evaluator, task, renderForms) {
                    if (renderForms) {
                      return Promise.resolve(new _operator_list.OperatorList());
                    }
                    return super.getOperatorList(evaluator, task, renderForms);
                  }
                }
                class TextWidgetAnnotation extends WidgetAnnotation {
                  constructor(params) {
                    super(params);
                    const dict = params.dict;
                    this.data.fieldValue = (0, _util2.stringToPDFString)(this.data.fieldValue || "");
                    let alignment = (0, _core_utils.getInheritableProperty)({ dict, key: "Q" });
                    if (!Number.isInteger(alignment) || alignment < 0 || alignment > 2) {
                      alignment = null;
                    }
                    this.data.textAlignment = alignment;
                    let maximumLength = (0, _core_utils.getInheritableProperty)({ dict, key: "MaxLen" });
                    if (!Number.isInteger(maximumLength) || maximumLength < 0) {
                      maximumLength = null;
                    }
                    this.data.maxLen = maximumLength;
                    this.data.multiLine = this.hasFieldFlag(_util2.AnnotationFieldFlag.MULTILINE);
                    this.data.comb = this.hasFieldFlag(_util2.AnnotationFieldFlag.COMB) && !this.hasFieldFlag(_util2.AnnotationFieldFlag.MULTILINE) && !this.hasFieldFlag(_util2.AnnotationFieldFlag.PASSWORD) && !this.hasFieldFlag(_util2.AnnotationFieldFlag.FILESELECT) && this.data.maxLen !== null;
                  }
                  getOperatorList(evaluator, task, renderForms) {
                    if (renderForms || this.appearance) {
                      return super.getOperatorList(evaluator, task, renderForms);
                    }
                    const operatorList = new _operator_list.OperatorList();
                    if (!this.data.defaultAppearance) {
                      return Promise.resolve(operatorList);
                    }
                    const stream = new _stream.Stream((0, _util2.stringToBytes)(this.data.defaultAppearance));
                    return evaluator.getOperatorList({ stream, task, resources: this.fieldResources, operatorList }).then(function() {
                      return operatorList;
                    });
                  }
                }
                class ButtonWidgetAnnotation extends WidgetAnnotation {
                  constructor(params) {
                    super(params);
                    this.data.checkBox = !this.hasFieldFlag(_util2.AnnotationFieldFlag.RADIO) && !this.hasFieldFlag(_util2.AnnotationFieldFlag.PUSHBUTTON);
                    this.data.radioButton = this.hasFieldFlag(_util2.AnnotationFieldFlag.RADIO) && !this.hasFieldFlag(_util2.AnnotationFieldFlag.PUSHBUTTON);
                    this.data.pushButton = this.hasFieldFlag(_util2.AnnotationFieldFlag.PUSHBUTTON);
                    if (this.data.checkBox) {
                      this._processCheckBox(params);
                    } else if (this.data.radioButton) {
                      this._processRadioButton(params);
                    } else if (this.data.pushButton) {
                      this._processPushButton(params);
                    } else {
                      (0, _util2.warn)("Invalid field flags for button widget annotation");
                    }
                  }
                  _processCheckBox(params) {
                    if ((0, _primitives.isName)(this.data.fieldValue)) {
                      this.data.fieldValue = this.data.fieldValue.name;
                    }
                    const customAppearance = params.dict.get("AP");
                    if (!(0, _primitives.isDict)(customAppearance)) {
                      return;
                    }
                    const exportValueOptionsDict = customAppearance.get("D");
                    if (!(0, _primitives.isDict)(exportValueOptionsDict)) {
                      return;
                    }
                    const exportValues = exportValueOptionsDict.getKeys();
                    const hasCorrectOptionCount = exportValues.length === 2;
                    if (!hasCorrectOptionCount) {
                      return;
                    }
                    this.data.exportValue = exportValues[0] === "Off" ? exportValues[1] : exportValues[0];
                  }
                  _processRadioButton(params) {
                    this.data.fieldValue = this.data.buttonValue = null;
                    const fieldParent = params.dict.get("Parent");
                    if ((0, _primitives.isDict)(fieldParent) && fieldParent.has("V")) {
                      const fieldParentValue = fieldParent.get("V");
                      if ((0, _primitives.isName)(fieldParentValue)) {
                        this.data.fieldValue = fieldParentValue.name;
                      }
                    }
                    const appearanceStates = params.dict.get("AP");
                    if (!(0, _primitives.isDict)(appearanceStates)) {
                      return;
                    }
                    const normalAppearanceState = appearanceStates.get("N");
                    if (!(0, _primitives.isDict)(normalAppearanceState)) {
                      return;
                    }
                    for (const key of normalAppearanceState.getKeys()) {
                      if (key !== "Off") {
                        this.data.buttonValue = key;
                        break;
                      }
                    }
                  }
                  _processPushButton(params) {
                    if (!params.dict.has("A")) {
                      (0, _util2.warn)("Push buttons without action dictionaries are not supported");
                      return;
                    }
                    _obj.Catalog.parseDestDictionary({ destDict: params.dict, resultObj: this.data, docBaseUrl: params.pdfManager.docBaseUrl });
                  }
                }
                class ChoiceWidgetAnnotation extends WidgetAnnotation {
                  constructor(params) {
                    super(params);
                    this.data.options = [];
                    const options = (0, _core_utils.getInheritableProperty)({ dict: params.dict, key: "Opt" });
                    if (Array.isArray(options)) {
                      const xref = params.xref;
                      for (let i = 0, ii = options.length; i < ii; i++) {
                        const option = xref.fetchIfRef(options[i]);
                        const isOptionArray = Array.isArray(option);
                        this.data.options[i] = { exportValue: isOptionArray ? xref.fetchIfRef(option[0]) : option, displayValue: (0, _util2.stringToPDFString)(isOptionArray ? xref.fetchIfRef(option[1]) : option) };
                      }
                    }
                    if (!Array.isArray(this.data.fieldValue)) {
                      this.data.fieldValue = [this.data.fieldValue];
                    }
                    this.data.combo = this.hasFieldFlag(_util2.AnnotationFieldFlag.COMBO);
                    this.data.multiSelect = this.hasFieldFlag(_util2.AnnotationFieldFlag.MULTISELECT);
                  }
                }
                class TextAnnotation extends MarkupAnnotation {
                  constructor(parameters) {
                    const DEFAULT_ICON_SIZE = 22;
                    super(parameters);
                    const dict = parameters.dict;
                    this.data.annotationType = _util2.AnnotationType.TEXT;
                    if (this.data.hasAppearance) {
                      this.data.name = "NoIcon";
                    } else {
                      this.data.rect[1] = this.data.rect[3] - DEFAULT_ICON_SIZE;
                      this.data.rect[2] = this.data.rect[0] + DEFAULT_ICON_SIZE;
                      this.data.name = dict.has("Name") ? dict.get("Name").name : "Note";
                    }
                    if (dict.has("State")) {
                      this.data.state = dict.get("State") || null;
                      this.data.stateModel = dict.get("StateModel") || null;
                    } else {
                      this.data.state = null;
                      this.data.stateModel = null;
                    }
                  }
                }
                class LinkAnnotation extends Annotation {
                  constructor(params) {
                    super(params);
                    this.data.annotationType = _util2.AnnotationType.LINK;
                    const quadPoints = getQuadPoints(params.dict, this.rectangle);
                    if (quadPoints) {
                      this.data.quadPoints = quadPoints;
                    }
                    _obj.Catalog.parseDestDictionary({ destDict: params.dict, resultObj: this.data, docBaseUrl: params.pdfManager.docBaseUrl });
                  }
                }
                class PopupAnnotation extends Annotation {
                  constructor(parameters) {
                    super(parameters);
                    this.data.annotationType = _util2.AnnotationType.POPUP;
                    let parentItem = parameters.dict.get("Parent");
                    if (!parentItem) {
                      (0, _util2.warn)("Popup annotation has a missing or invalid parent annotation.");
                      return;
                    }
                    const parentSubtype = parentItem.get("Subtype");
                    this.data.parentType = (0, _primitives.isName)(parentSubtype) ? parentSubtype.name : null;
                    const rawParent = parameters.dict.getRaw("Parent");
                    this.data.parentId = (0, _primitives.isRef)(rawParent) ? rawParent.toString() : null;
                    const rt = parentItem.get("RT");
                    if ((0, _primitives.isName)(rt, _util2.AnnotationReplyType.GROUP)) {
                      parentItem = parentItem.get("IRT");
                    }
                    if (!parentItem.has("M")) {
                      this.data.modificationDate = null;
                    } else {
                      this.setModificationDate(parentItem.get("M"));
                      this.data.modificationDate = this.modificationDate;
                    }
                    if (!parentItem.has("C")) {
                      this.data.color = null;
                    } else {
                      this.setColor(parentItem.getArray("C"));
                      this.data.color = this.color;
                    }
                    if (!this.viewable) {
                      const parentFlags = parentItem.get("F");
                      if (this._isViewable(parentFlags)) {
                        this.setFlags(parentFlags);
                      }
                    }
                    this.data.title = (0, _util2.stringToPDFString)(parentItem.get("T") || "");
                    this.data.contents = (0, _util2.stringToPDFString)(parentItem.get("Contents") || "");
                  }
                }
                class FreeTextAnnotation extends MarkupAnnotation {
                  constructor(parameters) {
                    super(parameters);
                    this.data.annotationType = _util2.AnnotationType.FREETEXT;
                  }
                }
                class LineAnnotation extends MarkupAnnotation {
                  constructor(parameters) {
                    super(parameters);
                    this.data.annotationType = _util2.AnnotationType.LINE;
                    this.data.lineCoordinates = _util2.Util.normalizeRect(parameters.dict.getArray("L"));
                  }
                }
                class SquareAnnotation extends MarkupAnnotation {
                  constructor(parameters) {
                    super(parameters);
                    this.data.annotationType = _util2.AnnotationType.SQUARE;
                  }
                }
                class CircleAnnotation extends MarkupAnnotation {
                  constructor(parameters) {
                    super(parameters);
                    this.data.annotationType = _util2.AnnotationType.CIRCLE;
                  }
                }
                class PolylineAnnotation extends MarkupAnnotation {
                  constructor(parameters) {
                    super(parameters);
                    this.data.annotationType = _util2.AnnotationType.POLYLINE;
                    const rawVertices = parameters.dict.getArray("Vertices");
                    this.data.vertices = [];
                    for (let i = 0, ii = rawVertices.length; i < ii; i += 2) {
                      this.data.vertices.push({ x: rawVertices[i], y: rawVertices[i + 1] });
                    }
                  }
                }
                class PolygonAnnotation extends PolylineAnnotation {
                  constructor(parameters) {
                    super(parameters);
                    this.data.annotationType = _util2.AnnotationType.POLYGON;
                  }
                }
                class CaretAnnotation extends MarkupAnnotation {
                  constructor(parameters) {
                    super(parameters);
                    this.data.annotationType = _util2.AnnotationType.CARET;
                  }
                }
                class InkAnnotation extends MarkupAnnotation {
                  constructor(parameters) {
                    super(parameters);
                    this.data.annotationType = _util2.AnnotationType.INK;
                    const xref = parameters.xref;
                    const originalInkLists = parameters.dict.getArray("InkList");
                    this.data.inkLists = [];
                    for (let i = 0, ii = originalInkLists.length; i < ii; ++i) {
                      this.data.inkLists.push([]);
                      for (let j = 0, jj = originalInkLists[i].length; j < jj; j += 2) {
                        this.data.inkLists[i].push({ x: xref.fetchIfRef(originalInkLists[i][j]), y: xref.fetchIfRef(originalInkLists[i][j + 1]) });
                      }
                    }
                  }
                }
                class HighlightAnnotation extends MarkupAnnotation {
                  constructor(parameters) {
                    super(parameters);
                    this.data.annotationType = _util2.AnnotationType.HIGHLIGHT;
                    const quadPoints = getQuadPoints(parameters.dict, this.rectangle);
                    if (quadPoints) {
                      this.data.quadPoints = quadPoints;
                    }
                  }
                }
                class UnderlineAnnotation extends MarkupAnnotation {
                  constructor(parameters) {
                    super(parameters);
                    this.data.annotationType = _util2.AnnotationType.UNDERLINE;
                    const quadPoints = getQuadPoints(parameters.dict, this.rectangle);
                    if (quadPoints) {
                      this.data.quadPoints = quadPoints;
                    }
                  }
                }
                class SquigglyAnnotation extends MarkupAnnotation {
                  constructor(parameters) {
                    super(parameters);
                    this.data.annotationType = _util2.AnnotationType.SQUIGGLY;
                    const quadPoints = getQuadPoints(parameters.dict, this.rectangle);
                    if (quadPoints) {
                      this.data.quadPoints = quadPoints;
                    }
                  }
                }
                class StrikeOutAnnotation extends MarkupAnnotation {
                  constructor(parameters) {
                    super(parameters);
                    this.data.annotationType = _util2.AnnotationType.STRIKEOUT;
                    const quadPoints = getQuadPoints(parameters.dict, this.rectangle);
                    if (quadPoints) {
                      this.data.quadPoints = quadPoints;
                    }
                  }
                }
                class StampAnnotation extends MarkupAnnotation {
                  constructor(parameters) {
                    super(parameters);
                    this.data.annotationType = _util2.AnnotationType.STAMP;
                  }
                }
                class FileAttachmentAnnotation extends MarkupAnnotation {
                  constructor(parameters) {
                    super(parameters);
                    const file = new _obj.FileSpec(parameters.dict.get("FS"), parameters.xref);
                    this.data.annotationType = _util2.AnnotationType.FILEATTACHMENT;
                    this.data.file = file.serializable;
                  }
                }
              }, function(module3, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.OperatorList = void 0;
                var _util2 = __w_pdfjs_require__2(2);
                var QueueOptimizer = function QueueOptimizerClosure() {
                  function addState(parentState, pattern, checkFn, iterateFn, processFn) {
                    var state = parentState;
                    for (var i = 0, ii = pattern.length - 1; i < ii; i++) {
                      var item = pattern[i];
                      state = state[item] || (state[item] = []);
                    }
                    state[pattern[pattern.length - 1]] = { checkFn, iterateFn, processFn };
                  }
                  function handlePaintSolidColorImageMask(iFirstSave, count, fnArray, argsArray) {
                    var iFirstPIMXO = iFirstSave + 2;
                    for (var i = 0; i < count; i++) {
                      var arg = argsArray[iFirstPIMXO + 4 * i];
                      var imageMask = arg.length === 1 && arg[0];
                      if (imageMask && imageMask.width === 1 && imageMask.height === 1 && (!imageMask.data.length || imageMask.data.length === 1 && imageMask.data[0] === 0)) {
                        fnArray[iFirstPIMXO + 4 * i] = _util2.OPS.paintSolidColorImageMask;
                        continue;
                      }
                      break;
                    }
                    return count - i;
                  }
                  var InitialState = [];
                  addState(InitialState, [_util2.OPS.save, _util2.OPS.transform, _util2.OPS.paintInlineImageXObject, _util2.OPS.restore], null, function iterateInlineImageGroup(context, i) {
                    var fnArray = context.fnArray;
                    var iFirstSave = context.iCurr - 3;
                    var pos = (i - iFirstSave) % 4;
                    switch (pos) {
                      case 0:
                        return fnArray[i] === _util2.OPS.save;
                      case 1:
                        return fnArray[i] === _util2.OPS.transform;
                      case 2:
                        return fnArray[i] === _util2.OPS.paintInlineImageXObject;
                      case 3:
                        return fnArray[i] === _util2.OPS.restore;
                    }
                    throw new Error(`iterateInlineImageGroup - invalid pos: ${pos}`);
                  }, function foundInlineImageGroup(context, i) {
                    var MIN_IMAGES_IN_INLINE_IMAGES_BLOCK = 10;
                    var MAX_IMAGES_IN_INLINE_IMAGES_BLOCK = 200;
                    var MAX_WIDTH = 1e3;
                    var IMAGE_PADDING = 1;
                    var fnArray = context.fnArray, argsArray = context.argsArray;
                    var curr = context.iCurr;
                    var iFirstSave = curr - 3;
                    var iFirstTransform = curr - 2;
                    var iFirstPIIXO = curr - 1;
                    var count = Math.min(Math.floor((i - iFirstSave) / 4), MAX_IMAGES_IN_INLINE_IMAGES_BLOCK);
                    if (count < MIN_IMAGES_IN_INLINE_IMAGES_BLOCK) {
                      return i - (i - iFirstSave) % 4;
                    }
                    var maxX = 0;
                    var map = [], maxLineHeight = 0;
                    var currentX = IMAGE_PADDING, currentY = IMAGE_PADDING;
                    var q;
                    for (q = 0; q < count; q++) {
                      var transform = argsArray[iFirstTransform + (q << 2)];
                      var img = argsArray[iFirstPIIXO + (q << 2)][0];
                      if (currentX + img.width > MAX_WIDTH) {
                        maxX = Math.max(maxX, currentX);
                        currentY += maxLineHeight + 2 * IMAGE_PADDING;
                        currentX = 0;
                        maxLineHeight = 0;
                      }
                      map.push({ transform, x: currentX, y: currentY, w: img.width, h: img.height });
                      currentX += img.width + 2 * IMAGE_PADDING;
                      maxLineHeight = Math.max(maxLineHeight, img.height);
                    }
                    var imgWidth = Math.max(maxX, currentX) + IMAGE_PADDING;
                    var imgHeight = currentY + maxLineHeight + IMAGE_PADDING;
                    var imgData = new Uint8ClampedArray(imgWidth * imgHeight * 4);
                    var imgRowSize = imgWidth << 2;
                    for (q = 0; q < count; q++) {
                      var data = argsArray[iFirstPIIXO + (q << 2)][0].data;
                      var rowSize = map[q].w << 2;
                      var dataOffset = 0;
                      var offset = map[q].x + map[q].y * imgWidth << 2;
                      imgData.set(data.subarray(0, rowSize), offset - imgRowSize);
                      for (var k = 0, kk = map[q].h; k < kk; k++) {
                        imgData.set(data.subarray(dataOffset, dataOffset + rowSize), offset);
                        dataOffset += rowSize;
                        offset += imgRowSize;
                      }
                      imgData.set(data.subarray(dataOffset - rowSize, dataOffset), offset);
                      while (offset >= 0) {
                        data[offset - 4] = data[offset];
                        data[offset - 3] = data[offset + 1];
                        data[offset - 2] = data[offset + 2];
                        data[offset - 1] = data[offset + 3];
                        data[offset + rowSize] = data[offset + rowSize - 4];
                        data[offset + rowSize + 1] = data[offset + rowSize - 3];
                        data[offset + rowSize + 2] = data[offset + rowSize - 2];
                        data[offset + rowSize + 3] = data[offset + rowSize - 1];
                        offset -= imgRowSize;
                      }
                    }
                    fnArray.splice(iFirstSave, count * 4, _util2.OPS.paintInlineImageXObjectGroup);
                    argsArray.splice(iFirstSave, count * 4, [{ width: imgWidth, height: imgHeight, kind: _util2.ImageKind.RGBA_32BPP, data: imgData }, map]);
                    return iFirstSave + 1;
                  });
                  addState(InitialState, [_util2.OPS.save, _util2.OPS.transform, _util2.OPS.paintImageMaskXObject, _util2.OPS.restore], null, function iterateImageMaskGroup(context, i) {
                    var fnArray = context.fnArray;
                    var iFirstSave = context.iCurr - 3;
                    var pos = (i - iFirstSave) % 4;
                    switch (pos) {
                      case 0:
                        return fnArray[i] === _util2.OPS.save;
                      case 1:
                        return fnArray[i] === _util2.OPS.transform;
                      case 2:
                        return fnArray[i] === _util2.OPS.paintImageMaskXObject;
                      case 3:
                        return fnArray[i] === _util2.OPS.restore;
                    }
                    throw new Error(`iterateImageMaskGroup - invalid pos: ${pos}`);
                  }, function foundImageMaskGroup(context, i) {
                    var MIN_IMAGES_IN_MASKS_BLOCK = 10;
                    var MAX_IMAGES_IN_MASKS_BLOCK = 100;
                    var MAX_SAME_IMAGES_IN_MASKS_BLOCK = 1e3;
                    var fnArray = context.fnArray, argsArray = context.argsArray;
                    var curr = context.iCurr;
                    var iFirstSave = curr - 3;
                    var iFirstTransform = curr - 2;
                    var iFirstPIMXO = curr - 1;
                    var count = Math.floor((i - iFirstSave) / 4);
                    count = handlePaintSolidColorImageMask(iFirstSave, count, fnArray, argsArray);
                    if (count < MIN_IMAGES_IN_MASKS_BLOCK) {
                      return i - (i - iFirstSave) % 4;
                    }
                    var q;
                    var isSameImage = false;
                    var iTransform, transformArgs;
                    var firstPIMXOArg0 = argsArray[iFirstPIMXO][0];
                    if (argsArray[iFirstTransform][1] === 0 && argsArray[iFirstTransform][2] === 0) {
                      isSameImage = true;
                      var firstTransformArg0 = argsArray[iFirstTransform][0];
                      var firstTransformArg3 = argsArray[iFirstTransform][3];
                      iTransform = iFirstTransform + 4;
                      var iPIMXO = iFirstPIMXO + 4;
                      for (q = 1; q < count; q++, iTransform += 4, iPIMXO += 4) {
                        transformArgs = argsArray[iTransform];
                        if (argsArray[iPIMXO][0] !== firstPIMXOArg0 || transformArgs[0] !== firstTransformArg0 || transformArgs[1] !== 0 || transformArgs[2] !== 0 || transformArgs[3] !== firstTransformArg3) {
                          if (q < MIN_IMAGES_IN_MASKS_BLOCK) {
                            isSameImage = false;
                          } else {
                            count = q;
                          }
                          break;
                        }
                      }
                    }
                    if (isSameImage) {
                      count = Math.min(count, MAX_SAME_IMAGES_IN_MASKS_BLOCK);
                      var positions = new Float32Array(count * 2);
                      iTransform = iFirstTransform;
                      for (q = 0; q < count; q++, iTransform += 4) {
                        transformArgs = argsArray[iTransform];
                        positions[q << 1] = transformArgs[4];
                        positions[(q << 1) + 1] = transformArgs[5];
                      }
                      fnArray.splice(iFirstSave, count * 4, _util2.OPS.paintImageMaskXObjectRepeat);
                      argsArray.splice(iFirstSave, count * 4, [firstPIMXOArg0, firstTransformArg0, firstTransformArg3, positions]);
                    } else {
                      count = Math.min(count, MAX_IMAGES_IN_MASKS_BLOCK);
                      var images = [];
                      for (q = 0; q < count; q++) {
                        transformArgs = argsArray[iFirstTransform + (q << 2)];
                        var maskParams = argsArray[iFirstPIMXO + (q << 2)][0];
                        images.push({ data: maskParams.data, width: maskParams.width, height: maskParams.height, transform: transformArgs });
                      }
                      fnArray.splice(iFirstSave, count * 4, _util2.OPS.paintImageMaskXObjectGroup);
                      argsArray.splice(iFirstSave, count * 4, [images]);
                    }
                    return iFirstSave + 1;
                  });
                  addState(InitialState, [_util2.OPS.save, _util2.OPS.transform, _util2.OPS.paintImageXObject, _util2.OPS.restore], function(context) {
                    var argsArray = context.argsArray;
                    var iFirstTransform = context.iCurr - 2;
                    return argsArray[iFirstTransform][1] === 0 && argsArray[iFirstTransform][2] === 0;
                  }, function iterateImageGroup(context, i) {
                    var fnArray = context.fnArray, argsArray = context.argsArray;
                    var iFirstSave = context.iCurr - 3;
                    var pos = (i - iFirstSave) % 4;
                    switch (pos) {
                      case 0:
                        return fnArray[i] === _util2.OPS.save;
                      case 1:
                        if (fnArray[i] !== _util2.OPS.transform) {
                          return false;
                        }
                        var iFirstTransform = context.iCurr - 2;
                        var firstTransformArg0 = argsArray[iFirstTransform][0];
                        var firstTransformArg3 = argsArray[iFirstTransform][3];
                        if (argsArray[i][0] !== firstTransformArg0 || argsArray[i][1] !== 0 || argsArray[i][2] !== 0 || argsArray[i][3] !== firstTransformArg3) {
                          return false;
                        }
                        return true;
                      case 2:
                        if (fnArray[i] !== _util2.OPS.paintImageXObject) {
                          return false;
                        }
                        var iFirstPIXO = context.iCurr - 1;
                        var firstPIXOArg0 = argsArray[iFirstPIXO][0];
                        if (argsArray[i][0] !== firstPIXOArg0) {
                          return false;
                        }
                        return true;
                      case 3:
                        return fnArray[i] === _util2.OPS.restore;
                    }
                    throw new Error(`iterateImageGroup - invalid pos: ${pos}`);
                  }, function(context, i) {
                    var MIN_IMAGES_IN_BLOCK = 3;
                    var MAX_IMAGES_IN_BLOCK = 1e3;
                    var fnArray = context.fnArray, argsArray = context.argsArray;
                    var curr = context.iCurr;
                    var iFirstSave = curr - 3;
                    var iFirstTransform = curr - 2;
                    var iFirstPIXO = curr - 1;
                    var firstPIXOArg0 = argsArray[iFirstPIXO][0];
                    var firstTransformArg0 = argsArray[iFirstTransform][0];
                    var firstTransformArg3 = argsArray[iFirstTransform][3];
                    var count = Math.min(Math.floor((i - iFirstSave) / 4), MAX_IMAGES_IN_BLOCK);
                    if (count < MIN_IMAGES_IN_BLOCK) {
                      return i - (i - iFirstSave) % 4;
                    }
                    var positions = new Float32Array(count * 2);
                    var iTransform = iFirstTransform;
                    for (var q = 0; q < count; q++, iTransform += 4) {
                      var transformArgs = argsArray[iTransform];
                      positions[q << 1] = transformArgs[4];
                      positions[(q << 1) + 1] = transformArgs[5];
                    }
                    var args = [firstPIXOArg0, firstTransformArg0, firstTransformArg3, positions];
                    fnArray.splice(iFirstSave, count * 4, _util2.OPS.paintImageXObjectRepeat);
                    argsArray.splice(iFirstSave, count * 4, args);
                    return iFirstSave + 1;
                  });
                  addState(InitialState, [_util2.OPS.beginText, _util2.OPS.setFont, _util2.OPS.setTextMatrix, _util2.OPS.showText, _util2.OPS.endText], null, function iterateShowTextGroup(context, i) {
                    var fnArray = context.fnArray, argsArray = context.argsArray;
                    var iFirstSave = context.iCurr - 4;
                    var pos = (i - iFirstSave) % 5;
                    switch (pos) {
                      case 0:
                        return fnArray[i] === _util2.OPS.beginText;
                      case 1:
                        return fnArray[i] === _util2.OPS.setFont;
                      case 2:
                        return fnArray[i] === _util2.OPS.setTextMatrix;
                      case 3:
                        if (fnArray[i] !== _util2.OPS.showText) {
                          return false;
                        }
                        var iFirstSetFont = context.iCurr - 3;
                        var firstSetFontArg0 = argsArray[iFirstSetFont][0];
                        var firstSetFontArg1 = argsArray[iFirstSetFont][1];
                        if (argsArray[i][0] !== firstSetFontArg0 || argsArray[i][1] !== firstSetFontArg1) {
                          return false;
                        }
                        return true;
                      case 4:
                        return fnArray[i] === _util2.OPS.endText;
                    }
                    throw new Error(`iterateShowTextGroup - invalid pos: ${pos}`);
                  }, function(context, i) {
                    var MIN_CHARS_IN_BLOCK = 3;
                    var MAX_CHARS_IN_BLOCK = 1e3;
                    var fnArray = context.fnArray, argsArray = context.argsArray;
                    var curr = context.iCurr;
                    var iFirstBeginText = curr - 4;
                    var iFirstSetFont = curr - 3;
                    var iFirstSetTextMatrix = curr - 2;
                    var iFirstShowText = curr - 1;
                    var iFirstEndText = curr;
                    var firstSetFontArg0 = argsArray[iFirstSetFont][0];
                    var firstSetFontArg1 = argsArray[iFirstSetFont][1];
                    var count = Math.min(Math.floor((i - iFirstBeginText) / 5), MAX_CHARS_IN_BLOCK);
                    if (count < MIN_CHARS_IN_BLOCK) {
                      return i - (i - iFirstBeginText) % 5;
                    }
                    var iFirst = iFirstBeginText;
                    if (iFirstBeginText >= 4 && fnArray[iFirstBeginText - 4] === fnArray[iFirstSetFont] && fnArray[iFirstBeginText - 3] === fnArray[iFirstSetTextMatrix] && fnArray[iFirstBeginText - 2] === fnArray[iFirstShowText] && fnArray[iFirstBeginText - 1] === fnArray[iFirstEndText] && argsArray[iFirstBeginText - 4][0] === firstSetFontArg0 && argsArray[iFirstBeginText - 4][1] === firstSetFontArg1) {
                      count++;
                      iFirst -= 5;
                    }
                    var iEndText = iFirst + 4;
                    for (var q = 1; q < count; q++) {
                      fnArray.splice(iEndText, 3);
                      argsArray.splice(iEndText, 3);
                      iEndText += 2;
                    }
                    return iEndText + 1;
                  });
                  function QueueOptimizer2(queue) {
                    this.queue = queue;
                    this.state = null;
                    this.context = { iCurr: 0, fnArray: queue.fnArray, argsArray: queue.argsArray };
                    this.match = null;
                    this.lastProcessed = 0;
                  }
                  QueueOptimizer2.prototype = { _optimize() {
                    const fnArray = this.queue.fnArray;
                    let i = this.lastProcessed, ii = fnArray.length;
                    let state = this.state;
                    let match = this.match;
                    if (!state && !match && i + 1 === ii && !InitialState[fnArray[i]]) {
                      this.lastProcessed = ii;
                      return;
                    }
                    const context = this.context;
                    while (i < ii) {
                      if (match) {
                        const iterate = (0, match.iterateFn)(context, i);
                        if (iterate) {
                          i++;
                          continue;
                        }
                        i = (0, match.processFn)(context, i + 1);
                        ii = fnArray.length;
                        match = null;
                        state = null;
                        if (i >= ii) {
                          break;
                        }
                      }
                      state = (state || InitialState)[fnArray[i]];
                      if (!state || Array.isArray(state)) {
                        i++;
                        continue;
                      }
                      context.iCurr = i;
                      i++;
                      if (state.checkFn && !(0, state.checkFn)(context)) {
                        state = null;
                        continue;
                      }
                      match = state;
                      state = null;
                    }
                    this.state = state;
                    this.match = match;
                    this.lastProcessed = i;
                  }, push(fn, args) {
                    this.queue.fnArray.push(fn);
                    this.queue.argsArray.push(args);
                    this._optimize();
                  }, flush() {
                    while (this.match) {
                      const length = this.queue.fnArray.length;
                      this.lastProcessed = (0, this.match.processFn)(this.context, length);
                      this.match = null;
                      this.state = null;
                      this._optimize();
                    }
                  }, reset() {
                    this.state = null;
                    this.match = null;
                    this.lastProcessed = 0;
                  } };
                  return QueueOptimizer2;
                }();
                var NullOptimizer = function NullOptimizerClosure() {
                  function NullOptimizer2(queue) {
                    this.queue = queue;
                  }
                  NullOptimizer2.prototype = { push(fn, args) {
                    this.queue.fnArray.push(fn);
                    this.queue.argsArray.push(args);
                  }, flush() {
                  }, reset() {
                  } };
                  return NullOptimizer2;
                }();
                var OperatorList = function OperatorListClosure() {
                  var CHUNK_SIZE = 1e3;
                  var CHUNK_SIZE_ABOUT = CHUNK_SIZE - 5;
                  function OperatorList2(intent, streamSink, pageIndex) {
                    this._streamSink = streamSink;
                    this.fnArray = [];
                    this.argsArray = [];
                    if (streamSink && intent !== "oplist") {
                      this.optimizer = new QueueOptimizer(this);
                    } else {
                      this.optimizer = new NullOptimizer(this);
                    }
                    this.dependencies = /* @__PURE__ */ Object.create(null);
                    this._totalLength = 0;
                    this.pageIndex = pageIndex;
                    this.intent = intent;
                    this.weight = 0;
                    this._resolved = streamSink ? null : Promise.resolve();
                  }
                  OperatorList2.prototype = { get length() {
                    return this.argsArray.length;
                  }, get ready() {
                    return this._resolved || this._streamSink.ready;
                  }, get totalLength() {
                    return this._totalLength + this.length;
                  }, addOp(fn, args) {
                    this.optimizer.push(fn, args);
                    this.weight++;
                    if (this._streamSink) {
                      if (this.weight >= CHUNK_SIZE) {
                        this.flush();
                      } else if (this.weight >= CHUNK_SIZE_ABOUT && (fn === _util2.OPS.restore || fn === _util2.OPS.endText)) {
                        this.flush();
                      }
                    }
                  }, addDependency(dependency) {
                    if (dependency in this.dependencies) {
                      return;
                    }
                    this.dependencies[dependency] = true;
                    this.addOp(_util2.OPS.dependency, [dependency]);
                  }, addDependencies(dependencies) {
                    for (var key in dependencies) {
                      this.addDependency(key);
                    }
                  }, addOpList(opList) {
                    Object.assign(this.dependencies, opList.dependencies);
                    for (var i = 0, ii = opList.length; i < ii; i++) {
                      this.addOp(opList.fnArray[i], opList.argsArray[i]);
                    }
                  }, getIR() {
                    return { fnArray: this.fnArray, argsArray: this.argsArray, length: this.length };
                  }, get _transfers() {
                    const transfers = [];
                    const { fnArray, argsArray, length } = this;
                    for (let i = 0; i < length; i++) {
                      switch (fnArray[i]) {
                        case _util2.OPS.paintInlineImageXObject:
                        case _util2.OPS.paintInlineImageXObjectGroup:
                        case _util2.OPS.paintImageMaskXObject:
                          const arg = argsArray[i][0];
                          ;
                          if (!arg.cached) {
                            transfers.push(arg.data.buffer);
                          }
                          break;
                      }
                    }
                    return transfers;
                  }, flush(lastChunk = false) {
                    this.optimizer.flush();
                    const length = this.length;
                    this._totalLength += length;
                    this._streamSink.enqueue({ fnArray: this.fnArray, argsArray: this.argsArray, lastChunk, length }, 1, this._transfers);
                    this.dependencies = /* @__PURE__ */ Object.create(null);
                    this.fnArray.length = 0;
                    this.argsArray.length = 0;
                    this.weight = 0;
                    this.optimizer.reset();
                  } };
                  return OperatorList2;
                }();
                exports2.OperatorList = OperatorList;
              }, function(module3, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.PartialEvaluator = void 0;
                var _util2 = __w_pdfjs_require__2(2);
                var _cmap = __w_pdfjs_require__2(26);
                var _primitives = __w_pdfjs_require__2(4);
                var _fonts = __w_pdfjs_require__2(27);
                var _encodings = __w_pdfjs_require__2(30);
                var _core_utils = __w_pdfjs_require__2(7);
                var _unicode = __w_pdfjs_require__2(33);
                var _standard_fonts = __w_pdfjs_require__2(32);
                var _pattern = __w_pdfjs_require__2(36);
                var _parser = __w_pdfjs_require__2(10);
                var _bidi = __w_pdfjs_require__2(37);
                var _colorspace = __w_pdfjs_require__2(22);
                var _stream = __w_pdfjs_require__2(11);
                var _glyphlist = __w_pdfjs_require__2(31);
                var _metrics = __w_pdfjs_require__2(38);
                var _function = __w_pdfjs_require__2(39);
                var _jpeg_stream = __w_pdfjs_require__2(17);
                var _murmurhash = __w_pdfjs_require__2(41);
                var _image_utils = __w_pdfjs_require__2(42);
                var _operator_list = __w_pdfjs_require__2(24);
                var _image = __w_pdfjs_require__2(43);
                var PartialEvaluator = function PartialEvaluatorClosure() {
                  const DefaultPartialEvaluatorOptions = { forceDataSchema: false, maxImageSize: -1, disableFontFace: false, nativeImageDecoderSupport: _util2.NativeImageDecoding.DECODE, ignoreErrors: false, isEvalSupported: true };
                  function PartialEvaluator2({ xref, handler, pageIndex, idFactory, fontCache, builtInCMapCache, options = null, pdfFunctionFactory }) {
                    this.xref = xref;
                    this.handler = handler;
                    this.pageIndex = pageIndex;
                    this.idFactory = idFactory;
                    this.fontCache = fontCache;
                    this.builtInCMapCache = builtInCMapCache;
                    this.options = options || DefaultPartialEvaluatorOptions;
                    this.pdfFunctionFactory = pdfFunctionFactory;
                    this.parsingType3Font = false;
                    this.fetchBuiltInCMap = async (name) => {
                      if (this.builtInCMapCache.has(name)) {
                        return this.builtInCMapCache.get(name);
                      }
                      const readableStream = this.handler.sendWithStream("FetchBuiltInCMap", { name });
                      const reader = readableStream.getReader();
                      const data = await new Promise(function(resolve, reject) {
                        function pump() {
                          reader.read().then(function({ value, done }) {
                            if (done) {
                              return;
                            }
                            resolve(value);
                            pump();
                          }, reject);
                        }
                        pump();
                      });
                      if (data.compressionType !== _util2.CMapCompressionType.NONE) {
                        this.builtInCMapCache.set(name, data);
                      }
                      return data;
                    };
                  }
                  var TIME_SLOT_DURATION_MS = 20;
                  var CHECK_TIME_EVERY = 100;
                  function TimeSlotManager() {
                    this.reset();
                  }
                  TimeSlotManager.prototype = { check: function TimeSlotManager_check() {
                    if (++this.checked < CHECK_TIME_EVERY) {
                      return false;
                    }
                    this.checked = 0;
                    return this.endTime <= Date.now();
                  }, reset: function TimeSlotManager_reset() {
                    this.endTime = Date.now() + TIME_SLOT_DURATION_MS;
                    this.checked = 0;
                  } };
                  function normalizeBlendMode(value, parsingArray = false) {
                    if (Array.isArray(value)) {
                      for (let i = 0, ii = value.length; i < ii; i++) {
                        const maybeBM = normalizeBlendMode(value[i], true);
                        if (maybeBM) {
                          return maybeBM;
                        }
                      }
                      (0, _util2.warn)(`Unsupported blend mode Array: ${value}`);
                      return "source-over";
                    }
                    if (!(0, _primitives.isName)(value)) {
                      if (parsingArray) {
                        return null;
                      }
                      return "source-over";
                    }
                    switch (value.name) {
                      case "Normal":
                      case "Compatible":
                        return "source-over";
                      case "Multiply":
                        return "multiply";
                      case "Screen":
                        return "screen";
                      case "Overlay":
                        return "overlay";
                      case "Darken":
                        return "darken";
                      case "Lighten":
                        return "lighten";
                      case "ColorDodge":
                        return "color-dodge";
                      case "ColorBurn":
                        return "color-burn";
                      case "HardLight":
                        return "hard-light";
                      case "SoftLight":
                        return "soft-light";
                      case "Difference":
                        return "difference";
                      case "Exclusion":
                        return "exclusion";
                      case "Hue":
                        return "hue";
                      case "Saturation":
                        return "saturation";
                      case "Color":
                        return "color";
                      case "Luminosity":
                        return "luminosity";
                    }
                    if (parsingArray) {
                      return null;
                    }
                    (0, _util2.warn)(`Unsupported blend mode: ${value.name}`);
                    return "source-over";
                  }
                  var deferred = Promise.resolve();
                  var TILING_PATTERN = 1, SHADING_PATTERN = 2;
                  PartialEvaluator2.prototype = { clone(newOptions = DefaultPartialEvaluatorOptions) {
                    var newEvaluator = Object.create(this);
                    newEvaluator.options = newOptions;
                    return newEvaluator;
                  }, hasBlendModes: function PartialEvaluator_hasBlendModes(resources) {
                    if (!(resources instanceof _primitives.Dict)) {
                      return false;
                    }
                    var processed = /* @__PURE__ */ Object.create(null);
                    if (resources.objId) {
                      processed[resources.objId] = true;
                    }
                    var nodes = [resources], xref = this.xref;
                    while (nodes.length) {
                      var node = nodes.shift();
                      var graphicStates = node.get("ExtGState");
                      if (graphicStates instanceof _primitives.Dict) {
                        var graphicStatesKeys = graphicStates.getKeys();
                        for (let i = 0, ii = graphicStatesKeys.length; i < ii; i++) {
                          const key = graphicStatesKeys[i];
                          let graphicState = graphicStates.getRaw(key);
                          if (graphicState instanceof _primitives.Ref) {
                            if (processed[graphicState.toString()]) {
                              continue;
                            }
                            try {
                              graphicState = xref.fetch(graphicState);
                            } catch (ex) {
                              if (ex instanceof _core_utils.MissingDataException) {
                                throw ex;
                              }
                              if (this.options.ignoreErrors) {
                                if (graphicState instanceof _primitives.Ref) {
                                  processed[graphicState.toString()] = true;
                                }
                                this.handler.send("UnsupportedFeature", { featureId: _util2.UNSUPPORTED_FEATURES.unknown });
                                (0, _util2.warn)(`hasBlendModes - ignoring ExtGState: "${ex}".`);
                                continue;
                              }
                              throw ex;
                            }
                          }
                          if (!(graphicState instanceof _primitives.Dict)) {
                            continue;
                          }
                          if (graphicState.objId) {
                            processed[graphicState.objId] = true;
                          }
                          const bm = graphicState.get("BM");
                          if (bm instanceof _primitives.Name) {
                            if (bm.name !== "Normal") {
                              return true;
                            }
                            continue;
                          }
                          if (bm !== void 0 && Array.isArray(bm)) {
                            for (let j = 0, jj = bm.length; j < jj; j++) {
                              if (bm[j] instanceof _primitives.Name && bm[j].name !== "Normal") {
                                return true;
                              }
                            }
                          }
                        }
                      }
                      var xObjects = node.get("XObject");
                      if (!(xObjects instanceof _primitives.Dict)) {
                        continue;
                      }
                      var xObjectsKeys = xObjects.getKeys();
                      for (let i = 0, ii = xObjectsKeys.length; i < ii; i++) {
                        const key = xObjectsKeys[i];
                        var xObject = xObjects.getRaw(key);
                        if (xObject instanceof _primitives.Ref) {
                          if (processed[xObject.toString()]) {
                            continue;
                          }
                          try {
                            xObject = xref.fetch(xObject);
                          } catch (ex) {
                            if (ex instanceof _core_utils.MissingDataException) {
                              throw ex;
                            }
                            if (this.options.ignoreErrors) {
                              if (xObject instanceof _primitives.Ref) {
                                processed[xObject.toString()] = true;
                              }
                              this.handler.send("UnsupportedFeature", { featureId: _util2.UNSUPPORTED_FEATURES.unknown });
                              (0, _util2.warn)(`hasBlendModes - ignoring XObject: "${ex}".`);
                              continue;
                            }
                            throw ex;
                          }
                        }
                        if (!(0, _primitives.isStream)(xObject)) {
                          continue;
                        }
                        if (xObject.dict.objId) {
                          if (processed[xObject.dict.objId]) {
                            continue;
                          }
                          processed[xObject.dict.objId] = true;
                        }
                        var xResources = xObject.dict.get("Resources");
                        if (xResources instanceof _primitives.Dict && (!xResources.objId || !processed[xResources.objId])) {
                          nodes.push(xResources);
                          if (xResources.objId) {
                            processed[xResources.objId] = true;
                          }
                        }
                      }
                    }
                    return false;
                  }, async buildFormXObject(resources, xobj, smask, operatorList, task, initialState) {
                    var dict = xobj.dict;
                    var matrix = dict.getArray("Matrix");
                    var bbox = dict.getArray("BBox");
                    if (Array.isArray(bbox) && bbox.length === 4) {
                      bbox = _util2.Util.normalizeRect(bbox);
                    } else {
                      bbox = null;
                    }
                    var group = dict.get("Group");
                    if (group) {
                      var groupOptions = { matrix, bbox, smask, isolated: false, knockout: false };
                      var groupSubtype = group.get("S");
                      var colorSpace = null;
                      if ((0, _primitives.isName)(groupSubtype, "Transparency")) {
                        groupOptions.isolated = group.get("I") || false;
                        groupOptions.knockout = group.get("K") || false;
                        if (group.has("CS")) {
                          colorSpace = await this.parseColorSpace({ cs: group.get("CS"), resources });
                        }
                      }
                      if (smask && smask.backdrop) {
                        colorSpace = colorSpace || _colorspace.ColorSpace.singletons.rgb;
                        smask.backdrop = colorSpace.getRgb(smask.backdrop, 0);
                      }
                      operatorList.addOp(_util2.OPS.beginGroup, [groupOptions]);
                    }
                    operatorList.addOp(_util2.OPS.paintFormXObjectBegin, [matrix, bbox]);
                    return this.getOperatorList({ stream: xobj, task, resources: dict.get("Resources") || resources, operatorList, initialState }).then(function() {
                      operatorList.addOp(_util2.OPS.paintFormXObjectEnd, []);
                      if (group) {
                        operatorList.addOp(_util2.OPS.endGroup, [groupOptions]);
                      }
                    });
                  }, async buildPaintImageXObject({ resources, image, isInline = false, operatorList, cacheKey, imageCache, forceDisableNativeImageDecoder = false }) {
                    var dict = image.dict;
                    var w = dict.get("Width", "W");
                    var h = dict.get("Height", "H");
                    if (!(w && (0, _util2.isNum)(w)) || !(h && (0, _util2.isNum)(h))) {
                      (0, _util2.warn)("Image dimensions are missing, or not numbers.");
                      return void 0;
                    }
                    var maxImageSize = this.options.maxImageSize;
                    if (maxImageSize !== -1 && w * h > maxImageSize) {
                      (0, _util2.warn)("Image exceeded maximum allowed size and was removed.");
                      return void 0;
                    }
                    var imageMask = dict.get("ImageMask", "IM") || false;
                    var imgData, args;
                    if (imageMask) {
                      var width = dict.get("Width", "W");
                      var height = dict.get("Height", "H");
                      var bitStrideLength = width + 7 >> 3;
                      var imgArray = image.getBytes(bitStrideLength * height, true);
                      var decode = dict.getArray("Decode", "D");
                      imgData = _image.PDFImage.createMask({ imgArray, width, height, imageIsFromDecodeStream: image instanceof _stream.DecodeStream, inverseDecode: !!decode && decode[0] > 0 });
                      imgData.cached = !!cacheKey;
                      args = [imgData];
                      operatorList.addOp(_util2.OPS.paintImageMaskXObject, args);
                      if (cacheKey) {
                        imageCache[cacheKey] = { fn: _util2.OPS.paintImageMaskXObject, args };
                      }
                      return void 0;
                    }
                    var softMask = dict.get("SMask", "SM") || false;
                    var mask = dict.get("Mask") || false;
                    var SMALL_IMAGE_DIMENSIONS = 200;
                    if (isInline && !softMask && !mask && !(image instanceof _jpeg_stream.JpegStream) && w + h < SMALL_IMAGE_DIMENSIONS) {
                      const imageObj = new _image.PDFImage({ xref: this.xref, res: resources, image, isInline, pdfFunctionFactory: this.pdfFunctionFactory });
                      imgData = imageObj.createImageData(true);
                      operatorList.addOp(_util2.OPS.paintInlineImageXObject, [imgData]);
                      return void 0;
                    }
                    const nativeImageDecoderSupport = forceDisableNativeImageDecoder ? _util2.NativeImageDecoding.NONE : this.options.nativeImageDecoderSupport;
                    let objId = `img_${this.idFactory.createObjId()}`;
                    if (this.parsingType3Font) {
                      (0, _util2.assert)(nativeImageDecoderSupport === _util2.NativeImageDecoding.NONE, "Type3 image resources should be completely decoded in the worker.");
                      objId = `${this.idFactory.getDocId()}_type3res_${objId}`;
                    }
                    if (nativeImageDecoderSupport !== _util2.NativeImageDecoding.NONE && !softMask && !mask && image instanceof _jpeg_stream.JpegStream && _image_utils.NativeImageDecoder.isSupported(image, this.xref, resources, this.pdfFunctionFactory) && image.maybeValidDimensions) {
                      return this.handler.sendWithPromise("obj", [objId, this.pageIndex, "JpegStream", image.getIR(this.options.forceDataSchema)]).then(function() {
                        operatorList.addDependency(objId);
                        args = [objId, w, h];
                        operatorList.addOp(_util2.OPS.paintJpegXObject, args);
                        if (cacheKey) {
                          imageCache[cacheKey] = { fn: _util2.OPS.paintJpegXObject, args };
                        }
                      }, (reason) => {
                        (0, _util2.warn)("Native JPEG decoding failed -- trying to recover: " + (reason && reason.message));
                        return this.buildPaintImageXObject({ resources, image, isInline, operatorList, cacheKey, imageCache, forceDisableNativeImageDecoder: true });
                      });
                    }
                    var nativeImageDecoder = null;
                    if (nativeImageDecoderSupport === _util2.NativeImageDecoding.DECODE && (image instanceof _jpeg_stream.JpegStream || mask instanceof _jpeg_stream.JpegStream || softMask instanceof _jpeg_stream.JpegStream)) {
                      nativeImageDecoder = new _image_utils.NativeImageDecoder({ xref: this.xref, resources, handler: this.handler, forceDataSchema: this.options.forceDataSchema, pdfFunctionFactory: this.pdfFunctionFactory });
                    }
                    operatorList.addDependency(objId);
                    args = [objId, w, h];
                    const imgPromise = _image.PDFImage.buildImage({ handler: this.handler, xref: this.xref, res: resources, image, isInline, nativeDecoder: nativeImageDecoder, pdfFunctionFactory: this.pdfFunctionFactory }).then((imageObj) => {
                      var imgData2 = imageObj.createImageData(false);
                      if (this.parsingType3Font) {
                        return this.handler.sendWithPromise("commonobj", [objId, "FontType3Res", imgData2], [imgData2.data.buffer]);
                      }
                      this.handler.send("obj", [objId, this.pageIndex, "Image", imgData2], [imgData2.data.buffer]);
                      return void 0;
                    }).catch((reason) => {
                      (0, _util2.warn)("Unable to decode image: " + reason);
                      if (this.parsingType3Font) {
                        return this.handler.sendWithPromise("commonobj", [objId, "FontType3Res", null]);
                      }
                      this.handler.send("obj", [objId, this.pageIndex, "Image", null]);
                      return void 0;
                    });
                    if (this.parsingType3Font) {
                      await imgPromise;
                    }
                    operatorList.addOp(_util2.OPS.paintImageXObject, args);
                    if (cacheKey) {
                      imageCache[cacheKey] = { fn: _util2.OPS.paintImageXObject, args };
                    }
                    return void 0;
                  }, handleSMask: function PartialEvaluator_handleSmask(smask, resources, operatorList, task, stateManager) {
                    var smaskContent = smask.get("G");
                    var smaskOptions = { subtype: smask.get("S").name, backdrop: smask.get("BC") };
                    var transferObj = smask.get("TR");
                    if ((0, _function.isPDFFunction)(transferObj)) {
                      const transferFn = this.pdfFunctionFactory.create(transferObj);
                      var transferMap = new Uint8Array(256);
                      var tmp = new Float32Array(1);
                      for (var i = 0; i < 256; i++) {
                        tmp[0] = i / 255;
                        transferFn(tmp, 0, tmp, 0);
                        transferMap[i] = tmp[0] * 255 | 0;
                      }
                      smaskOptions.transferMap = transferMap;
                    }
                    return this.buildFormXObject(resources, smaskContent, smaskOptions, operatorList, task, stateManager.state.clone());
                  }, handleTilingType(fn, args, resources, pattern, patternDict, operatorList, task) {
                    const tilingOpList = new _operator_list.OperatorList();
                    const resourcesArray = [patternDict.get("Resources"), resources];
                    const patternResources = _primitives.Dict.merge(this.xref, resourcesArray);
                    return this.getOperatorList({ stream: pattern, task, resources: patternResources, operatorList: tilingOpList }).then(function() {
                      return (0, _pattern.getTilingPatternIR)({ fnArray: tilingOpList.fnArray, argsArray: tilingOpList.argsArray }, patternDict, args);
                    }).then(function(tilingPatternIR) {
                      operatorList.addDependencies(tilingOpList.dependencies);
                      operatorList.addOp(fn, tilingPatternIR);
                    }, (reason) => {
                      if (reason instanceof _util2.AbortException) {
                        return;
                      }
                      if (this.options.ignoreErrors) {
                        this.handler.send("UnsupportedFeature", { featureId: _util2.UNSUPPORTED_FEATURES.unknown });
                        (0, _util2.warn)(`handleTilingType - ignoring pattern: "${reason}".`);
                        return;
                      }
                      throw reason;
                    });
                  }, handleSetFont: function PartialEvaluator_handleSetFont(resources, fontArgs, fontRef, operatorList, task, state) {
                    var fontName;
                    if (fontArgs) {
                      fontArgs = fontArgs.slice();
                      fontName = fontArgs[0].name;
                    }
                    return this.loadFont(fontName, fontRef, resources).then((translated) => {
                      if (!translated.font.isType3Font) {
                        return translated;
                      }
                      return translated.loadType3Data(this, resources, operatorList, task).then(function() {
                        return translated;
                      }).catch((reason) => {
                        this.handler.send("UnsupportedFeature", { featureId: _util2.UNSUPPORTED_FEATURES.font });
                        return new TranslatedFont("g_font_error", new _fonts.ErrorFont("Type3 font load error: " + reason), translated.font);
                      });
                    }).then((translated) => {
                      state.font = translated.font;
                      translated.send(this.handler);
                      return translated.loadedName;
                    });
                  }, handleText(chars, state) {
                    const font = state.font;
                    const glyphs = font.charsToGlyphs(chars);
                    if (font.data) {
                      const isAddToPathSet = !!(state.textRenderingMode & _util2.TextRenderingMode.ADD_TO_PATH_FLAG);
                      if (isAddToPathSet || state.fillColorSpace.name === "Pattern" || font.disableFontFace || this.options.disableFontFace) {
                        PartialEvaluator2.buildFontPaths(font, glyphs, this.handler);
                      }
                    }
                    return glyphs;
                  }, ensureStateFont(state) {
                    if (state.font) {
                      return;
                    }
                    const reason = new _util2.FormatError("Missing setFont (Tf) operator before text rendering operator.");
                    if (this.options.ignoreErrors) {
                      this.handler.send("UnsupportedFeature", { featureId: _util2.UNSUPPORTED_FEATURES.font });
                      (0, _util2.warn)(`ensureStateFont: "${reason}".`);
                      return;
                    }
                    throw reason;
                  }, setGState: function PartialEvaluator_setGState(resources, gState, operatorList, task, stateManager) {
                    var gStateObj = [];
                    var gStateKeys = gState.getKeys();
                    var promise = Promise.resolve();
                    for (var i = 0, ii = gStateKeys.length; i < ii; i++) {
                      const key = gStateKeys[i];
                      const value = gState.get(key);
                      switch (key) {
                        case "Type":
                          break;
                        case "LW":
                        case "LC":
                        case "LJ":
                        case "ML":
                        case "D":
                        case "RI":
                        case "FL":
                        case "CA":
                        case "ca":
                          gStateObj.push([key, value]);
                          break;
                        case "Font":
                          promise = promise.then(() => {
                            return this.handleSetFont(resources, null, value[0], operatorList, task, stateManager.state).then(function(loadedName) {
                              operatorList.addDependency(loadedName);
                              gStateObj.push([key, [loadedName, value[1]]]);
                            });
                          });
                          break;
                        case "BM":
                          gStateObj.push([key, normalizeBlendMode(value)]);
                          break;
                        case "SMask":
                          if ((0, _primitives.isName)(value, "None")) {
                            gStateObj.push([key, false]);
                            break;
                          }
                          if ((0, _primitives.isDict)(value)) {
                            promise = promise.then(() => {
                              return this.handleSMask(value, resources, operatorList, task, stateManager);
                            });
                            gStateObj.push([key, true]);
                          } else {
                            (0, _util2.warn)("Unsupported SMask type");
                          }
                          break;
                        case "OP":
                        case "op":
                        case "OPM":
                        case "BG":
                        case "BG2":
                        case "UCR":
                        case "UCR2":
                        case "TR":
                        case "TR2":
                        case "HT":
                        case "SM":
                        case "SA":
                        case "AIS":
                        case "TK":
                          (0, _util2.info)("graphic state operator " + key);
                          break;
                        default:
                          (0, _util2.info)("Unknown graphic state operator " + key);
                          break;
                      }
                    }
                    return promise.then(function() {
                      if (gStateObj.length > 0) {
                        operatorList.addOp(_util2.OPS.setGState, [gStateObj]);
                      }
                    });
                  }, loadFont: function PartialEvaluator_loadFont(fontName, font, resources) {
                    function errorFont() {
                      return Promise.resolve(new TranslatedFont("g_font_error", new _fonts.ErrorFont("Font " + fontName + " is not available"), font));
                    }
                    var fontRef, xref = this.xref;
                    if (font) {
                      if (!(0, _primitives.isRef)(font)) {
                        throw new _util2.FormatError('The "font" object should be a reference.');
                      }
                      fontRef = font;
                    } else {
                      var fontRes = resources.get("Font");
                      if (fontRes) {
                        fontRef = fontRes.getRaw(fontName);
                      }
                    }
                    if (!fontRef) {
                      const partialMsg = `Font "${fontName || font && font.toString()}" is not available`;
                      if (!this.options.ignoreErrors && !this.parsingType3Font) {
                        (0, _util2.warn)(`${partialMsg}.`);
                        return errorFont();
                      }
                      this.handler.send("UnsupportedFeature", { featureId: _util2.UNSUPPORTED_FEATURES.font });
                      (0, _util2.warn)(`${partialMsg} -- attempting to fallback to a default font.`);
                      fontRef = PartialEvaluator2.getFallbackFontDict();
                    }
                    if (this.fontCache.has(fontRef)) {
                      return this.fontCache.get(fontRef);
                    }
                    font = xref.fetchIfRef(fontRef);
                    if (!(0, _primitives.isDict)(font)) {
                      return errorFont();
                    }
                    if (font.translated) {
                      return font.translated;
                    }
                    var fontCapability = (0, _util2.createPromiseCapability)();
                    var preEvaluatedFont = this.preEvaluateFont(font);
                    const { descriptor, hash } = preEvaluatedFont;
                    var fontRefIsRef = (0, _primitives.isRef)(fontRef), fontID;
                    if (fontRefIsRef) {
                      fontID = fontRef.toString();
                    }
                    if (hash && (0, _primitives.isDict)(descriptor)) {
                      if (!descriptor.fontAliases) {
                        descriptor.fontAliases = /* @__PURE__ */ Object.create(null);
                      }
                      var fontAliases = descriptor.fontAliases;
                      if (fontAliases[hash]) {
                        var aliasFontRef = fontAliases[hash].aliasRef;
                        if (fontRefIsRef && aliasFontRef && this.fontCache.has(aliasFontRef)) {
                          this.fontCache.putAlias(fontRef, aliasFontRef);
                          return this.fontCache.get(fontRef);
                        }
                      } else {
                        fontAliases[hash] = { fontID: _fonts.Font.getFontID() };
                      }
                      if (fontRefIsRef) {
                        fontAliases[hash].aliasRef = fontRef;
                      }
                      fontID = fontAliases[hash].fontID;
                    }
                    if (fontRefIsRef) {
                      this.fontCache.put(fontRef, fontCapability.promise);
                    } else {
                      if (!fontID) {
                        fontID = this.idFactory.createObjId();
                      }
                      this.fontCache.put(`id_${fontID}`, fontCapability.promise);
                    }
                    (0, _util2.assert)(fontID, 'The "fontID" must be defined.');
                    font.loadedName = `${this.idFactory.getDocId()}_f${fontID}`;
                    font.translated = fontCapability.promise;
                    var translatedPromise;
                    try {
                      translatedPromise = this.translateFont(preEvaluatedFont);
                    } catch (e) {
                      translatedPromise = Promise.reject(e);
                    }
                    translatedPromise.then(function(translatedFont) {
                      if (translatedFont.fontType !== void 0) {
                        var xrefFontStats = xref.stats.fontTypes;
                        xrefFontStats[translatedFont.fontType] = true;
                      }
                      fontCapability.resolve(new TranslatedFont(font.loadedName, translatedFont, font));
                    }).catch((reason) => {
                      this.handler.send("UnsupportedFeature", { featureId: _util2.UNSUPPORTED_FEATURES.font });
                      try {
                        var fontFile3 = descriptor && descriptor.get("FontFile3");
                        var subtype = fontFile3 && fontFile3.get("Subtype");
                        var fontType = (0, _fonts.getFontType)(preEvaluatedFont.type, subtype && subtype.name);
                        var xrefFontStats = xref.stats.fontTypes;
                        xrefFontStats[fontType] = true;
                      } catch (ex) {
                      }
                      fontCapability.resolve(new TranslatedFont(font.loadedName, new _fonts.ErrorFont(reason instanceof Error ? reason.message : reason), font));
                    });
                    return fontCapability.promise;
                  }, buildPath(operatorList, fn, args, parsingText = false) {
                    var lastIndex = operatorList.length - 1;
                    if (!args) {
                      args = [];
                    }
                    if (lastIndex < 0 || operatorList.fnArray[lastIndex] !== _util2.OPS.constructPath) {
                      if (parsingText) {
                        (0, _util2.warn)(`Encountered path operator "${fn}" inside of a text object.`);
                        operatorList.addOp(_util2.OPS.save, null);
                      }
                      operatorList.addOp(_util2.OPS.constructPath, [[fn], args]);
                      if (parsingText) {
                        operatorList.addOp(_util2.OPS.restore, null);
                      }
                    } else {
                      var opArgs = operatorList.argsArray[lastIndex];
                      opArgs[0].push(fn);
                      Array.prototype.push.apply(opArgs[1], args);
                    }
                  }, parseColorSpace({ cs, resources }) {
                    return new Promise((resolve) => {
                      resolve(_colorspace.ColorSpace.parse(cs, this.xref, resources, this.pdfFunctionFactory));
                    }).catch((reason) => {
                      if (reason instanceof _util2.AbortException) {
                        return null;
                      }
                      if (this.options.ignoreErrors) {
                        this.handler.send("UnsupportedFeature", { featureId: _util2.UNSUPPORTED_FEATURES.unknown });
                        (0, _util2.warn)(`parseColorSpace - ignoring ColorSpace: "${reason}".`);
                        return null;
                      }
                      throw reason;
                    });
                  }, async handleColorN(operatorList, fn, args, cs, patterns, resources, task) {
                    var patternName = args[args.length - 1];
                    var pattern;
                    if ((0, _primitives.isName)(patternName) && (pattern = patterns.get(patternName.name))) {
                      var dict = (0, _primitives.isStream)(pattern) ? pattern.dict : pattern;
                      var typeNum = dict.get("PatternType");
                      if (typeNum === TILING_PATTERN) {
                        var color = cs.base ? cs.base.getRgb(args, 0) : null;
                        return this.handleTilingType(fn, color, resources, pattern, dict, operatorList, task);
                      } else if (typeNum === SHADING_PATTERN) {
                        var shading = dict.get("Shading");
                        var matrix = dict.getArray("Matrix");
                        pattern = _pattern.Pattern.parseShading(shading, matrix, this.xref, resources, this.handler, this.pdfFunctionFactory);
                        operatorList.addOp(fn, pattern.getIR());
                        return void 0;
                      }
                      throw new _util2.FormatError(`Unknown PatternType: ${typeNum}`);
                    }
                    throw new _util2.FormatError(`Unknown PatternName: ${patternName}`);
                  }, getOperatorList({ stream, task, resources, operatorList, initialState = null }) {
                    resources = resources || _primitives.Dict.empty;
                    initialState = initialState || new EvalState();
                    if (!operatorList) {
                      throw new Error('getOperatorList: missing "operatorList" parameter');
                    }
                    var self2 = this;
                    var xref = this.xref;
                    let parsingText = false;
                    var imageCache = /* @__PURE__ */ Object.create(null);
                    var xobjs = resources.get("XObject") || _primitives.Dict.empty;
                    var patterns = resources.get("Pattern") || _primitives.Dict.empty;
                    var stateManager = new StateManager(initialState);
                    var preprocessor = new EvaluatorPreprocessor(stream, xref, stateManager);
                    var timeSlotManager = new TimeSlotManager();
                    function closePendingRestoreOPS(argument) {
                      for (var i = 0, ii = preprocessor.savedStatesDepth; i < ii; i++) {
                        operatorList.addOp(_util2.OPS.restore, []);
                      }
                    }
                    return new Promise(function promiseBody(resolve, reject) {
                      const next = function(promise) {
                        Promise.all([promise, operatorList.ready]).then(function() {
                          try {
                            promiseBody(resolve, reject);
                          } catch (ex) {
                            reject(ex);
                          }
                        }, reject);
                      };
                      task.ensureNotTerminated();
                      timeSlotManager.reset();
                      var stop, operation = {}, i, ii, cs;
                      while (!(stop = timeSlotManager.check())) {
                        operation.args = null;
                        if (!preprocessor.read(operation)) {
                          break;
                        }
                        var args = operation.args;
                        var fn = operation.fn;
                        switch (fn | 0) {
                          case _util2.OPS.paintXObject:
                            var name = args[0].name;
                            if (name && imageCache[name] !== void 0) {
                              operatorList.addOp(imageCache[name].fn, imageCache[name].args);
                              args = null;
                              continue;
                            }
                            next(new Promise(function(resolveXObject, rejectXObject) {
                              if (!name) {
                                throw new _util2.FormatError("XObject must be referred to by name.");
                              }
                              const xobj = xobjs.get(name);
                              if (!xobj) {
                                operatorList.addOp(fn, args);
                                resolveXObject();
                                return;
                              }
                              if (!(0, _primitives.isStream)(xobj)) {
                                throw new _util2.FormatError("XObject should be a stream");
                              }
                              const type = xobj.dict.get("Subtype");
                              if (!(0, _primitives.isName)(type)) {
                                throw new _util2.FormatError("XObject should have a Name subtype");
                              }
                              if (type.name === "Form") {
                                stateManager.save();
                                self2.buildFormXObject(resources, xobj, null, operatorList, task, stateManager.state.clone()).then(function() {
                                  stateManager.restore();
                                  resolveXObject();
                                }, rejectXObject);
                                return;
                              } else if (type.name === "Image") {
                                self2.buildPaintImageXObject({ resources, image: xobj, operatorList, cacheKey: name, imageCache }).then(resolveXObject, rejectXObject);
                                return;
                              } else if (type.name === "PS") {
                                (0, _util2.info)("Ignored XObject subtype PS");
                              } else {
                                throw new _util2.FormatError(`Unhandled XObject subtype ${type.name}`);
                              }
                              resolveXObject();
                            }).catch(function(reason) {
                              if (reason instanceof _util2.AbortException) {
                                return;
                              }
                              if (self2.options.ignoreErrors) {
                                self2.handler.send("UnsupportedFeature", { featureId: _util2.UNSUPPORTED_FEATURES.unknown });
                                (0, _util2.warn)(`getOperatorList - ignoring XObject: "${reason}".`);
                                return;
                              }
                              throw reason;
                            }));
                            return;
                          case _util2.OPS.setFont:
                            var fontSize = args[1];
                            next(self2.handleSetFont(resources, args, null, operatorList, task, stateManager.state).then(function(loadedName) {
                              operatorList.addDependency(loadedName);
                              operatorList.addOp(_util2.OPS.setFont, [loadedName, fontSize]);
                            }));
                            return;
                          case _util2.OPS.beginText:
                            parsingText = true;
                            break;
                          case _util2.OPS.endText:
                            parsingText = false;
                            break;
                          case _util2.OPS.endInlineImage:
                            var cacheKey = args[0].cacheKey;
                            if (cacheKey) {
                              var cacheEntry = imageCache[cacheKey];
                              if (cacheEntry !== void 0) {
                                operatorList.addOp(cacheEntry.fn, cacheEntry.args);
                                args = null;
                                continue;
                              }
                            }
                            next(self2.buildPaintImageXObject({ resources, image: args[0], isInline: true, operatorList, cacheKey, imageCache }));
                            return;
                          case _util2.OPS.showText:
                            if (!stateManager.state.font) {
                              self2.ensureStateFont(stateManager.state);
                              continue;
                            }
                            args[0] = self2.handleText(args[0], stateManager.state);
                            break;
                          case _util2.OPS.showSpacedText:
                            if (!stateManager.state.font) {
                              self2.ensureStateFont(stateManager.state);
                              continue;
                            }
                            var arr = args[0];
                            var combinedGlyphs = [];
                            var arrLength = arr.length;
                            var state = stateManager.state;
                            for (i = 0; i < arrLength; ++i) {
                              var arrItem = arr[i];
                              if ((0, _util2.isString)(arrItem)) {
                                Array.prototype.push.apply(combinedGlyphs, self2.handleText(arrItem, state));
                              } else if ((0, _util2.isNum)(arrItem)) {
                                combinedGlyphs.push(arrItem);
                              }
                            }
                            args[0] = combinedGlyphs;
                            fn = _util2.OPS.showText;
                            break;
                          case _util2.OPS.nextLineShowText:
                            if (!stateManager.state.font) {
                              self2.ensureStateFont(stateManager.state);
                              continue;
                            }
                            operatorList.addOp(_util2.OPS.nextLine);
                            args[0] = self2.handleText(args[0], stateManager.state);
                            fn = _util2.OPS.showText;
                            break;
                          case _util2.OPS.nextLineSetSpacingShowText:
                            if (!stateManager.state.font) {
                              self2.ensureStateFont(stateManager.state);
                              continue;
                            }
                            operatorList.addOp(_util2.OPS.nextLine);
                            operatorList.addOp(_util2.OPS.setWordSpacing, [args.shift()]);
                            operatorList.addOp(_util2.OPS.setCharSpacing, [args.shift()]);
                            args[0] = self2.handleText(args[0], stateManager.state);
                            fn = _util2.OPS.showText;
                            break;
                          case _util2.OPS.setTextRenderingMode:
                            stateManager.state.textRenderingMode = args[0];
                            break;
                          case _util2.OPS.setFillColorSpace:
                            next(self2.parseColorSpace({ cs: args[0], resources }).then(function(colorSpace) {
                              if (colorSpace) {
                                stateManager.state.fillColorSpace = colorSpace;
                              }
                            }));
                            return;
                          case _util2.OPS.setStrokeColorSpace:
                            next(self2.parseColorSpace({ cs: args[0], resources }).then(function(colorSpace) {
                              if (colorSpace) {
                                stateManager.state.strokeColorSpace = colorSpace;
                              }
                            }));
                            return;
                          case _util2.OPS.setFillColor:
                            cs = stateManager.state.fillColorSpace;
                            args = cs.getRgb(args, 0);
                            fn = _util2.OPS.setFillRGBColor;
                            break;
                          case _util2.OPS.setStrokeColor:
                            cs = stateManager.state.strokeColorSpace;
                            args = cs.getRgb(args, 0);
                            fn = _util2.OPS.setStrokeRGBColor;
                            break;
                          case _util2.OPS.setFillGray:
                            stateManager.state.fillColorSpace = _colorspace.ColorSpace.singletons.gray;
                            args = _colorspace.ColorSpace.singletons.gray.getRgb(args, 0);
                            fn = _util2.OPS.setFillRGBColor;
                            break;
                          case _util2.OPS.setStrokeGray:
                            stateManager.state.strokeColorSpace = _colorspace.ColorSpace.singletons.gray;
                            args = _colorspace.ColorSpace.singletons.gray.getRgb(args, 0);
                            fn = _util2.OPS.setStrokeRGBColor;
                            break;
                          case _util2.OPS.setFillCMYKColor:
                            stateManager.state.fillColorSpace = _colorspace.ColorSpace.singletons.cmyk;
                            args = _colorspace.ColorSpace.singletons.cmyk.getRgb(args, 0);
                            fn = _util2.OPS.setFillRGBColor;
                            break;
                          case _util2.OPS.setStrokeCMYKColor:
                            stateManager.state.strokeColorSpace = _colorspace.ColorSpace.singletons.cmyk;
                            args = _colorspace.ColorSpace.singletons.cmyk.getRgb(args, 0);
                            fn = _util2.OPS.setStrokeRGBColor;
                            break;
                          case _util2.OPS.setFillRGBColor:
                            stateManager.state.fillColorSpace = _colorspace.ColorSpace.singletons.rgb;
                            args = _colorspace.ColorSpace.singletons.rgb.getRgb(args, 0);
                            break;
                          case _util2.OPS.setStrokeRGBColor:
                            stateManager.state.strokeColorSpace = _colorspace.ColorSpace.singletons.rgb;
                            args = _colorspace.ColorSpace.singletons.rgb.getRgb(args, 0);
                            break;
                          case _util2.OPS.setFillColorN:
                            cs = stateManager.state.fillColorSpace;
                            if (cs.name === "Pattern") {
                              next(self2.handleColorN(operatorList, _util2.OPS.setFillColorN, args, cs, patterns, resources, task));
                              return;
                            }
                            args = cs.getRgb(args, 0);
                            fn = _util2.OPS.setFillRGBColor;
                            break;
                          case _util2.OPS.setStrokeColorN:
                            cs = stateManager.state.strokeColorSpace;
                            if (cs.name === "Pattern") {
                              next(self2.handleColorN(operatorList, _util2.OPS.setStrokeColorN, args, cs, patterns, resources, task));
                              return;
                            }
                            args = cs.getRgb(args, 0);
                            fn = _util2.OPS.setStrokeRGBColor;
                            break;
                          case _util2.OPS.shadingFill:
                            var shadingRes = resources.get("Shading");
                            if (!shadingRes) {
                              throw new _util2.FormatError("No shading resource found");
                            }
                            var shading = shadingRes.get(args[0].name);
                            if (!shading) {
                              throw new _util2.FormatError("No shading object found");
                            }
                            var shadingFill = _pattern.Pattern.parseShading(shading, null, xref, resources, self2.handler, self2.pdfFunctionFactory);
                            var patternIR = shadingFill.getIR();
                            args = [patternIR];
                            fn = _util2.OPS.shadingFill;
                            break;
                          case _util2.OPS.setGState:
                            var dictName = args[0];
                            var extGState = resources.get("ExtGState");
                            if (!(0, _primitives.isDict)(extGState) || !extGState.has(dictName.name)) {
                              break;
                            }
                            var gState = extGState.get(dictName.name);
                            next(self2.setGState(resources, gState, operatorList, task, stateManager));
                            return;
                          case _util2.OPS.moveTo:
                          case _util2.OPS.lineTo:
                          case _util2.OPS.curveTo:
                          case _util2.OPS.curveTo2:
                          case _util2.OPS.curveTo3:
                          case _util2.OPS.closePath:
                          case _util2.OPS.rectangle:
                            self2.buildPath(operatorList, fn, args, parsingText);
                            continue;
                          case _util2.OPS.markPoint:
                          case _util2.OPS.markPointProps:
                          case _util2.OPS.beginMarkedContent:
                          case _util2.OPS.beginMarkedContentProps:
                          case _util2.OPS.endMarkedContent:
                          case _util2.OPS.beginCompat:
                          case _util2.OPS.endCompat:
                            continue;
                          default:
                            if (args !== null) {
                              for (i = 0, ii = args.length; i < ii; i++) {
                                if (args[i] instanceof _primitives.Dict) {
                                  break;
                                }
                              }
                              if (i < ii) {
                                (0, _util2.warn)("getOperatorList - ignoring operator: " + fn);
                                continue;
                              }
                            }
                        }
                        operatorList.addOp(fn, args);
                      }
                      if (stop) {
                        next(deferred);
                        return;
                      }
                      closePendingRestoreOPS();
                      resolve();
                    }).catch((reason) => {
                      if (reason instanceof _util2.AbortException) {
                        return;
                      }
                      if (this.options.ignoreErrors) {
                        this.handler.send("UnsupportedFeature", { featureId: _util2.UNSUPPORTED_FEATURES.unknown });
                        (0, _util2.warn)(`getOperatorList - ignoring errors during "${task.name}" task: "${reason}".`);
                        closePendingRestoreOPS();
                        return;
                      }
                      throw reason;
                    });
                  }, getTextContent({ stream, task, resources, stateManager = null, normalizeWhitespace = false, combineTextItems = false, sink, seenStyles = /* @__PURE__ */ Object.create(null) }) {
                    resources = resources || _primitives.Dict.empty;
                    stateManager = stateManager || new StateManager(new TextState());
                    var WhitespaceRegexp = /\s/g;
                    var textContent = { items: [], styles: /* @__PURE__ */ Object.create(null) };
                    var textContentItem = { initialized: false, str: [], width: 0, height: 0, vertical: false, lastAdvanceWidth: 0, lastAdvanceHeight: 0, textAdvanceScale: 0, spaceWidth: 0, fakeSpaceMin: Infinity, fakeMultiSpaceMin: Infinity, fakeMultiSpaceMax: -0, textRunBreakAllowed: false, transform: null, fontName: null };
                    var SPACE_FACTOR = 0.3;
                    var MULTI_SPACE_FACTOR = 1.5;
                    var MULTI_SPACE_FACTOR_MAX = 4;
                    var self2 = this;
                    var xref = this.xref;
                    var xobjs = null;
                    var skipEmptyXObjs = /* @__PURE__ */ Object.create(null);
                    var preprocessor = new EvaluatorPreprocessor(stream, xref, stateManager);
                    var textState;
                    function ensureTextContentItem() {
                      if (textContentItem.initialized) {
                        return textContentItem;
                      }
                      var font = textState.font;
                      if (!(font.loadedName in seenStyles)) {
                        seenStyles[font.loadedName] = true;
                        textContent.styles[font.loadedName] = { fontFamily: font.fallbackName, ascent: font.ascent, descent: font.descent, vertical: !!font.vertical };
                      }
                      textContentItem.fontName = font.loadedName;
                      var tsm = [textState.fontSize * textState.textHScale, 0, 0, textState.fontSize, 0, textState.textRise];
                      if (font.isType3Font && textState.fontSize <= 1 && !(0, _util2.isArrayEqual)(textState.fontMatrix, _util2.FONT_IDENTITY_MATRIX)) {
                        const glyphHeight = font.bbox[3] - font.bbox[1];
                        if (glyphHeight > 0) {
                          tsm[3] *= glyphHeight * textState.fontMatrix[3];
                        }
                      }
                      var trm = _util2.Util.transform(textState.ctm, _util2.Util.transform(textState.textMatrix, tsm));
                      textContentItem.transform = trm;
                      if (!font.vertical) {
                        textContentItem.width = 0;
                        textContentItem.height = Math.sqrt(trm[2] * trm[2] + trm[3] * trm[3]);
                        textContentItem.vertical = false;
                      } else {
                        textContentItem.width = Math.sqrt(trm[0] * trm[0] + trm[1] * trm[1]);
                        textContentItem.height = 0;
                        textContentItem.vertical = true;
                      }
                      var a = textState.textLineMatrix[0];
                      var b = textState.textLineMatrix[1];
                      var scaleLineX = Math.sqrt(a * a + b * b);
                      a = textState.ctm[0];
                      b = textState.ctm[1];
                      var scaleCtmX = Math.sqrt(a * a + b * b);
                      textContentItem.textAdvanceScale = scaleCtmX * scaleLineX;
                      textContentItem.lastAdvanceWidth = 0;
                      textContentItem.lastAdvanceHeight = 0;
                      var spaceWidth = font.spaceWidth / 1e3 * textState.fontSize;
                      if (spaceWidth) {
                        textContentItem.spaceWidth = spaceWidth;
                        textContentItem.fakeSpaceMin = spaceWidth * SPACE_FACTOR;
                        textContentItem.fakeMultiSpaceMin = spaceWidth * MULTI_SPACE_FACTOR;
                        textContentItem.fakeMultiSpaceMax = spaceWidth * MULTI_SPACE_FACTOR_MAX;
                        textContentItem.textRunBreakAllowed = !font.isMonospace;
                      } else {
                        textContentItem.spaceWidth = 0;
                        textContentItem.fakeSpaceMin = Infinity;
                        textContentItem.fakeMultiSpaceMin = Infinity;
                        textContentItem.fakeMultiSpaceMax = 0;
                        textContentItem.textRunBreakAllowed = false;
                      }
                      textContentItem.initialized = true;
                      return textContentItem;
                    }
                    function replaceWhitespace(str) {
                      var i = 0, ii = str.length, code;
                      while (i < ii && (code = str.charCodeAt(i)) >= 32 && code <= 127) {
                        i++;
                      }
                      return i < ii ? str.replace(WhitespaceRegexp, " ") : str;
                    }
                    function runBidiTransform(textChunk) {
                      var str = textChunk.str.join("");
                      var bidiResult = (0, _bidi.bidi)(str, -1, textChunk.vertical);
                      return { str: normalizeWhitespace ? replaceWhitespace(bidiResult.str) : bidiResult.str, dir: bidiResult.dir, width: textChunk.width, height: textChunk.height, transform: textChunk.transform, fontName: textChunk.fontName };
                    }
                    function handleSetFont(fontName, fontRef) {
                      return self2.loadFont(fontName, fontRef, resources).then(function(translated) {
                        textState.font = translated.font;
                        textState.fontMatrix = translated.font.fontMatrix || _util2.FONT_IDENTITY_MATRIX;
                      });
                    }
                    function buildTextContentItem(chars) {
                      var font = textState.font;
                      var textChunk = ensureTextContentItem();
                      var width = 0;
                      var height = 0;
                      var glyphs = font.charsToGlyphs(chars);
                      for (var i = 0; i < glyphs.length; i++) {
                        var glyph = glyphs[i];
                        var glyphWidth = null;
                        if (font.vertical && glyph.vmetric) {
                          glyphWidth = glyph.vmetric[0];
                        } else {
                          glyphWidth = glyph.width;
                        }
                        var glyphUnicode = glyph.unicode;
                        var NormalizedUnicodes = (0, _unicode.getNormalizedUnicodes)();
                        if (NormalizedUnicodes[glyphUnicode] !== void 0) {
                          glyphUnicode = NormalizedUnicodes[glyphUnicode];
                        }
                        glyphUnicode = (0, _unicode.reverseIfRtl)(glyphUnicode);
                        var charSpacing = textState.charSpacing;
                        if (glyph.isSpace) {
                          var wordSpacing = textState.wordSpacing;
                          charSpacing += wordSpacing;
                          if (wordSpacing > 0) {
                            addFakeSpaces(wordSpacing, textChunk.str);
                          }
                        }
                        var tx = 0;
                        var ty = 0;
                        if (!font.vertical) {
                          var w0 = glyphWidth * textState.fontMatrix[0];
                          tx = (w0 * textState.fontSize + charSpacing) * textState.textHScale;
                          width += tx;
                        } else {
                          var w1 = glyphWidth * textState.fontMatrix[0];
                          ty = w1 * textState.fontSize + charSpacing;
                          height += ty;
                        }
                        textState.translateTextMatrix(tx, ty);
                        textChunk.str.push(glyphUnicode);
                      }
                      if (!font.vertical) {
                        textChunk.lastAdvanceWidth = width;
                        textChunk.width += width;
                      } else {
                        textChunk.lastAdvanceHeight = height;
                        textChunk.height += Math.abs(height);
                      }
                      return textChunk;
                    }
                    function addFakeSpaces(width, strBuf) {
                      if (width < textContentItem.fakeSpaceMin) {
                        return;
                      }
                      if (width < textContentItem.fakeMultiSpaceMin) {
                        strBuf.push(" ");
                        return;
                      }
                      var fakeSpaces = Math.round(width / textContentItem.spaceWidth);
                      while (fakeSpaces-- > 0) {
                        strBuf.push(" ");
                      }
                    }
                    function flushTextContentItem() {
                      if (!textContentItem.initialized) {
                        return;
                      }
                      if (!textContentItem.vertical) {
                        textContentItem.width *= textContentItem.textAdvanceScale;
                      } else {
                        textContentItem.height *= textContentItem.textAdvanceScale;
                      }
                      textContent.items.push(runBidiTransform(textContentItem));
                      textContentItem.initialized = false;
                      textContentItem.str.length = 0;
                    }
                    function enqueueChunk() {
                      const length = textContent.items.length;
                      if (length > 0) {
                        sink.enqueue(textContent, length);
                        textContent.items = [];
                        textContent.styles = /* @__PURE__ */ Object.create(null);
                      }
                    }
                    var timeSlotManager = new TimeSlotManager();
                    return new Promise(function promiseBody(resolve, reject) {
                      const next = function(promise) {
                        enqueueChunk();
                        Promise.all([promise, sink.ready]).then(function() {
                          try {
                            promiseBody(resolve, reject);
                          } catch (ex) {
                            reject(ex);
                          }
                        }, reject);
                      };
                      task.ensureNotTerminated();
                      timeSlotManager.reset();
                      var stop, operation = {}, args = [];
                      while (!(stop = timeSlotManager.check())) {
                        args.length = 0;
                        operation.args = args;
                        if (!preprocessor.read(operation)) {
                          break;
                        }
                        textState = stateManager.state;
                        var fn = operation.fn;
                        args = operation.args;
                        var advance, diff;
                        switch (fn | 0) {
                          case _util2.OPS.setFont:
                            var fontNameArg = args[0].name, fontSizeArg = args[1];
                            if (textState.font && fontNameArg === textState.fontName && fontSizeArg === textState.fontSize) {
                              break;
                            }
                            flushTextContentItem();
                            textState.fontName = fontNameArg;
                            textState.fontSize = fontSizeArg;
                            next(handleSetFont(fontNameArg, null));
                            return;
                          case _util2.OPS.setTextRise:
                            flushTextContentItem();
                            textState.textRise = args[0];
                            break;
                          case _util2.OPS.setHScale:
                            flushTextContentItem();
                            textState.textHScale = args[0] / 100;
                            break;
                          case _util2.OPS.setLeading:
                            flushTextContentItem();
                            textState.leading = args[0];
                            break;
                          case _util2.OPS.moveText:
                            var isSameTextLine = !textState.font ? false : (textState.font.vertical ? args[0] : args[1]) === 0;
                            advance = args[0] - args[1];
                            if (combineTextItems && isSameTextLine && textContentItem.initialized && advance > 0 && advance <= textContentItem.fakeMultiSpaceMax) {
                              textState.translateTextLineMatrix(args[0], args[1]);
                              textContentItem.width += args[0] - textContentItem.lastAdvanceWidth;
                              textContentItem.height += args[1] - textContentItem.lastAdvanceHeight;
                              diff = args[0] - textContentItem.lastAdvanceWidth - (args[1] - textContentItem.lastAdvanceHeight);
                              addFakeSpaces(diff, textContentItem.str);
                              break;
                            }
                            flushTextContentItem();
                            textState.translateTextLineMatrix(args[0], args[1]);
                            textState.textMatrix = textState.textLineMatrix.slice();
                            break;
                          case _util2.OPS.setLeadingMoveText:
                            flushTextContentItem();
                            textState.leading = -args[1];
                            textState.translateTextLineMatrix(args[0], args[1]);
                            textState.textMatrix = textState.textLineMatrix.slice();
                            break;
                          case _util2.OPS.nextLine:
                            flushTextContentItem();
                            textState.carriageReturn();
                            break;
                          case _util2.OPS.setTextMatrix:
                            advance = textState.calcTextLineMatrixAdvance(args[0], args[1], args[2], args[3], args[4], args[5]);
                            if (combineTextItems && advance !== null && textContentItem.initialized && advance.value > 0 && advance.value <= textContentItem.fakeMultiSpaceMax) {
                              textState.translateTextLineMatrix(advance.width, advance.height);
                              textContentItem.width += advance.width - textContentItem.lastAdvanceWidth;
                              textContentItem.height += advance.height - textContentItem.lastAdvanceHeight;
                              diff = advance.width - textContentItem.lastAdvanceWidth - (advance.height - textContentItem.lastAdvanceHeight);
                              addFakeSpaces(diff, textContentItem.str);
                              break;
                            }
                            flushTextContentItem();
                            textState.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
                            textState.setTextLineMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
                            break;
                          case _util2.OPS.setCharSpacing:
                            textState.charSpacing = args[0];
                            break;
                          case _util2.OPS.setWordSpacing:
                            textState.wordSpacing = args[0];
                            break;
                          case _util2.OPS.beginText:
                            flushTextContentItem();
                            textState.textMatrix = _util2.IDENTITY_MATRIX.slice();
                            textState.textLineMatrix = _util2.IDENTITY_MATRIX.slice();
                            break;
                          case _util2.OPS.showSpacedText:
                            if (!stateManager.state.font) {
                              self2.ensureStateFont(stateManager.state);
                              continue;
                            }
                            var items = args[0];
                            var offset;
                            for (var j = 0, jj = items.length; j < jj; j++) {
                              if (typeof items[j] === "string") {
                                buildTextContentItem(items[j]);
                              } else if ((0, _util2.isNum)(items[j])) {
                                ensureTextContentItem();
                                advance = items[j] * textState.fontSize / 1e3;
                                var breakTextRun = false;
                                if (textState.font.vertical) {
                                  offset = advance;
                                  textState.translateTextMatrix(0, offset);
                                  breakTextRun = textContentItem.textRunBreakAllowed && advance > textContentItem.fakeMultiSpaceMax;
                                  if (!breakTextRun) {
                                    textContentItem.height += offset;
                                  }
                                } else {
                                  advance = -advance;
                                  offset = advance * textState.textHScale;
                                  textState.translateTextMatrix(offset, 0);
                                  breakTextRun = textContentItem.textRunBreakAllowed && advance > textContentItem.fakeMultiSpaceMax;
                                  if (!breakTextRun) {
                                    textContentItem.width += offset;
                                  }
                                }
                                if (breakTextRun) {
                                  flushTextContentItem();
                                } else if (advance > 0) {
                                  addFakeSpaces(advance, textContentItem.str);
                                }
                              }
                            }
                            break;
                          case _util2.OPS.showText:
                            if (!stateManager.state.font) {
                              self2.ensureStateFont(stateManager.state);
                              continue;
                            }
                            buildTextContentItem(args[0]);
                            break;
                          case _util2.OPS.nextLineShowText:
                            if (!stateManager.state.font) {
                              self2.ensureStateFont(stateManager.state);
                              continue;
                            }
                            flushTextContentItem();
                            textState.carriageReturn();
                            buildTextContentItem(args[0]);
                            break;
                          case _util2.OPS.nextLineSetSpacingShowText:
                            if (!stateManager.state.font) {
                              self2.ensureStateFont(stateManager.state);
                              continue;
                            }
                            flushTextContentItem();
                            textState.wordSpacing = args[0];
                            textState.charSpacing = args[1];
                            textState.carriageReturn();
                            buildTextContentItem(args[2]);
                            break;
                          case _util2.OPS.paintXObject:
                            flushTextContentItem();
                            if (!xobjs) {
                              xobjs = resources.get("XObject") || _primitives.Dict.empty;
                            }
                            var name = args[0].name;
                            if (name && skipEmptyXObjs[name] !== void 0) {
                              break;
                            }
                            next(new Promise(function(resolveXObject, rejectXObject) {
                              if (!name) {
                                throw new _util2.FormatError("XObject must be referred to by name.");
                              }
                              const xobj = xobjs.get(name);
                              if (!xobj) {
                                resolveXObject();
                                return;
                              }
                              if (!(0, _primitives.isStream)(xobj)) {
                                throw new _util2.FormatError("XObject should be a stream");
                              }
                              const type = xobj.dict.get("Subtype");
                              if (!(0, _primitives.isName)(type)) {
                                throw new _util2.FormatError("XObject should have a Name subtype");
                              }
                              if (type.name !== "Form") {
                                skipEmptyXObjs[name] = true;
                                resolveXObject();
                                return;
                              }
                              const currentState = stateManager.state.clone();
                              const xObjStateManager = new StateManager(currentState);
                              const matrix = xobj.dict.getArray("Matrix");
                              if (Array.isArray(matrix) && matrix.length === 6) {
                                xObjStateManager.transform(matrix);
                              }
                              enqueueChunk();
                              const sinkWrapper = { enqueueInvoked: false, enqueue(chunk, size) {
                                this.enqueueInvoked = true;
                                sink.enqueue(chunk, size);
                              }, get desiredSize() {
                                return sink.desiredSize;
                              }, get ready() {
                                return sink.ready;
                              } };
                              self2.getTextContent({ stream: xobj, task, resources: xobj.dict.get("Resources") || resources, stateManager: xObjStateManager, normalizeWhitespace, combineTextItems, sink: sinkWrapper, seenStyles }).then(function() {
                                if (!sinkWrapper.enqueueInvoked) {
                                  skipEmptyXObjs[name] = true;
                                }
                                resolveXObject();
                              }, rejectXObject);
                            }).catch(function(reason) {
                              if (reason instanceof _util2.AbortException) {
                                return;
                              }
                              if (self2.options.ignoreErrors) {
                                (0, _util2.warn)(`getTextContent - ignoring XObject: "${reason}".`);
                                return;
                              }
                              throw reason;
                            }));
                            return;
                          case _util2.OPS.setGState:
                            flushTextContentItem();
                            var dictName = args[0];
                            var extGState = resources.get("ExtGState");
                            if (!(0, _primitives.isDict)(extGState) || !(0, _primitives.isName)(dictName)) {
                              break;
                            }
                            var gState = extGState.get(dictName.name);
                            if (!(0, _primitives.isDict)(gState)) {
                              break;
                            }
                            var gStateFont = gState.get("Font");
                            if (gStateFont) {
                              textState.fontName = null;
                              textState.fontSize = gStateFont[1];
                              next(handleSetFont(null, gStateFont[0]));
                              return;
                            }
                            break;
                        }
                        if (textContent.items.length >= sink.desiredSize) {
                          stop = true;
                          break;
                        }
                      }
                      if (stop) {
                        next(deferred);
                        return;
                      }
                      flushTextContentItem();
                      enqueueChunk();
                      resolve();
                    }).catch((reason) => {
                      if (reason instanceof _util2.AbortException) {
                        return;
                      }
                      if (this.options.ignoreErrors) {
                        (0, _util2.warn)(`getTextContent - ignoring errors during "${task.name}" task: "${reason}".`);
                        flushTextContentItem();
                        enqueueChunk();
                        return;
                      }
                      throw reason;
                    });
                  }, extractDataStructures: function PartialEvaluator_extractDataStructures(dict, baseDict, properties) {
                    const xref = this.xref;
                    let cidToGidBytes;
                    var toUnicode = dict.get("ToUnicode") || baseDict.get("ToUnicode");
                    var toUnicodePromise = toUnicode ? this.readToUnicode(toUnicode) : Promise.resolve(void 0);
                    if (properties.composite) {
                      var cidSystemInfo = dict.get("CIDSystemInfo");
                      if ((0, _primitives.isDict)(cidSystemInfo)) {
                        properties.cidSystemInfo = { registry: (0, _util2.stringToPDFString)(cidSystemInfo.get("Registry")), ordering: (0, _util2.stringToPDFString)(cidSystemInfo.get("Ordering")), supplement: cidSystemInfo.get("Supplement") };
                      }
                      var cidToGidMap = dict.get("CIDToGIDMap");
                      if ((0, _primitives.isStream)(cidToGidMap)) {
                        cidToGidBytes = cidToGidMap.getBytes();
                      }
                    }
                    var differences = [];
                    var baseEncodingName = null;
                    var encoding;
                    if (dict.has("Encoding")) {
                      encoding = dict.get("Encoding");
                      if ((0, _primitives.isDict)(encoding)) {
                        baseEncodingName = encoding.get("BaseEncoding");
                        baseEncodingName = (0, _primitives.isName)(baseEncodingName) ? baseEncodingName.name : null;
                        if (encoding.has("Differences")) {
                          var diffEncoding = encoding.get("Differences");
                          var index = 0;
                          for (var j = 0, jj = diffEncoding.length; j < jj; j++) {
                            var data = xref.fetchIfRef(diffEncoding[j]);
                            if ((0, _util2.isNum)(data)) {
                              index = data;
                            } else if ((0, _primitives.isName)(data)) {
                              differences[index++] = data.name;
                            } else {
                              throw new _util2.FormatError(`Invalid entry in 'Differences' array: ${data}`);
                            }
                          }
                        }
                      } else if ((0, _primitives.isName)(encoding)) {
                        baseEncodingName = encoding.name;
                      } else {
                        throw new _util2.FormatError("Encoding is not a Name nor a Dict");
                      }
                      if (baseEncodingName !== "MacRomanEncoding" && baseEncodingName !== "MacExpertEncoding" && baseEncodingName !== "WinAnsiEncoding") {
                        baseEncodingName = null;
                      }
                    }
                    if (baseEncodingName) {
                      properties.defaultEncoding = (0, _encodings.getEncoding)(baseEncodingName).slice();
                    } else {
                      var isSymbolicFont = !!(properties.flags & _fonts.FontFlags.Symbolic);
                      var isNonsymbolicFont = !!(properties.flags & _fonts.FontFlags.Nonsymbolic);
                      encoding = _encodings.StandardEncoding;
                      if (properties.type === "TrueType" && !isNonsymbolicFont) {
                        encoding = _encodings.WinAnsiEncoding;
                      }
                      if (isSymbolicFont) {
                        encoding = _encodings.MacRomanEncoding;
                        if (!properties.file) {
                          if (/Symbol/i.test(properties.name)) {
                            encoding = _encodings.SymbolSetEncoding;
                          } else if (/Dingbats|Wingdings/i.test(properties.name)) {
                            encoding = _encodings.ZapfDingbatsEncoding;
                          }
                        }
                      }
                      properties.defaultEncoding = encoding;
                    }
                    properties.differences = differences;
                    properties.baseEncodingName = baseEncodingName;
                    properties.hasEncoding = !!baseEncodingName || differences.length > 0;
                    properties.dict = dict;
                    return toUnicodePromise.then((toUnicode2) => {
                      properties.toUnicode = toUnicode2;
                      return this.buildToUnicode(properties);
                    }).then((toUnicode2) => {
                      properties.toUnicode = toUnicode2;
                      if (cidToGidBytes) {
                        properties.cidToGidMap = this.readCidToGidMap(cidToGidBytes, toUnicode2);
                      }
                      return properties;
                    });
                  }, _buildSimpleFontToUnicode(properties, forceGlyphs = false) {
                    (0, _util2.assert)(!properties.composite, "Must be a simple font.");
                    const toUnicode = [];
                    const encoding = properties.defaultEncoding.slice();
                    const baseEncodingName = properties.baseEncodingName;
                    const differences = properties.differences;
                    for (const charcode in differences) {
                      const glyphName = differences[charcode];
                      if (glyphName === ".notdef") {
                        continue;
                      }
                      encoding[charcode] = glyphName;
                    }
                    const glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();
                    for (const charcode in encoding) {
                      let glyphName = encoding[charcode];
                      if (glyphName === "") {
                        continue;
                      } else if (glyphsUnicodeMap[glyphName] === void 0) {
                        let code = 0;
                        switch (glyphName[0]) {
                          case "G":
                            if (glyphName.length === 3) {
                              code = parseInt(glyphName.substring(1), 16);
                            }
                            break;
                          case "g":
                            if (glyphName.length === 5) {
                              code = parseInt(glyphName.substring(1), 16);
                            }
                            break;
                          case "C":
                          case "c":
                            if (glyphName.length >= 3 && glyphName.length <= 4) {
                              const codeStr = glyphName.substring(1);
                              if (forceGlyphs) {
                                code = parseInt(codeStr, 16);
                                break;
                              }
                              code = +codeStr;
                              if (Number.isNaN(code) && Number.isInteger(parseInt(codeStr, 16))) {
                                return this._buildSimpleFontToUnicode(properties, true);
                              }
                            }
                            break;
                          default:
                            const unicode = (0, _unicode.getUnicodeForGlyph)(glyphName, glyphsUnicodeMap);
                            if (unicode !== -1) {
                              code = unicode;
                            }
                        }
                        if (code > 0 && Number.isInteger(code)) {
                          if (baseEncodingName && code === +charcode) {
                            const baseEncoding = (0, _encodings.getEncoding)(baseEncodingName);
                            if (baseEncoding && (glyphName = baseEncoding[charcode])) {
                              toUnicode[charcode] = String.fromCharCode(glyphsUnicodeMap[glyphName]);
                              continue;
                            }
                          }
                          toUnicode[charcode] = String.fromCodePoint(code);
                        }
                        continue;
                      }
                      toUnicode[charcode] = String.fromCharCode(glyphsUnicodeMap[glyphName]);
                    }
                    return new _fonts.ToUnicodeMap(toUnicode);
                  }, buildToUnicode(properties) {
                    properties.hasIncludedToUnicodeMap = !!properties.toUnicode && properties.toUnicode.length > 0;
                    if (properties.hasIncludedToUnicodeMap) {
                      if (!properties.composite && properties.hasEncoding) {
                        properties.fallbackToUnicode = this._buildSimpleFontToUnicode(properties);
                      }
                      return Promise.resolve(properties.toUnicode);
                    }
                    if (!properties.composite) {
                      return Promise.resolve(this._buildSimpleFontToUnicode(properties));
                    }
                    if (properties.composite && (properties.cMap.builtInCMap && !(properties.cMap instanceof _cmap.IdentityCMap) || properties.cidSystemInfo.registry === "Adobe" && (properties.cidSystemInfo.ordering === "GB1" || properties.cidSystemInfo.ordering === "CNS1" || properties.cidSystemInfo.ordering === "Japan1" || properties.cidSystemInfo.ordering === "Korea1"))) {
                      const registry = properties.cidSystemInfo.registry;
                      const ordering = properties.cidSystemInfo.ordering;
                      const ucs2CMapName = _primitives.Name.get(registry + "-" + ordering + "-UCS2");
                      return _cmap.CMapFactory.create({ encoding: ucs2CMapName, fetchBuiltInCMap: this.fetchBuiltInCMap, useCMap: null }).then(function(ucs2CMap) {
                        const cMap = properties.cMap;
                        const toUnicode = [];
                        cMap.forEach(function(charcode, cid) {
                          if (cid > 65535) {
                            throw new _util2.FormatError("Max size of CID is 65,535");
                          }
                          const ucs2 = ucs2CMap.lookup(cid);
                          if (ucs2) {
                            toUnicode[charcode] = String.fromCharCode((ucs2.charCodeAt(0) << 8) + ucs2.charCodeAt(1));
                          }
                        });
                        return new _fonts.ToUnicodeMap(toUnicode);
                      });
                    }
                    return Promise.resolve(new _fonts.IdentityToUnicodeMap(properties.firstChar, properties.lastChar));
                  }, readToUnicode: function PartialEvaluator_readToUnicode(toUnicode) {
                    var cmapObj = toUnicode;
                    if ((0, _primitives.isName)(cmapObj)) {
                      return _cmap.CMapFactory.create({ encoding: cmapObj, fetchBuiltInCMap: this.fetchBuiltInCMap, useCMap: null }).then(function(cmap) {
                        if (cmap instanceof _cmap.IdentityCMap) {
                          return new _fonts.IdentityToUnicodeMap(0, 65535);
                        }
                        return new _fonts.ToUnicodeMap(cmap.getMap());
                      });
                    } else if ((0, _primitives.isStream)(cmapObj)) {
                      return _cmap.CMapFactory.create({ encoding: cmapObj, fetchBuiltInCMap: this.fetchBuiltInCMap, useCMap: null }).then(function(cmap) {
                        if (cmap instanceof _cmap.IdentityCMap) {
                          return new _fonts.IdentityToUnicodeMap(0, 65535);
                        }
                        var map = new Array(cmap.length);
                        cmap.forEach(function(charCode, token) {
                          var str = [];
                          for (var k = 0; k < token.length; k += 2) {
                            var w1 = token.charCodeAt(k) << 8 | token.charCodeAt(k + 1);
                            if ((w1 & 63488) !== 55296) {
                              str.push(w1);
                              continue;
                            }
                            k += 2;
                            var w2 = token.charCodeAt(k) << 8 | token.charCodeAt(k + 1);
                            str.push(((w1 & 1023) << 10) + (w2 & 1023) + 65536);
                          }
                          map[charCode] = String.fromCodePoint.apply(String, str);
                        });
                        return new _fonts.ToUnicodeMap(map);
                      }, (reason) => {
                        if (reason instanceof _util2.AbortException) {
                          return null;
                        }
                        if (this.options.ignoreErrors) {
                          this.handler.send("UnsupportedFeature", { featureId: _util2.UNSUPPORTED_FEATURES.font });
                          (0, _util2.warn)(`readToUnicode - ignoring ToUnicode data: "${reason}".`);
                          return null;
                        }
                        throw reason;
                      });
                    }
                    return Promise.resolve(null);
                  }, readCidToGidMap(glyphsData, toUnicode) {
                    var result = [];
                    for (var j = 0, jj = glyphsData.length; j < jj; j++) {
                      var glyphID = glyphsData[j++] << 8 | glyphsData[j];
                      const code = j >> 1;
                      if (glyphID === 0 && !toUnicode.has(code)) {
                        continue;
                      }
                      result[code] = glyphID;
                    }
                    return result;
                  }, extractWidths: function PartialEvaluator_extractWidths(dict, descriptor, properties) {
                    var xref = this.xref;
                    var glyphsWidths = [];
                    var defaultWidth = 0;
                    var glyphsVMetrics = [];
                    var defaultVMetrics;
                    var i, ii, j, jj, start, code, widths;
                    if (properties.composite) {
                      defaultWidth = dict.has("DW") ? dict.get("DW") : 1e3;
                      widths = dict.get("W");
                      if (widths) {
                        for (i = 0, ii = widths.length; i < ii; i++) {
                          start = xref.fetchIfRef(widths[i++]);
                          code = xref.fetchIfRef(widths[i]);
                          if (Array.isArray(code)) {
                            for (j = 0, jj = code.length; j < jj; j++) {
                              glyphsWidths[start++] = xref.fetchIfRef(code[j]);
                            }
                          } else {
                            var width = xref.fetchIfRef(widths[++i]);
                            for (j = start; j <= code; j++) {
                              glyphsWidths[j] = width;
                            }
                          }
                        }
                      }
                      if (properties.vertical) {
                        var vmetrics = dict.getArray("DW2") || [880, -1e3];
                        defaultVMetrics = [vmetrics[1], defaultWidth * 0.5, vmetrics[0]];
                        vmetrics = dict.get("W2");
                        if (vmetrics) {
                          for (i = 0, ii = vmetrics.length; i < ii; i++) {
                            start = xref.fetchIfRef(vmetrics[i++]);
                            code = xref.fetchIfRef(vmetrics[i]);
                            if (Array.isArray(code)) {
                              for (j = 0, jj = code.length; j < jj; j++) {
                                glyphsVMetrics[start++] = [xref.fetchIfRef(code[j++]), xref.fetchIfRef(code[j++]), xref.fetchIfRef(code[j])];
                              }
                            } else {
                              var vmetric = [xref.fetchIfRef(vmetrics[++i]), xref.fetchIfRef(vmetrics[++i]), xref.fetchIfRef(vmetrics[++i])];
                              for (j = start; j <= code; j++) {
                                glyphsVMetrics[j] = vmetric;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      var firstChar = properties.firstChar;
                      widths = dict.get("Widths");
                      if (widths) {
                        j = firstChar;
                        for (i = 0, ii = widths.length; i < ii; i++) {
                          glyphsWidths[j++] = xref.fetchIfRef(widths[i]);
                        }
                        defaultWidth = parseFloat(descriptor.get("MissingWidth")) || 0;
                      } else {
                        var baseFontName = dict.get("BaseFont");
                        if ((0, _primitives.isName)(baseFontName)) {
                          var metrics = this.getBaseFontMetrics(baseFontName.name);
                          glyphsWidths = this.buildCharCodeToWidth(metrics.widths, properties);
                          defaultWidth = metrics.defaultWidth;
                        }
                      }
                    }
                    var isMonospace = true;
                    var firstWidth = defaultWidth;
                    for (var glyph in glyphsWidths) {
                      var glyphWidth = glyphsWidths[glyph];
                      if (!glyphWidth) {
                        continue;
                      }
                      if (!firstWidth) {
                        firstWidth = glyphWidth;
                        continue;
                      }
                      if (firstWidth !== glyphWidth) {
                        isMonospace = false;
                        break;
                      }
                    }
                    if (isMonospace) {
                      properties.flags |= _fonts.FontFlags.FixedPitch;
                    }
                    properties.defaultWidth = defaultWidth;
                    properties.widths = glyphsWidths;
                    properties.defaultVMetrics = defaultVMetrics;
                    properties.vmetrics = glyphsVMetrics;
                  }, isSerifFont: function PartialEvaluator_isSerifFont(baseFontName) {
                    var fontNameWoStyle = baseFontName.split("-")[0];
                    return fontNameWoStyle in (0, _standard_fonts.getSerifFonts)() || fontNameWoStyle.search(/serif/gi) !== -1;
                  }, getBaseFontMetrics: function PartialEvaluator_getBaseFontMetrics(name) {
                    var defaultWidth = 0;
                    var widths = [];
                    var monospace = false;
                    var stdFontMap = (0, _standard_fonts.getStdFontMap)();
                    var lookupName = stdFontMap[name] || name;
                    var Metrics = (0, _metrics.getMetrics)();
                    if (!(lookupName in Metrics)) {
                      if (this.isSerifFont(name)) {
                        lookupName = "Times-Roman";
                      } else {
                        lookupName = "Helvetica";
                      }
                    }
                    var glyphWidths = Metrics[lookupName];
                    if ((0, _util2.isNum)(glyphWidths)) {
                      defaultWidth = glyphWidths;
                      monospace = true;
                    } else {
                      widths = glyphWidths();
                    }
                    return { defaultWidth, monospace, widths };
                  }, buildCharCodeToWidth: function PartialEvaluator_bulildCharCodeToWidth(widthsByGlyphName, properties) {
                    var widths = /* @__PURE__ */ Object.create(null);
                    var differences = properties.differences;
                    var encoding = properties.defaultEncoding;
                    for (var charCode = 0; charCode < 256; charCode++) {
                      if (charCode in differences && widthsByGlyphName[differences[charCode]]) {
                        widths[charCode] = widthsByGlyphName[differences[charCode]];
                        continue;
                      }
                      if (charCode in encoding && widthsByGlyphName[encoding[charCode]]) {
                        widths[charCode] = widthsByGlyphName[encoding[charCode]];
                        continue;
                      }
                    }
                    return widths;
                  }, preEvaluateFont: function PartialEvaluator_preEvaluateFont(dict) {
                    var baseDict = dict;
                    var type = dict.get("Subtype");
                    if (!(0, _primitives.isName)(type)) {
                      throw new _util2.FormatError("invalid font Subtype");
                    }
                    var composite = false;
                    var uint8array;
                    if (type.name === "Type0") {
                      var df = dict.get("DescendantFonts");
                      if (!df) {
                        throw new _util2.FormatError("Descendant fonts are not specified");
                      }
                      dict = Array.isArray(df) ? this.xref.fetchIfRef(df[0]) : df;
                      type = dict.get("Subtype");
                      if (!(0, _primitives.isName)(type)) {
                        throw new _util2.FormatError("invalid font Subtype");
                      }
                      composite = true;
                    }
                    var descriptor = dict.get("FontDescriptor");
                    if (descriptor) {
                      var hash = new _murmurhash.MurmurHash3_64();
                      var encoding = baseDict.getRaw("Encoding");
                      if ((0, _primitives.isName)(encoding)) {
                        hash.update(encoding.name);
                      } else if ((0, _primitives.isRef)(encoding)) {
                        hash.update(encoding.toString());
                      } else if ((0, _primitives.isDict)(encoding)) {
                        var keys = encoding.getKeys();
                        for (var i = 0, ii = keys.length; i < ii; i++) {
                          var entry = encoding.getRaw(keys[i]);
                          if ((0, _primitives.isName)(entry)) {
                            hash.update(entry.name);
                          } else if ((0, _primitives.isRef)(entry)) {
                            hash.update(entry.toString());
                          } else if (Array.isArray(entry)) {
                            var diffLength = entry.length, diffBuf = new Array(diffLength);
                            for (var j = 0; j < diffLength; j++) {
                              var diffEntry = entry[j];
                              if ((0, _primitives.isName)(diffEntry)) {
                                diffBuf[j] = diffEntry.name;
                              } else if ((0, _util2.isNum)(diffEntry) || (0, _primitives.isRef)(diffEntry)) {
                                diffBuf[j] = diffEntry.toString();
                              }
                            }
                            hash.update(diffBuf.join());
                          }
                        }
                      }
                      const firstChar = dict.get("FirstChar") || 0;
                      const lastChar = dict.get("LastChar") || (composite ? 65535 : 255);
                      hash.update(`${firstChar}-${lastChar}`);
                      var toUnicode = dict.get("ToUnicode") || baseDict.get("ToUnicode");
                      if ((0, _primitives.isStream)(toUnicode)) {
                        var stream = toUnicode.str || toUnicode;
                        uint8array = stream.buffer ? new Uint8Array(stream.buffer.buffer, 0, stream.bufferLength) : new Uint8Array(stream.bytes.buffer, stream.start, stream.end - stream.start);
                        hash.update(uint8array);
                      } else if ((0, _primitives.isName)(toUnicode)) {
                        hash.update(toUnicode.name);
                      }
                      var widths = dict.get("Widths") || baseDict.get("Widths");
                      if (widths) {
                        uint8array = new Uint8Array(new Uint32Array(widths).buffer);
                        hash.update(uint8array);
                      }
                    }
                    return { descriptor, dict, baseDict, composite, type: type.name, hash: hash ? hash.hexdigest() : "" };
                  }, translateFont: function PartialEvaluator_translateFont(preEvaluatedFont) {
                    var baseDict = preEvaluatedFont.baseDict;
                    var dict = preEvaluatedFont.dict;
                    var composite = preEvaluatedFont.composite;
                    var descriptor = preEvaluatedFont.descriptor;
                    var type = preEvaluatedFont.type;
                    var maxCharIndex = composite ? 65535 : 255;
                    var properties;
                    const firstChar = dict.get("FirstChar") || 0;
                    const lastChar = dict.get("LastChar") || maxCharIndex;
                    if (!descriptor) {
                      if (type === "Type3") {
                        descriptor = new _primitives.Dict(null);
                        descriptor.set("FontName", _primitives.Name.get(type));
                        descriptor.set("FontBBox", dict.getArray("FontBBox") || [0, 0, 0, 0]);
                      } else {
                        var baseFontName = dict.get("BaseFont");
                        if (!(0, _primitives.isName)(baseFontName)) {
                          throw new _util2.FormatError("Base font is not specified");
                        }
                        baseFontName = baseFontName.name.replace(/[,_]/g, "-");
                        var metrics = this.getBaseFontMetrics(baseFontName);
                        var fontNameWoStyle = baseFontName.split("-")[0];
                        var flags = (this.isSerifFont(fontNameWoStyle) ? _fonts.FontFlags.Serif : 0) | (metrics.monospace ? _fonts.FontFlags.FixedPitch : 0) | ((0, _standard_fonts.getSymbolsFonts)()[fontNameWoStyle] ? _fonts.FontFlags.Symbolic : _fonts.FontFlags.Nonsymbolic);
                        properties = { type, name: baseFontName, widths: metrics.widths, defaultWidth: metrics.defaultWidth, flags, firstChar, lastChar };
                        const widths = dict.get("Widths");
                        return this.extractDataStructures(dict, dict, properties).then((properties2) => {
                          if (widths) {
                            const glyphWidths = [];
                            let j = firstChar;
                            for (let i = 0, ii = widths.length; i < ii; i++) {
                              glyphWidths[j++] = this.xref.fetchIfRef(widths[i]);
                            }
                            properties2.widths = glyphWidths;
                          } else {
                            properties2.widths = this.buildCharCodeToWidth(metrics.widths, properties2);
                          }
                          return new _fonts.Font(baseFontName, null, properties2);
                        });
                      }
                    }
                    var fontName = descriptor.get("FontName");
                    var baseFont = dict.get("BaseFont");
                    if ((0, _util2.isString)(fontName)) {
                      fontName = _primitives.Name.get(fontName);
                    }
                    if ((0, _util2.isString)(baseFont)) {
                      baseFont = _primitives.Name.get(baseFont);
                    }
                    if (type !== "Type3") {
                      var fontNameStr = fontName && fontName.name;
                      var baseFontStr = baseFont && baseFont.name;
                      if (fontNameStr !== baseFontStr) {
                        (0, _util2.info)(`The FontDescriptor's FontName is "${fontNameStr}" but should be the same as the Font's BaseFont "${baseFontStr}".`);
                        if (fontNameStr && baseFontStr && baseFontStr.startsWith(fontNameStr)) {
                          fontName = baseFont;
                        }
                      }
                    }
                    fontName = fontName || baseFont;
                    if (!(0, _primitives.isName)(fontName)) {
                      throw new _util2.FormatError("invalid font name");
                    }
                    var fontFile = descriptor.get("FontFile", "FontFile2", "FontFile3");
                    if (fontFile) {
                      if (fontFile.dict) {
                        var subtype = fontFile.dict.get("Subtype");
                        if (subtype) {
                          subtype = subtype.name;
                        }
                        var length1 = fontFile.dict.get("Length1");
                        var length2 = fontFile.dict.get("Length2");
                        var length3 = fontFile.dict.get("Length3");
                      }
                    }
                    properties = { type, name: fontName.name, subtype, file: fontFile, length1, length2, length3, loadedName: baseDict.loadedName, composite, wideChars: composite, fixedPitch: false, fontMatrix: dict.getArray("FontMatrix") || _util2.FONT_IDENTITY_MATRIX, firstChar: firstChar || 0, lastChar: lastChar || maxCharIndex, bbox: descriptor.getArray("FontBBox"), ascent: descriptor.get("Ascent"), descent: descriptor.get("Descent"), xHeight: descriptor.get("XHeight"), capHeight: descriptor.get("CapHeight"), flags: descriptor.get("Flags"), italicAngle: descriptor.get("ItalicAngle"), isType3Font: false };
                    var cMapPromise;
                    if (composite) {
                      var cidEncoding = baseDict.get("Encoding");
                      if ((0, _primitives.isName)(cidEncoding)) {
                        properties.cidEncoding = cidEncoding.name;
                      }
                      cMapPromise = _cmap.CMapFactory.create({ encoding: cidEncoding, fetchBuiltInCMap: this.fetchBuiltInCMap, useCMap: null }).then(function(cMap) {
                        properties.cMap = cMap;
                        properties.vertical = properties.cMap.vertical;
                      });
                    } else {
                      cMapPromise = Promise.resolve(void 0);
                    }
                    return cMapPromise.then(() => {
                      return this.extractDataStructures(dict, baseDict, properties);
                    }).then((properties2) => {
                      this.extractWidths(dict, descriptor, properties2);
                      if (type === "Type3") {
                        properties2.isType3Font = true;
                      }
                      return new _fonts.Font(fontName.name, fontFile, properties2);
                    });
                  } };
                  PartialEvaluator2.buildFontPaths = function(font, glyphs, handler) {
                    function buildPath(fontChar) {
                      if (font.renderer.hasBuiltPath(fontChar)) {
                        return;
                      }
                      handler.send("commonobj", [`${font.loadedName}_path_${fontChar}`, "FontPath", font.renderer.getPathJs(fontChar)]);
                    }
                    for (const glyph of glyphs) {
                      buildPath(glyph.fontChar);
                      const accent = glyph.accent;
                      if (accent && accent.fontChar) {
                        buildPath(accent.fontChar);
                      }
                    }
                  };
                  PartialEvaluator2.getFallbackFontDict = function() {
                    if (this._fallbackFontDict) {
                      return this._fallbackFontDict;
                    }
                    const dict = new _primitives.Dict();
                    dict.set("BaseFont", _primitives.Name.get("PDFJS-FallbackFont"));
                    dict.set("Type", _primitives.Name.get("FallbackType"));
                    dict.set("Subtype", _primitives.Name.get("FallbackType"));
                    dict.set("Encoding", _primitives.Name.get("WinAnsiEncoding"));
                    return this._fallbackFontDict = dict;
                  };
                  return PartialEvaluator2;
                }();
                exports2.PartialEvaluator = PartialEvaluator;
                var TranslatedFont = function TranslatedFontClosure() {
                  function TranslatedFont2(loadedName, font, dict) {
                    this.loadedName = loadedName;
                    this.font = font;
                    this.dict = dict;
                    this.type3Loaded = null;
                    this.sent = false;
                  }
                  TranslatedFont2.prototype = { send(handler) {
                    if (this.sent) {
                      return;
                    }
                    this.sent = true;
                    handler.send("commonobj", [this.loadedName, "Font", this.font.exportData()]);
                  }, fallback(handler) {
                    if (!this.font.data) {
                      return;
                    }
                    this.font.disableFontFace = true;
                    const glyphs = this.font.glyphCacheValues;
                    PartialEvaluator.buildFontPaths(this.font, glyphs, handler);
                  }, loadType3Data(evaluator, resources, parentOperatorList, task) {
                    if (!this.font.isType3Font) {
                      throw new Error("Must be a Type3 font.");
                    }
                    if (this.type3Loaded) {
                      return this.type3Loaded;
                    }
                    var type3Options = Object.create(evaluator.options);
                    type3Options.ignoreErrors = false;
                    type3Options.nativeImageDecoderSupport = _util2.NativeImageDecoding.NONE;
                    var type3Evaluator = evaluator.clone(type3Options);
                    type3Evaluator.parsingType3Font = true;
                    var translatedFont = this.font;
                    var loadCharProcsPromise = Promise.resolve();
                    var charProcs = this.dict.get("CharProcs");
                    var fontResources = this.dict.get("Resources") || resources;
                    var charProcKeys = charProcs.getKeys();
                    var charProcOperatorList = /* @__PURE__ */ Object.create(null);
                    for (var i = 0, n = charProcKeys.length; i < n; ++i) {
                      const key = charProcKeys[i];
                      loadCharProcsPromise = loadCharProcsPromise.then(function() {
                        var glyphStream = charProcs.get(key);
                        var operatorList = new _operator_list.OperatorList();
                        return type3Evaluator.getOperatorList({ stream: glyphStream, task, resources: fontResources, operatorList }).then(function() {
                          charProcOperatorList[key] = operatorList.getIR();
                          parentOperatorList.addDependencies(operatorList.dependencies);
                        }).catch(function(reason) {
                          (0, _util2.warn)(`Type3 font resource "${key}" is not available.`);
                          var operatorList2 = new _operator_list.OperatorList();
                          charProcOperatorList[key] = operatorList2.getIR();
                        });
                      });
                    }
                    this.type3Loaded = loadCharProcsPromise.then(function() {
                      translatedFont.charProcOperatorList = charProcOperatorList;
                    });
                    return this.type3Loaded;
                  } };
                  return TranslatedFont2;
                }();
                var StateManager = function StateManagerClosure() {
                  function StateManager2(initialState) {
                    this.state = initialState;
                    this.stateStack = [];
                  }
                  StateManager2.prototype = { save() {
                    var old = this.state;
                    this.stateStack.push(this.state);
                    this.state = old.clone();
                  }, restore() {
                    var prev = this.stateStack.pop();
                    if (prev) {
                      this.state = prev;
                    }
                  }, transform(args) {
                    this.state.ctm = _util2.Util.transform(this.state.ctm, args);
                  } };
                  return StateManager2;
                }();
                var TextState = function TextStateClosure() {
                  function TextState2() {
                    this.ctm = new Float32Array(_util2.IDENTITY_MATRIX);
                    this.fontName = null;
                    this.fontSize = 0;
                    this.font = null;
                    this.fontMatrix = _util2.FONT_IDENTITY_MATRIX;
                    this.textMatrix = _util2.IDENTITY_MATRIX.slice();
                    this.textLineMatrix = _util2.IDENTITY_MATRIX.slice();
                    this.charSpacing = 0;
                    this.wordSpacing = 0;
                    this.leading = 0;
                    this.textHScale = 1;
                    this.textRise = 0;
                  }
                  TextState2.prototype = { setTextMatrix: function TextState_setTextMatrix(a, b, c, d, e, f) {
                    var m = this.textMatrix;
                    m[0] = a;
                    m[1] = b;
                    m[2] = c;
                    m[3] = d;
                    m[4] = e;
                    m[5] = f;
                  }, setTextLineMatrix: function TextState_setTextMatrix(a, b, c, d, e, f) {
                    var m = this.textLineMatrix;
                    m[0] = a;
                    m[1] = b;
                    m[2] = c;
                    m[3] = d;
                    m[4] = e;
                    m[5] = f;
                  }, translateTextMatrix: function TextState_translateTextMatrix(x, y) {
                    var m = this.textMatrix;
                    m[4] = m[0] * x + m[2] * y + m[4];
                    m[5] = m[1] * x + m[3] * y + m[5];
                  }, translateTextLineMatrix: function TextState_translateTextMatrix(x, y) {
                    var m = this.textLineMatrix;
                    m[4] = m[0] * x + m[2] * y + m[4];
                    m[5] = m[1] * x + m[3] * y + m[5];
                  }, calcTextLineMatrixAdvance: function TextState_calcTextLineMatrixAdvance(a, b, c, d, e, f) {
                    var font = this.font;
                    if (!font) {
                      return null;
                    }
                    var m = this.textLineMatrix;
                    if (!(a === m[0] && b === m[1] && c === m[2] && d === m[3])) {
                      return null;
                    }
                    var txDiff = e - m[4], tyDiff = f - m[5];
                    if (font.vertical && txDiff !== 0 || !font.vertical && tyDiff !== 0) {
                      return null;
                    }
                    var tx, ty, denominator = a * d - b * c;
                    if (font.vertical) {
                      tx = -tyDiff * c / denominator;
                      ty = tyDiff * a / denominator;
                    } else {
                      tx = txDiff * d / denominator;
                      ty = -txDiff * b / denominator;
                    }
                    return { width: tx, height: ty, value: font.vertical ? ty : tx };
                  }, calcRenderMatrix: function TextState_calcRendeMatrix(ctm) {
                    var tsm = [this.fontSize * this.textHScale, 0, 0, this.fontSize, 0, this.textRise];
                    return _util2.Util.transform(ctm, _util2.Util.transform(this.textMatrix, tsm));
                  }, carriageReturn: function TextState_carriageReturn() {
                    this.translateTextLineMatrix(0, -this.leading);
                    this.textMatrix = this.textLineMatrix.slice();
                  }, clone: function TextState_clone() {
                    var clone = Object.create(this);
                    clone.textMatrix = this.textMatrix.slice();
                    clone.textLineMatrix = this.textLineMatrix.slice();
                    clone.fontMatrix = this.fontMatrix.slice();
                    return clone;
                  } };
                  return TextState2;
                }();
                var EvalState = function EvalStateClosure() {
                  function EvalState2() {
                    this.ctm = new Float32Array(_util2.IDENTITY_MATRIX);
                    this.font = null;
                    this.textRenderingMode = _util2.TextRenderingMode.FILL;
                    this.fillColorSpace = _colorspace.ColorSpace.singletons.gray;
                    this.strokeColorSpace = _colorspace.ColorSpace.singletons.gray;
                  }
                  EvalState2.prototype = { clone: function CanvasExtraState_clone() {
                    return Object.create(this);
                  } };
                  return EvalState2;
                }();
                var EvaluatorPreprocessor = function EvaluatorPreprocessorClosure() {
                  var getOPMap = (0, _core_utils.getLookupTableFactory)(function(t) {
                    t["w"] = { id: _util2.OPS.setLineWidth, numArgs: 1, variableArgs: false };
                    t["J"] = { id: _util2.OPS.setLineCap, numArgs: 1, variableArgs: false };
                    t["j"] = { id: _util2.OPS.setLineJoin, numArgs: 1, variableArgs: false };
                    t["M"] = { id: _util2.OPS.setMiterLimit, numArgs: 1, variableArgs: false };
                    t["d"] = { id: _util2.OPS.setDash, numArgs: 2, variableArgs: false };
                    t["ri"] = { id: _util2.OPS.setRenderingIntent, numArgs: 1, variableArgs: false };
                    t["i"] = { id: _util2.OPS.setFlatness, numArgs: 1, variableArgs: false };
                    t["gs"] = { id: _util2.OPS.setGState, numArgs: 1, variableArgs: false };
                    t["q"] = { id: _util2.OPS.save, numArgs: 0, variableArgs: false };
                    t["Q"] = { id: _util2.OPS.restore, numArgs: 0, variableArgs: false };
                    t["cm"] = { id: _util2.OPS.transform, numArgs: 6, variableArgs: false };
                    t["m"] = { id: _util2.OPS.moveTo, numArgs: 2, variableArgs: false };
                    t["l"] = { id: _util2.OPS.lineTo, numArgs: 2, variableArgs: false };
                    t["c"] = { id: _util2.OPS.curveTo, numArgs: 6, variableArgs: false };
                    t["v"] = { id: _util2.OPS.curveTo2, numArgs: 4, variableArgs: false };
                    t["y"] = { id: _util2.OPS.curveTo3, numArgs: 4, variableArgs: false };
                    t["h"] = { id: _util2.OPS.closePath, numArgs: 0, variableArgs: false };
                    t["re"] = { id: _util2.OPS.rectangle, numArgs: 4, variableArgs: false };
                    t["S"] = { id: _util2.OPS.stroke, numArgs: 0, variableArgs: false };
                    t["s"] = { id: _util2.OPS.closeStroke, numArgs: 0, variableArgs: false };
                    t["f"] = { id: _util2.OPS.fill, numArgs: 0, variableArgs: false };
                    t["F"] = { id: _util2.OPS.fill, numArgs: 0, variableArgs: false };
                    t["f*"] = { id: _util2.OPS.eoFill, numArgs: 0, variableArgs: false };
                    t["B"] = { id: _util2.OPS.fillStroke, numArgs: 0, variableArgs: false };
                    t["B*"] = { id: _util2.OPS.eoFillStroke, numArgs: 0, variableArgs: false };
                    t["b"] = { id: _util2.OPS.closeFillStroke, numArgs: 0, variableArgs: false };
                    t["b*"] = { id: _util2.OPS.closeEOFillStroke, numArgs: 0, variableArgs: false };
                    t["n"] = { id: _util2.OPS.endPath, numArgs: 0, variableArgs: false };
                    t["W"] = { id: _util2.OPS.clip, numArgs: 0, variableArgs: false };
                    t["W*"] = { id: _util2.OPS.eoClip, numArgs: 0, variableArgs: false };
                    t["BT"] = { id: _util2.OPS.beginText, numArgs: 0, variableArgs: false };
                    t["ET"] = { id: _util2.OPS.endText, numArgs: 0, variableArgs: false };
                    t["Tc"] = { id: _util2.OPS.setCharSpacing, numArgs: 1, variableArgs: false };
                    t["Tw"] = { id: _util2.OPS.setWordSpacing, numArgs: 1, variableArgs: false };
                    t["Tz"] = { id: _util2.OPS.setHScale, numArgs: 1, variableArgs: false };
                    t["TL"] = { id: _util2.OPS.setLeading, numArgs: 1, variableArgs: false };
                    t["Tf"] = { id: _util2.OPS.setFont, numArgs: 2, variableArgs: false };
                    t["Tr"] = { id: _util2.OPS.setTextRenderingMode, numArgs: 1, variableArgs: false };
                    t["Ts"] = { id: _util2.OPS.setTextRise, numArgs: 1, variableArgs: false };
                    t["Td"] = { id: _util2.OPS.moveText, numArgs: 2, variableArgs: false };
                    t["TD"] = { id: _util2.OPS.setLeadingMoveText, numArgs: 2, variableArgs: false };
                    t["Tm"] = { id: _util2.OPS.setTextMatrix, numArgs: 6, variableArgs: false };
                    t["T*"] = { id: _util2.OPS.nextLine, numArgs: 0, variableArgs: false };
                    t["Tj"] = { id: _util2.OPS.showText, numArgs: 1, variableArgs: false };
                    t["TJ"] = { id: _util2.OPS.showSpacedText, numArgs: 1, variableArgs: false };
                    t["'"] = { id: _util2.OPS.nextLineShowText, numArgs: 1, variableArgs: false };
                    t['"'] = { id: _util2.OPS.nextLineSetSpacingShowText, numArgs: 3, variableArgs: false };
                    t["d0"] = { id: _util2.OPS.setCharWidth, numArgs: 2, variableArgs: false };
                    t["d1"] = { id: _util2.OPS.setCharWidthAndBounds, numArgs: 6, variableArgs: false };
                    t["CS"] = { id: _util2.OPS.setStrokeColorSpace, numArgs: 1, variableArgs: false };
                    t["cs"] = { id: _util2.OPS.setFillColorSpace, numArgs: 1, variableArgs: false };
                    t["SC"] = { id: _util2.OPS.setStrokeColor, numArgs: 4, variableArgs: true };
                    t["SCN"] = { id: _util2.OPS.setStrokeColorN, numArgs: 33, variableArgs: true };
                    t["sc"] = { id: _util2.OPS.setFillColor, numArgs: 4, variableArgs: true };
                    t["scn"] = { id: _util2.OPS.setFillColorN, numArgs: 33, variableArgs: true };
                    t["G"] = { id: _util2.OPS.setStrokeGray, numArgs: 1, variableArgs: false };
                    t["g"] = { id: _util2.OPS.setFillGray, numArgs: 1, variableArgs: false };
                    t["RG"] = { id: _util2.OPS.setStrokeRGBColor, numArgs: 3, variableArgs: false };
                    t["rg"] = { id: _util2.OPS.setFillRGBColor, numArgs: 3, variableArgs: false };
                    t["K"] = { id: _util2.OPS.setStrokeCMYKColor, numArgs: 4, variableArgs: false };
                    t["k"] = { id: _util2.OPS.setFillCMYKColor, numArgs: 4, variableArgs: false };
                    t["sh"] = { id: _util2.OPS.shadingFill, numArgs: 1, variableArgs: false };
                    t["BI"] = { id: _util2.OPS.beginInlineImage, numArgs: 0, variableArgs: false };
                    t["ID"] = { id: _util2.OPS.beginImageData, numArgs: 0, variableArgs: false };
                    t["EI"] = { id: _util2.OPS.endInlineImage, numArgs: 1, variableArgs: false };
                    t["Do"] = { id: _util2.OPS.paintXObject, numArgs: 1, variableArgs: false };
                    t["MP"] = { id: _util2.OPS.markPoint, numArgs: 1, variableArgs: false };
                    t["DP"] = { id: _util2.OPS.markPointProps, numArgs: 2, variableArgs: false };
                    t["BMC"] = { id: _util2.OPS.beginMarkedContent, numArgs: 1, variableArgs: false };
                    t["BDC"] = { id: _util2.OPS.beginMarkedContentProps, numArgs: 2, variableArgs: false };
                    t["EMC"] = { id: _util2.OPS.endMarkedContent, numArgs: 0, variableArgs: false };
                    t["BX"] = { id: _util2.OPS.beginCompat, numArgs: 0, variableArgs: false };
                    t["EX"] = { id: _util2.OPS.endCompat, numArgs: 0, variableArgs: false };
                    t["BM"] = null;
                    t["BD"] = null;
                    t["true"] = null;
                    t["fa"] = null;
                    t["fal"] = null;
                    t["fals"] = null;
                    t["false"] = null;
                    t["nu"] = null;
                    t["nul"] = null;
                    t["null"] = null;
                  });
                  const MAX_INVALID_PATH_OPS = 20;
                  function EvaluatorPreprocessor2(stream, xref, stateManager) {
                    this.opMap = getOPMap();
                    this.parser = new _parser.Parser({ lexer: new _parser.Lexer(stream, this.opMap), xref });
                    this.stateManager = stateManager;
                    this.nonProcessedArgs = [];
                    this._numInvalidPathOPS = 0;
                  }
                  EvaluatorPreprocessor2.prototype = { get savedStatesDepth() {
                    return this.stateManager.stateStack.length;
                  }, read: function EvaluatorPreprocessor_read(operation) {
                    var args = operation.args;
                    while (true) {
                      var obj = this.parser.getObj();
                      if (obj instanceof _primitives.Cmd) {
                        var cmd = obj.cmd;
                        var opSpec = this.opMap[cmd];
                        if (!opSpec) {
                          (0, _util2.warn)(`Unknown command "${cmd}".`);
                          continue;
                        }
                        var fn = opSpec.id;
                        var numArgs = opSpec.numArgs;
                        var argsLength = args !== null ? args.length : 0;
                        if (!opSpec.variableArgs) {
                          if (argsLength !== numArgs) {
                            var nonProcessedArgs = this.nonProcessedArgs;
                            while (argsLength > numArgs) {
                              nonProcessedArgs.push(args.shift());
                              argsLength--;
                            }
                            while (argsLength < numArgs && nonProcessedArgs.length !== 0) {
                              if (args === null) {
                                args = [];
                              }
                              args.unshift(nonProcessedArgs.pop());
                              argsLength++;
                            }
                          }
                          if (argsLength < numArgs) {
                            const partialMsg = `command ${cmd}: expected ${numArgs} args, but received ${argsLength} args.`;
                            if (fn >= _util2.OPS.moveTo && fn <= _util2.OPS.endPath && ++this._numInvalidPathOPS > MAX_INVALID_PATH_OPS) {
                              throw new _util2.FormatError(`Invalid ${partialMsg}`);
                            }
                            (0, _util2.warn)(`Skipping ${partialMsg}`);
                            if (args !== null) {
                              args.length = 0;
                            }
                            continue;
                          }
                        } else if (argsLength > numArgs) {
                          (0, _util2.info)(`Command ${cmd}: expected [0, ${numArgs}] args, but received ${argsLength} args.`);
                        }
                        this.preprocessCommand(fn, args);
                        operation.fn = fn;
                        operation.args = args;
                        return true;
                      }
                      if (obj === _primitives.EOF) {
                        return false;
                      }
                      if (obj !== null) {
                        if (args === null) {
                          args = [];
                        }
                        args.push(obj);
                        if (args.length > 33) {
                          throw new _util2.FormatError("Too many arguments");
                        }
                      }
                    }
                  }, preprocessCommand: function EvaluatorPreprocessor_preprocessCommand(fn, args) {
                    switch (fn | 0) {
                      case _util2.OPS.save:
                        this.stateManager.save();
                        break;
                      case _util2.OPS.restore:
                        this.stateManager.restore();
                        break;
                      case _util2.OPS.transform:
                        this.stateManager.transform(args);
                        break;
                    }
                  } };
                  return EvaluatorPreprocessor2;
                }();
              }, function(module3, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.CMapFactory = exports2.IdentityCMap = exports2.CMap = void 0;
                var _util2 = __w_pdfjs_require__2(2);
                var _primitives = __w_pdfjs_require__2(4);
                var _parser = __w_pdfjs_require__2(10);
                var _core_utils = __w_pdfjs_require__2(7);
                var _stream = __w_pdfjs_require__2(11);
                var BUILT_IN_CMAPS = ["Adobe-GB1-UCS2", "Adobe-CNS1-UCS2", "Adobe-Japan1-UCS2", "Adobe-Korea1-UCS2", "78-EUC-H", "78-EUC-V", "78-H", "78-RKSJ-H", "78-RKSJ-V", "78-V", "78ms-RKSJ-H", "78ms-RKSJ-V", "83pv-RKSJ-H", "90ms-RKSJ-H", "90ms-RKSJ-V", "90msp-RKSJ-H", "90msp-RKSJ-V", "90pv-RKSJ-H", "90pv-RKSJ-V", "Add-H", "Add-RKSJ-H", "Add-RKSJ-V", "Add-V", "Adobe-CNS1-0", "Adobe-CNS1-1", "Adobe-CNS1-2", "Adobe-CNS1-3", "Adobe-CNS1-4", "Adobe-CNS1-5", "Adobe-CNS1-6", "Adobe-GB1-0", "Adobe-GB1-1", "Adobe-GB1-2", "Adobe-GB1-3", "Adobe-GB1-4", "Adobe-GB1-5", "Adobe-Japan1-0", "Adobe-Japan1-1", "Adobe-Japan1-2", "Adobe-Japan1-3", "Adobe-Japan1-4", "Adobe-Japan1-5", "Adobe-Japan1-6", "Adobe-Korea1-0", "Adobe-Korea1-1", "Adobe-Korea1-2", "B5-H", "B5-V", "B5pc-H", "B5pc-V", "CNS-EUC-H", "CNS-EUC-V", "CNS1-H", "CNS1-V", "CNS2-H", "CNS2-V", "ETHK-B5-H", "ETHK-B5-V", "ETen-B5-H", "ETen-B5-V", "ETenms-B5-H", "ETenms-B5-V", "EUC-H", "EUC-V", "Ext-H", "Ext-RKSJ-H", "Ext-RKSJ-V", "Ext-V", "GB-EUC-H", "GB-EUC-V", "GB-H", "GB-V", "GBK-EUC-H", "GBK-EUC-V", "GBK2K-H", "GBK2K-V", "GBKp-EUC-H", "GBKp-EUC-V", "GBT-EUC-H", "GBT-EUC-V", "GBT-H", "GBT-V", "GBTpc-EUC-H", "GBTpc-EUC-V", "GBpc-EUC-H", "GBpc-EUC-V", "H", "HKdla-B5-H", "HKdla-B5-V", "HKdlb-B5-H", "HKdlb-B5-V", "HKgccs-B5-H", "HKgccs-B5-V", "HKm314-B5-H", "HKm314-B5-V", "HKm471-B5-H", "HKm471-B5-V", "HKscs-B5-H", "HKscs-B5-V", "Hankaku", "Hiragana", "KSC-EUC-H", "KSC-EUC-V", "KSC-H", "KSC-Johab-H", "KSC-Johab-V", "KSC-V", "KSCms-UHC-H", "KSCms-UHC-HW-H", "KSCms-UHC-HW-V", "KSCms-UHC-V", "KSCpc-EUC-H", "KSCpc-EUC-V", "Katakana", "NWP-H", "NWP-V", "RKSJ-H", "RKSJ-V", "Roman", "UniCNS-UCS2-H", "UniCNS-UCS2-V", "UniCNS-UTF16-H", "UniCNS-UTF16-V", "UniCNS-UTF32-H", "UniCNS-UTF32-V", "UniCNS-UTF8-H", "UniCNS-UTF8-V", "UniGB-UCS2-H", "UniGB-UCS2-V", "UniGB-UTF16-H", "UniGB-UTF16-V", "UniGB-UTF32-H", "UniGB-UTF32-V", "UniGB-UTF8-H", "UniGB-UTF8-V", "UniJIS-UCS2-H", "UniJIS-UCS2-HW-H", "UniJIS-UCS2-HW-V", "UniJIS-UCS2-V", "UniJIS-UTF16-H", "UniJIS-UTF16-V", "UniJIS-UTF32-H", "UniJIS-UTF32-V", "UniJIS-UTF8-H", "UniJIS-UTF8-V", "UniJIS2004-UTF16-H", "UniJIS2004-UTF16-V", "UniJIS2004-UTF32-H", "UniJIS2004-UTF32-V", "UniJIS2004-UTF8-H", "UniJIS2004-UTF8-V", "UniJISPro-UCS2-HW-V", "UniJISPro-UCS2-V", "UniJISPro-UTF8-V", "UniJISX0213-UTF32-H", "UniJISX0213-UTF32-V", "UniJISX02132004-UTF32-H", "UniJISX02132004-UTF32-V", "UniKS-UCS2-H", "UniKS-UCS2-V", "UniKS-UTF16-H", "UniKS-UTF16-V", "UniKS-UTF32-H", "UniKS-UTF32-V", "UniKS-UTF8-H", "UniKS-UTF8-V", "V", "WP-Symbol"];
                class CMap {
                  constructor(builtInCMap = false) {
                    this.codespaceRanges = [[], [], [], []];
                    this.numCodespaceRanges = 0;
                    this._map = [];
                    this.name = "";
                    this.vertical = false;
                    this.useCMap = null;
                    this.builtInCMap = builtInCMap;
                  }
                  addCodespaceRange(n, low, high) {
                    this.codespaceRanges[n - 1].push(low, high);
                    this.numCodespaceRanges++;
                  }
                  mapCidRange(low, high, dstLow) {
                    while (low <= high) {
                      this._map[low++] = dstLow++;
                    }
                  }
                  mapBfRange(low, high, dstLow) {
                    var lastByte = dstLow.length - 1;
                    while (low <= high) {
                      this._map[low++] = dstLow;
                      dstLow = dstLow.substring(0, lastByte) + String.fromCharCode(dstLow.charCodeAt(lastByte) + 1);
                    }
                  }
                  mapBfRangeToArray(low, high, array) {
                    const ii = array.length;
                    let i = 0;
                    while (low <= high && i < ii) {
                      this._map[low] = array[i++];
                      ++low;
                    }
                  }
                  mapOne(src, dst) {
                    this._map[src] = dst;
                  }
                  lookup(code) {
                    return this._map[code];
                  }
                  contains(code) {
                    return this._map[code] !== void 0;
                  }
                  forEach(callback) {
                    const map = this._map;
                    const length = map.length;
                    if (length <= 65536) {
                      for (let i = 0; i < length; i++) {
                        if (map[i] !== void 0) {
                          callback(i, map[i]);
                        }
                      }
                    } else {
                      for (const i in map) {
                        callback(i, map[i]);
                      }
                    }
                  }
                  charCodeOf(value) {
                    const map = this._map;
                    if (map.length <= 65536) {
                      return map.indexOf(value);
                    }
                    for (const charCode in map) {
                      if (map[charCode] === value) {
                        return charCode | 0;
                      }
                    }
                    return -1;
                  }
                  getMap() {
                    return this._map;
                  }
                  readCharCode(str, offset, out) {
                    let c = 0;
                    const codespaceRanges = this.codespaceRanges;
                    for (let n = 0, nn = codespaceRanges.length; n < nn; n++) {
                      c = (c << 8 | str.charCodeAt(offset + n)) >>> 0;
                      const codespaceRange = codespaceRanges[n];
                      for (let k = 0, kk = codespaceRange.length; k < kk; ) {
                        const low = codespaceRange[k++];
                        const high = codespaceRange[k++];
                        if (c >= low && c <= high) {
                          out.charcode = c;
                          out.length = n + 1;
                          return;
                        }
                      }
                    }
                    out.charcode = 0;
                    out.length = 1;
                  }
                  get length() {
                    return this._map.length;
                  }
                  get isIdentityCMap() {
                    if (!(this.name === "Identity-H" || this.name === "Identity-V")) {
                      return false;
                    }
                    if (this._map.length !== 65536) {
                      return false;
                    }
                    for (let i = 0; i < 65536; i++) {
                      if (this._map[i] !== i) {
                        return false;
                      }
                    }
                    return true;
                  }
                }
                exports2.CMap = CMap;
                class IdentityCMap extends CMap {
                  constructor(vertical, n) {
                    super();
                    this.vertical = vertical;
                    this.addCodespaceRange(n, 0, 65535);
                  }
                  mapCidRange(low, high, dstLow) {
                    (0, _util2.unreachable)("should not call mapCidRange");
                  }
                  mapBfRange(low, high, dstLow) {
                    (0, _util2.unreachable)("should not call mapBfRange");
                  }
                  mapBfRangeToArray(low, high, array) {
                    (0, _util2.unreachable)("should not call mapBfRangeToArray");
                  }
                  mapOne(src, dst) {
                    (0, _util2.unreachable)("should not call mapCidOne");
                  }
                  lookup(code) {
                    return Number.isInteger(code) && code <= 65535 ? code : void 0;
                  }
                  contains(code) {
                    return Number.isInteger(code) && code <= 65535;
                  }
                  forEach(callback) {
                    for (let i = 0; i <= 65535; i++) {
                      callback(i, i);
                    }
                  }
                  charCodeOf(value) {
                    return Number.isInteger(value) && value <= 65535 ? value : -1;
                  }
                  getMap() {
                    const map = new Array(65536);
                    for (let i = 0; i <= 65535; i++) {
                      map[i] = i;
                    }
                    return map;
                  }
                  get length() {
                    return 65536;
                  }
                  get isIdentityCMap() {
                    (0, _util2.unreachable)("should not access .isIdentityCMap");
                  }
                }
                exports2.IdentityCMap = IdentityCMap;
                var BinaryCMapReader = function BinaryCMapReaderClosure() {
                  function hexToInt(a, size) {
                    var n = 0;
                    for (var i = 0; i <= size; i++) {
                      n = n << 8 | a[i];
                    }
                    return n >>> 0;
                  }
                  function hexToStr(a, size) {
                    if (size === 1) {
                      return String.fromCharCode(a[0], a[1]);
                    }
                    if (size === 3) {
                      return String.fromCharCode(a[0], a[1], a[2], a[3]);
                    }
                    return String.fromCharCode.apply(null, a.subarray(0, size + 1));
                  }
                  function addHex(a, b, size) {
                    var c = 0;
                    for (var i = size; i >= 0; i--) {
                      c += a[i] + b[i];
                      a[i] = c & 255;
                      c >>= 8;
                    }
                  }
                  function incHex(a, size) {
                    var c = 1;
                    for (var i = size; i >= 0 && c > 0; i--) {
                      c += a[i];
                      a[i] = c & 255;
                      c >>= 8;
                    }
                  }
                  var MAX_NUM_SIZE = 16;
                  var MAX_ENCODED_NUM_SIZE = 19;
                  function BinaryCMapStream(data) {
                    this.buffer = data;
                    this.pos = 0;
                    this.end = data.length;
                    this.tmpBuf = new Uint8Array(MAX_ENCODED_NUM_SIZE);
                  }
                  BinaryCMapStream.prototype = { readByte() {
                    if (this.pos >= this.end) {
                      return -1;
                    }
                    return this.buffer[this.pos++];
                  }, readNumber() {
                    var n = 0;
                    var last;
                    do {
                      var b = this.readByte();
                      if (b < 0) {
                        throw new _util2.FormatError("unexpected EOF in bcmap");
                      }
                      last = !(b & 128);
                      n = n << 7 | b & 127;
                    } while (!last);
                    return n;
                  }, readSigned() {
                    var n = this.readNumber();
                    return n & 1 ? ~(n >>> 1) : n >>> 1;
                  }, readHex(num, size) {
                    num.set(this.buffer.subarray(this.pos, this.pos + size + 1));
                    this.pos += size + 1;
                  }, readHexNumber(num, size) {
                    var last;
                    var stack = this.tmpBuf, sp = 0;
                    do {
                      var b = this.readByte();
                      if (b < 0) {
                        throw new _util2.FormatError("unexpected EOF in bcmap");
                      }
                      last = !(b & 128);
                      stack[sp++] = b & 127;
                    } while (!last);
                    var i = size, buffer = 0, bufferSize = 0;
                    while (i >= 0) {
                      while (bufferSize < 8 && stack.length > 0) {
                        buffer = stack[--sp] << bufferSize | buffer;
                        bufferSize += 7;
                      }
                      num[i] = buffer & 255;
                      i--;
                      buffer >>= 8;
                      bufferSize -= 8;
                    }
                  }, readHexSigned(num, size) {
                    this.readHexNumber(num, size);
                    var sign = num[size] & 1 ? 255 : 0;
                    var c = 0;
                    for (var i = 0; i <= size; i++) {
                      c = (c & 1) << 8 | num[i];
                      num[i] = c >> 1 ^ sign;
                    }
                  }, readString() {
                    var len = this.readNumber();
                    var s = "";
                    for (var i = 0; i < len; i++) {
                      s += String.fromCharCode(this.readNumber());
                    }
                    return s;
                  } };
                  function processBinaryCMap(data, cMap, extend) {
                    return new Promise(function(resolve, reject) {
                      var stream = new BinaryCMapStream(data);
                      var header = stream.readByte();
                      cMap.vertical = !!(header & 1);
                      var useCMap = null;
                      var start = new Uint8Array(MAX_NUM_SIZE);
                      var end = new Uint8Array(MAX_NUM_SIZE);
                      var char = new Uint8Array(MAX_NUM_SIZE);
                      var charCode = new Uint8Array(MAX_NUM_SIZE);
                      var tmp = new Uint8Array(MAX_NUM_SIZE);
                      var code;
                      var b;
                      while ((b = stream.readByte()) >= 0) {
                        var type = b >> 5;
                        if (type === 7) {
                          switch (b & 31) {
                            case 0:
                              stream.readString();
                              break;
                            case 1:
                              useCMap = stream.readString();
                              break;
                          }
                          continue;
                        }
                        var sequence = !!(b & 16);
                        var dataSize = b & 15;
                        if (dataSize + 1 > MAX_NUM_SIZE) {
                          throw new Error("processBinaryCMap: Invalid dataSize.");
                        }
                        var ucs2DataSize = 1;
                        var subitemsCount = stream.readNumber();
                        var i;
                        switch (type) {
                          case 0:
                            stream.readHex(start, dataSize);
                            stream.readHexNumber(end, dataSize);
                            addHex(end, start, dataSize);
                            cMap.addCodespaceRange(dataSize + 1, hexToInt(start, dataSize), hexToInt(end, dataSize));
                            for (i = 1; i < subitemsCount; i++) {
                              incHex(end, dataSize);
                              stream.readHexNumber(start, dataSize);
                              addHex(start, end, dataSize);
                              stream.readHexNumber(end, dataSize);
                              addHex(end, start, dataSize);
                              cMap.addCodespaceRange(dataSize + 1, hexToInt(start, dataSize), hexToInt(end, dataSize));
                            }
                            break;
                          case 1:
                            stream.readHex(start, dataSize);
                            stream.readHexNumber(end, dataSize);
                            addHex(end, start, dataSize);
                            stream.readNumber();
                            for (i = 1; i < subitemsCount; i++) {
                              incHex(end, dataSize);
                              stream.readHexNumber(start, dataSize);
                              addHex(start, end, dataSize);
                              stream.readHexNumber(end, dataSize);
                              addHex(end, start, dataSize);
                              stream.readNumber();
                            }
                            break;
                          case 2:
                            stream.readHex(char, dataSize);
                            code = stream.readNumber();
                            cMap.mapOne(hexToInt(char, dataSize), code);
                            for (i = 1; i < subitemsCount; i++) {
                              incHex(char, dataSize);
                              if (!sequence) {
                                stream.readHexNumber(tmp, dataSize);
                                addHex(char, tmp, dataSize);
                              }
                              code = stream.readSigned() + (code + 1);
                              cMap.mapOne(hexToInt(char, dataSize), code);
                            }
                            break;
                          case 3:
                            stream.readHex(start, dataSize);
                            stream.readHexNumber(end, dataSize);
                            addHex(end, start, dataSize);
                            code = stream.readNumber();
                            cMap.mapCidRange(hexToInt(start, dataSize), hexToInt(end, dataSize), code);
                            for (i = 1; i < subitemsCount; i++) {
                              incHex(end, dataSize);
                              if (!sequence) {
                                stream.readHexNumber(start, dataSize);
                                addHex(start, end, dataSize);
                              } else {
                                start.set(end);
                              }
                              stream.readHexNumber(end, dataSize);
                              addHex(end, start, dataSize);
                              code = stream.readNumber();
                              cMap.mapCidRange(hexToInt(start, dataSize), hexToInt(end, dataSize), code);
                            }
                            break;
                          case 4:
                            stream.readHex(char, ucs2DataSize);
                            stream.readHex(charCode, dataSize);
                            cMap.mapOne(hexToInt(char, ucs2DataSize), hexToStr(charCode, dataSize));
                            for (i = 1; i < subitemsCount; i++) {
                              incHex(char, ucs2DataSize);
                              if (!sequence) {
                                stream.readHexNumber(tmp, ucs2DataSize);
                                addHex(char, tmp, ucs2DataSize);
                              }
                              incHex(charCode, dataSize);
                              stream.readHexSigned(tmp, dataSize);
                              addHex(charCode, tmp, dataSize);
                              cMap.mapOne(hexToInt(char, ucs2DataSize), hexToStr(charCode, dataSize));
                            }
                            break;
                          case 5:
                            stream.readHex(start, ucs2DataSize);
                            stream.readHexNumber(end, ucs2DataSize);
                            addHex(end, start, ucs2DataSize);
                            stream.readHex(charCode, dataSize);
                            cMap.mapBfRange(hexToInt(start, ucs2DataSize), hexToInt(end, ucs2DataSize), hexToStr(charCode, dataSize));
                            for (i = 1; i < subitemsCount; i++) {
                              incHex(end, ucs2DataSize);
                              if (!sequence) {
                                stream.readHexNumber(start, ucs2DataSize);
                                addHex(start, end, ucs2DataSize);
                              } else {
                                start.set(end);
                              }
                              stream.readHexNumber(end, ucs2DataSize);
                              addHex(end, start, ucs2DataSize);
                              stream.readHex(charCode, dataSize);
                              cMap.mapBfRange(hexToInt(start, ucs2DataSize), hexToInt(end, ucs2DataSize), hexToStr(charCode, dataSize));
                            }
                            break;
                          default:
                            reject(new Error("processBinaryCMap: Unknown type: " + type));
                            return;
                        }
                      }
                      if (useCMap) {
                        resolve(extend(useCMap));
                        return;
                      }
                      resolve(cMap);
                    });
                  }
                  function BinaryCMapReader2() {
                  }
                  BinaryCMapReader2.prototype = { process: processBinaryCMap };
                  return BinaryCMapReader2;
                }();
                var CMapFactory = function CMapFactoryClosure() {
                  function strToInt(str) {
                    var a = 0;
                    for (var i = 0; i < str.length; i++) {
                      a = a << 8 | str.charCodeAt(i);
                    }
                    return a >>> 0;
                  }
                  function expectString(obj) {
                    if (!(0, _util2.isString)(obj)) {
                      throw new _util2.FormatError("Malformed CMap: expected string.");
                    }
                  }
                  function expectInt(obj) {
                    if (!Number.isInteger(obj)) {
                      throw new _util2.FormatError("Malformed CMap: expected int.");
                    }
                  }
                  function parseBfChar(cMap, lexer) {
                    while (true) {
                      var obj = lexer.getObj();
                      if ((0, _primitives.isEOF)(obj)) {
                        break;
                      }
                      if ((0, _primitives.isCmd)(obj, "endbfchar")) {
                        return;
                      }
                      expectString(obj);
                      var src = strToInt(obj);
                      obj = lexer.getObj();
                      expectString(obj);
                      var dst = obj;
                      cMap.mapOne(src, dst);
                    }
                  }
                  function parseBfRange(cMap, lexer) {
                    while (true) {
                      var obj = lexer.getObj();
                      if ((0, _primitives.isEOF)(obj)) {
                        break;
                      }
                      if ((0, _primitives.isCmd)(obj, "endbfrange")) {
                        return;
                      }
                      expectString(obj);
                      var low = strToInt(obj);
                      obj = lexer.getObj();
                      expectString(obj);
                      var high = strToInt(obj);
                      obj = lexer.getObj();
                      if (Number.isInteger(obj) || (0, _util2.isString)(obj)) {
                        var dstLow = Number.isInteger(obj) ? String.fromCharCode(obj) : obj;
                        cMap.mapBfRange(low, high, dstLow);
                      } else if ((0, _primitives.isCmd)(obj, "[")) {
                        obj = lexer.getObj();
                        var array = [];
                        while (!(0, _primitives.isCmd)(obj, "]") && !(0, _primitives.isEOF)(obj)) {
                          array.push(obj);
                          obj = lexer.getObj();
                        }
                        cMap.mapBfRangeToArray(low, high, array);
                      } else {
                        break;
                      }
                    }
                    throw new _util2.FormatError("Invalid bf range.");
                  }
                  function parseCidChar(cMap, lexer) {
                    while (true) {
                      var obj = lexer.getObj();
                      if ((0, _primitives.isEOF)(obj)) {
                        break;
                      }
                      if ((0, _primitives.isCmd)(obj, "endcidchar")) {
                        return;
                      }
                      expectString(obj);
                      var src = strToInt(obj);
                      obj = lexer.getObj();
                      expectInt(obj);
                      var dst = obj;
                      cMap.mapOne(src, dst);
                    }
                  }
                  function parseCidRange(cMap, lexer) {
                    while (true) {
                      var obj = lexer.getObj();
                      if ((0, _primitives.isEOF)(obj)) {
                        break;
                      }
                      if ((0, _primitives.isCmd)(obj, "endcidrange")) {
                        return;
                      }
                      expectString(obj);
                      var low = strToInt(obj);
                      obj = lexer.getObj();
                      expectString(obj);
                      var high = strToInt(obj);
                      obj = lexer.getObj();
                      expectInt(obj);
                      var dstLow = obj;
                      cMap.mapCidRange(low, high, dstLow);
                    }
                  }
                  function parseCodespaceRange(cMap, lexer) {
                    while (true) {
                      var obj = lexer.getObj();
                      if ((0, _primitives.isEOF)(obj)) {
                        break;
                      }
                      if ((0, _primitives.isCmd)(obj, "endcodespacerange")) {
                        return;
                      }
                      if (!(0, _util2.isString)(obj)) {
                        break;
                      }
                      var low = strToInt(obj);
                      obj = lexer.getObj();
                      if (!(0, _util2.isString)(obj)) {
                        break;
                      }
                      var high = strToInt(obj);
                      cMap.addCodespaceRange(obj.length, low, high);
                    }
                    throw new _util2.FormatError("Invalid codespace range.");
                  }
                  function parseWMode(cMap, lexer) {
                    var obj = lexer.getObj();
                    if (Number.isInteger(obj)) {
                      cMap.vertical = !!obj;
                    }
                  }
                  function parseCMapName(cMap, lexer) {
                    var obj = lexer.getObj();
                    if ((0, _primitives.isName)(obj) && (0, _util2.isString)(obj.name)) {
                      cMap.name = obj.name;
                    }
                  }
                  function parseCMap(cMap, lexer, fetchBuiltInCMap, useCMap) {
                    var previous;
                    var embeddedUseCMap;
                    objLoop:
                      while (true) {
                        try {
                          var obj = lexer.getObj();
                          if ((0, _primitives.isEOF)(obj)) {
                            break;
                          } else if ((0, _primitives.isName)(obj)) {
                            if (obj.name === "WMode") {
                              parseWMode(cMap, lexer);
                            } else if (obj.name === "CMapName") {
                              parseCMapName(cMap, lexer);
                            }
                            previous = obj;
                          } else if ((0, _primitives.isCmd)(obj)) {
                            switch (obj.cmd) {
                              case "endcmap":
                                break objLoop;
                              case "usecmap":
                                if ((0, _primitives.isName)(previous)) {
                                  embeddedUseCMap = previous.name;
                                }
                                break;
                              case "begincodespacerange":
                                parseCodespaceRange(cMap, lexer);
                                break;
                              case "beginbfchar":
                                parseBfChar(cMap, lexer);
                                break;
                              case "begincidchar":
                                parseCidChar(cMap, lexer);
                                break;
                              case "beginbfrange":
                                parseBfRange(cMap, lexer);
                                break;
                              case "begincidrange":
                                parseCidRange(cMap, lexer);
                                break;
                            }
                          }
                        } catch (ex) {
                          if (ex instanceof _core_utils.MissingDataException) {
                            throw ex;
                          }
                          (0, _util2.warn)("Invalid cMap data: " + ex);
                          continue;
                        }
                      }
                    if (!useCMap && embeddedUseCMap) {
                      useCMap = embeddedUseCMap;
                    }
                    if (useCMap) {
                      return extendCMap(cMap, fetchBuiltInCMap, useCMap);
                    }
                    return Promise.resolve(cMap);
                  }
                  function extendCMap(cMap, fetchBuiltInCMap, useCMap) {
                    return createBuiltInCMap(useCMap, fetchBuiltInCMap).then(function(newCMap) {
                      cMap.useCMap = newCMap;
                      if (cMap.numCodespaceRanges === 0) {
                        var useCodespaceRanges = cMap.useCMap.codespaceRanges;
                        for (var i = 0; i < useCodespaceRanges.length; i++) {
                          cMap.codespaceRanges[i] = useCodespaceRanges[i].slice();
                        }
                        cMap.numCodespaceRanges = cMap.useCMap.numCodespaceRanges;
                      }
                      cMap.useCMap.forEach(function(key, value) {
                        if (!cMap.contains(key)) {
                          cMap.mapOne(key, cMap.useCMap.lookup(key));
                        }
                      });
                      return cMap;
                    });
                  }
                  function createBuiltInCMap(name, fetchBuiltInCMap) {
                    if (name === "Identity-H") {
                      return Promise.resolve(new IdentityCMap(false, 2));
                    } else if (name === "Identity-V") {
                      return Promise.resolve(new IdentityCMap(true, 2));
                    }
                    if (!BUILT_IN_CMAPS.includes(name)) {
                      return Promise.reject(new Error("Unknown CMap name: " + name));
                    }
                    if (!fetchBuiltInCMap) {
                      return Promise.reject(new Error("Built-in CMap parameters are not provided."));
                    }
                    return fetchBuiltInCMap(name).then(function(data) {
                      var cMapData = data.cMapData, compressionType = data.compressionType;
                      var cMap = new CMap(true);
                      if (compressionType === _util2.CMapCompressionType.BINARY) {
                        return new BinaryCMapReader().process(cMapData, cMap, function(useCMap) {
                          return extendCMap(cMap, fetchBuiltInCMap, useCMap);
                        });
                      }
                      if (compressionType === _util2.CMapCompressionType.NONE) {
                        var lexer = new _parser.Lexer(new _stream.Stream(cMapData));
                        return parseCMap(cMap, lexer, fetchBuiltInCMap, null);
                      }
                      return Promise.reject(new Error("TODO: Only BINARY/NONE CMap compression is currently supported."));
                    });
                  }
                  return { async create(params) {
                    var encoding = params.encoding;
                    var fetchBuiltInCMap = params.fetchBuiltInCMap;
                    var useCMap = params.useCMap;
                    if ((0, _primitives.isName)(encoding)) {
                      return createBuiltInCMap(encoding.name, fetchBuiltInCMap);
                    } else if ((0, _primitives.isStream)(encoding)) {
                      var cMap = new CMap();
                      var lexer = new _parser.Lexer(encoding);
                      return parseCMap(cMap, lexer, fetchBuiltInCMap, useCMap).then(function(parsedCMap) {
                        if (parsedCMap.isIdentityCMap) {
                          return createBuiltInCMap(parsedCMap.name, fetchBuiltInCMap);
                        }
                        return parsedCMap;
                      });
                    }
                    throw new Error("Encoding required.");
                  } };
                }();
                exports2.CMapFactory = CMapFactory;
              }, function(module3, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.getFontType = getFontType;
                exports2.IdentityToUnicodeMap = exports2.ToUnicodeMap = exports2.FontFlags = exports2.Font = exports2.ErrorFont = exports2.SEAC_ANALYSIS_ENABLED = void 0;
                var _util2 = __w_pdfjs_require__2(2);
                var _cff_parser = __w_pdfjs_require__2(28);
                var _glyphlist = __w_pdfjs_require__2(31);
                var _encodings = __w_pdfjs_require__2(30);
                var _standard_fonts = __w_pdfjs_require__2(32);
                var _unicode = __w_pdfjs_require__2(33);
                var _core_utils = __w_pdfjs_require__2(7);
                var _font_renderer = __w_pdfjs_require__2(34);
                var _cmap = __w_pdfjs_require__2(26);
                var _stream = __w_pdfjs_require__2(11);
                var _type1_parser = __w_pdfjs_require__2(35);
                const PRIVATE_USE_AREAS = [[57344, 63743], [1048576, 1114109]];
                var PDF_GLYPH_SPACE_UNITS = 1e3;
                var SEAC_ANALYSIS_ENABLED = true;
                exports2.SEAC_ANALYSIS_ENABLED = SEAC_ANALYSIS_ENABLED;
                var FontFlags = { FixedPitch: 1, Serif: 2, Symbolic: 4, Script: 8, Nonsymbolic: 32, Italic: 64, AllCap: 65536, SmallCap: 131072, ForceBold: 262144 };
                exports2.FontFlags = FontFlags;
                var MacStandardGlyphOrdering = [".notdef", ".null", "nonmarkingreturn", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "nonbreakingspace", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "Lslash", "lslash", "Scaron", "scaron", "Zcaron", "zcaron", "brokenbar", "Eth", "eth", "Yacute", "yacute", "Thorn", "thorn", "minus", "multiply", "onesuperior", "twosuperior", "threesuperior", "onehalf", "onequarter", "threequarters", "franc", "Gbreve", "gbreve", "Idotaccent", "Scedilla", "scedilla", "Cacute", "cacute", "Ccaron", "ccaron", "dcroat"];
                function adjustWidths(properties) {
                  if (!properties.fontMatrix) {
                    return;
                  }
                  if (properties.fontMatrix[0] === _util2.FONT_IDENTITY_MATRIX[0]) {
                    return;
                  }
                  var scale = 1e-3 / properties.fontMatrix[0];
                  var glyphsWidths = properties.widths;
                  for (var glyph in glyphsWidths) {
                    glyphsWidths[glyph] *= scale;
                  }
                  properties.defaultWidth *= scale;
                }
                function adjustToUnicode(properties, builtInEncoding) {
                  if (properties.hasIncludedToUnicodeMap) {
                    return;
                  }
                  if (properties.hasEncoding) {
                    return;
                  }
                  if (builtInEncoding === properties.defaultEncoding) {
                    return;
                  }
                  if (properties.toUnicode instanceof IdentityToUnicodeMap) {
                    return;
                  }
                  var toUnicode = [], glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();
                  for (var charCode in builtInEncoding) {
                    var glyphName = builtInEncoding[charCode];
                    var unicode = (0, _unicode.getUnicodeForGlyph)(glyphName, glyphsUnicodeMap);
                    if (unicode !== -1) {
                      toUnicode[charCode] = String.fromCharCode(unicode);
                    }
                  }
                  properties.toUnicode.amend(toUnicode);
                }
                function getFontType(type, subtype) {
                  switch (type) {
                    case "Type1":
                      return subtype === "Type1C" ? _util2.FontType.TYPE1C : _util2.FontType.TYPE1;
                    case "CIDFontType0":
                      return subtype === "CIDFontType0C" ? _util2.FontType.CIDFONTTYPE0C : _util2.FontType.CIDFONTTYPE0;
                    case "OpenType":
                      return _util2.FontType.OPENTYPE;
                    case "TrueType":
                      return _util2.FontType.TRUETYPE;
                    case "CIDFontType2":
                      return _util2.FontType.CIDFONTTYPE2;
                    case "MMType1":
                      return _util2.FontType.MMTYPE1;
                    case "Type0":
                      return _util2.FontType.TYPE0;
                    default:
                      return _util2.FontType.UNKNOWN;
                  }
                }
                function recoverGlyphName(name, glyphsUnicodeMap) {
                  if (glyphsUnicodeMap[name] !== void 0) {
                    return name;
                  }
                  var unicode = (0, _unicode.getUnicodeForGlyph)(name, glyphsUnicodeMap);
                  if (unicode !== -1) {
                    for (var key in glyphsUnicodeMap) {
                      if (glyphsUnicodeMap[key] === unicode) {
                        return key;
                      }
                    }
                  }
                  (0, _util2.info)("Unable to recover a standard glyph name for: " + name);
                  return name;
                }
                var Glyph = function GlyphClosure() {
                  function Glyph2(fontChar, unicode, accent, width, vmetric, operatorListId, isSpace, isInFont) {
                    this.fontChar = fontChar;
                    this.unicode = unicode;
                    this.accent = accent;
                    this.width = width;
                    this.vmetric = vmetric;
                    this.operatorListId = operatorListId;
                    this.isSpace = isSpace;
                    this.isInFont = isInFont;
                  }
                  Glyph2.prototype.matchesForCache = function(fontChar, unicode, accent, width, vmetric, operatorListId, isSpace, isInFont) {
                    return this.fontChar === fontChar && this.unicode === unicode && this.accent === accent && this.width === width && this.vmetric === vmetric && this.operatorListId === operatorListId && this.isSpace === isSpace && this.isInFont === isInFont;
                  };
                  return Glyph2;
                }();
                var ToUnicodeMap = function ToUnicodeMapClosure() {
                  function ToUnicodeMap2(cmap = []) {
                    this._map = cmap;
                  }
                  ToUnicodeMap2.prototype = { get length() {
                    return this._map.length;
                  }, forEach(callback) {
                    for (var charCode in this._map) {
                      callback(charCode, this._map[charCode].charCodeAt(0));
                    }
                  }, has(i) {
                    return this._map[i] !== void 0;
                  }, get(i) {
                    return this._map[i];
                  }, charCodeOf(value) {
                    const map = this._map;
                    if (map.length <= 65536) {
                      return map.indexOf(value);
                    }
                    for (const charCode in map) {
                      if (map[charCode] === value) {
                        return charCode | 0;
                      }
                    }
                    return -1;
                  }, amend(map) {
                    for (var charCode in map) {
                      this._map[charCode] = map[charCode];
                    }
                  } };
                  return ToUnicodeMap2;
                }();
                exports2.ToUnicodeMap = ToUnicodeMap;
                var IdentityToUnicodeMap = function IdentityToUnicodeMapClosure() {
                  function IdentityToUnicodeMap2(firstChar, lastChar) {
                    this.firstChar = firstChar;
                    this.lastChar = lastChar;
                  }
                  IdentityToUnicodeMap2.prototype = { get length() {
                    return this.lastChar + 1 - this.firstChar;
                  }, forEach(callback) {
                    for (var i = this.firstChar, ii = this.lastChar; i <= ii; i++) {
                      callback(i, i);
                    }
                  }, has(i) {
                    return this.firstChar <= i && i <= this.lastChar;
                  }, get(i) {
                    if (this.firstChar <= i && i <= this.lastChar) {
                      return String.fromCharCode(i);
                    }
                    return void 0;
                  }, charCodeOf(v) {
                    return Number.isInteger(v) && v >= this.firstChar && v <= this.lastChar ? v : -1;
                  }, amend(map) {
                    (0, _util2.unreachable)("Should not call amend()");
                  } };
                  return IdentityToUnicodeMap2;
                }();
                exports2.IdentityToUnicodeMap = IdentityToUnicodeMap;
                var OpenTypeFileBuilder = function OpenTypeFileBuilderClosure() {
                  function writeInt16(dest, offset, num) {
                    dest[offset] = num >> 8 & 255;
                    dest[offset + 1] = num & 255;
                  }
                  function writeInt32(dest, offset, num) {
                    dest[offset] = num >> 24 & 255;
                    dest[offset + 1] = num >> 16 & 255;
                    dest[offset + 2] = num >> 8 & 255;
                    dest[offset + 3] = num & 255;
                  }
                  function writeData(dest, offset, data) {
                    var i, ii;
                    if (data instanceof Uint8Array) {
                      dest.set(data, offset);
                    } else if (typeof data === "string") {
                      for (i = 0, ii = data.length; i < ii; i++) {
                        dest[offset++] = data.charCodeAt(i) & 255;
                      }
                    } else {
                      for (i = 0, ii = data.length; i < ii; i++) {
                        dest[offset++] = data[i] & 255;
                      }
                    }
                  }
                  function OpenTypeFileBuilder2(sfnt) {
                    this.sfnt = sfnt;
                    this.tables = /* @__PURE__ */ Object.create(null);
                  }
                  OpenTypeFileBuilder2.getSearchParams = function OpenTypeFileBuilder_getSearchParams(entriesCount, entrySize) {
                    var maxPower2 = 1, log2 = 0;
                    while ((maxPower2 ^ entriesCount) > maxPower2) {
                      maxPower2 <<= 1;
                      log2++;
                    }
                    var searchRange = maxPower2 * entrySize;
                    return { range: searchRange, entry: log2, rangeShift: entrySize * entriesCount - searchRange };
                  };
                  var OTF_HEADER_SIZE = 12;
                  var OTF_TABLE_ENTRY_SIZE = 16;
                  OpenTypeFileBuilder2.prototype = { toArray: function OpenTypeFileBuilder_toArray() {
                    var sfnt = this.sfnt;
                    var tables = this.tables;
                    var tablesNames = Object.keys(tables);
                    tablesNames.sort();
                    var numTables = tablesNames.length;
                    var i, j, jj, table, tableName;
                    var offset = OTF_HEADER_SIZE + numTables * OTF_TABLE_ENTRY_SIZE;
                    var tableOffsets = [offset];
                    for (i = 0; i < numTables; i++) {
                      table = tables[tablesNames[i]];
                      var paddedLength = (table.length + 3 & ~3) >>> 0;
                      offset += paddedLength;
                      tableOffsets.push(offset);
                    }
                    var file = new Uint8Array(offset);
                    for (i = 0; i < numTables; i++) {
                      table = tables[tablesNames[i]];
                      writeData(file, tableOffsets[i], table);
                    }
                    if (sfnt === "true") {
                      sfnt = (0, _util2.string32)(65536);
                    }
                    file[0] = sfnt.charCodeAt(0) & 255;
                    file[1] = sfnt.charCodeAt(1) & 255;
                    file[2] = sfnt.charCodeAt(2) & 255;
                    file[3] = sfnt.charCodeAt(3) & 255;
                    writeInt16(file, 4, numTables);
                    var searchParams = OpenTypeFileBuilder2.getSearchParams(numTables, 16);
                    writeInt16(file, 6, searchParams.range);
                    writeInt16(file, 8, searchParams.entry);
                    writeInt16(file, 10, searchParams.rangeShift);
                    offset = OTF_HEADER_SIZE;
                    for (i = 0; i < numTables; i++) {
                      tableName = tablesNames[i];
                      file[offset] = tableName.charCodeAt(0) & 255;
                      file[offset + 1] = tableName.charCodeAt(1) & 255;
                      file[offset + 2] = tableName.charCodeAt(2) & 255;
                      file[offset + 3] = tableName.charCodeAt(3) & 255;
                      var checksum = 0;
                      for (j = tableOffsets[i], jj = tableOffsets[i + 1]; j < jj; j += 4) {
                        var quad = (0, _core_utils.readUint32)(file, j);
                        checksum = checksum + quad >>> 0;
                      }
                      writeInt32(file, offset + 4, checksum);
                      writeInt32(file, offset + 8, tableOffsets[i]);
                      writeInt32(file, offset + 12, tables[tableName].length);
                      offset += OTF_TABLE_ENTRY_SIZE;
                    }
                    return file;
                  }, addTable: function OpenTypeFileBuilder_addTable(tag, data) {
                    if (tag in this.tables) {
                      throw new Error("Table " + tag + " already exists");
                    }
                    this.tables[tag] = data;
                  } };
                  return OpenTypeFileBuilder2;
                }();
                var Font = function FontClosure() {
                  function Font2(name, file, properties) {
                    var charCode;
                    this.name = name;
                    this.loadedName = properties.loadedName;
                    this.isType3Font = properties.isType3Font;
                    this.sizes = [];
                    this.missingFile = false;
                    this.glyphCache = /* @__PURE__ */ Object.create(null);
                    this.isSerifFont = !!(properties.flags & FontFlags.Serif);
                    this.isSymbolicFont = !!(properties.flags & FontFlags.Symbolic);
                    this.isMonospace = !!(properties.flags & FontFlags.FixedPitch);
                    var type = properties.type;
                    var subtype = properties.subtype;
                    this.type = type;
                    this.subtype = subtype;
                    let fallbackName = "sans-serif";
                    if (this.isMonospace) {
                      fallbackName = "monospace";
                    } else if (this.isSerifFont) {
                      fallbackName = "serif";
                    }
                    this.fallbackName = fallbackName;
                    this.differences = properties.differences;
                    this.widths = properties.widths;
                    this.defaultWidth = properties.defaultWidth;
                    this.composite = properties.composite;
                    this.wideChars = properties.wideChars;
                    this.cMap = properties.cMap;
                    this.ascent = properties.ascent / PDF_GLYPH_SPACE_UNITS;
                    this.descent = properties.descent / PDF_GLYPH_SPACE_UNITS;
                    this.fontMatrix = properties.fontMatrix;
                    this.bbox = properties.bbox;
                    this.defaultEncoding = properties.defaultEncoding;
                    this.toUnicode = properties.toUnicode;
                    this.fallbackToUnicode = properties.fallbackToUnicode || new ToUnicodeMap();
                    this.toFontChar = [];
                    if (properties.type === "Type3") {
                      for (charCode = 0; charCode < 256; charCode++) {
                        this.toFontChar[charCode] = this.differences[charCode] || properties.defaultEncoding[charCode];
                      }
                      this.fontType = _util2.FontType.TYPE3;
                      return;
                    }
                    this.cidEncoding = properties.cidEncoding;
                    this.vertical = properties.vertical;
                    if (this.vertical) {
                      this.vmetrics = properties.vmetrics;
                      this.defaultVMetrics = properties.defaultVMetrics;
                    }
                    if (!file || file.isEmpty) {
                      if (file) {
                        (0, _util2.warn)('Font file is empty in "' + name + '" (' + this.loadedName + ")");
                      }
                      this.fallbackToSystemFont();
                      return;
                    }
                    [type, subtype] = getFontFileType(file, properties);
                    if (type !== this.type || subtype !== this.subtype) {
                      (0, _util2.info)(`Inconsistent font file Type/SubType, expected: ${this.type}/${this.subtype} but found: ${type}/${subtype}.`);
                    }
                    try {
                      var data;
                      switch (type) {
                        case "MMType1":
                          (0, _util2.info)("MMType1 font (" + name + "), falling back to Type1.");
                        case "Type1":
                        case "CIDFontType0":
                          this.mimetype = "font/opentype";
                          var cff = subtype === "Type1C" || subtype === "CIDFontType0C" ? new CFFFont(file, properties) : new Type1Font(name, file, properties);
                          adjustWidths(properties);
                          data = this.convert(name, cff, properties);
                          break;
                        case "OpenType":
                        case "TrueType":
                        case "CIDFontType2":
                          this.mimetype = "font/opentype";
                          data = this.checkAndRepair(name, file, properties);
                          if (this.isOpenType) {
                            adjustWidths(properties);
                            type = "OpenType";
                          }
                          break;
                        default:
                          throw new _util2.FormatError(`Font ${type} is not supported`);
                      }
                    } catch (e) {
                      (0, _util2.warn)(e);
                      this.fallbackToSystemFont();
                      return;
                    }
                    this.data = data;
                    this.fontType = getFontType(type, subtype);
                    this.fontMatrix = properties.fontMatrix;
                    this.widths = properties.widths;
                    this.defaultWidth = properties.defaultWidth;
                    this.toUnicode = properties.toUnicode;
                    this.encoding = properties.baseEncoding;
                    this.seacMap = properties.seacMap;
                  }
                  Font2.getFontID = function() {
                    var ID = 1;
                    return function Font_getFontID() {
                      return String(ID++);
                    };
                  }();
                  function int16(b0, b1) {
                    return (b0 << 8) + b1;
                  }
                  function writeSignedInt16(bytes, index, value) {
                    bytes[index + 1] = value;
                    bytes[index] = value >>> 8;
                  }
                  function signedInt16(b0, b1) {
                    var value = (b0 << 8) + b1;
                    return value & 1 << 15 ? value - 65536 : value;
                  }
                  function int32(b0, b1, b2, b3) {
                    return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
                  }
                  function string16(value) {
                    return String.fromCharCode(value >> 8 & 255, value & 255);
                  }
                  function safeString16(value) {
                    if (value > 32767) {
                      value = 32767;
                    } else if (value < -32768) {
                      value = -32768;
                    }
                    return String.fromCharCode(value >> 8 & 255, value & 255);
                  }
                  function isTrueTypeFile(file) {
                    var header = file.peekBytes(4);
                    return (0, _core_utils.readUint32)(header, 0) === 65536 || (0, _util2.bytesToString)(header) === "true";
                  }
                  function isTrueTypeCollectionFile(file) {
                    const header = file.peekBytes(4);
                    return (0, _util2.bytesToString)(header) === "ttcf";
                  }
                  function isOpenTypeFile(file) {
                    var header = file.peekBytes(4);
                    return (0, _util2.bytesToString)(header) === "OTTO";
                  }
                  function isType1File(file) {
                    var header = file.peekBytes(2);
                    if (header[0] === 37 && header[1] === 33) {
                      return true;
                    }
                    if (header[0] === 128 && header[1] === 1) {
                      return true;
                    }
                    return false;
                  }
                  function isCFFFile(file) {
                    const header = file.peekBytes(4);
                    if (header[0] >= 1 && header[3] >= 1 && header[3] <= 4) {
                      return true;
                    }
                    return false;
                  }
                  function getFontFileType(file, { type, subtype, composite }) {
                    let fileType, fileSubtype;
                    if (isTrueTypeFile(file) || isTrueTypeCollectionFile(file)) {
                      if (composite) {
                        fileType = "CIDFontType2";
                      } else {
                        fileType = "TrueType";
                      }
                    } else if (isOpenTypeFile(file)) {
                      if (composite) {
                        fileType = "CIDFontType2";
                      } else {
                        fileType = "OpenType";
                      }
                    } else if (isType1File(file)) {
                      if (composite) {
                        fileType = "CIDFontType0";
                      } else {
                        fileType = type === "MMType1" ? "MMType1" : "Type1";
                      }
                    } else if (isCFFFile(file)) {
                      if (composite) {
                        fileType = "CIDFontType0";
                        fileSubtype = "CIDFontType0C";
                      } else {
                        fileType = type === "MMType1" ? "MMType1" : "Type1";
                        fileSubtype = "Type1C";
                      }
                    } else {
                      (0, _util2.warn)("getFontFileType: Unable to detect correct font file Type/Subtype.");
                      fileType = type;
                      fileSubtype = subtype;
                    }
                    return [fileType, fileSubtype];
                  }
                  function buildToFontChar(encoding, glyphsUnicodeMap, differences) {
                    var toFontChar = [], unicode;
                    for (var i = 0, ii = encoding.length; i < ii; i++) {
                      unicode = (0, _unicode.getUnicodeForGlyph)(encoding[i], glyphsUnicodeMap);
                      if (unicode !== -1) {
                        toFontChar[i] = unicode;
                      }
                    }
                    for (var charCode in differences) {
                      unicode = (0, _unicode.getUnicodeForGlyph)(differences[charCode], glyphsUnicodeMap);
                      if (unicode !== -1) {
                        toFontChar[+charCode] = unicode;
                      }
                    }
                    return toFontChar;
                  }
                  function adjustMapping(charCodeToGlyphId, hasGlyph, newGlyphZeroId) {
                    var newMap = /* @__PURE__ */ Object.create(null);
                    var toFontChar = [];
                    var privateUseAreaIndex = 0;
                    var nextAvailableFontCharCode = PRIVATE_USE_AREAS[privateUseAreaIndex][0];
                    var privateUseOffetEnd = PRIVATE_USE_AREAS[privateUseAreaIndex][1];
                    for (var originalCharCode in charCodeToGlyphId) {
                      originalCharCode |= 0;
                      var glyphId = charCodeToGlyphId[originalCharCode];
                      if (!hasGlyph(glyphId)) {
                        continue;
                      }
                      if (nextAvailableFontCharCode > privateUseOffetEnd) {
                        privateUseAreaIndex++;
                        if (privateUseAreaIndex >= PRIVATE_USE_AREAS.length) {
                          (0, _util2.warn)("Ran out of space in font private use area.");
                          break;
                        }
                        nextAvailableFontCharCode = PRIVATE_USE_AREAS[privateUseAreaIndex][0];
                        privateUseOffetEnd = PRIVATE_USE_AREAS[privateUseAreaIndex][1];
                      }
                      var fontCharCode = nextAvailableFontCharCode++;
                      if (glyphId === 0) {
                        glyphId = newGlyphZeroId;
                      }
                      newMap[fontCharCode] = glyphId;
                      toFontChar[originalCharCode] = fontCharCode;
                    }
                    return { toFontChar, charCodeToGlyphId: newMap, nextAvailableFontCharCode };
                  }
                  function getRanges(glyphs, numGlyphs) {
                    var codes = [];
                    for (var charCode in glyphs) {
                      if (glyphs[charCode] >= numGlyphs) {
                        continue;
                      }
                      codes.push({ fontCharCode: charCode | 0, glyphId: glyphs[charCode] });
                    }
                    if (codes.length === 0) {
                      codes.push({ fontCharCode: 0, glyphId: 0 });
                    }
                    codes.sort(function fontGetRangesSort(a, b) {
                      return a.fontCharCode - b.fontCharCode;
                    });
                    var ranges = [];
                    var length = codes.length;
                    for (var n = 0; n < length; ) {
                      var start = codes[n].fontCharCode;
                      var codeIndices = [codes[n].glyphId];
                      ++n;
                      var end = start;
                      while (n < length && end + 1 === codes[n].fontCharCode) {
                        codeIndices.push(codes[n].glyphId);
                        ++end;
                        ++n;
                        if (end === 65535) {
                          break;
                        }
                      }
                      ranges.push([start, end, codeIndices]);
                    }
                    return ranges;
                  }
                  function createCmapTable(glyphs, numGlyphs) {
                    var ranges = getRanges(glyphs, numGlyphs);
                    var numTables = ranges[ranges.length - 1][1] > 65535 ? 2 : 1;
                    var cmap = "\0\0" + string16(numTables) + "\0\0" + (0, _util2.string32)(4 + numTables * 8);
                    var i, ii, j, jj;
                    for (i = ranges.length - 1; i >= 0; --i) {
                      if (ranges[i][0] <= 65535) {
                        break;
                      }
                    }
                    var bmpLength = i + 1;
                    if (ranges[i][0] < 65535 && ranges[i][1] === 65535) {
                      ranges[i][1] = 65534;
                    }
                    var trailingRangesCount = ranges[i][1] < 65535 ? 1 : 0;
                    var segCount = bmpLength + trailingRangesCount;
                    var searchParams = OpenTypeFileBuilder.getSearchParams(segCount, 2);
                    var startCount = "";
                    var endCount = "";
                    var idDeltas = "";
                    var idRangeOffsets = "";
                    var glyphsIds = "";
                    var bias = 0;
                    var range, start, end, codes;
                    for (i = 0, ii = bmpLength; i < ii; i++) {
                      range = ranges[i];
                      start = range[0];
                      end = range[1];
                      startCount += string16(start);
                      endCount += string16(end);
                      codes = range[2];
                      var contiguous = true;
                      for (j = 1, jj = codes.length; j < jj; ++j) {
                        if (codes[j] !== codes[j - 1] + 1) {
                          contiguous = false;
                          break;
                        }
                      }
                      if (!contiguous) {
                        var offset = (segCount - i) * 2 + bias * 2;
                        bias += end - start + 1;
                        idDeltas += string16(0);
                        idRangeOffsets += string16(offset);
                        for (j = 0, jj = codes.length; j < jj; ++j) {
                          glyphsIds += string16(codes[j]);
                        }
                      } else {
                        var startCode = codes[0];
                        idDeltas += string16(startCode - start & 65535);
                        idRangeOffsets += string16(0);
                      }
                    }
                    if (trailingRangesCount > 0) {
                      endCount += "\xFF\xFF";
                      startCount += "\xFF\xFF";
                      idDeltas += "\0";
                      idRangeOffsets += "\0\0";
                    }
                    var format314 = "\0\0" + string16(2 * segCount) + string16(searchParams.range) + string16(searchParams.entry) + string16(searchParams.rangeShift) + endCount + "\0\0" + startCount + idDeltas + idRangeOffsets + glyphsIds;
                    var format31012 = "";
                    var header31012 = "";
                    if (numTables > 1) {
                      cmap += "\0\0\n" + (0, _util2.string32)(4 + numTables * 8 + 4 + format314.length);
                      format31012 = "";
                      for (i = 0, ii = ranges.length; i < ii; i++) {
                        range = ranges[i];
                        start = range[0];
                        codes = range[2];
                        var code = codes[0];
                        for (j = 1, jj = codes.length; j < jj; ++j) {
                          if (codes[j] !== codes[j - 1] + 1) {
                            end = range[0] + j - 1;
                            format31012 += (0, _util2.string32)(start) + (0, _util2.string32)(end) + (0, _util2.string32)(code);
                            start = end + 1;
                            code = codes[j];
                          }
                        }
                        format31012 += (0, _util2.string32)(start) + (0, _util2.string32)(range[1]) + (0, _util2.string32)(code);
                      }
                      header31012 = "\0\f\0\0" + (0, _util2.string32)(format31012.length + 16) + "\0\0\0\0" + (0, _util2.string32)(format31012.length / 12);
                    }
                    return cmap + "\0" + string16(format314.length + 4) + format314 + header31012 + format31012;
                  }
                  function validateOS2Table(os2) {
                    var stream = new _stream.Stream(os2.data);
                    var version2 = stream.getUint16();
                    stream.getBytes(60);
                    var selection = stream.getUint16();
                    if (version2 < 4 && selection & 768) {
                      return false;
                    }
                    var firstChar = stream.getUint16();
                    var lastChar = stream.getUint16();
                    if (firstChar > lastChar) {
                      return false;
                    }
                    stream.getBytes(6);
                    var usWinAscent = stream.getUint16();
                    if (usWinAscent === 0) {
                      return false;
                    }
                    os2.data[8] = os2.data[9] = 0;
                    return true;
                  }
                  function createOS2Table(properties, charstrings, override) {
                    override = override || { unitsPerEm: 0, yMax: 0, yMin: 0, ascent: 0, descent: 0 };
                    var ulUnicodeRange1 = 0;
                    var ulUnicodeRange2 = 0;
                    var ulUnicodeRange3 = 0;
                    var ulUnicodeRange4 = 0;
                    var firstCharIndex = null;
                    var lastCharIndex = 0;
                    if (charstrings) {
                      for (var code in charstrings) {
                        code |= 0;
                        if (firstCharIndex > code || !firstCharIndex) {
                          firstCharIndex = code;
                        }
                        if (lastCharIndex < code) {
                          lastCharIndex = code;
                        }
                        var position = (0, _unicode.getUnicodeRangeFor)(code);
                        if (position < 32) {
                          ulUnicodeRange1 |= 1 << position;
                        } else if (position < 64) {
                          ulUnicodeRange2 |= 1 << position - 32;
                        } else if (position < 96) {
                          ulUnicodeRange3 |= 1 << position - 64;
                        } else if (position < 123) {
                          ulUnicodeRange4 |= 1 << position - 96;
                        } else {
                          throw new _util2.FormatError("Unicode ranges Bits > 123 are reserved for internal usage");
                        }
                      }
                      if (lastCharIndex > 65535) {
                        lastCharIndex = 65535;
                      }
                    } else {
                      firstCharIndex = 0;
                      lastCharIndex = 255;
                    }
                    var bbox = properties.bbox || [0, 0, 0, 0];
                    var unitsPerEm = override.unitsPerEm || 1 / (properties.fontMatrix || _util2.FONT_IDENTITY_MATRIX)[0];
                    var scale = properties.ascentScaled ? 1 : unitsPerEm / PDF_GLYPH_SPACE_UNITS;
                    var typoAscent = override.ascent || Math.round(scale * (properties.ascent || bbox[3]));
                    var typoDescent = override.descent || Math.round(scale * (properties.descent || bbox[1]));
                    if (typoDescent > 0 && properties.descent > 0 && bbox[1] < 0) {
                      typoDescent = -typoDescent;
                    }
                    var winAscent = override.yMax || typoAscent;
                    var winDescent = -override.yMin || -typoDescent;
                    return "\0$\xF4\0\0\0\x8A\xBB\0\0\0\x8C\x8A\xBB\0\0\xDF\x001\0\0\0\0" + String.fromCharCode(properties.fixedPitch ? 9 : 0) + "\0\0\0\0\0\0" + (0, _util2.string32)(ulUnicodeRange1) + (0, _util2.string32)(ulUnicodeRange2) + (0, _util2.string32)(ulUnicodeRange3) + (0, _util2.string32)(ulUnicodeRange4) + "*21*" + string16(properties.italicAngle ? 1 : 0) + string16(firstCharIndex || properties.firstChar) + string16(lastCharIndex || properties.lastChar) + string16(typoAscent) + string16(typoDescent) + "\0d" + string16(winAscent) + string16(winDescent) + "\0\0\0\0\0\0\0\0" + string16(properties.xHeight) + string16(properties.capHeight) + string16(0) + string16(firstCharIndex || properties.firstChar) + "\0";
                  }
                  function createPostTable(properties) {
                    var angle = Math.floor(properties.italicAngle * 2 ** 16);
                    return "\0\0\0" + (0, _util2.string32)(angle) + "\0\0\0\0" + (0, _util2.string32)(properties.fixedPitch) + "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
                  }
                  function createNameTable(name, proto) {
                    if (!proto) {
                      proto = [[], []];
                    }
                    var strings = [proto[0][0] || "Original licence", proto[0][1] || name, proto[0][2] || "Unknown", proto[0][3] || "uniqueID", proto[0][4] || name, proto[0][5] || "Version 0.11", proto[0][6] || "", proto[0][7] || "Unknown", proto[0][8] || "Unknown", proto[0][9] || "Unknown"];
                    var stringsUnicode = [];
                    var i, ii, j, jj, str;
                    for (i = 0, ii = strings.length; i < ii; i++) {
                      str = proto[1][i] || strings[i];
                      var strBufUnicode = [];
                      for (j = 0, jj = str.length; j < jj; j++) {
                        strBufUnicode.push(string16(str.charCodeAt(j)));
                      }
                      stringsUnicode.push(strBufUnicode.join(""));
                    }
                    var names = [strings, stringsUnicode];
                    var platforms = ["\0", "\0"];
                    var encodings = ["\0\0", "\0"];
                    var languages = ["\0\0", "	"];
                    var namesRecordCount = strings.length * platforms.length;
                    var nameTable = "\0\0" + string16(namesRecordCount) + string16(namesRecordCount * 12 + 6);
                    var strOffset = 0;
                    for (i = 0, ii = platforms.length; i < ii; i++) {
                      var strs = names[i];
                      for (j = 0, jj = strs.length; j < jj; j++) {
                        str = strs[j];
                        var nameRecord = platforms[i] + encodings[i] + languages[i] + string16(j) + string16(str.length) + string16(strOffset);
                        nameTable += nameRecord;
                        strOffset += str.length;
                      }
                    }
                    nameTable += strings.join("") + stringsUnicode.join("");
                    return nameTable;
                  }
                  Font2.prototype = { name: null, font: null, mimetype: null, encoding: null, disableFontFace: false, get renderer() {
                    var renderer = _font_renderer.FontRendererFactory.create(this, SEAC_ANALYSIS_ENABLED);
                    return (0, _util2.shadow)(this, "renderer", renderer);
                  }, exportData: function Font_exportData() {
                    var data = {};
                    for (var i in this) {
                      if (this.hasOwnProperty(i)) {
                        data[i] = this[i];
                      }
                    }
                    return data;
                  }, fallbackToSystemFont: function Font_fallbackToSystemFont() {
                    this.missingFile = true;
                    var charCode, unicode;
                    var name = this.name;
                    var type = this.type;
                    var subtype = this.subtype;
                    let fontName = name.replace(/[,_]/g, "-").replace(/\s/g, "");
                    var stdFontMap = (0, _standard_fonts.getStdFontMap)(), nonStdFontMap = (0, _standard_fonts.getNonStdFontMap)();
                    var isStandardFont = !!stdFontMap[fontName] || !!(nonStdFontMap[fontName] && stdFontMap[nonStdFontMap[fontName]]);
                    fontName = stdFontMap[fontName] || nonStdFontMap[fontName] || fontName;
                    this.bold = fontName.search(/bold/gi) !== -1;
                    this.italic = fontName.search(/oblique/gi) !== -1 || fontName.search(/italic/gi) !== -1;
                    this.black = name.search(/Black/g) !== -1;
                    this.remeasure = Object.keys(this.widths).length > 0;
                    if (isStandardFont && type === "CIDFontType2" && this.cidEncoding.startsWith("Identity-")) {
                      const GlyphMapForStandardFonts = (0, _standard_fonts.getGlyphMapForStandardFonts)();
                      const map = [];
                      for (charCode in GlyphMapForStandardFonts) {
                        map[+charCode] = GlyphMapForStandardFonts[charCode];
                      }
                      if (/Arial-?Black/i.test(name)) {
                        var SupplementalGlyphMapForArialBlack = (0, _standard_fonts.getSupplementalGlyphMapForArialBlack)();
                        for (charCode in SupplementalGlyphMapForArialBlack) {
                          map[+charCode] = SupplementalGlyphMapForArialBlack[charCode];
                        }
                      } else if (/Calibri/i.test(name)) {
                        const SupplementalGlyphMapForCalibri = (0, _standard_fonts.getSupplementalGlyphMapForCalibri)();
                        for (charCode in SupplementalGlyphMapForCalibri) {
                          map[+charCode] = SupplementalGlyphMapForCalibri[charCode];
                        }
                      }
                      var isIdentityUnicode = this.toUnicode instanceof IdentityToUnicodeMap;
                      if (!isIdentityUnicode) {
                        this.toUnicode.forEach(function(charCode2, unicodeCharCode) {
                          map[+charCode2] = unicodeCharCode;
                        });
                      }
                      this.toFontChar = map;
                      this.toUnicode = new ToUnicodeMap(map);
                    } else if (/Symbol/i.test(fontName)) {
                      this.toFontChar = buildToFontChar(_encodings.SymbolSetEncoding, (0, _glyphlist.getGlyphsUnicode)(), this.differences);
                    } else if (/Dingbats/i.test(fontName)) {
                      if (/Wingdings/i.test(name)) {
                        (0, _util2.warn)("Non-embedded Wingdings font, falling back to ZapfDingbats.");
                      }
                      this.toFontChar = buildToFontChar(_encodings.ZapfDingbatsEncoding, (0, _glyphlist.getDingbatsGlyphsUnicode)(), this.differences);
                    } else if (isStandardFont) {
                      this.toFontChar = buildToFontChar(this.defaultEncoding, (0, _glyphlist.getGlyphsUnicode)(), this.differences);
                    } else {
                      const glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();
                      const map = [];
                      this.toUnicode.forEach((charCode2, unicodeCharCode) => {
                        if (!this.composite) {
                          var glyphName = this.differences[charCode2] || this.defaultEncoding[charCode2];
                          unicode = (0, _unicode.getUnicodeForGlyph)(glyphName, glyphsUnicodeMap);
                          if (unicode !== -1) {
                            unicodeCharCode = unicode;
                          }
                        }
                        map[+charCode2] = unicodeCharCode;
                      });
                      if (this.composite && this.toUnicode instanceof IdentityToUnicodeMap) {
                        if (/Verdana/i.test(name)) {
                          const GlyphMapForStandardFonts = (0, _standard_fonts.getGlyphMapForStandardFonts)();
                          for (charCode in GlyphMapForStandardFonts) {
                            map[+charCode] = GlyphMapForStandardFonts[charCode];
                          }
                        }
                      }
                      this.toFontChar = map;
                    }
                    this.loadedName = fontName.split("-")[0];
                    this.fontType = getFontType(type, subtype);
                  }, checkAndRepair: function Font_checkAndRepair(name, font, properties) {
                    const VALID_TABLES = ["OS/2", "cmap", "head", "hhea", "hmtx", "maxp", "name", "post", "loca", "glyf", "fpgm", "prep", "cvt ", "CFF "];
                    function readTables(file, numTables) {
                      const tables2 = /* @__PURE__ */ Object.create(null);
                      tables2["OS/2"] = null;
                      tables2["cmap"] = null;
                      tables2["head"] = null;
                      tables2["hhea"] = null;
                      tables2["hmtx"] = null;
                      tables2["maxp"] = null;
                      tables2["name"] = null;
                      tables2["post"] = null;
                      for (let i = 0; i < numTables; i++) {
                        const table = readTableEntry(font);
                        if (!VALID_TABLES.includes(table.tag)) {
                          continue;
                        }
                        if (table.length === 0) {
                          continue;
                        }
                        tables2[table.tag] = table;
                      }
                      return tables2;
                    }
                    function readTableEntry(file) {
                      var tag = (0, _util2.bytesToString)(file.getBytes(4));
                      var checksum = file.getInt32() >>> 0;
                      var offset = file.getInt32() >>> 0;
                      var length = file.getInt32() >>> 0;
                      var previousPosition = file.pos;
                      file.pos = file.start ? file.start : 0;
                      file.skip(offset);
                      var data = file.getBytes(length);
                      file.pos = previousPosition;
                      if (tag === "head") {
                        data[8] = data[9] = data[10] = data[11] = 0;
                        data[17] |= 32;
                      }
                      return { tag, checksum, length, offset, data };
                    }
                    function readOpenTypeHeader(ttf) {
                      return { version: (0, _util2.bytesToString)(ttf.getBytes(4)), numTables: ttf.getUint16(), searchRange: ttf.getUint16(), entrySelector: ttf.getUint16(), rangeShift: ttf.getUint16() };
                    }
                    function readTrueTypeCollectionHeader(ttc) {
                      const ttcTag = (0, _util2.bytesToString)(ttc.getBytes(4));
                      (0, _util2.assert)(ttcTag === "ttcf", "Must be a TrueType Collection font.");
                      const majorVersion = ttc.getUint16();
                      const minorVersion = ttc.getUint16();
                      const numFonts = ttc.getInt32() >>> 0;
                      const offsetTable = [];
                      for (let i = 0; i < numFonts; i++) {
                        offsetTable.push(ttc.getInt32() >>> 0);
                      }
                      const header2 = { ttcTag, majorVersion, minorVersion, numFonts, offsetTable };
                      switch (majorVersion) {
                        case 1:
                          return header2;
                        case 2:
                          header2.dsigTag = ttc.getInt32() >>> 0;
                          header2.dsigLength = ttc.getInt32() >>> 0;
                          header2.dsigOffset = ttc.getInt32() >>> 0;
                          return header2;
                      }
                      throw new _util2.FormatError(`Invalid TrueType Collection majorVersion: ${majorVersion}.`);
                    }
                    function readTrueTypeCollectionData(ttc, fontName) {
                      const { numFonts, offsetTable } = readTrueTypeCollectionHeader(ttc);
                      for (let i = 0; i < numFonts; i++) {
                        ttc.pos = (ttc.start || 0) + offsetTable[i];
                        const potentialHeader = readOpenTypeHeader(ttc);
                        const potentialTables = readTables(ttc, potentialHeader.numTables);
                        if (!potentialTables["name"]) {
                          throw new _util2.FormatError('TrueType Collection font must contain a "name" table.');
                        }
                        const nameTable = readNameTable(potentialTables["name"]);
                        for (let j = 0, jj = nameTable.length; j < jj; j++) {
                          for (let k = 0, kk = nameTable[j].length; k < kk; k++) {
                            const nameEntry = nameTable[j][k];
                            if (nameEntry && nameEntry.replace(/\s/g, "") === fontName) {
                              return { header: potentialHeader, tables: potentialTables };
                            }
                          }
                        }
                      }
                      throw new _util2.FormatError(`TrueType Collection does not contain "${fontName}" font.`);
                    }
                    function readCmapTable(cmap, font2, isSymbolicFont, hasEncoding) {
                      if (!cmap) {
                        (0, _util2.warn)("No cmap table available.");
                        return { platformId: -1, encodingId: -1, mappings: [], hasShortCmap: false };
                      }
                      var segment;
                      var start = (font2.start ? font2.start : 0) + cmap.offset;
                      font2.pos = start;
                      font2.getUint16();
                      var numTables = font2.getUint16();
                      var potentialTable;
                      var canBreak = false;
                      for (var i = 0; i < numTables; i++) {
                        var platformId = font2.getUint16();
                        var encodingId = font2.getUint16();
                        var offset = font2.getInt32() >>> 0;
                        var useTable = false;
                        if (potentialTable && potentialTable.platformId === platformId && potentialTable.encodingId === encodingId) {
                          continue;
                        }
                        if (platformId === 0 && encodingId === 0) {
                          useTable = true;
                        } else if (platformId === 1 && encodingId === 0) {
                          useTable = true;
                        } else if (platformId === 3 && encodingId === 1 && (hasEncoding || !potentialTable)) {
                          useTable = true;
                          if (!isSymbolicFont) {
                            canBreak = true;
                          }
                        } else if (isSymbolicFont && platformId === 3 && encodingId === 0) {
                          useTable = true;
                          canBreak = true;
                        }
                        if (useTable) {
                          potentialTable = { platformId, encodingId, offset };
                        }
                        if (canBreak) {
                          break;
                        }
                      }
                      if (potentialTable) {
                        font2.pos = start + potentialTable.offset;
                      }
                      if (!potentialTable || font2.peekByte() === -1) {
                        (0, _util2.warn)("Could not find a preferred cmap table.");
                        return { platformId: -1, encodingId: -1, mappings: [], hasShortCmap: false };
                      }
                      var format = font2.getUint16();
                      font2.getUint16();
                      font2.getUint16();
                      var hasShortCmap = false;
                      var mappings = [];
                      var j, glyphId2;
                      if (format === 0) {
                        for (j = 0; j < 256; j++) {
                          var index = font2.getByte();
                          if (!index) {
                            continue;
                          }
                          mappings.push({ charCode: j, glyphId: index });
                        }
                        hasShortCmap = true;
                      } else if (format === 4) {
                        var segCount = font2.getUint16() >> 1;
                        font2.getBytes(6);
                        var segIndex, segments = [];
                        for (segIndex = 0; segIndex < segCount; segIndex++) {
                          segments.push({ end: font2.getUint16() });
                        }
                        font2.getUint16();
                        for (segIndex = 0; segIndex < segCount; segIndex++) {
                          segments[segIndex].start = font2.getUint16();
                        }
                        for (segIndex = 0; segIndex < segCount; segIndex++) {
                          segments[segIndex].delta = font2.getUint16();
                        }
                        var offsetsCount = 0;
                        for (segIndex = 0; segIndex < segCount; segIndex++) {
                          segment = segments[segIndex];
                          var rangeOffset = font2.getUint16();
                          if (!rangeOffset) {
                            segment.offsetIndex = -1;
                            continue;
                          }
                          var offsetIndex = (rangeOffset >> 1) - (segCount - segIndex);
                          segment.offsetIndex = offsetIndex;
                          offsetsCount = Math.max(offsetsCount, offsetIndex + segment.end - segment.start + 1);
                        }
                        var offsets = [];
                        for (j = 0; j < offsetsCount; j++) {
                          offsets.push(font2.getUint16());
                        }
                        for (segIndex = 0; segIndex < segCount; segIndex++) {
                          segment = segments[segIndex];
                          start = segment.start;
                          var end = segment.end;
                          var delta = segment.delta;
                          offsetIndex = segment.offsetIndex;
                          for (j = start; j <= end; j++) {
                            if (j === 65535) {
                              continue;
                            }
                            glyphId2 = offsetIndex < 0 ? j : offsets[offsetIndex + j - start];
                            glyphId2 = glyphId2 + delta & 65535;
                            mappings.push({ charCode: j, glyphId: glyphId2 });
                          }
                        }
                      } else if (format === 6) {
                        var firstCode = font2.getUint16();
                        var entryCount = font2.getUint16();
                        for (j = 0; j < entryCount; j++) {
                          glyphId2 = font2.getUint16();
                          var charCode2 = firstCode + j;
                          mappings.push({ charCode: charCode2, glyphId: glyphId2 });
                        }
                      } else {
                        (0, _util2.warn)("cmap table has unsupported format: " + format);
                        return { platformId: -1, encodingId: -1, mappings: [], hasShortCmap: false };
                      }
                      mappings.sort(function(a, b) {
                        return a.charCode - b.charCode;
                      });
                      for (i = 1; i < mappings.length; i++) {
                        if (mappings[i - 1].charCode === mappings[i].charCode) {
                          mappings.splice(i, 1);
                          i--;
                        }
                      }
                      return { platformId: potentialTable.platformId, encodingId: potentialTable.encodingId, mappings, hasShortCmap };
                    }
                    function sanitizeMetrics(font2, header2, metrics, numGlyphs2, dupFirstEntry2) {
                      if (!header2) {
                        if (metrics) {
                          metrics.data = null;
                        }
                        return;
                      }
                      font2.pos = (font2.start ? font2.start : 0) + header2.offset;
                      font2.pos += 4;
                      font2.pos += 2;
                      font2.pos += 2;
                      font2.pos += 2;
                      font2.pos += 2;
                      font2.pos += 2;
                      font2.pos += 2;
                      font2.pos += 2;
                      font2.pos += 2;
                      font2.pos += 2;
                      font2.pos += 2;
                      font2.pos += 8;
                      font2.pos += 2;
                      var numOfMetrics = font2.getUint16();
                      if (numOfMetrics > numGlyphs2) {
                        (0, _util2.info)("The numOfMetrics (" + numOfMetrics + ") should not be greater than the numGlyphs (" + numGlyphs2 + ")");
                        numOfMetrics = numGlyphs2;
                        header2.data[34] = (numOfMetrics & 65280) >> 8;
                        header2.data[35] = numOfMetrics & 255;
                      }
                      var numOfSidebearings = numGlyphs2 - numOfMetrics;
                      var numMissing = numOfSidebearings - (metrics.length - numOfMetrics * 4 >> 1);
                      if (numMissing > 0) {
                        var entries = new Uint8Array(metrics.length + numMissing * 2);
                        entries.set(metrics.data);
                        if (dupFirstEntry2) {
                          entries[metrics.length] = metrics.data[2];
                          entries[metrics.length + 1] = metrics.data[3];
                        }
                        metrics.data = entries;
                      }
                    }
                    function sanitizeGlyph(source, sourceStart, sourceEnd, dest, destStart, hintsValid2) {
                      var glyphProfile = { length: 0, sizeOfInstructions: 0 };
                      if (sourceEnd - sourceStart <= 12) {
                        return glyphProfile;
                      }
                      var glyf = source.subarray(sourceStart, sourceEnd);
                      var contoursCount = signedInt16(glyf[0], glyf[1]);
                      if (contoursCount < 0) {
                        contoursCount = -1;
                        writeSignedInt16(glyf, 0, contoursCount);
                        dest.set(glyf, destStart);
                        glyphProfile.length = glyf.length;
                        return glyphProfile;
                      }
                      var i, j = 10, flagsCount = 0;
                      for (i = 0; i < contoursCount; i++) {
                        var endPoint = glyf[j] << 8 | glyf[j + 1];
                        flagsCount = endPoint + 1;
                        j += 2;
                      }
                      var instructionsStart = j;
                      var instructionsLength = glyf[j] << 8 | glyf[j + 1];
                      glyphProfile.sizeOfInstructions = instructionsLength;
                      j += 2 + instructionsLength;
                      var instructionsEnd = j;
                      var coordinatesLength = 0;
                      for (i = 0; i < flagsCount; i++) {
                        var flag = glyf[j++];
                        if (flag & 192) {
                          glyf[j - 1] = flag & 63;
                        }
                        let xLength = 2;
                        if (flag & 2) {
                          xLength = 1;
                        } else if (flag & 16) {
                          xLength = 0;
                        }
                        let yLength = 2;
                        if (flag & 4) {
                          yLength = 1;
                        } else if (flag & 32) {
                          yLength = 0;
                        }
                        const xyLength = xLength + yLength;
                        coordinatesLength += xyLength;
                        if (flag & 8) {
                          var repeat = glyf[j++];
                          i += repeat;
                          coordinatesLength += repeat * xyLength;
                        }
                      }
                      if (coordinatesLength === 0) {
                        return glyphProfile;
                      }
                      var glyphDataLength = j + coordinatesLength;
                      if (glyphDataLength > glyf.length) {
                        return glyphProfile;
                      }
                      if (!hintsValid2 && instructionsLength > 0) {
                        dest.set(glyf.subarray(0, instructionsStart), destStart);
                        dest.set([0, 0], destStart + instructionsStart);
                        dest.set(glyf.subarray(instructionsEnd, glyphDataLength), destStart + instructionsStart + 2);
                        glyphDataLength -= instructionsLength;
                        if (glyf.length - glyphDataLength > 3) {
                          glyphDataLength = glyphDataLength + 3 & ~3;
                        }
                        glyphProfile.length = glyphDataLength;
                        return glyphProfile;
                      }
                      if (glyf.length - glyphDataLength > 3) {
                        glyphDataLength = glyphDataLength + 3 & ~3;
                        dest.set(glyf.subarray(0, glyphDataLength), destStart);
                        glyphProfile.length = glyphDataLength;
                        return glyphProfile;
                      }
                      dest.set(glyf, destStart);
                      glyphProfile.length = glyf.length;
                      return glyphProfile;
                    }
                    function sanitizeHead(head, numGlyphs2, locaLength) {
                      var data = head.data;
                      var version3 = int32(data[0], data[1], data[2], data[3]);
                      if (version3 >> 16 !== 1) {
                        (0, _util2.info)("Attempting to fix invalid version in head table: " + version3);
                        data[0] = 0;
                        data[1] = 1;
                        data[2] = 0;
                        data[3] = 0;
                      }
                      var indexToLocFormat = int16(data[50], data[51]);
                      if (indexToLocFormat < 0 || indexToLocFormat > 1) {
                        (0, _util2.info)("Attempting to fix invalid indexToLocFormat in head table: " + indexToLocFormat);
                        var numGlyphsPlusOne = numGlyphs2 + 1;
                        if (locaLength === numGlyphsPlusOne << 1) {
                          data[50] = 0;
                          data[51] = 0;
                        } else if (locaLength === numGlyphsPlusOne << 2) {
                          data[50] = 0;
                          data[51] = 1;
                        } else {
                          throw new _util2.FormatError("Could not fix indexToLocFormat: " + indexToLocFormat);
                        }
                      }
                    }
                    function sanitizeGlyphLocations(loca, glyf, numGlyphs2, isGlyphLocationsLong2, hintsValid2, dupFirstEntry2, maxSizeOfInstructions2) {
                      var itemSize, itemDecode, itemEncode;
                      if (isGlyphLocationsLong2) {
                        itemSize = 4;
                        itemDecode = function fontItemDecodeLong(data, offset) {
                          return data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3];
                        };
                        itemEncode = function fontItemEncodeLong(data, offset, value) {
                          data[offset] = value >>> 24 & 255;
                          data[offset + 1] = value >> 16 & 255;
                          data[offset + 2] = value >> 8 & 255;
                          data[offset + 3] = value & 255;
                        };
                      } else {
                        itemSize = 2;
                        itemDecode = function fontItemDecode(data, offset) {
                          return data[offset] << 9 | data[offset + 1] << 1;
                        };
                        itemEncode = function fontItemEncode(data, offset, value) {
                          data[offset] = value >> 9 & 255;
                          data[offset + 1] = value >> 1 & 255;
                        };
                      }
                      var numGlyphsOut2 = dupFirstEntry2 ? numGlyphs2 + 1 : numGlyphs2;
                      var locaDataSize = itemSize * (1 + numGlyphsOut2);
                      var locaData = new Uint8Array(locaDataSize);
                      locaData.set(loca.data.subarray(0, locaDataSize));
                      loca.data = locaData;
                      var oldGlyfData = glyf.data;
                      var oldGlyfDataLength = oldGlyfData.length;
                      var newGlyfData = new Uint8Array(oldGlyfDataLength);
                      var startOffset = itemDecode(locaData, 0);
                      var writeOffset = 0;
                      var missingGlyphs2 = /* @__PURE__ */ Object.create(null);
                      itemEncode(locaData, 0, writeOffset);
                      var i, j;
                      for (i = 0, j = itemSize; i < numGlyphs2; i++, j += itemSize) {
                        var endOffset = itemDecode(locaData, j);
                        if (endOffset === 0) {
                          endOffset = startOffset;
                        }
                        if (endOffset > oldGlyfDataLength && (oldGlyfDataLength + 3 & ~3) === endOffset) {
                          endOffset = oldGlyfDataLength;
                        }
                        if (endOffset > oldGlyfDataLength) {
                          startOffset = endOffset;
                        }
                        var glyphProfile = sanitizeGlyph(oldGlyfData, startOffset, endOffset, newGlyfData, writeOffset, hintsValid2);
                        var newLength = glyphProfile.length;
                        if (newLength === 0) {
                          missingGlyphs2[i] = true;
                        }
                        if (glyphProfile.sizeOfInstructions > maxSizeOfInstructions2) {
                          maxSizeOfInstructions2 = glyphProfile.sizeOfInstructions;
                        }
                        writeOffset += newLength;
                        itemEncode(locaData, j, writeOffset);
                        startOffset = endOffset;
                      }
                      if (writeOffset === 0) {
                        var simpleGlyph = new Uint8Array([0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 49, 0]);
                        for (i = 0, j = itemSize; i < numGlyphsOut2; i++, j += itemSize) {
                          itemEncode(locaData, j, simpleGlyph.length);
                        }
                        glyf.data = simpleGlyph;
                      } else if (dupFirstEntry2) {
                        var firstEntryLength = itemDecode(locaData, itemSize);
                        if (newGlyfData.length > firstEntryLength + writeOffset) {
                          glyf.data = newGlyfData.subarray(0, firstEntryLength + writeOffset);
                        } else {
                          glyf.data = new Uint8Array(firstEntryLength + writeOffset);
                          glyf.data.set(newGlyfData.subarray(0, writeOffset));
                        }
                        glyf.data.set(newGlyfData.subarray(0, firstEntryLength), writeOffset);
                        itemEncode(loca.data, locaData.length - itemSize, writeOffset + firstEntryLength);
                      } else {
                        glyf.data = newGlyfData.subarray(0, writeOffset);
                      }
                      return { missingGlyphs: missingGlyphs2, maxSizeOfInstructions: maxSizeOfInstructions2 };
                    }
                    function readPostScriptTable(post, properties2, maxpNumGlyphs) {
                      var start = (font.start ? font.start : 0) + post.offset;
                      font.pos = start;
                      var length = post.length, end = start + length;
                      var version3 = font.getInt32();
                      font.getBytes(28);
                      var glyphNames;
                      var valid = true;
                      var i;
                      switch (version3) {
                        case 65536:
                          glyphNames = MacStandardGlyphOrdering;
                          break;
                        case 131072:
                          var numGlyphs2 = font.getUint16();
                          if (numGlyphs2 !== maxpNumGlyphs) {
                            valid = false;
                            break;
                          }
                          var glyphNameIndexes = [];
                          for (i = 0; i < numGlyphs2; ++i) {
                            var index = font.getUint16();
                            if (index >= 32768) {
                              valid = false;
                              break;
                            }
                            glyphNameIndexes.push(index);
                          }
                          if (!valid) {
                            break;
                          }
                          var customNames = [];
                          var strBuf = [];
                          while (font.pos < end) {
                            var stringLength = font.getByte();
                            strBuf.length = stringLength;
                            for (i = 0; i < stringLength; ++i) {
                              strBuf[i] = String.fromCharCode(font.getByte());
                            }
                            customNames.push(strBuf.join(""));
                          }
                          glyphNames = [];
                          for (i = 0; i < numGlyphs2; ++i) {
                            var j = glyphNameIndexes[i];
                            if (j < 258) {
                              glyphNames.push(MacStandardGlyphOrdering[j]);
                              continue;
                            }
                            glyphNames.push(customNames[j - 258]);
                          }
                          break;
                        case 196608:
                          break;
                        default:
                          (0, _util2.warn)("Unknown/unsupported post table version " + version3);
                          valid = false;
                          if (properties2.defaultEncoding) {
                            glyphNames = properties2.defaultEncoding;
                          }
                          break;
                      }
                      properties2.glyphNames = glyphNames;
                      return valid;
                    }
                    function readNameTable(nameTable) {
                      var start = (font.start ? font.start : 0) + nameTable.offset;
                      font.pos = start;
                      var names = [[], []];
                      var length = nameTable.length, end = start + length;
                      var format = font.getUint16();
                      var FORMAT_0_HEADER_LENGTH = 6;
                      if (format !== 0 || length < FORMAT_0_HEADER_LENGTH) {
                        return names;
                      }
                      var numRecords = font.getUint16();
                      var stringsStart = font.getUint16();
                      var records = [];
                      var NAME_RECORD_LENGTH = 12;
                      var i, ii;
                      for (i = 0; i < numRecords && font.pos + NAME_RECORD_LENGTH <= end; i++) {
                        var r = { platform: font.getUint16(), encoding: font.getUint16(), language: font.getUint16(), name: font.getUint16(), length: font.getUint16(), offset: font.getUint16() };
                        if (r.platform === 1 && r.encoding === 0 && r.language === 0 || r.platform === 3 && r.encoding === 1 && r.language === 1033) {
                          records.push(r);
                        }
                      }
                      for (i = 0, ii = records.length; i < ii; i++) {
                        var record = records[i];
                        if (record.length <= 0) {
                          continue;
                        }
                        var pos = start + stringsStart + record.offset;
                        if (pos + record.length > end) {
                          continue;
                        }
                        font.pos = pos;
                        var nameIndex = record.name;
                        if (record.encoding) {
                          var str = "";
                          for (var j = 0, jj = record.length; j < jj; j += 2) {
                            str += String.fromCharCode(font.getUint16());
                          }
                          names[1][nameIndex] = str;
                        } else {
                          names[0][nameIndex] = (0, _util2.bytesToString)(font.getBytes(record.length));
                        }
                      }
                      return names;
                    }
                    var TTOpsStackDeltas = [0, 0, 0, 0, 0, 0, 0, 0, -2, -2, -2, -2, 0, 0, -2, -5, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, -1, -1, 1, -1, -999, 0, 1, 0, -1, -2, 0, -1, -2, -1, -1, 0, -1, -1, 0, 0, -999, -999, -1, -1, -1, -1, -2, -999, -2, -2, -999, 0, -2, -2, 0, 0, -2, 0, -2, 0, 0, 0, -2, -1, -1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, 0, -999, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, -999, -999, -999, -999, -999, -1, -1, -2, -2, 0, 0, 0, 0, -1, -1, -999, -2, -2, 0, 0, -1, -2, -2, 0, 0, 0, -1, -1, -1, -2];
                    function sanitizeTTProgram(table, ttContext) {
                      var data = table.data;
                      var i = 0, j, n, b, funcId, pc, lastEndf = 0, lastDeff = 0;
                      var stack = [];
                      var callstack = [];
                      var functionsCalled = [];
                      var tooComplexToFollowFunctions = ttContext.tooComplexToFollowFunctions;
                      var inFDEF = false, ifLevel = 0, inELSE = 0;
                      for (var ii = data.length; i < ii; ) {
                        var op = data[i++];
                        if (op === 64) {
                          n = data[i++];
                          if (inFDEF || inELSE) {
                            i += n;
                          } else {
                            for (j = 0; j < n; j++) {
                              stack.push(data[i++]);
                            }
                          }
                        } else if (op === 65) {
                          n = data[i++];
                          if (inFDEF || inELSE) {
                            i += n * 2;
                          } else {
                            for (j = 0; j < n; j++) {
                              b = data[i++];
                              stack.push(b << 8 | data[i++]);
                            }
                          }
                        } else if ((op & 248) === 176) {
                          n = op - 176 + 1;
                          if (inFDEF || inELSE) {
                            i += n;
                          } else {
                            for (j = 0; j < n; j++) {
                              stack.push(data[i++]);
                            }
                          }
                        } else if ((op & 248) === 184) {
                          n = op - 184 + 1;
                          if (inFDEF || inELSE) {
                            i += n * 2;
                          } else {
                            for (j = 0; j < n; j++) {
                              b = data[i++];
                              stack.push(b << 8 | data[i++]);
                            }
                          }
                        } else if (op === 43 && !tooComplexToFollowFunctions) {
                          if (!inFDEF && !inELSE) {
                            funcId = stack[stack.length - 1];
                            if (isNaN(funcId)) {
                              (0, _util2.info)("TT: CALL empty stack (or invalid entry).");
                            } else {
                              ttContext.functionsUsed[funcId] = true;
                              if (funcId in ttContext.functionsStackDeltas) {
                                const newStackLength = stack.length + ttContext.functionsStackDeltas[funcId];
                                if (newStackLength < 0) {
                                  (0, _util2.warn)("TT: CALL invalid functions stack delta.");
                                  ttContext.hintsValid = false;
                                  return;
                                }
                                stack.length = newStackLength;
                              } else if (funcId in ttContext.functionsDefined && !functionsCalled.includes(funcId)) {
                                callstack.push({ data, i, stackTop: stack.length - 1 });
                                functionsCalled.push(funcId);
                                pc = ttContext.functionsDefined[funcId];
                                if (!pc) {
                                  (0, _util2.warn)("TT: CALL non-existent function");
                                  ttContext.hintsValid = false;
                                  return;
                                }
                                data = pc.data;
                                i = pc.i;
                              }
                            }
                          }
                        } else if (op === 44 && !tooComplexToFollowFunctions) {
                          if (inFDEF || inELSE) {
                            (0, _util2.warn)("TT: nested FDEFs not allowed");
                            tooComplexToFollowFunctions = true;
                          }
                          inFDEF = true;
                          lastDeff = i;
                          funcId = stack.pop();
                          ttContext.functionsDefined[funcId] = { data, i };
                        } else if (op === 45) {
                          if (inFDEF) {
                            inFDEF = false;
                            lastEndf = i;
                          } else {
                            pc = callstack.pop();
                            if (!pc) {
                              (0, _util2.warn)("TT: ENDF bad stack");
                              ttContext.hintsValid = false;
                              return;
                            }
                            funcId = functionsCalled.pop();
                            data = pc.data;
                            i = pc.i;
                            ttContext.functionsStackDeltas[funcId] = stack.length - pc.stackTop;
                          }
                        } else if (op === 137) {
                          if (inFDEF || inELSE) {
                            (0, _util2.warn)("TT: nested IDEFs not allowed");
                            tooComplexToFollowFunctions = true;
                          }
                          inFDEF = true;
                          lastDeff = i;
                        } else if (op === 88) {
                          ++ifLevel;
                        } else if (op === 27) {
                          inELSE = ifLevel;
                        } else if (op === 89) {
                          if (inELSE === ifLevel) {
                            inELSE = 0;
                          }
                          --ifLevel;
                        } else if (op === 28) {
                          if (!inFDEF && !inELSE) {
                            var offset = stack[stack.length - 1];
                            if (offset > 0) {
                              i += offset - 1;
                            }
                          }
                        }
                        if (!inFDEF && !inELSE) {
                          let stackDelta = 0;
                          if (op <= 142) {
                            stackDelta = TTOpsStackDeltas[op];
                          } else if (op >= 192 && op <= 223) {
                            stackDelta = -1;
                          } else if (op >= 224) {
                            stackDelta = -2;
                          }
                          if (op >= 113 && op <= 117) {
                            n = stack.pop();
                            if (!isNaN(n)) {
                              stackDelta = -n * 2;
                            }
                          }
                          while (stackDelta < 0 && stack.length > 0) {
                            stack.pop();
                            stackDelta++;
                          }
                          while (stackDelta > 0) {
                            stack.push(NaN);
                            stackDelta--;
                          }
                        }
                      }
                      ttContext.tooComplexToFollowFunctions = tooComplexToFollowFunctions;
                      var content = [data];
                      if (i > data.length) {
                        content.push(new Uint8Array(i - data.length));
                      }
                      if (lastDeff > lastEndf) {
                        (0, _util2.warn)("TT: complementing a missing function tail");
                        content.push(new Uint8Array([34, 45]));
                      }
                      foldTTTable(table, content);
                    }
                    function checkInvalidFunctions(ttContext, maxFunctionDefs2) {
                      if (ttContext.tooComplexToFollowFunctions) {
                        return;
                      }
                      if (ttContext.functionsDefined.length > maxFunctionDefs2) {
                        (0, _util2.warn)("TT: more functions defined than expected");
                        ttContext.hintsValid = false;
                        return;
                      }
                      for (var j = 0, jj = ttContext.functionsUsed.length; j < jj; j++) {
                        if (j > maxFunctionDefs2) {
                          (0, _util2.warn)("TT: invalid function id: " + j);
                          ttContext.hintsValid = false;
                          return;
                        }
                        if (ttContext.functionsUsed[j] && !ttContext.functionsDefined[j]) {
                          (0, _util2.warn)("TT: undefined function: " + j);
                          ttContext.hintsValid = false;
                          return;
                        }
                      }
                    }
                    function foldTTTable(table, content) {
                      if (content.length > 1) {
                        var newLength = 0;
                        var j, jj;
                        for (j = 0, jj = content.length; j < jj; j++) {
                          newLength += content[j].length;
                        }
                        newLength = newLength + 3 & ~3;
                        var result = new Uint8Array(newLength);
                        var pos = 0;
                        for (j = 0, jj = content.length; j < jj; j++) {
                          result.set(content[j], pos);
                          pos += content[j].length;
                        }
                        table.data = result;
                        table.length = newLength;
                      }
                    }
                    function sanitizeTTPrograms(fpgm, prep, cvt, maxFunctionDefs2) {
                      var ttContext = { functionsDefined: [], functionsUsed: [], functionsStackDeltas: [], tooComplexToFollowFunctions: false, hintsValid: true };
                      if (fpgm) {
                        sanitizeTTProgram(fpgm, ttContext);
                      }
                      if (prep) {
                        sanitizeTTProgram(prep, ttContext);
                      }
                      if (fpgm) {
                        checkInvalidFunctions(ttContext, maxFunctionDefs2);
                      }
                      if (cvt && cvt.length & 1) {
                        var cvtData = new Uint8Array(cvt.length + 1);
                        cvtData.set(cvt.data);
                        cvt.data = cvtData;
                      }
                      return ttContext.hintsValid;
                    }
                    font = new _stream.Stream(new Uint8Array(font.getBytes()));
                    let header, tables;
                    if (isTrueTypeCollectionFile(font)) {
                      const ttcData = readTrueTypeCollectionData(font, this.name);
                      header = ttcData.header;
                      tables = ttcData.tables;
                    } else {
                      header = readOpenTypeHeader(font);
                      tables = readTables(font, header.numTables);
                    }
                    let cff, cffFile;
                    var isTrueType = !tables["CFF "];
                    if (!isTrueType) {
                      const isComposite = properties.composite && ((properties.cidToGidMap || []).length > 0 || !(properties.cMap instanceof _cmap.IdentityCMap));
                      if (header.version === "OTTO" && !isComposite || !tables["head"] || !tables["hhea"] || !tables["maxp"] || !tables["post"]) {
                        cffFile = new _stream.Stream(tables["CFF "].data);
                        cff = new CFFFont(cffFile, properties);
                        adjustWidths(properties);
                        return this.convert(name, cff, properties);
                      }
                      delete tables["glyf"];
                      delete tables["loca"];
                      delete tables["fpgm"];
                      delete tables["prep"];
                      delete tables["cvt "];
                      this.isOpenType = true;
                    } else {
                      if (!tables["loca"]) {
                        throw new _util2.FormatError('Required "loca" table is not found');
                      }
                      if (!tables["glyf"]) {
                        (0, _util2.warn)('Required "glyf" table is not found -- trying to recover.');
                        tables["glyf"] = { tag: "glyf", data: new Uint8Array(0) };
                      }
                      this.isOpenType = false;
                    }
                    if (!tables["maxp"]) {
                      throw new _util2.FormatError('Required "maxp" table is not found');
                    }
                    font.pos = (font.start || 0) + tables["maxp"].offset;
                    var version2 = font.getInt32();
                    const numGlyphs = font.getUint16();
                    let numGlyphsOut = numGlyphs + 1;
                    let dupFirstEntry = true;
                    if (numGlyphsOut > 65535) {
                      dupFirstEntry = false;
                      numGlyphsOut = numGlyphs;
                      (0, _util2.warn)("Not enough space in glyfs to duplicate first glyph.");
                    }
                    var maxFunctionDefs = 0;
                    var maxSizeOfInstructions = 0;
                    if (version2 >= 65536 && tables["maxp"].length >= 22) {
                      font.pos += 8;
                      var maxZones = font.getUint16();
                      if (maxZones > 2) {
                        tables["maxp"].data[14] = 0;
                        tables["maxp"].data[15] = 2;
                      }
                      font.pos += 4;
                      maxFunctionDefs = font.getUint16();
                      font.pos += 4;
                      maxSizeOfInstructions = font.getUint16();
                    }
                    tables["maxp"].data[4] = numGlyphsOut >> 8;
                    tables["maxp"].data[5] = numGlyphsOut & 255;
                    var hintsValid = sanitizeTTPrograms(tables["fpgm"], tables["prep"], tables["cvt "], maxFunctionDefs);
                    if (!hintsValid) {
                      delete tables["fpgm"];
                      delete tables["prep"];
                      delete tables["cvt "];
                    }
                    sanitizeMetrics(font, tables["hhea"], tables["hmtx"], numGlyphsOut, dupFirstEntry);
                    if (!tables["head"]) {
                      throw new _util2.FormatError('Required "head" table is not found');
                    }
                    sanitizeHead(tables["head"], numGlyphs, isTrueType ? tables["loca"].length : 0);
                    var missingGlyphs = /* @__PURE__ */ Object.create(null);
                    if (isTrueType) {
                      var isGlyphLocationsLong = int16(tables["head"].data[50], tables["head"].data[51]);
                      var glyphsInfo = sanitizeGlyphLocations(tables["loca"], tables["glyf"], numGlyphs, isGlyphLocationsLong, hintsValid, dupFirstEntry, maxSizeOfInstructions);
                      missingGlyphs = glyphsInfo.missingGlyphs;
                      if (version2 >= 65536 && tables["maxp"].length >= 22) {
                        tables["maxp"].data[26] = glyphsInfo.maxSizeOfInstructions >> 8;
                        tables["maxp"].data[27] = glyphsInfo.maxSizeOfInstructions & 255;
                      }
                    }
                    if (!tables["hhea"]) {
                      throw new _util2.FormatError('Required "hhea" table is not found');
                    }
                    if (tables["hhea"].data[10] === 0 && tables["hhea"].data[11] === 0) {
                      tables["hhea"].data[10] = 255;
                      tables["hhea"].data[11] = 255;
                    }
                    var metricsOverride = { unitsPerEm: int16(tables["head"].data[18], tables["head"].data[19]), yMax: int16(tables["head"].data[42], tables["head"].data[43]), yMin: signedInt16(tables["head"].data[38], tables["head"].data[39]), ascent: int16(tables["hhea"].data[4], tables["hhea"].data[5]), descent: signedInt16(tables["hhea"].data[6], tables["hhea"].data[7]) };
                    this.ascent = metricsOverride.ascent / metricsOverride.unitsPerEm;
                    this.descent = metricsOverride.descent / metricsOverride.unitsPerEm;
                    if (tables["post"]) {
                      readPostScriptTable(tables["post"], properties, numGlyphs);
                    }
                    tables["post"] = { tag: "post", data: createPostTable(properties) };
                    var charCodeToGlyphId = [], charCode;
                    function hasGlyph(glyphId2) {
                      return !missingGlyphs[glyphId2];
                    }
                    if (properties.composite) {
                      var cidToGidMap = properties.cidToGidMap || [];
                      var isCidToGidMapEmpty = cidToGidMap.length === 0;
                      properties.cMap.forEach(function(charCode2, cid) {
                        if (cid > 65535) {
                          throw new _util2.FormatError("Max size of CID is 65,535");
                        }
                        var glyphId2 = -1;
                        if (isCidToGidMapEmpty) {
                          glyphId2 = cid;
                        } else if (cidToGidMap[cid] !== void 0) {
                          glyphId2 = cidToGidMap[cid];
                        }
                        if (glyphId2 >= 0 && glyphId2 < numGlyphs && hasGlyph(glyphId2)) {
                          charCodeToGlyphId[charCode2] = glyphId2;
                        }
                      });
                    } else {
                      var cmapTable = readCmapTable(tables["cmap"], font, this.isSymbolicFont, properties.hasEncoding);
                      var cmapPlatformId = cmapTable.platformId;
                      var cmapEncodingId = cmapTable.encodingId;
                      var cmapMappings = cmapTable.mappings;
                      var cmapMappingsLength = cmapMappings.length;
                      if (properties.hasEncoding && (cmapPlatformId === 3 && cmapEncodingId === 1 || cmapPlatformId === 1 && cmapEncodingId === 0) || cmapPlatformId === -1 && cmapEncodingId === -1 && !!(0, _encodings.getEncoding)(properties.baseEncodingName)) {
                        var baseEncoding = [];
                        if (properties.baseEncodingName === "MacRomanEncoding" || properties.baseEncodingName === "WinAnsiEncoding") {
                          baseEncoding = (0, _encodings.getEncoding)(properties.baseEncodingName);
                        }
                        var glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();
                        for (charCode = 0; charCode < 256; charCode++) {
                          var glyphName, standardGlyphName;
                          if (this.differences && charCode in this.differences) {
                            glyphName = this.differences[charCode];
                          } else if (charCode in baseEncoding && baseEncoding[charCode] !== "") {
                            glyphName = baseEncoding[charCode];
                          } else {
                            glyphName = _encodings.StandardEncoding[charCode];
                          }
                          if (!glyphName) {
                            continue;
                          }
                          standardGlyphName = recoverGlyphName(glyphName, glyphsUnicodeMap);
                          var unicodeOrCharCode;
                          if (cmapPlatformId === 3 && cmapEncodingId === 1) {
                            unicodeOrCharCode = glyphsUnicodeMap[standardGlyphName];
                          } else if (cmapPlatformId === 1 && cmapEncodingId === 0) {
                            unicodeOrCharCode = _encodings.MacRomanEncoding.indexOf(standardGlyphName);
                          }
                          var found = false;
                          for (let i = 0; i < cmapMappingsLength; ++i) {
                            if (cmapMappings[i].charCode !== unicodeOrCharCode) {
                              continue;
                            }
                            charCodeToGlyphId[charCode] = cmapMappings[i].glyphId;
                            found = true;
                            break;
                          }
                          if (!found && properties.glyphNames) {
                            var glyphId = properties.glyphNames.indexOf(glyphName);
                            if (glyphId === -1 && standardGlyphName !== glyphName) {
                              glyphId = properties.glyphNames.indexOf(standardGlyphName);
                            }
                            if (glyphId > 0 && hasGlyph(glyphId)) {
                              charCodeToGlyphId[charCode] = glyphId;
                            }
                          }
                        }
                      } else if (cmapPlatformId === 0 && cmapEncodingId === 0) {
                        for (let i = 0; i < cmapMappingsLength; ++i) {
                          charCodeToGlyphId[cmapMappings[i].charCode] = cmapMappings[i].glyphId;
                        }
                      } else {
                        for (let i = 0; i < cmapMappingsLength; ++i) {
                          charCode = cmapMappings[i].charCode;
                          if (cmapPlatformId === 3 && charCode >= 61440 && charCode <= 61695) {
                            charCode &= 255;
                          }
                          charCodeToGlyphId[charCode] = cmapMappings[i].glyphId;
                        }
                      }
                    }
                    if (charCodeToGlyphId.length === 0) {
                      charCodeToGlyphId[0] = 0;
                    }
                    let glyphZeroId = numGlyphsOut - 1;
                    if (!dupFirstEntry) {
                      glyphZeroId = 0;
                    }
                    var newMapping = adjustMapping(charCodeToGlyphId, hasGlyph, glyphZeroId);
                    this.toFontChar = newMapping.toFontChar;
                    tables["cmap"] = { tag: "cmap", data: createCmapTable(newMapping.charCodeToGlyphId, numGlyphsOut) };
                    if (!tables["OS/2"] || !validateOS2Table(tables["OS/2"])) {
                      tables["OS/2"] = { tag: "OS/2", data: createOS2Table(properties, newMapping.charCodeToGlyphId, metricsOverride) };
                    }
                    if (!isTrueType) {
                      try {
                        cffFile = new _stream.Stream(tables["CFF "].data);
                        var parser = new _cff_parser.CFFParser(cffFile, properties, SEAC_ANALYSIS_ENABLED);
                        cff = parser.parse();
                        cff.duplicateFirstGlyph();
                        var compiler = new _cff_parser.CFFCompiler(cff);
                        tables["CFF "].data = compiler.compile();
                      } catch (e) {
                        (0, _util2.warn)("Failed to compile font " + properties.loadedName);
                      }
                    }
                    if (!tables["name"]) {
                      tables["name"] = { tag: "name", data: createNameTable(this.name) };
                    } else {
                      var namePrototype = readNameTable(tables["name"]);
                      tables["name"].data = createNameTable(name, namePrototype);
                    }
                    var builder = new OpenTypeFileBuilder(header.version);
                    for (var tableTag in tables) {
                      builder.addTable(tableTag, tables[tableTag].data);
                    }
                    return builder.toArray();
                  }, convert: function Font_convert(fontName, font, properties) {
                    properties.fixedPitch = false;
                    if (properties.builtInEncoding) {
                      adjustToUnicode(properties, properties.builtInEncoding);
                    }
                    let glyphZeroId = 1;
                    if (font instanceof CFFFont) {
                      glyphZeroId = font.numGlyphs - 1;
                    }
                    var mapping = font.getGlyphMapping(properties);
                    var newMapping = adjustMapping(mapping, font.hasGlyphId.bind(font), glyphZeroId);
                    this.toFontChar = newMapping.toFontChar;
                    var numGlyphs = font.numGlyphs;
                    function getCharCodes(charCodeToGlyphId2, glyphId2) {
                      var charCodes2 = null;
                      for (var charCode2 in charCodeToGlyphId2) {
                        if (glyphId2 === charCodeToGlyphId2[charCode2]) {
                          if (!charCodes2) {
                            charCodes2 = [];
                          }
                          charCodes2.push(charCode2 | 0);
                        }
                      }
                      return charCodes2;
                    }
                    function createCharCode(charCodeToGlyphId2, glyphId2) {
                      for (var charCode2 in charCodeToGlyphId2) {
                        if (glyphId2 === charCodeToGlyphId2[charCode2]) {
                          return charCode2 | 0;
                        }
                      }
                      newMapping.charCodeToGlyphId[newMapping.nextAvailableFontCharCode] = glyphId2;
                      return newMapping.nextAvailableFontCharCode++;
                    }
                    var seacs = font.seacs;
                    if (SEAC_ANALYSIS_ENABLED && seacs && seacs.length) {
                      var matrix = properties.fontMatrix || _util2.FONT_IDENTITY_MATRIX;
                      var charset = font.getCharset();
                      var seacMap = /* @__PURE__ */ Object.create(null);
                      for (var glyphId in seacs) {
                        glyphId |= 0;
                        var seac = seacs[glyphId];
                        var baseGlyphName = _encodings.StandardEncoding[seac[2]];
                        var accentGlyphName = _encodings.StandardEncoding[seac[3]];
                        var baseGlyphId = charset.indexOf(baseGlyphName);
                        var accentGlyphId = charset.indexOf(accentGlyphName);
                        if (baseGlyphId < 0 || accentGlyphId < 0) {
                          continue;
                        }
                        var accentOffset = { x: seac[0] * matrix[0] + seac[1] * matrix[2] + matrix[4], y: seac[0] * matrix[1] + seac[1] * matrix[3] + matrix[5] };
                        var charCodes = getCharCodes(mapping, glyphId);
                        if (!charCodes) {
                          continue;
                        }
                        for (var i = 0, ii = charCodes.length; i < ii; i++) {
                          var charCode = charCodes[i];
                          var charCodeToGlyphId = newMapping.charCodeToGlyphId;
                          var baseFontCharCode = createCharCode(charCodeToGlyphId, baseGlyphId);
                          var accentFontCharCode = createCharCode(charCodeToGlyphId, accentGlyphId);
                          seacMap[charCode] = { baseFontCharCode, accentFontCharCode, accentOffset };
                        }
                      }
                      properties.seacMap = seacMap;
                    }
                    var unitsPerEm = 1 / (properties.fontMatrix || _util2.FONT_IDENTITY_MATRIX)[0];
                    var builder = new OpenTypeFileBuilder("OTTO");
                    builder.addTable("CFF ", font.data);
                    builder.addTable("OS/2", createOS2Table(properties, newMapping.charCodeToGlyphId));
                    builder.addTable("cmap", createCmapTable(newMapping.charCodeToGlyphId, numGlyphs));
                    builder.addTable("head", "\0\0\0\0\0\0\0\0\0\0_<\xF5\0\0" + safeString16(unitsPerEm) + "\0\0\0\0\x9E\v~'\0\0\0\0\x9E\v~'\0\0" + safeString16(properties.descent) + "\xFF" + safeString16(properties.ascent) + string16(properties.italicAngle ? 2 : 0) + "\0\0\0\0\0\0\0");
                    builder.addTable("hhea", "\0\0\0" + safeString16(properties.ascent) + safeString16(properties.descent) + "\0\0\xFF\xFF\0\0\0\0\0\0" + safeString16(properties.capHeight) + safeString16(Math.tan(properties.italicAngle) * properties.xHeight) + "\0\0\0\0\0\0\0\0\0\0\0\0" + string16(numGlyphs));
                    builder.addTable("hmtx", function fontFieldsHmtx() {
                      var charstrings = font.charstrings;
                      var cffWidths = font.cff ? font.cff.widths : null;
                      var hmtx = "\0\0\0\0";
                      for (var i2 = 1, ii2 = numGlyphs; i2 < ii2; i2++) {
                        var width = 0;
                        if (charstrings) {
                          var charstring = charstrings[i2 - 1];
                          width = "width" in charstring ? charstring.width : 0;
                        } else if (cffWidths) {
                          width = Math.ceil(cffWidths[i2] || 0);
                        }
                        hmtx += string16(width) + string16(0);
                      }
                      return hmtx;
                    }());
                    builder.addTable("maxp", "\0\0P\0" + string16(numGlyphs));
                    builder.addTable("name", createNameTable(fontName));
                    builder.addTable("post", createPostTable(properties));
                    return builder.toArray();
                  }, get spaceWidth() {
                    if ("_shadowWidth" in this) {
                      return this._shadowWidth;
                    }
                    var possibleSpaceReplacements = ["space", "minus", "one", "i", "I"];
                    var width;
                    for (var i = 0, ii = possibleSpaceReplacements.length; i < ii; i++) {
                      var glyphName = possibleSpaceReplacements[i];
                      if (glyphName in this.widths) {
                        width = this.widths[glyphName];
                        break;
                      }
                      var glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();
                      var glyphUnicode = glyphsUnicodeMap[glyphName];
                      var charcode = 0;
                      if (this.composite) {
                        if (this.cMap.contains(glyphUnicode)) {
                          charcode = this.cMap.lookup(glyphUnicode);
                        }
                      }
                      if (!charcode && this.toUnicode) {
                        charcode = this.toUnicode.charCodeOf(glyphUnicode);
                      }
                      if (charcode <= 0) {
                        charcode = glyphUnicode;
                      }
                      width = this.widths[charcode];
                      if (width) {
                        break;
                      }
                    }
                    width = width || this.defaultWidth;
                    this._shadowWidth = width;
                    return width;
                  }, charToGlyph: function Font_charToGlyph(charcode, isSpace) {
                    var fontCharCode, width, operatorListId;
                    var widthCode = charcode;
                    if (this.cMap && this.cMap.contains(charcode)) {
                      widthCode = this.cMap.lookup(charcode);
                    }
                    width = this.widths[widthCode];
                    width = (0, _util2.isNum)(width) ? width : this.defaultWidth;
                    var vmetric = this.vmetrics && this.vmetrics[widthCode];
                    let unicode = this.toUnicode.get(charcode) || this.fallbackToUnicode.get(charcode) || charcode;
                    if (typeof unicode === "number") {
                      unicode = String.fromCharCode(unicode);
                    }
                    var isInFont = charcode in this.toFontChar;
                    fontCharCode = this.toFontChar[charcode] || charcode;
                    if (this.missingFile) {
                      const glyphName = this.differences[charcode] || this.defaultEncoding[charcode];
                      if ((glyphName === ".notdef" || glyphName === "") && this.type === "Type1") {
                        fontCharCode = 32;
                      }
                      fontCharCode = (0, _unicode.mapSpecialUnicodeValues)(fontCharCode);
                    }
                    if (this.isType3Font) {
                      operatorListId = fontCharCode;
                    }
                    var accent = null;
                    if (this.seacMap && this.seacMap[charcode]) {
                      isInFont = true;
                      var seac = this.seacMap[charcode];
                      fontCharCode = seac.baseFontCharCode;
                      accent = { fontChar: String.fromCodePoint(seac.accentFontCharCode), offset: seac.accentOffset };
                    }
                    var fontChar = typeof fontCharCode === "number" ? String.fromCodePoint(fontCharCode) : "";
                    var glyph = this.glyphCache[charcode];
                    if (!glyph || !glyph.matchesForCache(fontChar, unicode, accent, width, vmetric, operatorListId, isSpace, isInFont)) {
                      glyph = new Glyph(fontChar, unicode, accent, width, vmetric, operatorListId, isSpace, isInFont);
                      this.glyphCache[charcode] = glyph;
                    }
                    return glyph;
                  }, charsToGlyphs: function Font_charsToGlyphs(chars) {
                    var charsCache = this.charsCache;
                    var glyphs, glyph, charcode;
                    if (charsCache) {
                      glyphs = charsCache[chars];
                      if (glyphs) {
                        return glyphs;
                      }
                    }
                    if (!charsCache) {
                      charsCache = this.charsCache = /* @__PURE__ */ Object.create(null);
                    }
                    glyphs = [];
                    var charsCacheKey = chars;
                    var i = 0, ii;
                    if (this.cMap) {
                      var c = /* @__PURE__ */ Object.create(null);
                      while (i < chars.length) {
                        this.cMap.readCharCode(chars, i, c);
                        charcode = c.charcode;
                        var length = c.length;
                        i += length;
                        var isSpace = length === 1 && chars.charCodeAt(i - 1) === 32;
                        glyph = this.charToGlyph(charcode, isSpace);
                        glyphs.push(glyph);
                      }
                    } else {
                      for (i = 0, ii = chars.length; i < ii; ++i) {
                        charcode = chars.charCodeAt(i);
                        glyph = this.charToGlyph(charcode, charcode === 32);
                        glyphs.push(glyph);
                      }
                    }
                    return charsCache[charsCacheKey] = glyphs;
                  }, get glyphCacheValues() {
                    return Object.values(this.glyphCache);
                  } };
                  return Font2;
                }();
                exports2.Font = Font;
                var ErrorFont = function ErrorFontClosure() {
                  function ErrorFont2(error) {
                    this.error = error;
                    this.loadedName = "g_font_error";
                    this.missingFile = true;
                  }
                  ErrorFont2.prototype = { charsToGlyphs: function ErrorFont_charsToGlyphs() {
                    return [];
                  }, exportData: function ErrorFont_exportData() {
                    return { error: this.error };
                  } };
                  return ErrorFont2;
                }();
                exports2.ErrorFont = ErrorFont;
                function type1FontGlyphMapping(properties, builtInEncoding, glyphNames) {
                  var charCodeToGlyphId = /* @__PURE__ */ Object.create(null);
                  var glyphId, charCode, baseEncoding;
                  var isSymbolicFont = !!(properties.flags & FontFlags.Symbolic);
                  if (properties.baseEncodingName) {
                    baseEncoding = (0, _encodings.getEncoding)(properties.baseEncodingName);
                    for (charCode = 0; charCode < baseEncoding.length; charCode++) {
                      glyphId = glyphNames.indexOf(baseEncoding[charCode]);
                      if (glyphId >= 0) {
                        charCodeToGlyphId[charCode] = glyphId;
                      } else {
                        charCodeToGlyphId[charCode] = 0;
                      }
                    }
                  } else if (isSymbolicFont) {
                    for (charCode in builtInEncoding) {
                      charCodeToGlyphId[charCode] = builtInEncoding[charCode];
                    }
                  } else {
                    baseEncoding = _encodings.StandardEncoding;
                    for (charCode = 0; charCode < baseEncoding.length; charCode++) {
                      glyphId = glyphNames.indexOf(baseEncoding[charCode]);
                      if (glyphId >= 0) {
                        charCodeToGlyphId[charCode] = glyphId;
                      } else {
                        charCodeToGlyphId[charCode] = 0;
                      }
                    }
                  }
                  var differences = properties.differences, glyphsUnicodeMap;
                  if (differences) {
                    for (charCode in differences) {
                      var glyphName = differences[charCode];
                      glyphId = glyphNames.indexOf(glyphName);
                      if (glyphId === -1) {
                        if (!glyphsUnicodeMap) {
                          glyphsUnicodeMap = (0, _glyphlist.getGlyphsUnicode)();
                        }
                        var standardGlyphName = recoverGlyphName(glyphName, glyphsUnicodeMap);
                        if (standardGlyphName !== glyphName) {
                          glyphId = glyphNames.indexOf(standardGlyphName);
                        }
                      }
                      if (glyphId >= 0) {
                        charCodeToGlyphId[charCode] = glyphId;
                      } else {
                        charCodeToGlyphId[charCode] = 0;
                      }
                    }
                  }
                  return charCodeToGlyphId;
                }
                var Type1Font = function Type1FontClosure() {
                  function findBlock(streamBytes, signature, startIndex) {
                    var streamBytesLength = streamBytes.length;
                    var signatureLength = signature.length;
                    var scanLength = streamBytesLength - signatureLength;
                    var i = startIndex, j, found = false;
                    while (i < scanLength) {
                      j = 0;
                      while (j < signatureLength && streamBytes[i + j] === signature[j]) {
                        j++;
                      }
                      if (j >= signatureLength) {
                        i += j;
                        while (i < streamBytesLength && (0, _core_utils.isWhiteSpace)(streamBytes[i])) {
                          i++;
                        }
                        found = true;
                        break;
                      }
                      i++;
                    }
                    return { found, length: i };
                  }
                  function getHeaderBlock(stream, suggestedLength) {
                    var EEXEC_SIGNATURE = [101, 101, 120, 101, 99];
                    var streamStartPos = stream.pos;
                    var headerBytes, headerBytesLength, block;
                    try {
                      headerBytes = stream.getBytes(suggestedLength);
                      headerBytesLength = headerBytes.length;
                    } catch (ex) {
                      if (ex instanceof _core_utils.MissingDataException) {
                        throw ex;
                      }
                    }
                    if (headerBytesLength === suggestedLength) {
                      block = findBlock(headerBytes, EEXEC_SIGNATURE, suggestedLength - 2 * EEXEC_SIGNATURE.length);
                      if (block.found && block.length === suggestedLength) {
                        return { stream: new _stream.Stream(headerBytes), length: suggestedLength };
                      }
                    }
                    (0, _util2.warn)('Invalid "Length1" property in Type1 font -- trying to recover.');
                    stream.pos = streamStartPos;
                    var SCAN_BLOCK_LENGTH = 2048;
                    var actualLength;
                    while (true) {
                      var scanBytes = stream.peekBytes(SCAN_BLOCK_LENGTH);
                      block = findBlock(scanBytes, EEXEC_SIGNATURE, 0);
                      if (block.length === 0) {
                        break;
                      }
                      stream.pos += block.length;
                      if (block.found) {
                        actualLength = stream.pos - streamStartPos;
                        break;
                      }
                    }
                    stream.pos = streamStartPos;
                    if (actualLength) {
                      return { stream: new _stream.Stream(stream.getBytes(actualLength)), length: actualLength };
                    }
                    (0, _util2.warn)('Unable to recover "Length1" property in Type1 font -- using as is.');
                    return { stream: new _stream.Stream(stream.getBytes(suggestedLength)), length: suggestedLength };
                  }
                  function getEexecBlock(stream, suggestedLength) {
                    var eexecBytes = stream.getBytes();
                    return { stream: new _stream.Stream(eexecBytes), length: eexecBytes.length };
                  }
                  function Type1Font2(name, file, properties) {
                    var PFB_HEADER_SIZE = 6;
                    var headerBlockLength = properties.length1;
                    var eexecBlockLength = properties.length2;
                    var pfbHeader = file.peekBytes(PFB_HEADER_SIZE);
                    var pfbHeaderPresent = pfbHeader[0] === 128 && pfbHeader[1] === 1;
                    if (pfbHeaderPresent) {
                      file.skip(PFB_HEADER_SIZE);
                      headerBlockLength = pfbHeader[5] << 24 | pfbHeader[4] << 16 | pfbHeader[3] << 8 | pfbHeader[2];
                    }
                    var headerBlock = getHeaderBlock(file, headerBlockLength);
                    var headerBlockParser = new _type1_parser.Type1Parser(headerBlock.stream, false, SEAC_ANALYSIS_ENABLED);
                    headerBlockParser.extractFontHeader(properties);
                    if (pfbHeaderPresent) {
                      pfbHeader = file.getBytes(PFB_HEADER_SIZE);
                      eexecBlockLength = pfbHeader[5] << 24 | pfbHeader[4] << 16 | pfbHeader[3] << 8 | pfbHeader[2];
                    }
                    var eexecBlock = getEexecBlock(file, eexecBlockLength);
                    var eexecBlockParser = new _type1_parser.Type1Parser(eexecBlock.stream, true, SEAC_ANALYSIS_ENABLED);
                    var data = eexecBlockParser.extractFontProgram(properties);
                    for (var info in data.properties) {
                      properties[info] = data.properties[info];
                    }
                    var charstrings = data.charstrings;
                    var type2Charstrings = this.getType2Charstrings(charstrings);
                    var subrs = this.getType2Subrs(data.subrs);
                    this.charstrings = charstrings;
                    this.data = this.wrap(name, type2Charstrings, this.charstrings, subrs, properties);
                    this.seacs = this.getSeacs(data.charstrings);
                  }
                  Type1Font2.prototype = { get numGlyphs() {
                    return this.charstrings.length + 1;
                  }, getCharset: function Type1Font_getCharset() {
                    var charset = [".notdef"];
                    var charstrings = this.charstrings;
                    for (var glyphId = 0; glyphId < charstrings.length; glyphId++) {
                      charset.push(charstrings[glyphId].glyphName);
                    }
                    return charset;
                  }, getGlyphMapping: function Type1Font_getGlyphMapping(properties) {
                    var charstrings = this.charstrings;
                    var glyphNames = [".notdef"], glyphId;
                    for (glyphId = 0; glyphId < charstrings.length; glyphId++) {
                      glyphNames.push(charstrings[glyphId].glyphName);
                    }
                    var encoding = properties.builtInEncoding;
                    if (encoding) {
                      var builtInEncoding = /* @__PURE__ */ Object.create(null);
                      for (var charCode in encoding) {
                        glyphId = glyphNames.indexOf(encoding[charCode]);
                        if (glyphId >= 0) {
                          builtInEncoding[charCode] = glyphId;
                        }
                      }
                    }
                    return type1FontGlyphMapping(properties, builtInEncoding, glyphNames);
                  }, hasGlyphId: function Type1Font_hasGlyphID(id) {
                    if (id < 0 || id >= this.numGlyphs) {
                      return false;
                    }
                    if (id === 0) {
                      return true;
                    }
                    var glyph = this.charstrings[id - 1];
                    return glyph.charstring.length > 0;
                  }, getSeacs: function Type1Font_getSeacs(charstrings) {
                    var i, ii;
                    var seacMap = [];
                    for (i = 0, ii = charstrings.length; i < ii; i++) {
                      var charstring = charstrings[i];
                      if (charstring.seac) {
                        seacMap[i + 1] = charstring.seac;
                      }
                    }
                    return seacMap;
                  }, getType2Charstrings: function Type1Font_getType2Charstrings(type1Charstrings) {
                    var type2Charstrings = [];
                    for (var i = 0, ii = type1Charstrings.length; i < ii; i++) {
                      type2Charstrings.push(type1Charstrings[i].charstring);
                    }
                    return type2Charstrings;
                  }, getType2Subrs: function Type1Font_getType2Subrs(type1Subrs) {
                    var bias = 0;
                    var count = type1Subrs.length;
                    if (count < 1133) {
                      bias = 107;
                    } else if (count < 33769) {
                      bias = 1131;
                    } else {
                      bias = 32768;
                    }
                    var type2Subrs = [];
                    var i;
                    for (i = 0; i < bias; i++) {
                      type2Subrs.push([11]);
                    }
                    for (i = 0; i < count; i++) {
                      type2Subrs.push(type1Subrs[i]);
                    }
                    return type2Subrs;
                  }, wrap: function Type1Font_wrap(name, glyphs, charstrings, subrs, properties) {
                    var cff = new _cff_parser.CFF();
                    cff.header = new _cff_parser.CFFHeader(1, 0, 4, 4);
                    cff.names = [name];
                    var topDict = new _cff_parser.CFFTopDict();
                    topDict.setByName("version", 391);
                    topDict.setByName("Notice", 392);
                    topDict.setByName("FullName", 393);
                    topDict.setByName("FamilyName", 394);
                    topDict.setByName("Weight", 395);
                    topDict.setByName("Encoding", null);
                    topDict.setByName("FontMatrix", properties.fontMatrix);
                    topDict.setByName("FontBBox", properties.bbox);
                    topDict.setByName("charset", null);
                    topDict.setByName("CharStrings", null);
                    topDict.setByName("Private", null);
                    cff.topDict = topDict;
                    var strings = new _cff_parser.CFFStrings();
                    strings.add("Version 0.11");
                    strings.add("See original notice");
                    strings.add(name);
                    strings.add(name);
                    strings.add("Medium");
                    cff.strings = strings;
                    cff.globalSubrIndex = new _cff_parser.CFFIndex();
                    var count = glyphs.length;
                    var charsetArray = [".notdef"];
                    var i, ii;
                    for (i = 0; i < count; i++) {
                      const glyphName = charstrings[i].glyphName;
                      const index = _cff_parser.CFFStandardStrings.indexOf(glyphName);
                      if (index === -1) {
                        strings.add(glyphName);
                      }
                      charsetArray.push(glyphName);
                    }
                    cff.charset = new _cff_parser.CFFCharset(false, 0, charsetArray);
                    var charStringsIndex = new _cff_parser.CFFIndex();
                    charStringsIndex.add([139, 14]);
                    for (i = 0; i < count; i++) {
                      charStringsIndex.add(glyphs[i]);
                    }
                    cff.charStrings = charStringsIndex;
                    var privateDict = new _cff_parser.CFFPrivateDict();
                    privateDict.setByName("Subrs", null);
                    var fields = ["BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StemSnapH", "StemSnapV", "BlueShift", "BlueFuzz", "BlueScale", "LanguageGroup", "ExpansionFactor", "ForceBold", "StdHW", "StdVW"];
                    for (i = 0, ii = fields.length; i < ii; i++) {
                      var field = fields[i];
                      if (!(field in properties.privateData)) {
                        continue;
                      }
                      var value = properties.privateData[field];
                      if (Array.isArray(value)) {
                        for (var j = value.length - 1; j > 0; j--) {
                          value[j] -= value[j - 1];
                        }
                      }
                      privateDict.setByName(field, value);
                    }
                    cff.topDict.privateDict = privateDict;
                    var subrIndex = new _cff_parser.CFFIndex();
                    for (i = 0, ii = subrs.length; i < ii; i++) {
                      subrIndex.add(subrs[i]);
                    }
                    privateDict.subrsIndex = subrIndex;
                    var compiler = new _cff_parser.CFFCompiler(cff);
                    return compiler.compile();
                  } };
                  return Type1Font2;
                }();
                var CFFFont = function CFFFontClosure() {
                  function CFFFont2(file, properties) {
                    this.properties = properties;
                    var parser = new _cff_parser.CFFParser(file, properties, SEAC_ANALYSIS_ENABLED);
                    this.cff = parser.parse();
                    this.cff.duplicateFirstGlyph();
                    var compiler = new _cff_parser.CFFCompiler(this.cff);
                    this.seacs = this.cff.seacs;
                    try {
                      this.data = compiler.compile();
                    } catch (e) {
                      (0, _util2.warn)("Failed to compile font " + properties.loadedName);
                      this.data = file;
                    }
                  }
                  CFFFont2.prototype = { get numGlyphs() {
                    return this.cff.charStrings.count;
                  }, getCharset: function CFFFont_getCharset() {
                    return this.cff.charset.charset;
                  }, getGlyphMapping: function CFFFont_getGlyphMapping() {
                    var cff = this.cff;
                    var properties = this.properties;
                    var charsets = cff.charset.charset;
                    var charCodeToGlyphId;
                    var glyphId;
                    if (properties.composite) {
                      charCodeToGlyphId = /* @__PURE__ */ Object.create(null);
                      let charCode;
                      if (cff.isCIDFont) {
                        for (glyphId = 0; glyphId < charsets.length; glyphId++) {
                          var cid = charsets[glyphId];
                          charCode = properties.cMap.charCodeOf(cid);
                          charCodeToGlyphId[charCode] = glyphId;
                        }
                      } else {
                        for (glyphId = 0; glyphId < cff.charStrings.count; glyphId++) {
                          charCode = properties.cMap.charCodeOf(glyphId);
                          charCodeToGlyphId[charCode] = glyphId;
                        }
                      }
                      return charCodeToGlyphId;
                    }
                    var encoding = cff.encoding ? cff.encoding.encoding : null;
                    charCodeToGlyphId = type1FontGlyphMapping(properties, encoding, charsets);
                    return charCodeToGlyphId;
                  }, hasGlyphId: function CFFFont_hasGlyphID(id) {
                    return this.cff.hasGlyphId(id);
                  } };
                  return CFFFont2;
                }();
              }, function(module3, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.CFFFDSelect = exports2.CFFCompiler = exports2.CFFPrivateDict = exports2.CFFTopDict = exports2.CFFCharset = exports2.CFFIndex = exports2.CFFStrings = exports2.CFFHeader = exports2.CFF = exports2.CFFParser = exports2.CFFStandardStrings = void 0;
                var _util2 = __w_pdfjs_require__2(2);
                var _charsets = __w_pdfjs_require__2(29);
                var _encodings = __w_pdfjs_require__2(30);
                var MAX_SUBR_NESTING = 10;
                var CFFStandardStrings = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall", "001.000", "001.001", "001.002", "001.003", "Black", "Bold", "Book", "Light", "Medium", "Regular", "Roman", "Semibold"];
                exports2.CFFStandardStrings = CFFStandardStrings;
                const NUM_STANDARD_CFF_STRINGS = 391;
                var CFFParser = function CFFParserClosure() {
                  var CharstringValidationData = [null, { id: "hstem", min: 2, stackClearing: true, stem: true }, null, { id: "vstem", min: 2, stackClearing: true, stem: true }, { id: "vmoveto", min: 1, stackClearing: true }, { id: "rlineto", min: 2, resetStack: true }, { id: "hlineto", min: 1, resetStack: true }, { id: "vlineto", min: 1, resetStack: true }, { id: "rrcurveto", min: 6, resetStack: true }, null, { id: "callsubr", min: 1, undefStack: true }, { id: "return", min: 0, undefStack: true }, null, null, { id: "endchar", min: 0, stackClearing: true }, null, null, null, { id: "hstemhm", min: 2, stackClearing: true, stem: true }, { id: "hintmask", min: 0, stackClearing: true }, { id: "cntrmask", min: 0, stackClearing: true }, { id: "rmoveto", min: 2, stackClearing: true }, { id: "hmoveto", min: 1, stackClearing: true }, { id: "vstemhm", min: 2, stackClearing: true, stem: true }, { id: "rcurveline", min: 8, resetStack: true }, { id: "rlinecurve", min: 8, resetStack: true }, { id: "vvcurveto", min: 4, resetStack: true }, { id: "hhcurveto", min: 4, resetStack: true }, null, { id: "callgsubr", min: 1, undefStack: true }, { id: "vhcurveto", min: 4, resetStack: true }, { id: "hvcurveto", min: 4, resetStack: true }];
                  var CharstringValidationData12 = [null, null, null, { id: "and", min: 2, stackDelta: -1 }, { id: "or", min: 2, stackDelta: -1 }, { id: "not", min: 1, stackDelta: 0 }, null, null, null, { id: "abs", min: 1, stackDelta: 0 }, { id: "add", min: 2, stackDelta: -1, stackFn: function stack_div(stack, index) {
                    stack[index - 2] = stack[index - 2] + stack[index - 1];
                  } }, { id: "sub", min: 2, stackDelta: -1, stackFn: function stack_div(stack, index) {
                    stack[index - 2] = stack[index - 2] - stack[index - 1];
                  } }, { id: "div", min: 2, stackDelta: -1, stackFn: function stack_div(stack, index) {
                    stack[index - 2] = stack[index - 2] / stack[index - 1];
                  } }, null, { id: "neg", min: 1, stackDelta: 0, stackFn: function stack_div(stack, index) {
                    stack[index - 1] = -stack[index - 1];
                  } }, { id: "eq", min: 2, stackDelta: -1 }, null, null, { id: "drop", min: 1, stackDelta: -1 }, null, { id: "put", min: 2, stackDelta: -2 }, { id: "get", min: 1, stackDelta: 0 }, { id: "ifelse", min: 4, stackDelta: -3 }, { id: "random", min: 0, stackDelta: 1 }, { id: "mul", min: 2, stackDelta: -1, stackFn: function stack_div(stack, index) {
                    stack[index - 2] = stack[index - 2] * stack[index - 1];
                  } }, null, { id: "sqrt", min: 1, stackDelta: 0 }, { id: "dup", min: 1, stackDelta: 1 }, { id: "exch", min: 2, stackDelta: 0 }, { id: "index", min: 2, stackDelta: 0 }, { id: "roll", min: 3, stackDelta: -2 }, null, null, null, { id: "hflex", min: 7, resetStack: true }, { id: "flex", min: 13, resetStack: true }, { id: "hflex1", min: 9, resetStack: true }, { id: "flex1", min: 11, resetStack: true }];
                  function CFFParser2(file, properties, seacAnalysisEnabled) {
                    this.bytes = file.getBytes();
                    this.properties = properties;
                    this.seacAnalysisEnabled = !!seacAnalysisEnabled;
                  }
                  CFFParser2.prototype = { parse: function CFFParser_parse() {
                    var properties = this.properties;
                    var cff = new CFF();
                    this.cff = cff;
                    var header = this.parseHeader();
                    var nameIndex = this.parseIndex(header.endPos);
                    var topDictIndex = this.parseIndex(nameIndex.endPos);
                    var stringIndex = this.parseIndex(topDictIndex.endPos);
                    var globalSubrIndex = this.parseIndex(stringIndex.endPos);
                    var topDictParsed = this.parseDict(topDictIndex.obj.get(0));
                    var topDict = this.createDict(CFFTopDict, topDictParsed, cff.strings);
                    cff.header = header.obj;
                    cff.names = this.parseNameIndex(nameIndex.obj);
                    cff.strings = this.parseStringIndex(stringIndex.obj);
                    cff.topDict = topDict;
                    cff.globalSubrIndex = globalSubrIndex.obj;
                    this.parsePrivateDict(cff.topDict);
                    cff.isCIDFont = topDict.hasName("ROS");
                    var charStringOffset = topDict.getByName("CharStrings");
                    var charStringIndex = this.parseIndex(charStringOffset).obj;
                    var fontMatrix = topDict.getByName("FontMatrix");
                    if (fontMatrix) {
                      properties.fontMatrix = fontMatrix;
                    }
                    var fontBBox = topDict.getByName("FontBBox");
                    if (fontBBox) {
                      properties.ascent = Math.max(fontBBox[3], fontBBox[1]);
                      properties.descent = Math.min(fontBBox[1], fontBBox[3]);
                      properties.ascentScaled = true;
                    }
                    var charset, encoding;
                    if (cff.isCIDFont) {
                      var fdArrayIndex = this.parseIndex(topDict.getByName("FDArray")).obj;
                      for (var i = 0, ii = fdArrayIndex.count; i < ii; ++i) {
                        var dictRaw = fdArrayIndex.get(i);
                        var fontDict = this.createDict(CFFTopDict, this.parseDict(dictRaw), cff.strings);
                        this.parsePrivateDict(fontDict);
                        cff.fdArray.push(fontDict);
                      }
                      encoding = null;
                      charset = this.parseCharsets(topDict.getByName("charset"), charStringIndex.count, cff.strings, true);
                      cff.fdSelect = this.parseFDSelect(topDict.getByName("FDSelect"), charStringIndex.count);
                    } else {
                      charset = this.parseCharsets(topDict.getByName("charset"), charStringIndex.count, cff.strings, false);
                      encoding = this.parseEncoding(topDict.getByName("Encoding"), properties, cff.strings, charset.charset);
                    }
                    cff.charset = charset;
                    cff.encoding = encoding;
                    var charStringsAndSeacs = this.parseCharStrings({ charStrings: charStringIndex, localSubrIndex: topDict.privateDict.subrsIndex, globalSubrIndex: globalSubrIndex.obj, fdSelect: cff.fdSelect, fdArray: cff.fdArray, privateDict: topDict.privateDict });
                    cff.charStrings = charStringsAndSeacs.charStrings;
                    cff.seacs = charStringsAndSeacs.seacs;
                    cff.widths = charStringsAndSeacs.widths;
                    return cff;
                  }, parseHeader: function CFFParser_parseHeader() {
                    var bytes = this.bytes;
                    var bytesLength = bytes.length;
                    var offset = 0;
                    while (offset < bytesLength && bytes[offset] !== 1) {
                      ++offset;
                    }
                    if (offset >= bytesLength) {
                      throw new _util2.FormatError("Invalid CFF header");
                    }
                    if (offset !== 0) {
                      (0, _util2.info)("cff data is shifted");
                      bytes = bytes.subarray(offset);
                      this.bytes = bytes;
                    }
                    var major = bytes[0];
                    var minor = bytes[1];
                    var hdrSize = bytes[2];
                    var offSize = bytes[3];
                    var header = new CFFHeader(major, minor, hdrSize, offSize);
                    return { obj: header, endPos: hdrSize };
                  }, parseDict: function CFFParser_parseDict(dict) {
                    var pos = 0;
                    function parseOperand() {
                      var value = dict[pos++];
                      if (value === 30) {
                        return parseFloatOperand();
                      } else if (value === 28) {
                        value = dict[pos++];
                        value = (value << 24 | dict[pos++] << 16) >> 16;
                        return value;
                      } else if (value === 29) {
                        value = dict[pos++];
                        value = value << 8 | dict[pos++];
                        value = value << 8 | dict[pos++];
                        value = value << 8 | dict[pos++];
                        return value;
                      } else if (value >= 32 && value <= 246) {
                        return value - 139;
                      } else if (value >= 247 && value <= 250) {
                        return (value - 247) * 256 + dict[pos++] + 108;
                      } else if (value >= 251 && value <= 254) {
                        return -((value - 251) * 256) - dict[pos++] - 108;
                      }
                      (0, _util2.warn)('CFFParser_parseDict: "' + value + '" is a reserved command.');
                      return NaN;
                    }
                    function parseFloatOperand() {
                      var str = "";
                      var eof = 15;
                      const lookup = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "E", "E-", null, "-"];
                      var length = dict.length;
                      while (pos < length) {
                        var b2 = dict[pos++];
                        var b1 = b2 >> 4;
                        var b22 = b2 & 15;
                        if (b1 === eof) {
                          break;
                        }
                        str += lookup[b1];
                        if (b22 === eof) {
                          break;
                        }
                        str += lookup[b22];
                      }
                      return parseFloat(str);
                    }
                    var operands = [];
                    var entries = [];
                    pos = 0;
                    var end = dict.length;
                    while (pos < end) {
                      var b = dict[pos];
                      if (b <= 21) {
                        if (b === 12) {
                          b = b << 8 | dict[++pos];
                        }
                        entries.push([b, operands]);
                        operands = [];
                        ++pos;
                      } else {
                        operands.push(parseOperand());
                      }
                    }
                    return entries;
                  }, parseIndex: function CFFParser_parseIndex(pos) {
                    var cffIndex = new CFFIndex();
                    var bytes = this.bytes;
                    var count = bytes[pos++] << 8 | bytes[pos++];
                    var offsets = [];
                    var end = pos;
                    var i, ii;
                    if (count !== 0) {
                      var offsetSize = bytes[pos++];
                      var startPos = pos + (count + 1) * offsetSize - 1;
                      for (i = 0, ii = count + 1; i < ii; ++i) {
                        var offset = 0;
                        for (var j = 0; j < offsetSize; ++j) {
                          offset <<= 8;
                          offset += bytes[pos++];
                        }
                        offsets.push(startPos + offset);
                      }
                      end = offsets[count];
                    }
                    for (i = 0, ii = offsets.length - 1; i < ii; ++i) {
                      var offsetStart = offsets[i];
                      var offsetEnd = offsets[i + 1];
                      cffIndex.add(bytes.subarray(offsetStart, offsetEnd));
                    }
                    return { obj: cffIndex, endPos: end };
                  }, parseNameIndex: function CFFParser_parseNameIndex(index) {
                    var names = [];
                    for (var i = 0, ii = index.count; i < ii; ++i) {
                      var name = index.get(i);
                      names.push((0, _util2.bytesToString)(name));
                    }
                    return names;
                  }, parseStringIndex: function CFFParser_parseStringIndex(index) {
                    var strings = new CFFStrings();
                    for (var i = 0, ii = index.count; i < ii; ++i) {
                      var data = index.get(i);
                      strings.add((0, _util2.bytesToString)(data));
                    }
                    return strings;
                  }, createDict: function CFFParser_createDict(Type, dict, strings) {
                    var cffDict = new Type(strings);
                    for (var i = 0, ii = dict.length; i < ii; ++i) {
                      var pair = dict[i];
                      var key = pair[0];
                      var value = pair[1];
                      cffDict.setByKey(key, value);
                    }
                    return cffDict;
                  }, parseCharString: function CFFParser_parseCharString(state, data, localSubrIndex, globalSubrIndex) {
                    if (!data || state.callDepth > MAX_SUBR_NESTING) {
                      return false;
                    }
                    var stackSize = state.stackSize;
                    var stack = state.stack;
                    var length = data.length;
                    for (var j = 0; j < length; ) {
                      var value = data[j++];
                      var validationCommand = null;
                      if (value === 12) {
                        var q = data[j++];
                        if (q === 0) {
                          data[j - 2] = 139;
                          data[j - 1] = 22;
                          stackSize = 0;
                        } else {
                          validationCommand = CharstringValidationData12[q];
                        }
                      } else if (value === 28) {
                        stack[stackSize] = (data[j] << 24 | data[j + 1] << 16) >> 16;
                        j += 2;
                        stackSize++;
                      } else if (value === 14) {
                        if (stackSize >= 4) {
                          stackSize -= 4;
                          if (this.seacAnalysisEnabled) {
                            state.seac = stack.slice(stackSize, stackSize + 4);
                            return false;
                          }
                        }
                        validationCommand = CharstringValidationData[value];
                      } else if (value >= 32 && value <= 246) {
                        stack[stackSize] = value - 139;
                        stackSize++;
                      } else if (value >= 247 && value <= 254) {
                        stack[stackSize] = value < 251 ? (value - 247 << 8) + data[j] + 108 : -(value - 251 << 8) - data[j] - 108;
                        j++;
                        stackSize++;
                      } else if (value === 255) {
                        stack[stackSize] = (data[j] << 24 | data[j + 1] << 16 | data[j + 2] << 8 | data[j + 3]) / 65536;
                        j += 4;
                        stackSize++;
                      } else if (value === 19 || value === 20) {
                        state.hints += stackSize >> 1;
                        j += state.hints + 7 >> 3;
                        stackSize %= 2;
                        validationCommand = CharstringValidationData[value];
                      } else if (value === 10 || value === 29) {
                        var subrsIndex;
                        if (value === 10) {
                          subrsIndex = localSubrIndex;
                        } else {
                          subrsIndex = globalSubrIndex;
                        }
                        if (!subrsIndex) {
                          validationCommand = CharstringValidationData[value];
                          (0, _util2.warn)("Missing subrsIndex for " + validationCommand.id);
                          return false;
                        }
                        var bias = 32768;
                        if (subrsIndex.count < 1240) {
                          bias = 107;
                        } else if (subrsIndex.count < 33900) {
                          bias = 1131;
                        }
                        var subrNumber = stack[--stackSize] + bias;
                        if (subrNumber < 0 || subrNumber >= subrsIndex.count || isNaN(subrNumber)) {
                          validationCommand = CharstringValidationData[value];
                          (0, _util2.warn)("Out of bounds subrIndex for " + validationCommand.id);
                          return false;
                        }
                        state.stackSize = stackSize;
                        state.callDepth++;
                        var valid = this.parseCharString(state, subrsIndex.get(subrNumber), localSubrIndex, globalSubrIndex);
                        if (!valid) {
                          return false;
                        }
                        state.callDepth--;
                        stackSize = state.stackSize;
                        continue;
                      } else if (value === 11) {
                        state.stackSize = stackSize;
                        return true;
                      } else {
                        validationCommand = CharstringValidationData[value];
                      }
                      if (validationCommand) {
                        if (validationCommand.stem) {
                          state.hints += stackSize >> 1;
                          if (value === 3 || value === 23) {
                            state.hasVStems = true;
                          } else if (state.hasVStems && (value === 1 || value === 18)) {
                            (0, _util2.warn)("CFF stem hints are in wrong order");
                            data[j - 1] = value === 1 ? 3 : 23;
                          }
                        }
                        if ("min" in validationCommand) {
                          if (!state.undefStack && stackSize < validationCommand.min) {
                            (0, _util2.warn)("Not enough parameters for " + validationCommand.id + "; actual: " + stackSize + ", expected: " + validationCommand.min);
                            return false;
                          }
                        }
                        if (state.firstStackClearing && validationCommand.stackClearing) {
                          state.firstStackClearing = false;
                          stackSize -= validationCommand.min;
                          if (stackSize >= 2 && validationCommand.stem) {
                            stackSize %= 2;
                          } else if (stackSize > 1) {
                            (0, _util2.warn)("Found too many parameters for stack-clearing command");
                          }
                          if (stackSize > 0 && stack[stackSize - 1] >= 0) {
                            state.width = stack[stackSize - 1];
                          }
                        }
                        if ("stackDelta" in validationCommand) {
                          if ("stackFn" in validationCommand) {
                            validationCommand.stackFn(stack, stackSize);
                          }
                          stackSize += validationCommand.stackDelta;
                        } else if (validationCommand.stackClearing) {
                          stackSize = 0;
                        } else if (validationCommand.resetStack) {
                          stackSize = 0;
                          state.undefStack = false;
                        } else if (validationCommand.undefStack) {
                          stackSize = 0;
                          state.undefStack = true;
                          state.firstStackClearing = false;
                        }
                      }
                    }
                    state.stackSize = stackSize;
                    return true;
                  }, parseCharStrings({ charStrings, localSubrIndex, globalSubrIndex, fdSelect, fdArray, privateDict }) {
                    var seacs = [];
                    var widths = [];
                    var count = charStrings.count;
                    for (var i = 0; i < count; i++) {
                      var charstring = charStrings.get(i);
                      var state = { callDepth: 0, stackSize: 0, stack: [], undefStack: true, hints: 0, firstStackClearing: true, seac: null, width: null, hasVStems: false };
                      var valid = true;
                      var localSubrToUse = null;
                      var privateDictToUse = privateDict;
                      if (fdSelect && fdArray.length) {
                        var fdIndex = fdSelect.getFDIndex(i);
                        if (fdIndex === -1) {
                          (0, _util2.warn)("Glyph index is not in fd select.");
                          valid = false;
                        }
                        if (fdIndex >= fdArray.length) {
                          (0, _util2.warn)("Invalid fd index for glyph index.");
                          valid = false;
                        }
                        if (valid) {
                          privateDictToUse = fdArray[fdIndex].privateDict;
                          localSubrToUse = privateDictToUse.subrsIndex;
                        }
                      } else if (localSubrIndex) {
                        localSubrToUse = localSubrIndex;
                      }
                      if (valid) {
                        valid = this.parseCharString(state, charstring, localSubrToUse, globalSubrIndex);
                      }
                      if (state.width !== null) {
                        const nominalWidth = privateDictToUse.getByName("nominalWidthX");
                        widths[i] = nominalWidth + state.width;
                      } else {
                        const defaultWidth = privateDictToUse.getByName("defaultWidthX");
                        widths[i] = defaultWidth;
                      }
                      if (state.seac !== null) {
                        seacs[i] = state.seac;
                      }
                      if (!valid) {
                        charStrings.set(i, new Uint8Array([14]));
                      }
                    }
                    return { charStrings, seacs, widths };
                  }, emptyPrivateDictionary: function CFFParser_emptyPrivateDictionary(parentDict) {
                    var privateDict = this.createDict(CFFPrivateDict, [], parentDict.strings);
                    parentDict.setByKey(18, [0, 0]);
                    parentDict.privateDict = privateDict;
                  }, parsePrivateDict: function CFFParser_parsePrivateDict(parentDict) {
                    if (!parentDict.hasName("Private")) {
                      this.emptyPrivateDictionary(parentDict);
                      return;
                    }
                    var privateOffset = parentDict.getByName("Private");
                    if (!Array.isArray(privateOffset) || privateOffset.length !== 2) {
                      parentDict.removeByName("Private");
                      return;
                    }
                    var size = privateOffset[0];
                    var offset = privateOffset[1];
                    if (size === 0 || offset >= this.bytes.length) {
                      this.emptyPrivateDictionary(parentDict);
                      return;
                    }
                    var privateDictEnd = offset + size;
                    var dictData = this.bytes.subarray(offset, privateDictEnd);
                    var dict = this.parseDict(dictData);
                    var privateDict = this.createDict(CFFPrivateDict, dict, parentDict.strings);
                    parentDict.privateDict = privateDict;
                    if (!privateDict.getByName("Subrs")) {
                      return;
                    }
                    var subrsOffset = privateDict.getByName("Subrs");
                    var relativeOffset = offset + subrsOffset;
                    if (subrsOffset === 0 || relativeOffset >= this.bytes.length) {
                      this.emptyPrivateDictionary(parentDict);
                      return;
                    }
                    var subrsIndex = this.parseIndex(relativeOffset);
                    privateDict.subrsIndex = subrsIndex.obj;
                  }, parseCharsets: function CFFParser_parseCharsets(pos, length, strings, cid) {
                    if (pos === 0) {
                      return new CFFCharset(true, CFFCharsetPredefinedTypes.ISO_ADOBE, _charsets.ISOAdobeCharset);
                    } else if (pos === 1) {
                      return new CFFCharset(true, CFFCharsetPredefinedTypes.EXPERT, _charsets.ExpertCharset);
                    } else if (pos === 2) {
                      return new CFFCharset(true, CFFCharsetPredefinedTypes.EXPERT_SUBSET, _charsets.ExpertSubsetCharset);
                    }
                    var bytes = this.bytes;
                    var start = pos;
                    var format = bytes[pos++];
                    var charset = [".notdef"];
                    var id, count, i;
                    length -= 1;
                    switch (format) {
                      case 0:
                        for (i = 0; i < length; i++) {
                          id = bytes[pos++] << 8 | bytes[pos++];
                          charset.push(cid ? id : strings.get(id));
                        }
                        break;
                      case 1:
                        while (charset.length <= length) {
                          id = bytes[pos++] << 8 | bytes[pos++];
                          count = bytes[pos++];
                          for (i = 0; i <= count; i++) {
                            charset.push(cid ? id++ : strings.get(id++));
                          }
                        }
                        break;
                      case 2:
                        while (charset.length <= length) {
                          id = bytes[pos++] << 8 | bytes[pos++];
                          count = bytes[pos++] << 8 | bytes[pos++];
                          for (i = 0; i <= count; i++) {
                            charset.push(cid ? id++ : strings.get(id++));
                          }
                        }
                        break;
                      default:
                        throw new _util2.FormatError("Unknown charset format");
                    }
                    var end = pos;
                    var raw = bytes.subarray(start, end);
                    return new CFFCharset(false, format, charset, raw);
                  }, parseEncoding: function CFFParser_parseEncoding(pos, properties, strings, charset) {
                    var encoding = /* @__PURE__ */ Object.create(null);
                    var bytes = this.bytes;
                    var predefined = false;
                    var format, i, ii;
                    var raw = null;
                    function readSupplement() {
                      var supplementsCount = bytes[pos++];
                      for (i = 0; i < supplementsCount; i++) {
                        var code = bytes[pos++];
                        var sid = (bytes[pos++] << 8) + (bytes[pos++] & 255);
                        encoding[code] = charset.indexOf(strings.get(sid));
                      }
                    }
                    if (pos === 0 || pos === 1) {
                      predefined = true;
                      format = pos;
                      var baseEncoding = pos ? _encodings.ExpertEncoding : _encodings.StandardEncoding;
                      for (i = 0, ii = charset.length; i < ii; i++) {
                        var index = baseEncoding.indexOf(charset[i]);
                        if (index !== -1) {
                          encoding[index] = i;
                        }
                      }
                    } else {
                      var dataStart = pos;
                      format = bytes[pos++];
                      switch (format & 127) {
                        case 0:
                          var glyphsCount = bytes[pos++];
                          for (i = 1; i <= glyphsCount; i++) {
                            encoding[bytes[pos++]] = i;
                          }
                          break;
                        case 1:
                          var rangesCount = bytes[pos++];
                          var gid = 1;
                          for (i = 0; i < rangesCount; i++) {
                            var start = bytes[pos++];
                            var left = bytes[pos++];
                            for (var j = start; j <= start + left; j++) {
                              encoding[j] = gid++;
                            }
                          }
                          break;
                        default:
                          throw new _util2.FormatError(`Unknown encoding format: ${format} in CFF`);
                      }
                      var dataEnd = pos;
                      if (format & 128) {
                        bytes[dataStart] &= 127;
                        readSupplement();
                      }
                      raw = bytes.subarray(dataStart, dataEnd);
                    }
                    format = format & 127;
                    return new CFFEncoding(predefined, format, encoding, raw);
                  }, parseFDSelect: function CFFParser_parseFDSelect(pos, length) {
                    var bytes = this.bytes;
                    var format = bytes[pos++];
                    var fdSelect = [];
                    var i;
                    switch (format) {
                      case 0:
                        for (i = 0; i < length; ++i) {
                          var id = bytes[pos++];
                          fdSelect.push(id);
                        }
                        break;
                      case 3:
                        var rangesCount = bytes[pos++] << 8 | bytes[pos++];
                        for (i = 0; i < rangesCount; ++i) {
                          var first = bytes[pos++] << 8 | bytes[pos++];
                          if (i === 0 && first !== 0) {
                            (0, _util2.warn)("parseFDSelect: The first range must have a first GID of 0 -- trying to recover.");
                            first = 0;
                          }
                          var fdIndex = bytes[pos++];
                          var next = bytes[pos] << 8 | bytes[pos + 1];
                          for (var j = first; j < next; ++j) {
                            fdSelect.push(fdIndex);
                          }
                        }
                        pos += 2;
                        break;
                      default:
                        throw new _util2.FormatError(`parseFDSelect: Unknown format "${format}".`);
                    }
                    if (fdSelect.length !== length) {
                      throw new _util2.FormatError("parseFDSelect: Invalid font data.");
                    }
                    return new CFFFDSelect(format, fdSelect);
                  } };
                  return CFFParser2;
                }();
                exports2.CFFParser = CFFParser;
                var CFF = function CFFClosure() {
                  function CFF2() {
                    this.header = null;
                    this.names = [];
                    this.topDict = null;
                    this.strings = new CFFStrings();
                    this.globalSubrIndex = null;
                    this.encoding = null;
                    this.charset = null;
                    this.charStrings = null;
                    this.fdArray = [];
                    this.fdSelect = null;
                    this.isCIDFont = false;
                  }
                  CFF2.prototype = { duplicateFirstGlyph: function CFF_duplicateFirstGlyph() {
                    if (this.charStrings.count >= 65535) {
                      (0, _util2.warn)("Not enough space in charstrings to duplicate first glyph.");
                      return;
                    }
                    var glyphZero = this.charStrings.get(0);
                    this.charStrings.add(glyphZero);
                    if (this.isCIDFont) {
                      this.fdSelect.fdSelect.push(this.fdSelect.fdSelect[0]);
                    }
                  }, hasGlyphId: function CFF_hasGlyphID(id) {
                    if (id < 0 || id >= this.charStrings.count) {
                      return false;
                    }
                    var glyph = this.charStrings.get(id);
                    return glyph.length > 0;
                  } };
                  return CFF2;
                }();
                exports2.CFF = CFF;
                var CFFHeader = function CFFHeaderClosure() {
                  function CFFHeader2(major, minor, hdrSize, offSize) {
                    this.major = major;
                    this.minor = minor;
                    this.hdrSize = hdrSize;
                    this.offSize = offSize;
                  }
                  return CFFHeader2;
                }();
                exports2.CFFHeader = CFFHeader;
                var CFFStrings = function CFFStringsClosure() {
                  function CFFStrings2() {
                    this.strings = [];
                  }
                  CFFStrings2.prototype = { get: function CFFStrings_get(index) {
                    if (index >= 0 && index <= NUM_STANDARD_CFF_STRINGS - 1) {
                      return CFFStandardStrings[index];
                    }
                    if (index - NUM_STANDARD_CFF_STRINGS <= this.strings.length) {
                      return this.strings[index - NUM_STANDARD_CFF_STRINGS];
                    }
                    return CFFStandardStrings[0];
                  }, getSID: function CFFStrings_getSID(str) {
                    let index = CFFStandardStrings.indexOf(str);
                    if (index !== -1) {
                      return index;
                    }
                    index = this.strings.indexOf(str);
                    if (index !== -1) {
                      return index + NUM_STANDARD_CFF_STRINGS;
                    }
                    return -1;
                  }, add: function CFFStrings_add(value) {
                    this.strings.push(value);
                  }, get count() {
                    return this.strings.length;
                  } };
                  return CFFStrings2;
                }();
                exports2.CFFStrings = CFFStrings;
                var CFFIndex = function CFFIndexClosure() {
                  function CFFIndex2() {
                    this.objects = [];
                    this.length = 0;
                  }
                  CFFIndex2.prototype = { add: function CFFIndex_add(data) {
                    this.length += data.length;
                    this.objects.push(data);
                  }, set: function CFFIndex_set(index, data) {
                    this.length += data.length - this.objects[index].length;
                    this.objects[index] = data;
                  }, get: function CFFIndex_get(index) {
                    return this.objects[index];
                  }, get count() {
                    return this.objects.length;
                  } };
                  return CFFIndex2;
                }();
                exports2.CFFIndex = CFFIndex;
                var CFFDict = function CFFDictClosure() {
                  function CFFDict2(tables, strings) {
                    this.keyToNameMap = tables.keyToNameMap;
                    this.nameToKeyMap = tables.nameToKeyMap;
                    this.defaults = tables.defaults;
                    this.types = tables.types;
                    this.opcodes = tables.opcodes;
                    this.order = tables.order;
                    this.strings = strings;
                    this.values = /* @__PURE__ */ Object.create(null);
                  }
                  CFFDict2.prototype = { setByKey: function CFFDict_setByKey(key, value) {
                    if (!(key in this.keyToNameMap)) {
                      return false;
                    }
                    var valueLength = value.length;
                    if (valueLength === 0) {
                      return true;
                    }
                    for (var i = 0; i < valueLength; i++) {
                      if (isNaN(value[i])) {
                        (0, _util2.warn)('Invalid CFFDict value: "' + value + '" for key "' + key + '".');
                        return true;
                      }
                    }
                    var type = this.types[key];
                    if (type === "num" || type === "sid" || type === "offset") {
                      value = value[0];
                    }
                    this.values[key] = value;
                    return true;
                  }, setByName: function CFFDict_setByName(name, value) {
                    if (!(name in this.nameToKeyMap)) {
                      throw new _util2.FormatError(`Invalid dictionary name "${name}"`);
                    }
                    this.values[this.nameToKeyMap[name]] = value;
                  }, hasName: function CFFDict_hasName(name) {
                    return this.nameToKeyMap[name] in this.values;
                  }, getByName: function CFFDict_getByName(name) {
                    if (!(name in this.nameToKeyMap)) {
                      throw new _util2.FormatError(`Invalid dictionary name ${name}"`);
                    }
                    var key = this.nameToKeyMap[name];
                    if (!(key in this.values)) {
                      return this.defaults[key];
                    }
                    return this.values[key];
                  }, removeByName: function CFFDict_removeByName(name) {
                    delete this.values[this.nameToKeyMap[name]];
                  } };
                  CFFDict2.createTables = function CFFDict_createTables(layout) {
                    var tables = { keyToNameMap: {}, nameToKeyMap: {}, defaults: {}, types: {}, opcodes: {}, order: [] };
                    for (var i = 0, ii = layout.length; i < ii; ++i) {
                      var entry = layout[i];
                      var key = Array.isArray(entry[0]) ? (entry[0][0] << 8) + entry[0][1] : entry[0];
                      tables.keyToNameMap[key] = entry[1];
                      tables.nameToKeyMap[entry[1]] = key;
                      tables.types[key] = entry[2];
                      tables.defaults[key] = entry[3];
                      tables.opcodes[key] = Array.isArray(entry[0]) ? entry[0] : [entry[0]];
                      tables.order.push(key);
                    }
                    return tables;
                  };
                  return CFFDict2;
                }();
                var CFFTopDict = function CFFTopDictClosure() {
                  var layout = [[[12, 30], "ROS", ["sid", "sid", "num"], null], [[12, 20], "SyntheticBase", "num", null], [0, "version", "sid", null], [1, "Notice", "sid", null], [[12, 0], "Copyright", "sid", null], [2, "FullName", "sid", null], [3, "FamilyName", "sid", null], [4, "Weight", "sid", null], [[12, 1], "isFixedPitch", "num", 0], [[12, 2], "ItalicAngle", "num", 0], [[12, 3], "UnderlinePosition", "num", -100], [[12, 4], "UnderlineThickness", "num", 50], [[12, 5], "PaintType", "num", 0], [[12, 6], "CharstringType", "num", 2], [[12, 7], "FontMatrix", ["num", "num", "num", "num", "num", "num"], [1e-3, 0, 0, 1e-3, 0, 0]], [13, "UniqueID", "num", null], [5, "FontBBox", ["num", "num", "num", "num"], [0, 0, 0, 0]], [[12, 8], "StrokeWidth", "num", 0], [14, "XUID", "array", null], [15, "charset", "offset", 0], [16, "Encoding", "offset", 0], [17, "CharStrings", "offset", 0], [18, "Private", ["offset", "offset"], null], [[12, 21], "PostScript", "sid", null], [[12, 22], "BaseFontName", "sid", null], [[12, 23], "BaseFontBlend", "delta", null], [[12, 31], "CIDFontVersion", "num", 0], [[12, 32], "CIDFontRevision", "num", 0], [[12, 33], "CIDFontType", "num", 0], [[12, 34], "CIDCount", "num", 8720], [[12, 35], "UIDBase", "num", null], [[12, 37], "FDSelect", "offset", null], [[12, 36], "FDArray", "offset", null], [[12, 38], "FontName", "sid", null]];
                  var tables = null;
                  function CFFTopDict2(strings) {
                    if (tables === null) {
                      tables = CFFDict.createTables(layout);
                    }
                    CFFDict.call(this, tables, strings);
                    this.privateDict = null;
                  }
                  CFFTopDict2.prototype = Object.create(CFFDict.prototype);
                  return CFFTopDict2;
                }();
                exports2.CFFTopDict = CFFTopDict;
                var CFFPrivateDict = function CFFPrivateDictClosure() {
                  var layout = [[6, "BlueValues", "delta", null], [7, "OtherBlues", "delta", null], [8, "FamilyBlues", "delta", null], [9, "FamilyOtherBlues", "delta", null], [[12, 9], "BlueScale", "num", 0.039625], [[12, 10], "BlueShift", "num", 7], [[12, 11], "BlueFuzz", "num", 1], [10, "StdHW", "num", null], [11, "StdVW", "num", null], [[12, 12], "StemSnapH", "delta", null], [[12, 13], "StemSnapV", "delta", null], [[12, 14], "ForceBold", "num", 0], [[12, 17], "LanguageGroup", "num", 0], [[12, 18], "ExpansionFactor", "num", 0.06], [[12, 19], "initialRandomSeed", "num", 0], [20, "defaultWidthX", "num", 0], [21, "nominalWidthX", "num", 0], [19, "Subrs", "offset", null]];
                  var tables = null;
                  function CFFPrivateDict2(strings) {
                    if (tables === null) {
                      tables = CFFDict.createTables(layout);
                    }
                    CFFDict.call(this, tables, strings);
                    this.subrsIndex = null;
                  }
                  CFFPrivateDict2.prototype = Object.create(CFFDict.prototype);
                  return CFFPrivateDict2;
                }();
                exports2.CFFPrivateDict = CFFPrivateDict;
                var CFFCharsetPredefinedTypes = { ISO_ADOBE: 0, EXPERT: 1, EXPERT_SUBSET: 2 };
                var CFFCharset = function CFFCharsetClosure() {
                  function CFFCharset2(predefined, format, charset, raw) {
                    this.predefined = predefined;
                    this.format = format;
                    this.charset = charset;
                    this.raw = raw;
                  }
                  return CFFCharset2;
                }();
                exports2.CFFCharset = CFFCharset;
                var CFFEncoding = function CFFEncodingClosure() {
                  function CFFEncoding2(predefined, format, encoding, raw) {
                    this.predefined = predefined;
                    this.format = format;
                    this.encoding = encoding;
                    this.raw = raw;
                  }
                  return CFFEncoding2;
                }();
                var CFFFDSelect = function CFFFDSelectClosure() {
                  function CFFFDSelect2(format, fdSelect) {
                    this.format = format;
                    this.fdSelect = fdSelect;
                  }
                  CFFFDSelect2.prototype = { getFDIndex: function CFFFDSelect_get(glyphIndex) {
                    if (glyphIndex < 0 || glyphIndex >= this.fdSelect.length) {
                      return -1;
                    }
                    return this.fdSelect[glyphIndex];
                  } };
                  return CFFFDSelect2;
                }();
                exports2.CFFFDSelect = CFFFDSelect;
                var CFFOffsetTracker = function CFFOffsetTrackerClosure() {
                  function CFFOffsetTracker2() {
                    this.offsets = /* @__PURE__ */ Object.create(null);
                  }
                  CFFOffsetTracker2.prototype = { isTracking: function CFFOffsetTracker_isTracking(key) {
                    return key in this.offsets;
                  }, track: function CFFOffsetTracker_track(key, location) {
                    if (key in this.offsets) {
                      throw new _util2.FormatError(`Already tracking location of ${key}`);
                    }
                    this.offsets[key] = location;
                  }, offset: function CFFOffsetTracker_offset(value) {
                    for (var key in this.offsets) {
                      this.offsets[key] += value;
                    }
                  }, setEntryLocation: function CFFOffsetTracker_setEntryLocation(key, values, output) {
                    if (!(key in this.offsets)) {
                      throw new _util2.FormatError(`Not tracking location of ${key}`);
                    }
                    var data = output.data;
                    var dataOffset = this.offsets[key];
                    var size = 5;
                    for (var i = 0, ii = values.length; i < ii; ++i) {
                      var offset0 = i * size + dataOffset;
                      var offset1 = offset0 + 1;
                      var offset2 = offset0 + 2;
                      var offset3 = offset0 + 3;
                      var offset4 = offset0 + 4;
                      if (data[offset0] !== 29 || data[offset1] !== 0 || data[offset2] !== 0 || data[offset3] !== 0 || data[offset4] !== 0) {
                        throw new _util2.FormatError("writing to an offset that is not empty");
                      }
                      var value = values[i];
                      data[offset0] = 29;
                      data[offset1] = value >> 24 & 255;
                      data[offset2] = value >> 16 & 255;
                      data[offset3] = value >> 8 & 255;
                      data[offset4] = value & 255;
                    }
                  } };
                  return CFFOffsetTracker2;
                }();
                var CFFCompiler = function CFFCompilerClosure() {
                  function CFFCompiler2(cff) {
                    this.cff = cff;
                  }
                  CFFCompiler2.prototype = { compile: function CFFCompiler_compile() {
                    var cff = this.cff;
                    var output = { data: [], length: 0, add: function CFFCompiler_add(data) {
                      this.data = this.data.concat(data);
                      this.length = this.data.length;
                    } };
                    var header = this.compileHeader(cff.header);
                    output.add(header);
                    var nameIndex = this.compileNameIndex(cff.names);
                    output.add(nameIndex);
                    if (cff.isCIDFont) {
                      if (cff.topDict.hasName("FontMatrix")) {
                        var base = cff.topDict.getByName("FontMatrix");
                        cff.topDict.removeByName("FontMatrix");
                        for (var i = 0, ii = cff.fdArray.length; i < ii; i++) {
                          var subDict = cff.fdArray[i];
                          var matrix = base.slice(0);
                          if (subDict.hasName("FontMatrix")) {
                            matrix = _util2.Util.transform(matrix, subDict.getByName("FontMatrix"));
                          }
                          subDict.setByName("FontMatrix", matrix);
                        }
                      }
                    }
                    cff.topDict.setByName("charset", 0);
                    var compiled = this.compileTopDicts([cff.topDict], output.length, cff.isCIDFont);
                    output.add(compiled.output);
                    var topDictTracker = compiled.trackers[0];
                    var stringIndex = this.compileStringIndex(cff.strings.strings);
                    output.add(stringIndex);
                    var globalSubrIndex = this.compileIndex(cff.globalSubrIndex);
                    output.add(globalSubrIndex);
                    if (cff.encoding && cff.topDict.hasName("Encoding")) {
                      if (cff.encoding.predefined) {
                        topDictTracker.setEntryLocation("Encoding", [cff.encoding.format], output);
                      } else {
                        var encoding = this.compileEncoding(cff.encoding);
                        topDictTracker.setEntryLocation("Encoding", [output.length], output);
                        output.add(encoding);
                      }
                    }
                    var charset = this.compileCharset(cff.charset, cff.charStrings.count, cff.strings, cff.isCIDFont);
                    topDictTracker.setEntryLocation("charset", [output.length], output);
                    output.add(charset);
                    var charStrings = this.compileCharStrings(cff.charStrings);
                    topDictTracker.setEntryLocation("CharStrings", [output.length], output);
                    output.add(charStrings);
                    if (cff.isCIDFont) {
                      topDictTracker.setEntryLocation("FDSelect", [output.length], output);
                      var fdSelect = this.compileFDSelect(cff.fdSelect);
                      output.add(fdSelect);
                      compiled = this.compileTopDicts(cff.fdArray, output.length, true);
                      topDictTracker.setEntryLocation("FDArray", [output.length], output);
                      output.add(compiled.output);
                      var fontDictTrackers = compiled.trackers;
                      this.compilePrivateDicts(cff.fdArray, fontDictTrackers, output);
                    }
                    this.compilePrivateDicts([cff.topDict], [topDictTracker], output);
                    output.add([0]);
                    return output.data;
                  }, encodeNumber: function CFFCompiler_encodeNumber(value) {
                    if (parseFloat(value) === parseInt(value, 10) && !isNaN(value)) {
                      return this.encodeInteger(value);
                    }
                    return this.encodeFloat(value);
                  }, encodeFloat: function CFFCompiler_encodeFloat(num) {
                    var value = num.toString();
                    var m = /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/.exec(value);
                    if (m) {
                      var epsilon = parseFloat("1e" + ((m[2] ? +m[2] : 0) + m[1].length));
                      value = (Math.round(num * epsilon) / epsilon).toString();
                    }
                    var nibbles = "";
                    var i, ii;
                    for (i = 0, ii = value.length; i < ii; ++i) {
                      var a = value[i];
                      if (a === "e") {
                        nibbles += value[++i] === "-" ? "c" : "b";
                      } else if (a === ".") {
                        nibbles += "a";
                      } else if (a === "-") {
                        nibbles += "e";
                      } else {
                        nibbles += a;
                      }
                    }
                    nibbles += nibbles.length & 1 ? "f" : "ff";
                    var out = [30];
                    for (i = 0, ii = nibbles.length; i < ii; i += 2) {
                      out.push(parseInt(nibbles.substring(i, i + 2), 16));
                    }
                    return out;
                  }, encodeInteger: function CFFCompiler_encodeInteger(value) {
                    var code;
                    if (value >= -107 && value <= 107) {
                      code = [value + 139];
                    } else if (value >= 108 && value <= 1131) {
                      value = value - 108;
                      code = [(value >> 8) + 247, value & 255];
                    } else if (value >= -1131 && value <= -108) {
                      value = -value - 108;
                      code = [(value >> 8) + 251, value & 255];
                    } else if (value >= -32768 && value <= 32767) {
                      code = [28, value >> 8 & 255, value & 255];
                    } else {
                      code = [29, value >> 24 & 255, value >> 16 & 255, value >> 8 & 255, value & 255];
                    }
                    return code;
                  }, compileHeader: function CFFCompiler_compileHeader(header) {
                    return [header.major, header.minor, header.hdrSize, header.offSize];
                  }, compileNameIndex: function CFFCompiler_compileNameIndex(names) {
                    var nameIndex = new CFFIndex();
                    for (var i = 0, ii = names.length; i < ii; ++i) {
                      var name = names[i];
                      var length = Math.min(name.length, 127);
                      var sanitizedName = new Array(length);
                      for (var j = 0; j < length; j++) {
                        var char = name[j];
                        if (char < "!" || char > "~" || char === "[" || char === "]" || char === "(" || char === ")" || char === "{" || char === "}" || char === "<" || char === ">" || char === "/" || char === "%") {
                          char = "_";
                        }
                        sanitizedName[j] = char;
                      }
                      sanitizedName = sanitizedName.join("");
                      if (sanitizedName === "") {
                        sanitizedName = "Bad_Font_Name";
                      }
                      nameIndex.add((0, _util2.stringToBytes)(sanitizedName));
                    }
                    return this.compileIndex(nameIndex);
                  }, compileTopDicts: function CFFCompiler_compileTopDicts(dicts, length, removeCidKeys) {
                    var fontDictTrackers = [];
                    var fdArrayIndex = new CFFIndex();
                    for (var i = 0, ii = dicts.length; i < ii; ++i) {
                      var fontDict = dicts[i];
                      if (removeCidKeys) {
                        fontDict.removeByName("CIDFontVersion");
                        fontDict.removeByName("CIDFontRevision");
                        fontDict.removeByName("CIDFontType");
                        fontDict.removeByName("CIDCount");
                        fontDict.removeByName("UIDBase");
                      }
                      var fontDictTracker = new CFFOffsetTracker();
                      var fontDictData = this.compileDict(fontDict, fontDictTracker);
                      fontDictTrackers.push(fontDictTracker);
                      fdArrayIndex.add(fontDictData);
                      fontDictTracker.offset(length);
                    }
                    fdArrayIndex = this.compileIndex(fdArrayIndex, fontDictTrackers);
                    return { trackers: fontDictTrackers, output: fdArrayIndex };
                  }, compilePrivateDicts: function CFFCompiler_compilePrivateDicts(dicts, trackers, output) {
                    for (var i = 0, ii = dicts.length; i < ii; ++i) {
                      var fontDict = dicts[i];
                      var privateDict = fontDict.privateDict;
                      if (!privateDict || !fontDict.hasName("Private")) {
                        throw new _util2.FormatError("There must be a private dictionary.");
                      }
                      var privateDictTracker = new CFFOffsetTracker();
                      var privateDictData = this.compileDict(privateDict, privateDictTracker);
                      var outputLength = output.length;
                      privateDictTracker.offset(outputLength);
                      if (!privateDictData.length) {
                        outputLength = 0;
                      }
                      trackers[i].setEntryLocation("Private", [privateDictData.length, outputLength], output);
                      output.add(privateDictData);
                      if (privateDict.subrsIndex && privateDict.hasName("Subrs")) {
                        var subrs = this.compileIndex(privateDict.subrsIndex);
                        privateDictTracker.setEntryLocation("Subrs", [privateDictData.length], output);
                        output.add(subrs);
                      }
                    }
                  }, compileDict: function CFFCompiler_compileDict(dict, offsetTracker) {
                    var out = [];
                    var order = dict.order;
                    for (var i = 0; i < order.length; ++i) {
                      var key = order[i];
                      if (!(key in dict.values)) {
                        continue;
                      }
                      var values = dict.values[key];
                      var types = dict.types[key];
                      if (!Array.isArray(types)) {
                        types = [types];
                      }
                      if (!Array.isArray(values)) {
                        values = [values];
                      }
                      if (values.length === 0) {
                        continue;
                      }
                      for (var j = 0, jj = types.length; j < jj; ++j) {
                        var type = types[j];
                        var value = values[j];
                        switch (type) {
                          case "num":
                          case "sid":
                            out = out.concat(this.encodeNumber(value));
                            break;
                          case "offset":
                            var name = dict.keyToNameMap[key];
                            if (!offsetTracker.isTracking(name)) {
                              offsetTracker.track(name, out.length);
                            }
                            out = out.concat([29, 0, 0, 0, 0]);
                            break;
                          case "array":
                          case "delta":
                            out = out.concat(this.encodeNumber(value));
                            for (var k = 1, kk = values.length; k < kk; ++k) {
                              out = out.concat(this.encodeNumber(values[k]));
                            }
                            break;
                          default:
                            throw new _util2.FormatError(`Unknown data type of ${type}`);
                        }
                      }
                      out = out.concat(dict.opcodes[key]);
                    }
                    return out;
                  }, compileStringIndex: function CFFCompiler_compileStringIndex(strings) {
                    var stringIndex = new CFFIndex();
                    for (var i = 0, ii = strings.length; i < ii; ++i) {
                      stringIndex.add((0, _util2.stringToBytes)(strings[i]));
                    }
                    return this.compileIndex(stringIndex);
                  }, compileGlobalSubrIndex: function CFFCompiler_compileGlobalSubrIndex() {
                    var globalSubrIndex = this.cff.globalSubrIndex;
                    this.out.writeByteArray(this.compileIndex(globalSubrIndex));
                  }, compileCharStrings: function CFFCompiler_compileCharStrings(charStrings) {
                    var charStringsIndex = new CFFIndex();
                    for (var i = 0; i < charStrings.count; i++) {
                      var glyph = charStrings.get(i);
                      if (glyph.length === 0) {
                        charStringsIndex.add(new Uint8Array([139, 14]));
                        continue;
                      }
                      charStringsIndex.add(glyph);
                    }
                    return this.compileIndex(charStringsIndex);
                  }, compileCharset: function CFFCompiler_compileCharset(charset, numGlyphs, strings, isCIDFont) {
                    let out;
                    const numGlyphsLessNotDef = numGlyphs - 1;
                    if (isCIDFont) {
                      out = new Uint8Array([2, 0, 0, numGlyphsLessNotDef >> 8 & 255, numGlyphsLessNotDef & 255]);
                    } else {
                      const length = 1 + numGlyphsLessNotDef * 2;
                      out = new Uint8Array(length);
                      out[0] = 0;
                      let charsetIndex = 0;
                      const numCharsets = charset.charset.length;
                      let warned = false;
                      for (let i = 1; i < out.length; i += 2) {
                        let sid = 0;
                        if (charsetIndex < numCharsets) {
                          const name = charset.charset[charsetIndex++];
                          sid = strings.getSID(name);
                          if (sid === -1) {
                            sid = 0;
                            if (!warned) {
                              warned = true;
                              (0, _util2.warn)(`Couldn't find ${name} in CFF strings`);
                            }
                          }
                        }
                        out[i] = sid >> 8 & 255;
                        out[i + 1] = sid & 255;
                      }
                    }
                    return this.compileTypedArray(out);
                  }, compileEncoding: function CFFCompiler_compileEncoding(encoding) {
                    return this.compileTypedArray(encoding.raw);
                  }, compileFDSelect: function CFFCompiler_compileFDSelect(fdSelect) {
                    const format = fdSelect.format;
                    let out, i;
                    switch (format) {
                      case 0:
                        out = new Uint8Array(1 + fdSelect.fdSelect.length);
                        out[0] = format;
                        for (i = 0; i < fdSelect.fdSelect.length; i++) {
                          out[i + 1] = fdSelect.fdSelect[i];
                        }
                        break;
                      case 3:
                        const start = 0;
                        let lastFD = fdSelect.fdSelect[0];
                        const ranges = [format, 0, 0, start >> 8 & 255, start & 255, lastFD];
                        for (i = 1; i < fdSelect.fdSelect.length; i++) {
                          const currentFD = fdSelect.fdSelect[i];
                          if (currentFD !== lastFD) {
                            ranges.push(i >> 8 & 255, i & 255, currentFD);
                            lastFD = currentFD;
                          }
                        }
                        const numRanges = (ranges.length - 3) / 3;
                        ranges[1] = numRanges >> 8 & 255;
                        ranges[2] = numRanges & 255;
                        ranges.push(i >> 8 & 255, i & 255);
                        out = new Uint8Array(ranges);
                        break;
                    }
                    return this.compileTypedArray(out);
                  }, compileTypedArray: function CFFCompiler_compileTypedArray(data) {
                    var out = [];
                    for (var i = 0, ii = data.length; i < ii; ++i) {
                      out[i] = data[i];
                    }
                    return out;
                  }, compileIndex: function CFFCompiler_compileIndex(index, trackers) {
                    trackers = trackers || [];
                    var objects = index.objects;
                    var count = objects.length;
                    if (count === 0) {
                      return [0, 0, 0];
                    }
                    var data = [count >> 8 & 255, count & 255];
                    var lastOffset = 1, i;
                    for (i = 0; i < count; ++i) {
                      lastOffset += objects[i].length;
                    }
                    var offsetSize;
                    if (lastOffset < 256) {
                      offsetSize = 1;
                    } else if (lastOffset < 65536) {
                      offsetSize = 2;
                    } else if (lastOffset < 16777216) {
                      offsetSize = 3;
                    } else {
                      offsetSize = 4;
                    }
                    data.push(offsetSize);
                    var relativeOffset = 1;
                    for (i = 0; i < count + 1; i++) {
                      if (offsetSize === 1) {
                        data.push(relativeOffset & 255);
                      } else if (offsetSize === 2) {
                        data.push(relativeOffset >> 8 & 255, relativeOffset & 255);
                      } else if (offsetSize === 3) {
                        data.push(relativeOffset >> 16 & 255, relativeOffset >> 8 & 255, relativeOffset & 255);
                      } else {
                        data.push(relativeOffset >>> 24 & 255, relativeOffset >> 16 & 255, relativeOffset >> 8 & 255, relativeOffset & 255);
                      }
                      if (objects[i]) {
                        relativeOffset += objects[i].length;
                      }
                    }
                    for (i = 0; i < count; i++) {
                      if (trackers[i]) {
                        trackers[i].offset(data.length);
                      }
                      for (var j = 0, jj = objects[i].length; j < jj; j++) {
                        data.push(objects[i][j]);
                      }
                    }
                    return data;
                  } };
                  return CFFCompiler2;
                }();
                exports2.CFFCompiler = CFFCompiler;
              }, function(module3, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.ExpertSubsetCharset = exports2.ExpertCharset = exports2.ISOAdobeCharset = void 0;
                const ISOAdobeCharset = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron"];
                exports2.ISOAdobeCharset = ISOAdobeCharset;
                const ExpertCharset = [".notdef", "space", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];
                exports2.ExpertCharset = ExpertCharset;
                const ExpertSubsetCharset = [".notdef", "space", "dollaroldstyle", "dollarsuperior", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "hyphensuperior", "colonmonetary", "onefitted", "rupiah", "centoldstyle", "figuredash", "hypheninferior", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior"];
                exports2.ExpertSubsetCharset = ExpertSubsetCharset;
              }, function(module3, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.getEncoding = getEncoding;
                exports2.ExpertEncoding = exports2.ZapfDingbatsEncoding = exports2.SymbolSetEncoding = exports2.MacRomanEncoding = exports2.StandardEncoding = exports2.WinAnsiEncoding = void 0;
                const ExpertEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "", "", "", "isuperior", "", "", "lsuperior", "msuperior", "nsuperior", "osuperior", "", "", "rsuperior", "ssuperior", "tsuperior", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdownsmall", "centoldstyle", "Lslashsmall", "", "", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "", "Dotaccentsmall", "", "", "Macronsmall", "", "", "figuredash", "hypheninferior", "", "", "Ogoneksmall", "Ringsmall", "Cedillasmall", "", "", "", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];
                exports2.ExpertEncoding = ExpertEncoding;
                const MacExpertEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "centoldstyle", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "", "threequartersemdash", "", "questionsmall", "", "", "", "", "Ethsmall", "", "", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "", "", "", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hypheninferior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "asuperior", "centsuperior", "", "", "", "", "Aacutesmall", "Agravesmall", "Acircumflexsmall", "Adieresissmall", "Atildesmall", "Aringsmall", "Ccedillasmall", "Eacutesmall", "Egravesmall", "Ecircumflexsmall", "Edieresissmall", "Iacutesmall", "Igravesmall", "Icircumflexsmall", "Idieresissmall", "Ntildesmall", "Oacutesmall", "Ogravesmall", "Ocircumflexsmall", "Odieresissmall", "Otildesmall", "Uacutesmall", "Ugravesmall", "Ucircumflexsmall", "Udieresissmall", "", "eightsuperior", "fourinferior", "threeinferior", "sixinferior", "eightinferior", "seveninferior", "Scaronsmall", "", "centinferior", "twoinferior", "", "Dieresissmall", "", "Caronsmall", "osuperior", "fiveinferior", "", "commainferior", "periodinferior", "Yacutesmall", "", "dollarinferior", "", "", "Thornsmall", "", "nineinferior", "zeroinferior", "Zcaronsmall", "AEsmall", "Oslashsmall", "questiondownsmall", "oneinferior", "Lslashsmall", "", "", "", "", "", "", "Cedillasmall", "", "", "", "", "", "OEsmall", "figuredash", "hyphensuperior", "", "", "", "", "exclamdownsmall", "", "Ydieresissmall", "", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "ninesuperior", "zerosuperior", "", "esuperior", "rsuperior", "tsuperior", "", "", "isuperior", "ssuperior", "dsuperior", "", "", "", "", "", "lsuperior", "Ogoneksmall", "Brevesmall", "Macronsmall", "bsuperior", "nsuperior", "msuperior", "commasuperior", "periodsuperior", "Dotaccentsmall", "Ringsmall", "", "", "", ""];
                const MacRomanEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "space", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron"];
                exports2.MacRomanEncoding = MacRomanEncoding;
                const StandardEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "", "endash", "dagger", "daggerdbl", "periodcentered", "", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "", "questiondown", "", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "", "ring", "cedilla", "", "hungarumlaut", "ogonek", "caron", "emdash", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "AE", "", "ordfeminine", "", "", "", "", "Lslash", "Oslash", "OE", "ordmasculine", "", "", "", "", "", "ae", "", "", "", "dotlessi", "", "", "lslash", "oslash", "oe", "germandbls", "", "", "", ""];
                exports2.StandardEncoding = StandardEncoding;
                const WinAnsiEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "bullet", "Euro", "bullet", "quotesinglbase", "florin", "quotedblbase", "ellipsis", "dagger", "daggerdbl", "circumflex", "perthousand", "Scaron", "guilsinglleft", "OE", "bullet", "Zcaron", "bullet", "bullet", "quoteleft", "quoteright", "quotedblleft", "quotedblright", "bullet", "endash", "emdash", "tilde", "trademark", "scaron", "guilsinglright", "oe", "bullet", "zcaron", "Ydieresis", "space", "exclamdown", "cent", "sterling", "currency", "yen", "brokenbar", "section", "dieresis", "copyright", "ordfeminine", "guillemotleft", "logicalnot", "hyphen", "registered", "macron", "degree", "plusminus", "twosuperior", "threesuperior", "acute", "mu", "paragraph", "periodcentered", "cedilla", "onesuperior", "ordmasculine", "guillemotright", "onequarter", "onehalf", "threequarters", "questiondown", "Agrave", "Aacute", "Acircumflex", "Atilde", "Adieresis", "Aring", "AE", "Ccedilla", "Egrave", "Eacute", "Ecircumflex", "Edieresis", "Igrave", "Iacute", "Icircumflex", "Idieresis", "Eth", "Ntilde", "Ograve", "Oacute", "Ocircumflex", "Otilde", "Odieresis", "multiply", "Oslash", "Ugrave", "Uacute", "Ucircumflex", "Udieresis", "Yacute", "Thorn", "germandbls", "agrave", "aacute", "acircumflex", "atilde", "adieresis", "aring", "ae", "ccedilla", "egrave", "eacute", "ecircumflex", "edieresis", "igrave", "iacute", "icircumflex", "idieresis", "eth", "ntilde", "ograve", "oacute", "ocircumflex", "otilde", "odieresis", "divide", "oslash", "ugrave", "uacute", "ucircumflex", "udieresis", "yacute", "thorn", "ydieresis"];
                exports2.WinAnsiEncoding = WinAnsiEncoding;
                const SymbolSetEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "universal", "numbersign", "existential", "percent", "ampersand", "suchthat", "parenleft", "parenright", "asteriskmath", "plus", "comma", "minus", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "congruent", "Alpha", "Beta", "Chi", "Delta", "Epsilon", "Phi", "Gamma", "Eta", "Iota", "theta1", "Kappa", "Lambda", "Mu", "Nu", "Omicron", "Pi", "Theta", "Rho", "Sigma", "Tau", "Upsilon", "sigma1", "Omega", "Xi", "Psi", "Zeta", "bracketleft", "therefore", "bracketright", "perpendicular", "underscore", "radicalex", "alpha", "beta", "chi", "delta", "epsilon", "phi", "gamma", "eta", "iota", "phi1", "kappa", "lambda", "mu", "nu", "omicron", "pi", "theta", "rho", "sigma", "tau", "upsilon", "omega1", "omega", "xi", "psi", "zeta", "braceleft", "bar", "braceright", "similar", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "Euro", "Upsilon1", "minute", "lessequal", "fraction", "infinity", "florin", "club", "diamond", "heart", "spade", "arrowboth", "arrowleft", "arrowup", "arrowright", "arrowdown", "degree", "plusminus", "second", "greaterequal", "multiply", "proportional", "partialdiff", "bullet", "divide", "notequal", "equivalence", "approxequal", "ellipsis", "arrowvertex", "arrowhorizex", "carriagereturn", "aleph", "Ifraktur", "Rfraktur", "weierstrass", "circlemultiply", "circleplus", "emptyset", "intersection", "union", "propersuperset", "reflexsuperset", "notsubset", "propersubset", "reflexsubset", "element", "notelement", "angle", "gradient", "registerserif", "copyrightserif", "trademarkserif", "product", "radical", "dotmath", "logicalnot", "logicaland", "logicalor", "arrowdblboth", "arrowdblleft", "arrowdblup", "arrowdblright", "arrowdbldown", "lozenge", "angleleft", "registersans", "copyrightsans", "trademarksans", "summation", "parenlefttp", "parenleftex", "parenleftbt", "bracketlefttp", "bracketleftex", "bracketleftbt", "bracelefttp", "braceleftmid", "braceleftbt", "braceex", "", "angleright", "integral", "integraltp", "integralex", "integralbt", "parenrighttp", "parenrightex", "parenrightbt", "bracketrighttp", "bracketrightex", "bracketrightbt", "bracerighttp", "bracerightmid", "bracerightbt", ""];
                exports2.SymbolSetEncoding = SymbolSetEncoding;
                const ZapfDingbatsEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "a1", "a2", "a202", "a3", "a4", "a5", "a119", "a118", "a117", "a11", "a12", "a13", "a14", "a15", "a16", "a105", "a17", "a18", "a19", "a20", "a21", "a22", "a23", "a24", "a25", "a26", "a27", "a28", "a6", "a7", "a8", "a9", "a10", "a29", "a30", "a31", "a32", "a33", "a34", "a35", "a36", "a37", "a38", "a39", "a40", "a41", "a42", "a43", "a44", "a45", "a46", "a47", "a48", "a49", "a50", "a51", "a52", "a53", "a54", "a55", "a56", "a57", "a58", "a59", "a60", "a61", "a62", "a63", "a64", "a65", "a66", "a67", "a68", "a69", "a70", "a71", "a72", "a73", "a74", "a203", "a75", "a204", "a76", "a77", "a78", "a79", "a81", "a82", "a83", "a84", "a97", "a98", "a99", "a100", "", "a89", "a90", "a93", "a94", "a91", "a92", "a205", "a85", "a206", "a86", "a87", "a88", "a95", "a96", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "a101", "a102", "a103", "a104", "a106", "a107", "a108", "a112", "a111", "a110", "a109", "a120", "a121", "a122", "a123", "a124", "a125", "a126", "a127", "a128", "a129", "a130", "a131", "a132", "a133", "a134", "a135", "a136", "a137", "a138", "a139", "a140", "a141", "a142", "a143", "a144", "a145", "a146", "a147", "a148", "a149", "a150", "a151", "a152", "a153", "a154", "a155", "a156", "a157", "a158", "a159", "a160", "a161", "a163", "a164", "a196", "a165", "a192", "a166", "a167", "a168", "a169", "a170", "a171", "a172", "a173", "a162", "a174", "a175", "a176", "a177", "a178", "a179", "a193", "a180", "a199", "a181", "a200", "a182", "", "a201", "a183", "a184", "a197", "a185", "a194", "a198", "a186", "a195", "a187", "a188", "a189", "a190", "a191", ""];
                exports2.ZapfDingbatsEncoding = ZapfDingbatsEncoding;
                function getEncoding(encodingName) {
                  switch (encodingName) {
                    case "WinAnsiEncoding":
                      return WinAnsiEncoding;
                    case "StandardEncoding":
                      return StandardEncoding;
                    case "MacRomanEncoding":
                      return MacRomanEncoding;
                    case "SymbolSetEncoding":
                      return SymbolSetEncoding;
                    case "ZapfDingbatsEncoding":
                      return ZapfDingbatsEncoding;
                    case "ExpertEncoding":
                      return ExpertEncoding;
                    case "MacExpertEncoding":
                      return MacExpertEncoding;
                    default:
                      return null;
                  }
                }
              }, function(module3, exports2, __w_pdfjs_require__2) {
                var getLookupTableFactory = __w_pdfjs_require__2(7).getLookupTableFactory;
                var getGlyphsUnicode = getLookupTableFactory(function(t) {
                  t["A"] = 65;
                  t["AE"] = 198;
                  t["AEacute"] = 508;
                  t["AEmacron"] = 482;
                  t["AEsmall"] = 63462;
                  t["Aacute"] = 193;
                  t["Aacutesmall"] = 63457;
                  t["Abreve"] = 258;
                  t["Abreveacute"] = 7854;
                  t["Abrevecyrillic"] = 1232;
                  t["Abrevedotbelow"] = 7862;
                  t["Abrevegrave"] = 7856;
                  t["Abrevehookabove"] = 7858;
                  t["Abrevetilde"] = 7860;
                  t["Acaron"] = 461;
                  t["Acircle"] = 9398;
                  t["Acircumflex"] = 194;
                  t["Acircumflexacute"] = 7844;
                  t["Acircumflexdotbelow"] = 7852;
                  t["Acircumflexgrave"] = 7846;
                  t["Acircumflexhookabove"] = 7848;
                  t["Acircumflexsmall"] = 63458;
                  t["Acircumflextilde"] = 7850;
                  t["Acute"] = 63177;
                  t["Acutesmall"] = 63412;
                  t["Acyrillic"] = 1040;
                  t["Adblgrave"] = 512;
                  t["Adieresis"] = 196;
                  t["Adieresiscyrillic"] = 1234;
                  t["Adieresismacron"] = 478;
                  t["Adieresissmall"] = 63460;
                  t["Adotbelow"] = 7840;
                  t["Adotmacron"] = 480;
                  t["Agrave"] = 192;
                  t["Agravesmall"] = 63456;
                  t["Ahookabove"] = 7842;
                  t["Aiecyrillic"] = 1236;
                  t["Ainvertedbreve"] = 514;
                  t["Alpha"] = 913;
                  t["Alphatonos"] = 902;
                  t["Amacron"] = 256;
                  t["Amonospace"] = 65313;
                  t["Aogonek"] = 260;
                  t["Aring"] = 197;
                  t["Aringacute"] = 506;
                  t["Aringbelow"] = 7680;
                  t["Aringsmall"] = 63461;
                  t["Asmall"] = 63329;
                  t["Atilde"] = 195;
                  t["Atildesmall"] = 63459;
                  t["Aybarmenian"] = 1329;
                  t["B"] = 66;
                  t["Bcircle"] = 9399;
                  t["Bdotaccent"] = 7682;
                  t["Bdotbelow"] = 7684;
                  t["Becyrillic"] = 1041;
                  t["Benarmenian"] = 1330;
                  t["Beta"] = 914;
                  t["Bhook"] = 385;
                  t["Blinebelow"] = 7686;
                  t["Bmonospace"] = 65314;
                  t["Brevesmall"] = 63220;
                  t["Bsmall"] = 63330;
                  t["Btopbar"] = 386;
                  t["C"] = 67;
                  t["Caarmenian"] = 1342;
                  t["Cacute"] = 262;
                  t["Caron"] = 63178;
                  t["Caronsmall"] = 63221;
                  t["Ccaron"] = 268;
                  t["Ccedilla"] = 199;
                  t["Ccedillaacute"] = 7688;
                  t["Ccedillasmall"] = 63463;
                  t["Ccircle"] = 9400;
                  t["Ccircumflex"] = 264;
                  t["Cdot"] = 266;
                  t["Cdotaccent"] = 266;
                  t["Cedillasmall"] = 63416;
                  t["Chaarmenian"] = 1353;
                  t["Cheabkhasiancyrillic"] = 1212;
                  t["Checyrillic"] = 1063;
                  t["Chedescenderabkhasiancyrillic"] = 1214;
                  t["Chedescendercyrillic"] = 1206;
                  t["Chedieresiscyrillic"] = 1268;
                  t["Cheharmenian"] = 1347;
                  t["Chekhakassiancyrillic"] = 1227;
                  t["Cheverticalstrokecyrillic"] = 1208;
                  t["Chi"] = 935;
                  t["Chook"] = 391;
                  t["Circumflexsmall"] = 63222;
                  t["Cmonospace"] = 65315;
                  t["Coarmenian"] = 1361;
                  t["Csmall"] = 63331;
                  t["D"] = 68;
                  t["DZ"] = 497;
                  t["DZcaron"] = 452;
                  t["Daarmenian"] = 1332;
                  t["Dafrican"] = 393;
                  t["Dcaron"] = 270;
                  t["Dcedilla"] = 7696;
                  t["Dcircle"] = 9401;
                  t["Dcircumflexbelow"] = 7698;
                  t["Dcroat"] = 272;
                  t["Ddotaccent"] = 7690;
                  t["Ddotbelow"] = 7692;
                  t["Decyrillic"] = 1044;
                  t["Deicoptic"] = 1006;
                  t["Delta"] = 8710;
                  t["Deltagreek"] = 916;
                  t["Dhook"] = 394;
                  t["Dieresis"] = 63179;
                  t["DieresisAcute"] = 63180;
                  t["DieresisGrave"] = 63181;
                  t["Dieresissmall"] = 63400;
                  t["Digammagreek"] = 988;
                  t["Djecyrillic"] = 1026;
                  t["Dlinebelow"] = 7694;
                  t["Dmonospace"] = 65316;
                  t["Dotaccentsmall"] = 63223;
                  t["Dslash"] = 272;
                  t["Dsmall"] = 63332;
                  t["Dtopbar"] = 395;
                  t["Dz"] = 498;
                  t["Dzcaron"] = 453;
                  t["Dzeabkhasiancyrillic"] = 1248;
                  t["Dzecyrillic"] = 1029;
                  t["Dzhecyrillic"] = 1039;
                  t["E"] = 69;
                  t["Eacute"] = 201;
                  t["Eacutesmall"] = 63465;
                  t["Ebreve"] = 276;
                  t["Ecaron"] = 282;
                  t["Ecedillabreve"] = 7708;
                  t["Echarmenian"] = 1333;
                  t["Ecircle"] = 9402;
                  t["Ecircumflex"] = 202;
                  t["Ecircumflexacute"] = 7870;
                  t["Ecircumflexbelow"] = 7704;
                  t["Ecircumflexdotbelow"] = 7878;
                  t["Ecircumflexgrave"] = 7872;
                  t["Ecircumflexhookabove"] = 7874;
                  t["Ecircumflexsmall"] = 63466;
                  t["Ecircumflextilde"] = 7876;
                  t["Ecyrillic"] = 1028;
                  t["Edblgrave"] = 516;
                  t["Edieresis"] = 203;
                  t["Edieresissmall"] = 63467;
                  t["Edot"] = 278;
                  t["Edotaccent"] = 278;
                  t["Edotbelow"] = 7864;
                  t["Efcyrillic"] = 1060;
                  t["Egrave"] = 200;
                  t["Egravesmall"] = 63464;
                  t["Eharmenian"] = 1335;
                  t["Ehookabove"] = 7866;
                  t["Eightroman"] = 8551;
                  t["Einvertedbreve"] = 518;
                  t["Eiotifiedcyrillic"] = 1124;
                  t["Elcyrillic"] = 1051;
                  t["Elevenroman"] = 8554;
                  t["Emacron"] = 274;
                  t["Emacronacute"] = 7702;
                  t["Emacrongrave"] = 7700;
                  t["Emcyrillic"] = 1052;
                  t["Emonospace"] = 65317;
                  t["Encyrillic"] = 1053;
                  t["Endescendercyrillic"] = 1186;
                  t["Eng"] = 330;
                  t["Enghecyrillic"] = 1188;
                  t["Enhookcyrillic"] = 1223;
                  t["Eogonek"] = 280;
                  t["Eopen"] = 400;
                  t["Epsilon"] = 917;
                  t["Epsilontonos"] = 904;
                  t["Ercyrillic"] = 1056;
                  t["Ereversed"] = 398;
                  t["Ereversedcyrillic"] = 1069;
                  t["Escyrillic"] = 1057;
                  t["Esdescendercyrillic"] = 1194;
                  t["Esh"] = 425;
                  t["Esmall"] = 63333;
                  t["Eta"] = 919;
                  t["Etarmenian"] = 1336;
                  t["Etatonos"] = 905;
                  t["Eth"] = 208;
                  t["Ethsmall"] = 63472;
                  t["Etilde"] = 7868;
                  t["Etildebelow"] = 7706;
                  t["Euro"] = 8364;
                  t["Ezh"] = 439;
                  t["Ezhcaron"] = 494;
                  t["Ezhreversed"] = 440;
                  t["F"] = 70;
                  t["Fcircle"] = 9403;
                  t["Fdotaccent"] = 7710;
                  t["Feharmenian"] = 1366;
                  t["Feicoptic"] = 996;
                  t["Fhook"] = 401;
                  t["Fitacyrillic"] = 1138;
                  t["Fiveroman"] = 8548;
                  t["Fmonospace"] = 65318;
                  t["Fourroman"] = 8547;
                  t["Fsmall"] = 63334;
                  t["G"] = 71;
                  t["GBsquare"] = 13191;
                  t["Gacute"] = 500;
                  t["Gamma"] = 915;
                  t["Gammaafrican"] = 404;
                  t["Gangiacoptic"] = 1002;
                  t["Gbreve"] = 286;
                  t["Gcaron"] = 486;
                  t["Gcedilla"] = 290;
                  t["Gcircle"] = 9404;
                  t["Gcircumflex"] = 284;
                  t["Gcommaaccent"] = 290;
                  t["Gdot"] = 288;
                  t["Gdotaccent"] = 288;
                  t["Gecyrillic"] = 1043;
                  t["Ghadarmenian"] = 1346;
                  t["Ghemiddlehookcyrillic"] = 1172;
                  t["Ghestrokecyrillic"] = 1170;
                  t["Gheupturncyrillic"] = 1168;
                  t["Ghook"] = 403;
                  t["Gimarmenian"] = 1331;
                  t["Gjecyrillic"] = 1027;
                  t["Gmacron"] = 7712;
                  t["Gmonospace"] = 65319;
                  t["Grave"] = 63182;
                  t["Gravesmall"] = 63328;
                  t["Gsmall"] = 63335;
                  t["Gsmallhook"] = 667;
                  t["Gstroke"] = 484;
                  t["H"] = 72;
                  t["H18533"] = 9679;
                  t["H18543"] = 9642;
                  t["H18551"] = 9643;
                  t["H22073"] = 9633;
                  t["HPsquare"] = 13259;
                  t["Haabkhasiancyrillic"] = 1192;
                  t["Hadescendercyrillic"] = 1202;
                  t["Hardsigncyrillic"] = 1066;
                  t["Hbar"] = 294;
                  t["Hbrevebelow"] = 7722;
                  t["Hcedilla"] = 7720;
                  t["Hcircle"] = 9405;
                  t["Hcircumflex"] = 292;
                  t["Hdieresis"] = 7718;
                  t["Hdotaccent"] = 7714;
                  t["Hdotbelow"] = 7716;
                  t["Hmonospace"] = 65320;
                  t["Hoarmenian"] = 1344;
                  t["Horicoptic"] = 1e3;
                  t["Hsmall"] = 63336;
                  t["Hungarumlaut"] = 63183;
                  t["Hungarumlautsmall"] = 63224;
                  t["Hzsquare"] = 13200;
                  t["I"] = 73;
                  t["IAcyrillic"] = 1071;
                  t["IJ"] = 306;
                  t["IUcyrillic"] = 1070;
                  t["Iacute"] = 205;
                  t["Iacutesmall"] = 63469;
                  t["Ibreve"] = 300;
                  t["Icaron"] = 463;
                  t["Icircle"] = 9406;
                  t["Icircumflex"] = 206;
                  t["Icircumflexsmall"] = 63470;
                  t["Icyrillic"] = 1030;
                  t["Idblgrave"] = 520;
                  t["Idieresis"] = 207;
                  t["Idieresisacute"] = 7726;
                  t["Idieresiscyrillic"] = 1252;
                  t["Idieresissmall"] = 63471;
                  t["Idot"] = 304;
                  t["Idotaccent"] = 304;
                  t["Idotbelow"] = 7882;
                  t["Iebrevecyrillic"] = 1238;
                  t["Iecyrillic"] = 1045;
                  t["Ifraktur"] = 8465;
                  t["Igrave"] = 204;
                  t["Igravesmall"] = 63468;
                  t["Ihookabove"] = 7880;
                  t["Iicyrillic"] = 1048;
                  t["Iinvertedbreve"] = 522;
                  t["Iishortcyrillic"] = 1049;
                  t["Imacron"] = 298;
                  t["Imacroncyrillic"] = 1250;
                  t["Imonospace"] = 65321;
                  t["Iniarmenian"] = 1339;
                  t["Iocyrillic"] = 1025;
                  t["Iogonek"] = 302;
                  t["Iota"] = 921;
                  t["Iotaafrican"] = 406;
                  t["Iotadieresis"] = 938;
                  t["Iotatonos"] = 906;
                  t["Ismall"] = 63337;
                  t["Istroke"] = 407;
                  t["Itilde"] = 296;
                  t["Itildebelow"] = 7724;
                  t["Izhitsacyrillic"] = 1140;
                  t["Izhitsadblgravecyrillic"] = 1142;
                  t["J"] = 74;
                  t["Jaarmenian"] = 1345;
                  t["Jcircle"] = 9407;
                  t["Jcircumflex"] = 308;
                  t["Jecyrillic"] = 1032;
                  t["Jheharmenian"] = 1355;
                  t["Jmonospace"] = 65322;
                  t["Jsmall"] = 63338;
                  t["K"] = 75;
                  t["KBsquare"] = 13189;
                  t["KKsquare"] = 13261;
                  t["Kabashkircyrillic"] = 1184;
                  t["Kacute"] = 7728;
                  t["Kacyrillic"] = 1050;
                  t["Kadescendercyrillic"] = 1178;
                  t["Kahookcyrillic"] = 1219;
                  t["Kappa"] = 922;
                  t["Kastrokecyrillic"] = 1182;
                  t["Kaverticalstrokecyrillic"] = 1180;
                  t["Kcaron"] = 488;
                  t["Kcedilla"] = 310;
                  t["Kcircle"] = 9408;
                  t["Kcommaaccent"] = 310;
                  t["Kdotbelow"] = 7730;
                  t["Keharmenian"] = 1364;
                  t["Kenarmenian"] = 1343;
                  t["Khacyrillic"] = 1061;
                  t["Kheicoptic"] = 998;
                  t["Khook"] = 408;
                  t["Kjecyrillic"] = 1036;
                  t["Klinebelow"] = 7732;
                  t["Kmonospace"] = 65323;
                  t["Koppacyrillic"] = 1152;
                  t["Koppagreek"] = 990;
                  t["Ksicyrillic"] = 1134;
                  t["Ksmall"] = 63339;
                  t["L"] = 76;
                  t["LJ"] = 455;
                  t["LL"] = 63167;
                  t["Lacute"] = 313;
                  t["Lambda"] = 923;
                  t["Lcaron"] = 317;
                  t["Lcedilla"] = 315;
                  t["Lcircle"] = 9409;
                  t["Lcircumflexbelow"] = 7740;
                  t["Lcommaaccent"] = 315;
                  t["Ldot"] = 319;
                  t["Ldotaccent"] = 319;
                  t["Ldotbelow"] = 7734;
                  t["Ldotbelowmacron"] = 7736;
                  t["Liwnarmenian"] = 1340;
                  t["Lj"] = 456;
                  t["Ljecyrillic"] = 1033;
                  t["Llinebelow"] = 7738;
                  t["Lmonospace"] = 65324;
                  t["Lslash"] = 321;
                  t["Lslashsmall"] = 63225;
                  t["Lsmall"] = 63340;
                  t["M"] = 77;
                  t["MBsquare"] = 13190;
                  t["Macron"] = 63184;
                  t["Macronsmall"] = 63407;
                  t["Macute"] = 7742;
                  t["Mcircle"] = 9410;
                  t["Mdotaccent"] = 7744;
                  t["Mdotbelow"] = 7746;
                  t["Menarmenian"] = 1348;
                  t["Mmonospace"] = 65325;
                  t["Msmall"] = 63341;
                  t["Mturned"] = 412;
                  t["Mu"] = 924;
                  t["N"] = 78;
                  t["NJ"] = 458;
                  t["Nacute"] = 323;
                  t["Ncaron"] = 327;
                  t["Ncedilla"] = 325;
                  t["Ncircle"] = 9411;
                  t["Ncircumflexbelow"] = 7754;
                  t["Ncommaaccent"] = 325;
                  t["Ndotaccent"] = 7748;
                  t["Ndotbelow"] = 7750;
                  t["Nhookleft"] = 413;
                  t["Nineroman"] = 8552;
                  t["Nj"] = 459;
                  t["Njecyrillic"] = 1034;
                  t["Nlinebelow"] = 7752;
                  t["Nmonospace"] = 65326;
                  t["Nowarmenian"] = 1350;
                  t["Nsmall"] = 63342;
                  t["Ntilde"] = 209;
                  t["Ntildesmall"] = 63473;
                  t["Nu"] = 925;
                  t["O"] = 79;
                  t["OE"] = 338;
                  t["OEsmall"] = 63226;
                  t["Oacute"] = 211;
                  t["Oacutesmall"] = 63475;
                  t["Obarredcyrillic"] = 1256;
                  t["Obarreddieresiscyrillic"] = 1258;
                  t["Obreve"] = 334;
                  t["Ocaron"] = 465;
                  t["Ocenteredtilde"] = 415;
                  t["Ocircle"] = 9412;
                  t["Ocircumflex"] = 212;
                  t["Ocircumflexacute"] = 7888;
                  t["Ocircumflexdotbelow"] = 7896;
                  t["Ocircumflexgrave"] = 7890;
                  t["Ocircumflexhookabove"] = 7892;
                  t["Ocircumflexsmall"] = 63476;
                  t["Ocircumflextilde"] = 7894;
                  t["Ocyrillic"] = 1054;
                  t["Odblacute"] = 336;
                  t["Odblgrave"] = 524;
                  t["Odieresis"] = 214;
                  t["Odieresiscyrillic"] = 1254;
                  t["Odieresissmall"] = 63478;
                  t["Odotbelow"] = 7884;
                  t["Ogoneksmall"] = 63227;
                  t["Ograve"] = 210;
                  t["Ogravesmall"] = 63474;
                  t["Oharmenian"] = 1365;
                  t["Ohm"] = 8486;
                  t["Ohookabove"] = 7886;
                  t["Ohorn"] = 416;
                  t["Ohornacute"] = 7898;
                  t["Ohorndotbelow"] = 7906;
                  t["Ohorngrave"] = 7900;
                  t["Ohornhookabove"] = 7902;
                  t["Ohorntilde"] = 7904;
                  t["Ohungarumlaut"] = 336;
                  t["Oi"] = 418;
                  t["Oinvertedbreve"] = 526;
                  t["Omacron"] = 332;
                  t["Omacronacute"] = 7762;
                  t["Omacrongrave"] = 7760;
                  t["Omega"] = 8486;
                  t["Omegacyrillic"] = 1120;
                  t["Omegagreek"] = 937;
                  t["Omegaroundcyrillic"] = 1146;
                  t["Omegatitlocyrillic"] = 1148;
                  t["Omegatonos"] = 911;
                  t["Omicron"] = 927;
                  t["Omicrontonos"] = 908;
                  t["Omonospace"] = 65327;
                  t["Oneroman"] = 8544;
                  t["Oogonek"] = 490;
                  t["Oogonekmacron"] = 492;
                  t["Oopen"] = 390;
                  t["Oslash"] = 216;
                  t["Oslashacute"] = 510;
                  t["Oslashsmall"] = 63480;
                  t["Osmall"] = 63343;
                  t["Ostrokeacute"] = 510;
                  t["Otcyrillic"] = 1150;
                  t["Otilde"] = 213;
                  t["Otildeacute"] = 7756;
                  t["Otildedieresis"] = 7758;
                  t["Otildesmall"] = 63477;
                  t["P"] = 80;
                  t["Pacute"] = 7764;
                  t["Pcircle"] = 9413;
                  t["Pdotaccent"] = 7766;
                  t["Pecyrillic"] = 1055;
                  t["Peharmenian"] = 1354;
                  t["Pemiddlehookcyrillic"] = 1190;
                  t["Phi"] = 934;
                  t["Phook"] = 420;
                  t["Pi"] = 928;
                  t["Piwrarmenian"] = 1363;
                  t["Pmonospace"] = 65328;
                  t["Psi"] = 936;
                  t["Psicyrillic"] = 1136;
                  t["Psmall"] = 63344;
                  t["Q"] = 81;
                  t["Qcircle"] = 9414;
                  t["Qmonospace"] = 65329;
                  t["Qsmall"] = 63345;
                  t["R"] = 82;
                  t["Raarmenian"] = 1356;
                  t["Racute"] = 340;
                  t["Rcaron"] = 344;
                  t["Rcedilla"] = 342;
                  t["Rcircle"] = 9415;
                  t["Rcommaaccent"] = 342;
                  t["Rdblgrave"] = 528;
                  t["Rdotaccent"] = 7768;
                  t["Rdotbelow"] = 7770;
                  t["Rdotbelowmacron"] = 7772;
                  t["Reharmenian"] = 1360;
                  t["Rfraktur"] = 8476;
                  t["Rho"] = 929;
                  t["Ringsmall"] = 63228;
                  t["Rinvertedbreve"] = 530;
                  t["Rlinebelow"] = 7774;
                  t["Rmonospace"] = 65330;
                  t["Rsmall"] = 63346;
                  t["Rsmallinverted"] = 641;
                  t["Rsmallinvertedsuperior"] = 694;
                  t["S"] = 83;
                  t["SF010000"] = 9484;
                  t["SF020000"] = 9492;
                  t["SF030000"] = 9488;
                  t["SF040000"] = 9496;
                  t["SF050000"] = 9532;
                  t["SF060000"] = 9516;
                  t["SF070000"] = 9524;
                  t["SF080000"] = 9500;
                  t["SF090000"] = 9508;
                  t["SF100000"] = 9472;
                  t["SF110000"] = 9474;
                  t["SF190000"] = 9569;
                  t["SF200000"] = 9570;
                  t["SF210000"] = 9558;
                  t["SF220000"] = 9557;
                  t["SF230000"] = 9571;
                  t["SF240000"] = 9553;
                  t["SF250000"] = 9559;
                  t["SF260000"] = 9565;
                  t["SF270000"] = 9564;
                  t["SF280000"] = 9563;
                  t["SF360000"] = 9566;
                  t["SF370000"] = 9567;
                  t["SF380000"] = 9562;
                  t["SF390000"] = 9556;
                  t["SF400000"] = 9577;
                  t["SF410000"] = 9574;
                  t["SF420000"] = 9568;
                  t["SF430000"] = 9552;
                  t["SF440000"] = 9580;
                  t["SF450000"] = 9575;
                  t["SF460000"] = 9576;
                  t["SF470000"] = 9572;
                  t["SF480000"] = 9573;
                  t["SF490000"] = 9561;
                  t["SF500000"] = 9560;
                  t["SF510000"] = 9554;
                  t["SF520000"] = 9555;
                  t["SF530000"] = 9579;
                  t["SF540000"] = 9578;
                  t["Sacute"] = 346;
                  t["Sacutedotaccent"] = 7780;
                  t["Sampigreek"] = 992;
                  t["Scaron"] = 352;
                  t["Scarondotaccent"] = 7782;
                  t["Scaronsmall"] = 63229;
                  t["Scedilla"] = 350;
                  t["Schwa"] = 399;
                  t["Schwacyrillic"] = 1240;
                  t["Schwadieresiscyrillic"] = 1242;
                  t["Scircle"] = 9416;
                  t["Scircumflex"] = 348;
                  t["Scommaaccent"] = 536;
                  t["Sdotaccent"] = 7776;
                  t["Sdotbelow"] = 7778;
                  t["Sdotbelowdotaccent"] = 7784;
                  t["Seharmenian"] = 1357;
                  t["Sevenroman"] = 8550;
                  t["Shaarmenian"] = 1351;
                  t["Shacyrillic"] = 1064;
                  t["Shchacyrillic"] = 1065;
                  t["Sheicoptic"] = 994;
                  t["Shhacyrillic"] = 1210;
                  t["Shimacoptic"] = 1004;
                  t["Sigma"] = 931;
                  t["Sixroman"] = 8549;
                  t["Smonospace"] = 65331;
                  t["Softsigncyrillic"] = 1068;
                  t["Ssmall"] = 63347;
                  t["Stigmagreek"] = 986;
                  t["T"] = 84;
                  t["Tau"] = 932;
                  t["Tbar"] = 358;
                  t["Tcaron"] = 356;
                  t["Tcedilla"] = 354;
                  t["Tcircle"] = 9417;
                  t["Tcircumflexbelow"] = 7792;
                  t["Tcommaaccent"] = 354;
                  t["Tdotaccent"] = 7786;
                  t["Tdotbelow"] = 7788;
                  t["Tecyrillic"] = 1058;
                  t["Tedescendercyrillic"] = 1196;
                  t["Tenroman"] = 8553;
                  t["Tetsecyrillic"] = 1204;
                  t["Theta"] = 920;
                  t["Thook"] = 428;
                  t["Thorn"] = 222;
                  t["Thornsmall"] = 63486;
                  t["Threeroman"] = 8546;
                  t["Tildesmall"] = 63230;
                  t["Tiwnarmenian"] = 1359;
                  t["Tlinebelow"] = 7790;
                  t["Tmonospace"] = 65332;
                  t["Toarmenian"] = 1337;
                  t["Tonefive"] = 444;
                  t["Tonesix"] = 388;
                  t["Tonetwo"] = 423;
                  t["Tretroflexhook"] = 430;
                  t["Tsecyrillic"] = 1062;
                  t["Tshecyrillic"] = 1035;
                  t["Tsmall"] = 63348;
                  t["Twelveroman"] = 8555;
                  t["Tworoman"] = 8545;
                  t["U"] = 85;
                  t["Uacute"] = 218;
                  t["Uacutesmall"] = 63482;
                  t["Ubreve"] = 364;
                  t["Ucaron"] = 467;
                  t["Ucircle"] = 9418;
                  t["Ucircumflex"] = 219;
                  t["Ucircumflexbelow"] = 7798;
                  t["Ucircumflexsmall"] = 63483;
                  t["Ucyrillic"] = 1059;
                  t["Udblacute"] = 368;
                  t["Udblgrave"] = 532;
                  t["Udieresis"] = 220;
                  t["Udieresisacute"] = 471;
                  t["Udieresisbelow"] = 7794;
                  t["Udieresiscaron"] = 473;
                  t["Udieresiscyrillic"] = 1264;
                  t["Udieresisgrave"] = 475;
                  t["Udieresismacron"] = 469;
                  t["Udieresissmall"] = 63484;
                  t["Udotbelow"] = 7908;
                  t["Ugrave"] = 217;
                  t["Ugravesmall"] = 63481;
                  t["Uhookabove"] = 7910;
                  t["Uhorn"] = 431;
                  t["Uhornacute"] = 7912;
                  t["Uhorndotbelow"] = 7920;
                  t["Uhorngrave"] = 7914;
                  t["Uhornhookabove"] = 7916;
                  t["Uhorntilde"] = 7918;
                  t["Uhungarumlaut"] = 368;
                  t["Uhungarumlautcyrillic"] = 1266;
                  t["Uinvertedbreve"] = 534;
                  t["Ukcyrillic"] = 1144;
                  t["Umacron"] = 362;
                  t["Umacroncyrillic"] = 1262;
                  t["Umacrondieresis"] = 7802;
                  t["Umonospace"] = 65333;
                  t["Uogonek"] = 370;
                  t["Upsilon"] = 933;
                  t["Upsilon1"] = 978;
                  t["Upsilonacutehooksymbolgreek"] = 979;
                  t["Upsilonafrican"] = 433;
                  t["Upsilondieresis"] = 939;
                  t["Upsilondieresishooksymbolgreek"] = 980;
                  t["Upsilonhooksymbol"] = 978;
                  t["Upsilontonos"] = 910;
                  t["Uring"] = 366;
                  t["Ushortcyrillic"] = 1038;
                  t["Usmall"] = 63349;
                  t["Ustraightcyrillic"] = 1198;
                  t["Ustraightstrokecyrillic"] = 1200;
                  t["Utilde"] = 360;
                  t["Utildeacute"] = 7800;
                  t["Utildebelow"] = 7796;
                  t["V"] = 86;
                  t["Vcircle"] = 9419;
                  t["Vdotbelow"] = 7806;
                  t["Vecyrillic"] = 1042;
                  t["Vewarmenian"] = 1358;
                  t["Vhook"] = 434;
                  t["Vmonospace"] = 65334;
                  t["Voarmenian"] = 1352;
                  t["Vsmall"] = 63350;
                  t["Vtilde"] = 7804;
                  t["W"] = 87;
                  t["Wacute"] = 7810;
                  t["Wcircle"] = 9420;
                  t["Wcircumflex"] = 372;
                  t["Wdieresis"] = 7812;
                  t["Wdotaccent"] = 7814;
                  t["Wdotbelow"] = 7816;
                  t["Wgrave"] = 7808;
                  t["Wmonospace"] = 65335;
                  t["Wsmall"] = 63351;
                  t["X"] = 88;
                  t["Xcircle"] = 9421;
                  t["Xdieresis"] = 7820;
                  t["Xdotaccent"] = 7818;
                  t["Xeharmenian"] = 1341;
                  t["Xi"] = 926;
                  t["Xmonospace"] = 65336;
                  t["Xsmall"] = 63352;
                  t["Y"] = 89;
                  t["Yacute"] = 221;
                  t["Yacutesmall"] = 63485;
                  t["Yatcyrillic"] = 1122;
                  t["Ycircle"] = 9422;
                  t["Ycircumflex"] = 374;
                  t["Ydieresis"] = 376;
                  t["Ydieresissmall"] = 63487;
                  t["Ydotaccent"] = 7822;
                  t["Ydotbelow"] = 7924;
                  t["Yericyrillic"] = 1067;
                  t["Yerudieresiscyrillic"] = 1272;
                  t["Ygrave"] = 7922;
                  t["Yhook"] = 435;
                  t["Yhookabove"] = 7926;
                  t["Yiarmenian"] = 1349;
                  t["Yicyrillic"] = 1031;
                  t["Yiwnarmenian"] = 1362;
                  t["Ymonospace"] = 65337;
                  t["Ysmall"] = 63353;
                  t["Ytilde"] = 7928;
                  t["Yusbigcyrillic"] = 1130;
                  t["Yusbigiotifiedcyrillic"] = 1132;
                  t["Yuslittlecyrillic"] = 1126;
                  t["Yuslittleiotifiedcyrillic"] = 1128;
                  t["Z"] = 90;
                  t["Zaarmenian"] = 1334;
                  t["Zacute"] = 377;
                  t["Zcaron"] = 381;
                  t["Zcaronsmall"] = 63231;
                  t["Zcircle"] = 9423;
                  t["Zcircumflex"] = 7824;
                  t["Zdot"] = 379;
                  t["Zdotaccent"] = 379;
                  t["Zdotbelow"] = 7826;
                  t["Zecyrillic"] = 1047;
                  t["Zedescendercyrillic"] = 1176;
                  t["Zedieresiscyrillic"] = 1246;
                  t["Zeta"] = 918;
                  t["Zhearmenian"] = 1338;
                  t["Zhebrevecyrillic"] = 1217;
                  t["Zhecyrillic"] = 1046;
                  t["Zhedescendercyrillic"] = 1174;
                  t["Zhedieresiscyrillic"] = 1244;
                  t["Zlinebelow"] = 7828;
                  t["Zmonospace"] = 65338;
                  t["Zsmall"] = 63354;
                  t["Zstroke"] = 437;
                  t["a"] = 97;
                  t["aabengali"] = 2438;
                  t["aacute"] = 225;
                  t["aadeva"] = 2310;
                  t["aagujarati"] = 2694;
                  t["aagurmukhi"] = 2566;
                  t["aamatragurmukhi"] = 2622;
                  t["aarusquare"] = 13059;
                  t["aavowelsignbengali"] = 2494;
                  t["aavowelsigndeva"] = 2366;
                  t["aavowelsigngujarati"] = 2750;
                  t["abbreviationmarkarmenian"] = 1375;
                  t["abbreviationsigndeva"] = 2416;
                  t["abengali"] = 2437;
                  t["abopomofo"] = 12570;
                  t["abreve"] = 259;
                  t["abreveacute"] = 7855;
                  t["abrevecyrillic"] = 1233;
                  t["abrevedotbelow"] = 7863;
                  t["abrevegrave"] = 7857;
                  t["abrevehookabove"] = 7859;
                  t["abrevetilde"] = 7861;
                  t["acaron"] = 462;
                  t["acircle"] = 9424;
                  t["acircumflex"] = 226;
                  t["acircumflexacute"] = 7845;
                  t["acircumflexdotbelow"] = 7853;
                  t["acircumflexgrave"] = 7847;
                  t["acircumflexhookabove"] = 7849;
                  t["acircumflextilde"] = 7851;
                  t["acute"] = 180;
                  t["acutebelowcmb"] = 791;
                  t["acutecmb"] = 769;
                  t["acutecomb"] = 769;
                  t["acutedeva"] = 2388;
                  t["acutelowmod"] = 719;
                  t["acutetonecmb"] = 833;
                  t["acyrillic"] = 1072;
                  t["adblgrave"] = 513;
                  t["addakgurmukhi"] = 2673;
                  t["adeva"] = 2309;
                  t["adieresis"] = 228;
                  t["adieresiscyrillic"] = 1235;
                  t["adieresismacron"] = 479;
                  t["adotbelow"] = 7841;
                  t["adotmacron"] = 481;
                  t["ae"] = 230;
                  t["aeacute"] = 509;
                  t["aekorean"] = 12624;
                  t["aemacron"] = 483;
                  t["afii00208"] = 8213;
                  t["afii08941"] = 8356;
                  t["afii10017"] = 1040;
                  t["afii10018"] = 1041;
                  t["afii10019"] = 1042;
                  t["afii10020"] = 1043;
                  t["afii10021"] = 1044;
                  t["afii10022"] = 1045;
                  t["afii10023"] = 1025;
                  t["afii10024"] = 1046;
                  t["afii10025"] = 1047;
                  t["afii10026"] = 1048;
                  t["afii10027"] = 1049;
                  t["afii10028"] = 1050;
                  t["afii10029"] = 1051;
                  t["afii10030"] = 1052;
                  t["afii10031"] = 1053;
                  t["afii10032"] = 1054;
                  t["afii10033"] = 1055;
                  t["afii10034"] = 1056;
                  t["afii10035"] = 1057;
                  t["afii10036"] = 1058;
                  t["afii10037"] = 1059;
                  t["afii10038"] = 1060;
                  t["afii10039"] = 1061;
                  t["afii10040"] = 1062;
                  t["afii10041"] = 1063;
                  t["afii10042"] = 1064;
                  t["afii10043"] = 1065;
                  t["afii10044"] = 1066;
                  t["afii10045"] = 1067;
                  t["afii10046"] = 1068;
                  t["afii10047"] = 1069;
                  t["afii10048"] = 1070;
                  t["afii10049"] = 1071;
                  t["afii10050"] = 1168;
                  t["afii10051"] = 1026;
                  t["afii10052"] = 1027;
                  t["afii10053"] = 1028;
                  t["afii10054"] = 1029;
                  t["afii10055"] = 1030;
                  t["afii10056"] = 1031;
                  t["afii10057"] = 1032;
                  t["afii10058"] = 1033;
                  t["afii10059"] = 1034;
                  t["afii10060"] = 1035;
                  t["afii10061"] = 1036;
                  t["afii10062"] = 1038;
                  t["afii10063"] = 63172;
                  t["afii10064"] = 63173;
                  t["afii10065"] = 1072;
                  t["afii10066"] = 1073;
                  t["afii10067"] = 1074;
                  t["afii10068"] = 1075;
                  t["afii10069"] = 1076;
                  t["afii10070"] = 1077;
                  t["afii10071"] = 1105;
                  t["afii10072"] = 1078;
                  t["afii10073"] = 1079;
                  t["afii10074"] = 1080;
                  t["afii10075"] = 1081;
                  t["afii10076"] = 1082;
                  t["afii10077"] = 1083;
                  t["afii10078"] = 1084;
                  t["afii10079"] = 1085;
                  t["afii10080"] = 1086;
                  t["afii10081"] = 1087;
                  t["afii10082"] = 1088;
                  t["afii10083"] = 1089;
                  t["afii10084"] = 1090;
                  t["afii10085"] = 1091;
                  t["afii10086"] = 1092;
                  t["afii10087"] = 1093;
                  t["afii10088"] = 1094;
                  t["afii10089"] = 1095;
                  t["afii10090"] = 1096;
                  t["afii10091"] = 1097;
                  t["afii10092"] = 1098;
                  t["afii10093"] = 1099;
                  t["afii10094"] = 1100;
                  t["afii10095"] = 1101;
                  t["afii10096"] = 1102;
                  t["afii10097"] = 1103;
                  t["afii10098"] = 1169;
                  t["afii10099"] = 1106;
                  t["afii10100"] = 1107;
                  t["afii10101"] = 1108;
                  t["afii10102"] = 1109;
                  t["afii10103"] = 1110;
                  t["afii10104"] = 1111;
                  t["afii10105"] = 1112;
                  t["afii10106"] = 1113;
                  t["afii10107"] = 1114;
                  t["afii10108"] = 1115;
                  t["afii10109"] = 1116;
                  t["afii10110"] = 1118;
                  t["afii10145"] = 1039;
                  t["afii10146"] = 1122;
                  t["afii10147"] = 1138;
                  t["afii10148"] = 1140;
                  t["afii10192"] = 63174;
                  t["afii10193"] = 1119;
                  t["afii10194"] = 1123;
                  t["afii10195"] = 1139;
                  t["afii10196"] = 1141;
                  t["afii10831"] = 63175;
                  t["afii10832"] = 63176;
                  t["afii10846"] = 1241;
                  t["afii299"] = 8206;
                  t["afii300"] = 8207;
                  t["afii301"] = 8205;
                  t["afii57381"] = 1642;
                  t["afii57388"] = 1548;
                  t["afii57392"] = 1632;
                  t["afii57393"] = 1633;
                  t["afii57394"] = 1634;
                  t["afii57395"] = 1635;
                  t["afii57396"] = 1636;
                  t["afii57397"] = 1637;
                  t["afii57398"] = 1638;
                  t["afii57399"] = 1639;
                  t["afii57400"] = 1640;
                  t["afii57401"] = 1641;
                  t["afii57403"] = 1563;
                  t["afii57407"] = 1567;
                  t["afii57409"] = 1569;
                  t["afii57410"] = 1570;
                  t["afii57411"] = 1571;
                  t["afii57412"] = 1572;
                  t["afii57413"] = 1573;
                  t["afii57414"] = 1574;
                  t["afii57415"] = 1575;
                  t["afii57416"] = 1576;
                  t["afii57417"] = 1577;
                  t["afii57418"] = 1578;
                  t["afii57419"] = 1579;
                  t["afii57420"] = 1580;
                  t["afii57421"] = 1581;
                  t["afii57422"] = 1582;
                  t["afii57423"] = 1583;
                  t["afii57424"] = 1584;
                  t["afii57425"] = 1585;
                  t["afii57426"] = 1586;
                  t["afii57427"] = 1587;
                  t["afii57428"] = 1588;
                  t["afii57429"] = 1589;
                  t["afii57430"] = 1590;
                  t["afii57431"] = 1591;
                  t["afii57432"] = 1592;
                  t["afii57433"] = 1593;
                  t["afii57434"] = 1594;
                  t["afii57440"] = 1600;
                  t["afii57441"] = 1601;
                  t["afii57442"] = 1602;
                  t["afii57443"] = 1603;
                  t["afii57444"] = 1604;
                  t["afii57445"] = 1605;
                  t["afii57446"] = 1606;
                  t["afii57448"] = 1608;
                  t["afii57449"] = 1609;
                  t["afii57450"] = 1610;
                  t["afii57451"] = 1611;
                  t["afii57452"] = 1612;
                  t["afii57453"] = 1613;
                  t["afii57454"] = 1614;
                  t["afii57455"] = 1615;
                  t["afii57456"] = 1616;
                  t["afii57457"] = 1617;
                  t["afii57458"] = 1618;
                  t["afii57470"] = 1607;
                  t["afii57505"] = 1700;
                  t["afii57506"] = 1662;
                  t["afii57507"] = 1670;
                  t["afii57508"] = 1688;
                  t["afii57509"] = 1711;
                  t["afii57511"] = 1657;
                  t["afii57512"] = 1672;
                  t["afii57513"] = 1681;
                  t["afii57514"] = 1722;
                  t["afii57519"] = 1746;
                  t["afii57534"] = 1749;
                  t["afii57636"] = 8362;
                  t["afii57645"] = 1470;
                  t["afii57658"] = 1475;
                  t["afii57664"] = 1488;
                  t["afii57665"] = 1489;
                  t["afii57666"] = 1490;
                  t["afii57667"] = 1491;
                  t["afii57668"] = 1492;
                  t["afii57669"] = 1493;
                  t["afii57670"] = 1494;
                  t["afii57671"] = 1495;
                  t["afii57672"] = 1496;
                  t["afii57673"] = 1497;
                  t["afii57674"] = 1498;
                  t["afii57675"] = 1499;
                  t["afii57676"] = 1500;
                  t["afii57677"] = 1501;
                  t["afii57678"] = 1502;
                  t["afii57679"] = 1503;
                  t["afii57680"] = 1504;
                  t["afii57681"] = 1505;
                  t["afii57682"] = 1506;
                  t["afii57683"] = 1507;
                  t["afii57684"] = 1508;
                  t["afii57685"] = 1509;
                  t["afii57686"] = 1510;
                  t["afii57687"] = 1511;
                  t["afii57688"] = 1512;
                  t["afii57689"] = 1513;
                  t["afii57690"] = 1514;
                  t["afii57694"] = 64298;
                  t["afii57695"] = 64299;
                  t["afii57700"] = 64331;
                  t["afii57705"] = 64287;
                  t["afii57716"] = 1520;
                  t["afii57717"] = 1521;
                  t["afii57718"] = 1522;
                  t["afii57723"] = 64309;
                  t["afii57793"] = 1460;
                  t["afii57794"] = 1461;
                  t["afii57795"] = 1462;
                  t["afii57796"] = 1467;
                  t["afii57797"] = 1464;
                  t["afii57798"] = 1463;
                  t["afii57799"] = 1456;
                  t["afii57800"] = 1458;
                  t["afii57801"] = 1457;
                  t["afii57802"] = 1459;
                  t["afii57803"] = 1474;
                  t["afii57804"] = 1473;
                  t["afii57806"] = 1465;
                  t["afii57807"] = 1468;
                  t["afii57839"] = 1469;
                  t["afii57841"] = 1471;
                  t["afii57842"] = 1472;
                  t["afii57929"] = 700;
                  t["afii61248"] = 8453;
                  t["afii61289"] = 8467;
                  t["afii61352"] = 8470;
                  t["afii61573"] = 8236;
                  t["afii61574"] = 8237;
                  t["afii61575"] = 8238;
                  t["afii61664"] = 8204;
                  t["afii63167"] = 1645;
                  t["afii64937"] = 701;
                  t["agrave"] = 224;
                  t["agujarati"] = 2693;
                  t["agurmukhi"] = 2565;
                  t["ahiragana"] = 12354;
                  t["ahookabove"] = 7843;
                  t["aibengali"] = 2448;
                  t["aibopomofo"] = 12574;
                  t["aideva"] = 2320;
                  t["aiecyrillic"] = 1237;
                  t["aigujarati"] = 2704;
                  t["aigurmukhi"] = 2576;
                  t["aimatragurmukhi"] = 2632;
                  t["ainarabic"] = 1593;
                  t["ainfinalarabic"] = 65226;
                  t["aininitialarabic"] = 65227;
                  t["ainmedialarabic"] = 65228;
                  t["ainvertedbreve"] = 515;
                  t["aivowelsignbengali"] = 2504;
                  t["aivowelsigndeva"] = 2376;
                  t["aivowelsigngujarati"] = 2760;
                  t["akatakana"] = 12450;
                  t["akatakanahalfwidth"] = 65393;
                  t["akorean"] = 12623;
                  t["alef"] = 1488;
                  t["alefarabic"] = 1575;
                  t["alefdageshhebrew"] = 64304;
                  t["aleffinalarabic"] = 65166;
                  t["alefhamzaabovearabic"] = 1571;
                  t["alefhamzaabovefinalarabic"] = 65156;
                  t["alefhamzabelowarabic"] = 1573;
                  t["alefhamzabelowfinalarabic"] = 65160;
                  t["alefhebrew"] = 1488;
                  t["aleflamedhebrew"] = 64335;
                  t["alefmaddaabovearabic"] = 1570;
                  t["alefmaddaabovefinalarabic"] = 65154;
                  t["alefmaksuraarabic"] = 1609;
                  t["alefmaksurafinalarabic"] = 65264;
                  t["alefmaksurainitialarabic"] = 65267;
                  t["alefmaksuramedialarabic"] = 65268;
                  t["alefpatahhebrew"] = 64302;
                  t["alefqamatshebrew"] = 64303;
                  t["aleph"] = 8501;
                  t["allequal"] = 8780;
                  t["alpha"] = 945;
                  t["alphatonos"] = 940;
                  t["amacron"] = 257;
                  t["amonospace"] = 65345;
                  t["ampersand"] = 38;
                  t["ampersandmonospace"] = 65286;
                  t["ampersandsmall"] = 63270;
                  t["amsquare"] = 13250;
                  t["anbopomofo"] = 12578;
                  t["angbopomofo"] = 12580;
                  t["angbracketleft"] = 12296;
                  t["angbracketright"] = 12297;
                  t["angkhankhuthai"] = 3674;
                  t["angle"] = 8736;
                  t["anglebracketleft"] = 12296;
                  t["anglebracketleftvertical"] = 65087;
                  t["anglebracketright"] = 12297;
                  t["anglebracketrightvertical"] = 65088;
                  t["angleleft"] = 9001;
                  t["angleright"] = 9002;
                  t["angstrom"] = 8491;
                  t["anoteleia"] = 903;
                  t["anudattadeva"] = 2386;
                  t["anusvarabengali"] = 2434;
                  t["anusvaradeva"] = 2306;
                  t["anusvaragujarati"] = 2690;
                  t["aogonek"] = 261;
                  t["apaatosquare"] = 13056;
                  t["aparen"] = 9372;
                  t["apostrophearmenian"] = 1370;
                  t["apostrophemod"] = 700;
                  t["apple"] = 63743;
                  t["approaches"] = 8784;
                  t["approxequal"] = 8776;
                  t["approxequalorimage"] = 8786;
                  t["approximatelyequal"] = 8773;
                  t["araeaekorean"] = 12686;
                  t["araeakorean"] = 12685;
                  t["arc"] = 8978;
                  t["arighthalfring"] = 7834;
                  t["aring"] = 229;
                  t["aringacute"] = 507;
                  t["aringbelow"] = 7681;
                  t["arrowboth"] = 8596;
                  t["arrowdashdown"] = 8675;
                  t["arrowdashleft"] = 8672;
                  t["arrowdashright"] = 8674;
                  t["arrowdashup"] = 8673;
                  t["arrowdblboth"] = 8660;
                  t["arrowdbldown"] = 8659;
                  t["arrowdblleft"] = 8656;
                  t["arrowdblright"] = 8658;
                  t["arrowdblup"] = 8657;
                  t["arrowdown"] = 8595;
                  t["arrowdownleft"] = 8601;
                  t["arrowdownright"] = 8600;
                  t["arrowdownwhite"] = 8681;
                  t["arrowheaddownmod"] = 709;
                  t["arrowheadleftmod"] = 706;
                  t["arrowheadrightmod"] = 707;
                  t["arrowheadupmod"] = 708;
                  t["arrowhorizex"] = 63719;
                  t["arrowleft"] = 8592;
                  t["arrowleftdbl"] = 8656;
                  t["arrowleftdblstroke"] = 8653;
                  t["arrowleftoverright"] = 8646;
                  t["arrowleftwhite"] = 8678;
                  t["arrowright"] = 8594;
                  t["arrowrightdblstroke"] = 8655;
                  t["arrowrightheavy"] = 10142;
                  t["arrowrightoverleft"] = 8644;
                  t["arrowrightwhite"] = 8680;
                  t["arrowtableft"] = 8676;
                  t["arrowtabright"] = 8677;
                  t["arrowup"] = 8593;
                  t["arrowupdn"] = 8597;
                  t["arrowupdnbse"] = 8616;
                  t["arrowupdownbase"] = 8616;
                  t["arrowupleft"] = 8598;
                  t["arrowupleftofdown"] = 8645;
                  t["arrowupright"] = 8599;
                  t["arrowupwhite"] = 8679;
                  t["arrowvertex"] = 63718;
                  t["asciicircum"] = 94;
                  t["asciicircummonospace"] = 65342;
                  t["asciitilde"] = 126;
                  t["asciitildemonospace"] = 65374;
                  t["ascript"] = 593;
                  t["ascriptturned"] = 594;
                  t["asmallhiragana"] = 12353;
                  t["asmallkatakana"] = 12449;
                  t["asmallkatakanahalfwidth"] = 65383;
                  t["asterisk"] = 42;
                  t["asteriskaltonearabic"] = 1645;
                  t["asteriskarabic"] = 1645;
                  t["asteriskmath"] = 8727;
                  t["asteriskmonospace"] = 65290;
                  t["asterisksmall"] = 65121;
                  t["asterism"] = 8258;
                  t["asuperior"] = 63209;
                  t["asymptoticallyequal"] = 8771;
                  t["at"] = 64;
                  t["atilde"] = 227;
                  t["atmonospace"] = 65312;
                  t["atsmall"] = 65131;
                  t["aturned"] = 592;
                  t["aubengali"] = 2452;
                  t["aubopomofo"] = 12576;
                  t["audeva"] = 2324;
                  t["augujarati"] = 2708;
                  t["augurmukhi"] = 2580;
                  t["aulengthmarkbengali"] = 2519;
                  t["aumatragurmukhi"] = 2636;
                  t["auvowelsignbengali"] = 2508;
                  t["auvowelsigndeva"] = 2380;
                  t["auvowelsigngujarati"] = 2764;
                  t["avagrahadeva"] = 2365;
                  t["aybarmenian"] = 1377;
                  t["ayin"] = 1506;
                  t["ayinaltonehebrew"] = 64288;
                  t["ayinhebrew"] = 1506;
                  t["b"] = 98;
                  t["babengali"] = 2476;
                  t["backslash"] = 92;
                  t["backslashmonospace"] = 65340;
                  t["badeva"] = 2348;
                  t["bagujarati"] = 2732;
                  t["bagurmukhi"] = 2604;
                  t["bahiragana"] = 12400;
                  t["bahtthai"] = 3647;
                  t["bakatakana"] = 12496;
                  t["bar"] = 124;
                  t["barmonospace"] = 65372;
                  t["bbopomofo"] = 12549;
                  t["bcircle"] = 9425;
                  t["bdotaccent"] = 7683;
                  t["bdotbelow"] = 7685;
                  t["beamedsixteenthnotes"] = 9836;
                  t["because"] = 8757;
                  t["becyrillic"] = 1073;
                  t["beharabic"] = 1576;
                  t["behfinalarabic"] = 65168;
                  t["behinitialarabic"] = 65169;
                  t["behiragana"] = 12409;
                  t["behmedialarabic"] = 65170;
                  t["behmeeminitialarabic"] = 64671;
                  t["behmeemisolatedarabic"] = 64520;
                  t["behnoonfinalarabic"] = 64621;
                  t["bekatakana"] = 12505;
                  t["benarmenian"] = 1378;
                  t["bet"] = 1489;
                  t["beta"] = 946;
                  t["betasymbolgreek"] = 976;
                  t["betdagesh"] = 64305;
                  t["betdageshhebrew"] = 64305;
                  t["bethebrew"] = 1489;
                  t["betrafehebrew"] = 64332;
                  t["bhabengali"] = 2477;
                  t["bhadeva"] = 2349;
                  t["bhagujarati"] = 2733;
                  t["bhagurmukhi"] = 2605;
                  t["bhook"] = 595;
                  t["bihiragana"] = 12403;
                  t["bikatakana"] = 12499;
                  t["bilabialclick"] = 664;
                  t["bindigurmukhi"] = 2562;
                  t["birusquare"] = 13105;
                  t["blackcircle"] = 9679;
                  t["blackdiamond"] = 9670;
                  t["blackdownpointingtriangle"] = 9660;
                  t["blackleftpointingpointer"] = 9668;
                  t["blackleftpointingtriangle"] = 9664;
                  t["blacklenticularbracketleft"] = 12304;
                  t["blacklenticularbracketleftvertical"] = 65083;
                  t["blacklenticularbracketright"] = 12305;
                  t["blacklenticularbracketrightvertical"] = 65084;
                  t["blacklowerlefttriangle"] = 9699;
                  t["blacklowerrighttriangle"] = 9698;
                  t["blackrectangle"] = 9644;
                  t["blackrightpointingpointer"] = 9658;
                  t["blackrightpointingtriangle"] = 9654;
                  t["blacksmallsquare"] = 9642;
                  t["blacksmilingface"] = 9787;
                  t["blacksquare"] = 9632;
                  t["blackstar"] = 9733;
                  t["blackupperlefttriangle"] = 9700;
                  t["blackupperrighttriangle"] = 9701;
                  t["blackuppointingsmalltriangle"] = 9652;
                  t["blackuppointingtriangle"] = 9650;
                  t["blank"] = 9251;
                  t["blinebelow"] = 7687;
                  t["block"] = 9608;
                  t["bmonospace"] = 65346;
                  t["bobaimaithai"] = 3610;
                  t["bohiragana"] = 12412;
                  t["bokatakana"] = 12508;
                  t["bparen"] = 9373;
                  t["bqsquare"] = 13251;
                  t["braceex"] = 63732;
                  t["braceleft"] = 123;
                  t["braceleftbt"] = 63731;
                  t["braceleftmid"] = 63730;
                  t["braceleftmonospace"] = 65371;
                  t["braceleftsmall"] = 65115;
                  t["bracelefttp"] = 63729;
                  t["braceleftvertical"] = 65079;
                  t["braceright"] = 125;
                  t["bracerightbt"] = 63742;
                  t["bracerightmid"] = 63741;
                  t["bracerightmonospace"] = 65373;
                  t["bracerightsmall"] = 65116;
                  t["bracerighttp"] = 63740;
                  t["bracerightvertical"] = 65080;
                  t["bracketleft"] = 91;
                  t["bracketleftbt"] = 63728;
                  t["bracketleftex"] = 63727;
                  t["bracketleftmonospace"] = 65339;
                  t["bracketlefttp"] = 63726;
                  t["bracketright"] = 93;
                  t["bracketrightbt"] = 63739;
                  t["bracketrightex"] = 63738;
                  t["bracketrightmonospace"] = 65341;
                  t["bracketrighttp"] = 63737;
                  t["breve"] = 728;
                  t["brevebelowcmb"] = 814;
                  t["brevecmb"] = 774;
                  t["breveinvertedbelowcmb"] = 815;
                  t["breveinvertedcmb"] = 785;
                  t["breveinverteddoublecmb"] = 865;
                  t["bridgebelowcmb"] = 810;
                  t["bridgeinvertedbelowcmb"] = 826;
                  t["brokenbar"] = 166;
                  t["bstroke"] = 384;
                  t["bsuperior"] = 63210;
                  t["btopbar"] = 387;
                  t["buhiragana"] = 12406;
                  t["bukatakana"] = 12502;
                  t["bullet"] = 8226;
                  t["bulletinverse"] = 9688;
                  t["bulletoperator"] = 8729;
                  t["bullseye"] = 9678;
                  t["c"] = 99;
                  t["caarmenian"] = 1390;
                  t["cabengali"] = 2458;
                  t["cacute"] = 263;
                  t["cadeva"] = 2330;
                  t["cagujarati"] = 2714;
                  t["cagurmukhi"] = 2586;
                  t["calsquare"] = 13192;
                  t["candrabindubengali"] = 2433;
                  t["candrabinducmb"] = 784;
                  t["candrabindudeva"] = 2305;
                  t["candrabindugujarati"] = 2689;
                  t["capslock"] = 8682;
                  t["careof"] = 8453;
                  t["caron"] = 711;
                  t["caronbelowcmb"] = 812;
                  t["caroncmb"] = 780;
                  t["carriagereturn"] = 8629;
                  t["cbopomofo"] = 12568;
                  t["ccaron"] = 269;
                  t["ccedilla"] = 231;
                  t["ccedillaacute"] = 7689;
                  t["ccircle"] = 9426;
                  t["ccircumflex"] = 265;
                  t["ccurl"] = 597;
                  t["cdot"] = 267;
                  t["cdotaccent"] = 267;
                  t["cdsquare"] = 13253;
                  t["cedilla"] = 184;
                  t["cedillacmb"] = 807;
                  t["cent"] = 162;
                  t["centigrade"] = 8451;
                  t["centinferior"] = 63199;
                  t["centmonospace"] = 65504;
                  t["centoldstyle"] = 63394;
                  t["centsuperior"] = 63200;
                  t["chaarmenian"] = 1401;
                  t["chabengali"] = 2459;
                  t["chadeva"] = 2331;
                  t["chagujarati"] = 2715;
                  t["chagurmukhi"] = 2587;
                  t["chbopomofo"] = 12564;
                  t["cheabkhasiancyrillic"] = 1213;
                  t["checkmark"] = 10003;
                  t["checyrillic"] = 1095;
                  t["chedescenderabkhasiancyrillic"] = 1215;
                  t["chedescendercyrillic"] = 1207;
                  t["chedieresiscyrillic"] = 1269;
                  t["cheharmenian"] = 1395;
                  t["chekhakassiancyrillic"] = 1228;
                  t["cheverticalstrokecyrillic"] = 1209;
                  t["chi"] = 967;
                  t["chieuchacirclekorean"] = 12919;
                  t["chieuchaparenkorean"] = 12823;
                  t["chieuchcirclekorean"] = 12905;
                  t["chieuchkorean"] = 12618;
                  t["chieuchparenkorean"] = 12809;
                  t["chochangthai"] = 3594;
                  t["chochanthai"] = 3592;
                  t["chochingthai"] = 3593;
                  t["chochoethai"] = 3596;
                  t["chook"] = 392;
                  t["cieucacirclekorean"] = 12918;
                  t["cieucaparenkorean"] = 12822;
                  t["cieuccirclekorean"] = 12904;
                  t["cieuckorean"] = 12616;
                  t["cieucparenkorean"] = 12808;
                  t["cieucuparenkorean"] = 12828;
                  t["circle"] = 9675;
                  t["circlecopyrt"] = 169;
                  t["circlemultiply"] = 8855;
                  t["circleot"] = 8857;
                  t["circleplus"] = 8853;
                  t["circlepostalmark"] = 12342;
                  t["circlewithlefthalfblack"] = 9680;
                  t["circlewithrighthalfblack"] = 9681;
                  t["circumflex"] = 710;
                  t["circumflexbelowcmb"] = 813;
                  t["circumflexcmb"] = 770;
                  t["clear"] = 8999;
                  t["clickalveolar"] = 450;
                  t["clickdental"] = 448;
                  t["clicklateral"] = 449;
                  t["clickretroflex"] = 451;
                  t["club"] = 9827;
                  t["clubsuitblack"] = 9827;
                  t["clubsuitwhite"] = 9831;
                  t["cmcubedsquare"] = 13220;
                  t["cmonospace"] = 65347;
                  t["cmsquaredsquare"] = 13216;
                  t["coarmenian"] = 1409;
                  t["colon"] = 58;
                  t["colonmonetary"] = 8353;
                  t["colonmonospace"] = 65306;
                  t["colonsign"] = 8353;
                  t["colonsmall"] = 65109;
                  t["colontriangularhalfmod"] = 721;
                  t["colontriangularmod"] = 720;
                  t["comma"] = 44;
                  t["commaabovecmb"] = 787;
                  t["commaaboverightcmb"] = 789;
                  t["commaaccent"] = 63171;
                  t["commaarabic"] = 1548;
                  t["commaarmenian"] = 1373;
                  t["commainferior"] = 63201;
                  t["commamonospace"] = 65292;
                  t["commareversedabovecmb"] = 788;
                  t["commareversedmod"] = 701;
                  t["commasmall"] = 65104;
                  t["commasuperior"] = 63202;
                  t["commaturnedabovecmb"] = 786;
                  t["commaturnedmod"] = 699;
                  t["compass"] = 9788;
                  t["congruent"] = 8773;
                  t["contourintegral"] = 8750;
                  t["control"] = 8963;
                  t["controlACK"] = 6;
                  t["controlBEL"] = 7;
                  t["controlBS"] = 8;
                  t["controlCAN"] = 24;
                  t["controlCR"] = 13;
                  t["controlDC1"] = 17;
                  t["controlDC2"] = 18;
                  t["controlDC3"] = 19;
                  t["controlDC4"] = 20;
                  t["controlDEL"] = 127;
                  t["controlDLE"] = 16;
                  t["controlEM"] = 25;
                  t["controlENQ"] = 5;
                  t["controlEOT"] = 4;
                  t["controlESC"] = 27;
                  t["controlETB"] = 23;
                  t["controlETX"] = 3;
                  t["controlFF"] = 12;
                  t["controlFS"] = 28;
                  t["controlGS"] = 29;
                  t["controlHT"] = 9;
                  t["controlLF"] = 10;
                  t["controlNAK"] = 21;
                  t["controlNULL"] = 0;
                  t["controlRS"] = 30;
                  t["controlSI"] = 15;
                  t["controlSO"] = 14;
                  t["controlSOT"] = 2;
                  t["controlSTX"] = 1;
                  t["controlSUB"] = 26;
                  t["controlSYN"] = 22;
                  t["controlUS"] = 31;
                  t["controlVT"] = 11;
                  t["copyright"] = 169;
                  t["copyrightsans"] = 63721;
                  t["copyrightserif"] = 63193;
                  t["cornerbracketleft"] = 12300;
                  t["cornerbracketlefthalfwidth"] = 65378;
                  t["cornerbracketleftvertical"] = 65089;
                  t["cornerbracketright"] = 12301;
                  t["cornerbracketrighthalfwidth"] = 65379;
                  t["cornerbracketrightvertical"] = 65090;
                  t["corporationsquare"] = 13183;
                  t["cosquare"] = 13255;
                  t["coverkgsquare"] = 13254;
                  t["cparen"] = 9374;
                  t["cruzeiro"] = 8354;
                  t["cstretched"] = 663;
                  t["curlyand"] = 8911;
                  t["curlyor"] = 8910;
                  t["currency"] = 164;
                  t["cyrBreve"] = 63185;
                  t["cyrFlex"] = 63186;
                  t["cyrbreve"] = 63188;
                  t["cyrflex"] = 63189;
                  t["d"] = 100;
                  t["daarmenian"] = 1380;
                  t["dabengali"] = 2470;
                  t["dadarabic"] = 1590;
                  t["dadeva"] = 2342;
                  t["dadfinalarabic"] = 65214;
                  t["dadinitialarabic"] = 65215;
                  t["dadmedialarabic"] = 65216;
                  t["dagesh"] = 1468;
                  t["dageshhebrew"] = 1468;
                  t["dagger"] = 8224;
                  t["daggerdbl"] = 8225;
                  t["dagujarati"] = 2726;
                  t["dagurmukhi"] = 2598;
                  t["dahiragana"] = 12384;
                  t["dakatakana"] = 12480;
                  t["dalarabic"] = 1583;
                  t["dalet"] = 1491;
                  t["daletdagesh"] = 64307;
                  t["daletdageshhebrew"] = 64307;
                  t["dalethebrew"] = 1491;
                  t["dalfinalarabic"] = 65194;
                  t["dammaarabic"] = 1615;
                  t["dammalowarabic"] = 1615;
                  t["dammatanaltonearabic"] = 1612;
                  t["dammatanarabic"] = 1612;
                  t["danda"] = 2404;
                  t["dargahebrew"] = 1447;
                  t["dargalefthebrew"] = 1447;
                  t["dasiapneumatacyrilliccmb"] = 1157;
                  t["dblGrave"] = 63187;
                  t["dblanglebracketleft"] = 12298;
                  t["dblanglebracketleftvertical"] = 65085;
                  t["dblanglebracketright"] = 12299;
                  t["dblanglebracketrightvertical"] = 65086;
                  t["dblarchinvertedbelowcmb"] = 811;
                  t["dblarrowleft"] = 8660;
                  t["dblarrowright"] = 8658;
                  t["dbldanda"] = 2405;
                  t["dblgrave"] = 63190;
                  t["dblgravecmb"] = 783;
                  t["dblintegral"] = 8748;
                  t["dbllowline"] = 8215;
                  t["dbllowlinecmb"] = 819;
                  t["dbloverlinecmb"] = 831;
                  t["dblprimemod"] = 698;
                  t["dblverticalbar"] = 8214;
                  t["dblverticallineabovecmb"] = 782;
                  t["dbopomofo"] = 12553;
                  t["dbsquare"] = 13256;
                  t["dcaron"] = 271;
                  t["dcedilla"] = 7697;
                  t["dcircle"] = 9427;
                  t["dcircumflexbelow"] = 7699;
                  t["dcroat"] = 273;
                  t["ddabengali"] = 2465;
                  t["ddadeva"] = 2337;
                  t["ddagujarati"] = 2721;
                  t["ddagurmukhi"] = 2593;
                  t["ddalarabic"] = 1672;
                  t["ddalfinalarabic"] = 64393;
                  t["dddhadeva"] = 2396;
                  t["ddhabengali"] = 2466;
                  t["ddhadeva"] = 2338;
                  t["ddhagujarati"] = 2722;
                  t["ddhagurmukhi"] = 2594;
                  t["ddotaccent"] = 7691;
                  t["ddotbelow"] = 7693;
                  t["decimalseparatorarabic"] = 1643;
                  t["decimalseparatorpersian"] = 1643;
                  t["decyrillic"] = 1076;
                  t["degree"] = 176;
                  t["dehihebrew"] = 1453;
                  t["dehiragana"] = 12391;
                  t["deicoptic"] = 1007;
                  t["dekatakana"] = 12487;
                  t["deleteleft"] = 9003;
                  t["deleteright"] = 8998;
                  t["delta"] = 948;
                  t["deltaturned"] = 397;
                  t["denominatorminusonenumeratorbengali"] = 2552;
                  t["dezh"] = 676;
                  t["dhabengali"] = 2471;
                  t["dhadeva"] = 2343;
                  t["dhagujarati"] = 2727;
                  t["dhagurmukhi"] = 2599;
                  t["dhook"] = 599;
                  t["dialytikatonos"] = 901;
                  t["dialytikatonoscmb"] = 836;
                  t["diamond"] = 9830;
                  t["diamondsuitwhite"] = 9826;
                  t["dieresis"] = 168;
                  t["dieresisacute"] = 63191;
                  t["dieresisbelowcmb"] = 804;
                  t["dieresiscmb"] = 776;
                  t["dieresisgrave"] = 63192;
                  t["dieresistonos"] = 901;
                  t["dihiragana"] = 12386;
                  t["dikatakana"] = 12482;
                  t["dittomark"] = 12291;
                  t["divide"] = 247;
                  t["divides"] = 8739;
                  t["divisionslash"] = 8725;
                  t["djecyrillic"] = 1106;
                  t["dkshade"] = 9619;
                  t["dlinebelow"] = 7695;
                  t["dlsquare"] = 13207;
                  t["dmacron"] = 273;
                  t["dmonospace"] = 65348;
                  t["dnblock"] = 9604;
                  t["dochadathai"] = 3598;
                  t["dodekthai"] = 3604;
                  t["dohiragana"] = 12393;
                  t["dokatakana"] = 12489;
                  t["dollar"] = 36;
                  t["dollarinferior"] = 63203;
                  t["dollarmonospace"] = 65284;
                  t["dollaroldstyle"] = 63268;
                  t["dollarsmall"] = 65129;
                  t["dollarsuperior"] = 63204;
                  t["dong"] = 8363;
                  t["dorusquare"] = 13094;
                  t["dotaccent"] = 729;
                  t["dotaccentcmb"] = 775;
                  t["dotbelowcmb"] = 803;
                  t["dotbelowcomb"] = 803;
                  t["dotkatakana"] = 12539;
                  t["dotlessi"] = 305;
                  t["dotlessj"] = 63166;
                  t["dotlessjstrokehook"] = 644;
                  t["dotmath"] = 8901;
                  t["dottedcircle"] = 9676;
                  t["doubleyodpatah"] = 64287;
                  t["doubleyodpatahhebrew"] = 64287;
                  t["downtackbelowcmb"] = 798;
                  t["downtackmod"] = 725;
                  t["dparen"] = 9375;
                  t["dsuperior"] = 63211;
                  t["dtail"] = 598;
                  t["dtopbar"] = 396;
                  t["duhiragana"] = 12389;
                  t["dukatakana"] = 12485;
                  t["dz"] = 499;
                  t["dzaltone"] = 675;
                  t["dzcaron"] = 454;
                  t["dzcurl"] = 677;
                  t["dzeabkhasiancyrillic"] = 1249;
                  t["dzecyrillic"] = 1109;
                  t["dzhecyrillic"] = 1119;
                  t["e"] = 101;
                  t["eacute"] = 233;
                  t["earth"] = 9793;
                  t["ebengali"] = 2447;
                  t["ebopomofo"] = 12572;
                  t["ebreve"] = 277;
                  t["ecandradeva"] = 2317;
                  t["ecandragujarati"] = 2701;
                  t["ecandravowelsigndeva"] = 2373;
                  t["ecandravowelsigngujarati"] = 2757;
                  t["ecaron"] = 283;
                  t["ecedillabreve"] = 7709;
                  t["echarmenian"] = 1381;
                  t["echyiwnarmenian"] = 1415;
                  t["ecircle"] = 9428;
                  t["ecircumflex"] = 234;
                  t["ecircumflexacute"] = 7871;
                  t["ecircumflexbelow"] = 7705;
                  t["ecircumflexdotbelow"] = 7879;
                  t["ecircumflexgrave"] = 7873;
                  t["ecircumflexhookabove"] = 7875;
                  t["ecircumflextilde"] = 7877;
                  t["ecyrillic"] = 1108;
                  t["edblgrave"] = 517;
                  t["edeva"] = 2319;
                  t["edieresis"] = 235;
                  t["edot"] = 279;
                  t["edotaccent"] = 279;
                  t["edotbelow"] = 7865;
                  t["eegurmukhi"] = 2575;
                  t["eematragurmukhi"] = 2631;
                  t["efcyrillic"] = 1092;
                  t["egrave"] = 232;
                  t["egujarati"] = 2703;
                  t["eharmenian"] = 1383;
                  t["ehbopomofo"] = 12573;
                  t["ehiragana"] = 12360;
                  t["ehookabove"] = 7867;
                  t["eibopomofo"] = 12575;
                  t["eight"] = 56;
                  t["eightarabic"] = 1640;
                  t["eightbengali"] = 2542;
                  t["eightcircle"] = 9319;
                  t["eightcircleinversesansserif"] = 10129;
                  t["eightdeva"] = 2414;
                  t["eighteencircle"] = 9329;
                  t["eighteenparen"] = 9349;
                  t["eighteenperiod"] = 9369;
                  t["eightgujarati"] = 2798;
                  t["eightgurmukhi"] = 2670;
                  t["eighthackarabic"] = 1640;
                  t["eighthangzhou"] = 12328;
                  t["eighthnotebeamed"] = 9835;
                  t["eightideographicparen"] = 12839;
                  t["eightinferior"] = 8328;
                  t["eightmonospace"] = 65304;
                  t["eightoldstyle"] = 63288;
                  t["eightparen"] = 9339;
                  t["eightperiod"] = 9359;
                  t["eightpersian"] = 1784;
                  t["eightroman"] = 8567;
                  t["eightsuperior"] = 8312;
                  t["eightthai"] = 3672;
                  t["einvertedbreve"] = 519;
                  t["eiotifiedcyrillic"] = 1125;
                  t["ekatakana"] = 12456;
                  t["ekatakanahalfwidth"] = 65396;
                  t["ekonkargurmukhi"] = 2676;
                  t["ekorean"] = 12628;
                  t["elcyrillic"] = 1083;
                  t["element"] = 8712;
                  t["elevencircle"] = 9322;
                  t["elevenparen"] = 9342;
                  t["elevenperiod"] = 9362;
                  t["elevenroman"] = 8570;
                  t["ellipsis"] = 8230;
                  t["ellipsisvertical"] = 8942;
                  t["emacron"] = 275;
                  t["emacronacute"] = 7703;
                  t["emacrongrave"] = 7701;
                  t["emcyrillic"] = 1084;
                  t["emdash"] = 8212;
                  t["emdashvertical"] = 65073;
                  t["emonospace"] = 65349;
                  t["emphasismarkarmenian"] = 1371;
                  t["emptyset"] = 8709;
                  t["enbopomofo"] = 12579;
                  t["encyrillic"] = 1085;
                  t["endash"] = 8211;
                  t["endashvertical"] = 65074;
                  t["endescendercyrillic"] = 1187;
                  t["eng"] = 331;
                  t["engbopomofo"] = 12581;
                  t["enghecyrillic"] = 1189;
                  t["enhookcyrillic"] = 1224;
                  t["enspace"] = 8194;
                  t["eogonek"] = 281;
                  t["eokorean"] = 12627;
                  t["eopen"] = 603;
                  t["eopenclosed"] = 666;
                  t["eopenreversed"] = 604;
                  t["eopenreversedclosed"] = 606;
                  t["eopenreversedhook"] = 605;
                  t["eparen"] = 9376;
                  t["epsilon"] = 949;
                  t["epsilontonos"] = 941;
                  t["equal"] = 61;
                  t["equalmonospace"] = 65309;
                  t["equalsmall"] = 65126;
                  t["equalsuperior"] = 8316;
                  t["equivalence"] = 8801;
                  t["erbopomofo"] = 12582;
                  t["ercyrillic"] = 1088;
                  t["ereversed"] = 600;
                  t["ereversedcyrillic"] = 1101;
                  t["escyrillic"] = 1089;
                  t["esdescendercyrillic"] = 1195;
                  t["esh"] = 643;
                  t["eshcurl"] = 646;
                  t["eshortdeva"] = 2318;
                  t["eshortvowelsigndeva"] = 2374;
                  t["eshreversedloop"] = 426;
                  t["eshsquatreversed"] = 645;
                  t["esmallhiragana"] = 12359;
                  t["esmallkatakana"] = 12455;
                  t["esmallkatakanahalfwidth"] = 65386;
                  t["estimated"] = 8494;
                  t["esuperior"] = 63212;
                  t["eta"] = 951;
                  t["etarmenian"] = 1384;
                  t["etatonos"] = 942;
                  t["eth"] = 240;
                  t["etilde"] = 7869;
                  t["etildebelow"] = 7707;
                  t["etnahtafoukhhebrew"] = 1425;
                  t["etnahtafoukhlefthebrew"] = 1425;
                  t["etnahtahebrew"] = 1425;
                  t["etnahtalefthebrew"] = 1425;
                  t["eturned"] = 477;
                  t["eukorean"] = 12641;
                  t["euro"] = 8364;
                  t["evowelsignbengali"] = 2503;
                  t["evowelsigndeva"] = 2375;
                  t["evowelsigngujarati"] = 2759;
                  t["exclam"] = 33;
                  t["exclamarmenian"] = 1372;
                  t["exclamdbl"] = 8252;
                  t["exclamdown"] = 161;
                  t["exclamdownsmall"] = 63393;
                  t["exclammonospace"] = 65281;
                  t["exclamsmall"] = 63265;
                  t["existential"] = 8707;
                  t["ezh"] = 658;
                  t["ezhcaron"] = 495;
                  t["ezhcurl"] = 659;
                  t["ezhreversed"] = 441;
                  t["ezhtail"] = 442;
                  t["f"] = 102;
                  t["fadeva"] = 2398;
                  t["fagurmukhi"] = 2654;
                  t["fahrenheit"] = 8457;
                  t["fathaarabic"] = 1614;
                  t["fathalowarabic"] = 1614;
                  t["fathatanarabic"] = 1611;
                  t["fbopomofo"] = 12552;
                  t["fcircle"] = 9429;
                  t["fdotaccent"] = 7711;
                  t["feharabic"] = 1601;
                  t["feharmenian"] = 1414;
                  t["fehfinalarabic"] = 65234;
                  t["fehinitialarabic"] = 65235;
                  t["fehmedialarabic"] = 65236;
                  t["feicoptic"] = 997;
                  t["female"] = 9792;
                  t["ff"] = 64256;
                  t["f_f"] = 64256;
                  t["ffi"] = 64259;
                  t["ffl"] = 64260;
                  t["fi"] = 64257;
                  t["fifteencircle"] = 9326;
                  t["fifteenparen"] = 9346;
                  t["fifteenperiod"] = 9366;
                  t["figuredash"] = 8210;
                  t["filledbox"] = 9632;
                  t["filledrect"] = 9644;
                  t["finalkaf"] = 1498;
                  t["finalkafdagesh"] = 64314;
                  t["finalkafdageshhebrew"] = 64314;
                  t["finalkafhebrew"] = 1498;
                  t["finalmem"] = 1501;
                  t["finalmemhebrew"] = 1501;
                  t["finalnun"] = 1503;
                  t["finalnunhebrew"] = 1503;
                  t["finalpe"] = 1507;
                  t["finalpehebrew"] = 1507;
                  t["finaltsadi"] = 1509;
                  t["finaltsadihebrew"] = 1509;
                  t["firsttonechinese"] = 713;
                  t["fisheye"] = 9673;
                  t["fitacyrillic"] = 1139;
                  t["five"] = 53;
                  t["fivearabic"] = 1637;
                  t["fivebengali"] = 2539;
                  t["fivecircle"] = 9316;
                  t["fivecircleinversesansserif"] = 10126;
                  t["fivedeva"] = 2411;
                  t["fiveeighths"] = 8541;
                  t["fivegujarati"] = 2795;
                  t["fivegurmukhi"] = 2667;
                  t["fivehackarabic"] = 1637;
                  t["fivehangzhou"] = 12325;
                  t["fiveideographicparen"] = 12836;
                  t["fiveinferior"] = 8325;
                  t["fivemonospace"] = 65301;
                  t["fiveoldstyle"] = 63285;
                  t["fiveparen"] = 9336;
                  t["fiveperiod"] = 9356;
                  t["fivepersian"] = 1781;
                  t["fiveroman"] = 8564;
                  t["fivesuperior"] = 8309;
                  t["fivethai"] = 3669;
                  t["fl"] = 64258;
                  t["florin"] = 402;
                  t["fmonospace"] = 65350;
                  t["fmsquare"] = 13209;
                  t["fofanthai"] = 3615;
                  t["fofathai"] = 3613;
                  t["fongmanthai"] = 3663;
                  t["forall"] = 8704;
                  t["four"] = 52;
                  t["fourarabic"] = 1636;
                  t["fourbengali"] = 2538;
                  t["fourcircle"] = 9315;
                  t["fourcircleinversesansserif"] = 10125;
                  t["fourdeva"] = 2410;
                  t["fourgujarati"] = 2794;
                  t["fourgurmukhi"] = 2666;
                  t["fourhackarabic"] = 1636;
                  t["fourhangzhou"] = 12324;
                  t["fourideographicparen"] = 12835;
                  t["fourinferior"] = 8324;
                  t["fourmonospace"] = 65300;
                  t["fournumeratorbengali"] = 2551;
                  t["fouroldstyle"] = 63284;
                  t["fourparen"] = 9335;
                  t["fourperiod"] = 9355;
                  t["fourpersian"] = 1780;
                  t["fourroman"] = 8563;
                  t["foursuperior"] = 8308;
                  t["fourteencircle"] = 9325;
                  t["fourteenparen"] = 9345;
                  t["fourteenperiod"] = 9365;
                  t["fourthai"] = 3668;
                  t["fourthtonechinese"] = 715;
                  t["fparen"] = 9377;
                  t["fraction"] = 8260;
                  t["franc"] = 8355;
                  t["g"] = 103;
                  t["gabengali"] = 2455;
                  t["gacute"] = 501;
                  t["gadeva"] = 2327;
                  t["gafarabic"] = 1711;
                  t["gaffinalarabic"] = 64403;
                  t["gafinitialarabic"] = 64404;
                  t["gafmedialarabic"] = 64405;
                  t["gagujarati"] = 2711;
                  t["gagurmukhi"] = 2583;
                  t["gahiragana"] = 12364;
                  t["gakatakana"] = 12460;
                  t["gamma"] = 947;
                  t["gammalatinsmall"] = 611;
                  t["gammasuperior"] = 736;
                  t["gangiacoptic"] = 1003;
                  t["gbopomofo"] = 12557;
                  t["gbreve"] = 287;
                  t["gcaron"] = 487;
                  t["gcedilla"] = 291;
                  t["gcircle"] = 9430;
                  t["gcircumflex"] = 285;
                  t["gcommaaccent"] = 291;
                  t["gdot"] = 289;
                  t["gdotaccent"] = 289;
                  t["gecyrillic"] = 1075;
                  t["gehiragana"] = 12370;
                  t["gekatakana"] = 12466;
                  t["geometricallyequal"] = 8785;
                  t["gereshaccenthebrew"] = 1436;
                  t["gereshhebrew"] = 1523;
                  t["gereshmuqdamhebrew"] = 1437;
                  t["germandbls"] = 223;
                  t["gershayimaccenthebrew"] = 1438;
                  t["gershayimhebrew"] = 1524;
                  t["getamark"] = 12307;
                  t["ghabengali"] = 2456;
                  t["ghadarmenian"] = 1394;
                  t["ghadeva"] = 2328;
                  t["ghagujarati"] = 2712;
                  t["ghagurmukhi"] = 2584;
                  t["ghainarabic"] = 1594;
                  t["ghainfinalarabic"] = 65230;
                  t["ghaininitialarabic"] = 65231;
                  t["ghainmedialarabic"] = 65232;
                  t["ghemiddlehookcyrillic"] = 1173;
                  t["ghestrokecyrillic"] = 1171;
                  t["gheupturncyrillic"] = 1169;
                  t["ghhadeva"] = 2394;
                  t["ghhagurmukhi"] = 2650;
                  t["ghook"] = 608;
                  t["ghzsquare"] = 13203;
                  t["gihiragana"] = 12366;
                  t["gikatakana"] = 12462;
                  t["gimarmenian"] = 1379;
                  t["gimel"] = 1490;
                  t["gimeldagesh"] = 64306;
                  t["gimeldageshhebrew"] = 64306;
                  t["gimelhebrew"] = 1490;
                  t["gjecyrillic"] = 1107;
                  t["glottalinvertedstroke"] = 446;
                  t["glottalstop"] = 660;
                  t["glottalstopinverted"] = 662;
                  t["glottalstopmod"] = 704;
                  t["glottalstopreversed"] = 661;
                  t["glottalstopreversedmod"] = 705;
                  t["glottalstopreversedsuperior"] = 740;
                  t["glottalstopstroke"] = 673;
                  t["glottalstopstrokereversed"] = 674;
                  t["gmacron"] = 7713;
                  t["gmonospace"] = 65351;
                  t["gohiragana"] = 12372;
                  t["gokatakana"] = 12468;
                  t["gparen"] = 9378;
                  t["gpasquare"] = 13228;
                  t["gradient"] = 8711;
                  t["grave"] = 96;
                  t["gravebelowcmb"] = 790;
                  t["gravecmb"] = 768;
                  t["gravecomb"] = 768;
                  t["gravedeva"] = 2387;
                  t["gravelowmod"] = 718;
                  t["gravemonospace"] = 65344;
                  t["gravetonecmb"] = 832;
                  t["greater"] = 62;
                  t["greaterequal"] = 8805;
                  t["greaterequalorless"] = 8923;
                  t["greatermonospace"] = 65310;
                  t["greaterorequivalent"] = 8819;
                  t["greaterorless"] = 8823;
                  t["greateroverequal"] = 8807;
                  t["greatersmall"] = 65125;
                  t["gscript"] = 609;
                  t["gstroke"] = 485;
                  t["guhiragana"] = 12368;
                  t["guillemotleft"] = 171;
                  t["guillemotright"] = 187;
                  t["guilsinglleft"] = 8249;
                  t["guilsinglright"] = 8250;
                  t["gukatakana"] = 12464;
                  t["guramusquare"] = 13080;
                  t["gysquare"] = 13257;
                  t["h"] = 104;
                  t["haabkhasiancyrillic"] = 1193;
                  t["haaltonearabic"] = 1729;
                  t["habengali"] = 2489;
                  t["hadescendercyrillic"] = 1203;
                  t["hadeva"] = 2361;
                  t["hagujarati"] = 2745;
                  t["hagurmukhi"] = 2617;
                  t["haharabic"] = 1581;
                  t["hahfinalarabic"] = 65186;
                  t["hahinitialarabic"] = 65187;
                  t["hahiragana"] = 12399;
                  t["hahmedialarabic"] = 65188;
                  t["haitusquare"] = 13098;
                  t["hakatakana"] = 12495;
                  t["hakatakanahalfwidth"] = 65418;
                  t["halantgurmukhi"] = 2637;
                  t["hamzaarabic"] = 1569;
                  t["hamzalowarabic"] = 1569;
                  t["hangulfiller"] = 12644;
                  t["hardsigncyrillic"] = 1098;
                  t["harpoonleftbarbup"] = 8636;
                  t["harpoonrightbarbup"] = 8640;
                  t["hasquare"] = 13258;
                  t["hatafpatah"] = 1458;
                  t["hatafpatah16"] = 1458;
                  t["hatafpatah23"] = 1458;
                  t["hatafpatah2f"] = 1458;
                  t["hatafpatahhebrew"] = 1458;
                  t["hatafpatahnarrowhebrew"] = 1458;
                  t["hatafpatahquarterhebrew"] = 1458;
                  t["hatafpatahwidehebrew"] = 1458;
                  t["hatafqamats"] = 1459;
                  t["hatafqamats1b"] = 1459;
                  t["hatafqamats28"] = 1459;
                  t["hatafqamats34"] = 1459;
                  t["hatafqamatshebrew"] = 1459;
                  t["hatafqamatsnarrowhebrew"] = 1459;
                  t["hatafqamatsquarterhebrew"] = 1459;
                  t["hatafqamatswidehebrew"] = 1459;
                  t["hatafsegol"] = 1457;
                  t["hatafsegol17"] = 1457;
                  t["hatafsegol24"] = 1457;
                  t["hatafsegol30"] = 1457;
                  t["hatafsegolhebrew"] = 1457;
                  t["hatafsegolnarrowhebrew"] = 1457;
                  t["hatafsegolquarterhebrew"] = 1457;
                  t["hatafsegolwidehebrew"] = 1457;
                  t["hbar"] = 295;
                  t["hbopomofo"] = 12559;
                  t["hbrevebelow"] = 7723;
                  t["hcedilla"] = 7721;
                  t["hcircle"] = 9431;
                  t["hcircumflex"] = 293;
                  t["hdieresis"] = 7719;
                  t["hdotaccent"] = 7715;
                  t["hdotbelow"] = 7717;
                  t["he"] = 1492;
                  t["heart"] = 9829;
                  t["heartsuitblack"] = 9829;
                  t["heartsuitwhite"] = 9825;
                  t["hedagesh"] = 64308;
                  t["hedageshhebrew"] = 64308;
                  t["hehaltonearabic"] = 1729;
                  t["heharabic"] = 1607;
                  t["hehebrew"] = 1492;
                  t["hehfinalaltonearabic"] = 64423;
                  t["hehfinalalttwoarabic"] = 65258;
                  t["hehfinalarabic"] = 65258;
                  t["hehhamzaabovefinalarabic"] = 64421;
                  t["hehhamzaaboveisolatedarabic"] = 64420;
                  t["hehinitialaltonearabic"] = 64424;
                  t["hehinitialarabic"] = 65259;
                  t["hehiragana"] = 12408;
                  t["hehmedialaltonearabic"] = 64425;
                  t["hehmedialarabic"] = 65260;
                  t["heiseierasquare"] = 13179;
                  t["hekatakana"] = 12504;
                  t["hekatakanahalfwidth"] = 65421;
                  t["hekutaarusquare"] = 13110;
                  t["henghook"] = 615;
                  t["herutusquare"] = 13113;
                  t["het"] = 1495;
                  t["hethebrew"] = 1495;
                  t["hhook"] = 614;
                  t["hhooksuperior"] = 689;
                  t["hieuhacirclekorean"] = 12923;
                  t["hieuhaparenkorean"] = 12827;
                  t["hieuhcirclekorean"] = 12909;
                  t["hieuhkorean"] = 12622;
                  t["hieuhparenkorean"] = 12813;
                  t["hihiragana"] = 12402;
                  t["hikatakana"] = 12498;
                  t["hikatakanahalfwidth"] = 65419;
                  t["hiriq"] = 1460;
                  t["hiriq14"] = 1460;
                  t["hiriq21"] = 1460;
                  t["hiriq2d"] = 1460;
                  t["hiriqhebrew"] = 1460;
                  t["hiriqnarrowhebrew"] = 1460;
                  t["hiriqquarterhebrew"] = 1460;
                  t["hiriqwidehebrew"] = 1460;
                  t["hlinebelow"] = 7830;
                  t["hmonospace"] = 65352;
                  t["hoarmenian"] = 1392;
                  t["hohipthai"] = 3627;
                  t["hohiragana"] = 12411;
                  t["hokatakana"] = 12507;
                  t["hokatakanahalfwidth"] = 65422;
                  t["holam"] = 1465;
                  t["holam19"] = 1465;
                  t["holam26"] = 1465;
                  t["holam32"] = 1465;
                  t["holamhebrew"] = 1465;
                  t["holamnarrowhebrew"] = 1465;
                  t["holamquarterhebrew"] = 1465;
                  t["holamwidehebrew"] = 1465;
                  t["honokhukthai"] = 3630;
                  t["hookabovecomb"] = 777;
                  t["hookcmb"] = 777;
                  t["hookpalatalizedbelowcmb"] = 801;
                  t["hookretroflexbelowcmb"] = 802;
                  t["hoonsquare"] = 13122;
                  t["horicoptic"] = 1001;
                  t["horizontalbar"] = 8213;
                  t["horncmb"] = 795;
                  t["hotsprings"] = 9832;
                  t["house"] = 8962;
                  t["hparen"] = 9379;
                  t["hsuperior"] = 688;
                  t["hturned"] = 613;
                  t["huhiragana"] = 12405;
                  t["huiitosquare"] = 13107;
                  t["hukatakana"] = 12501;
                  t["hukatakanahalfwidth"] = 65420;
                  t["hungarumlaut"] = 733;
                  t["hungarumlautcmb"] = 779;
                  t["hv"] = 405;
                  t["hyphen"] = 45;
                  t["hypheninferior"] = 63205;
                  t["hyphenmonospace"] = 65293;
                  t["hyphensmall"] = 65123;
                  t["hyphensuperior"] = 63206;
                  t["hyphentwo"] = 8208;
                  t["i"] = 105;
                  t["iacute"] = 237;
                  t["iacyrillic"] = 1103;
                  t["ibengali"] = 2439;
                  t["ibopomofo"] = 12583;
                  t["ibreve"] = 301;
                  t["icaron"] = 464;
                  t["icircle"] = 9432;
                  t["icircumflex"] = 238;
                  t["icyrillic"] = 1110;
                  t["idblgrave"] = 521;
                  t["ideographearthcircle"] = 12943;
                  t["ideographfirecircle"] = 12939;
                  t["ideographicallianceparen"] = 12863;
                  t["ideographiccallparen"] = 12858;
                  t["ideographiccentrecircle"] = 12965;
                  t["ideographicclose"] = 12294;
                  t["ideographiccomma"] = 12289;
                  t["ideographiccommaleft"] = 65380;
                  t["ideographiccongratulationparen"] = 12855;
                  t["ideographiccorrectcircle"] = 12963;
                  t["ideographicearthparen"] = 12847;
                  t["ideographicenterpriseparen"] = 12861;
                  t["ideographicexcellentcircle"] = 12957;
                  t["ideographicfestivalparen"] = 12864;
                  t["ideographicfinancialcircle"] = 12950;
                  t["ideographicfinancialparen"] = 12854;
                  t["ideographicfireparen"] = 12843;
                  t["ideographichaveparen"] = 12850;
                  t["ideographichighcircle"] = 12964;
                  t["ideographiciterationmark"] = 12293;
                  t["ideographiclaborcircle"] = 12952;
                  t["ideographiclaborparen"] = 12856;
                  t["ideographicleftcircle"] = 12967;
                  t["ideographiclowcircle"] = 12966;
                  t["ideographicmedicinecircle"] = 12969;
                  t["ideographicmetalparen"] = 12846;
                  t["ideographicmoonparen"] = 12842;
                  t["ideographicnameparen"] = 12852;
                  t["ideographicperiod"] = 12290;
                  t["ideographicprintcircle"] = 12958;
                  t["ideographicreachparen"] = 12867;
                  t["ideographicrepresentparen"] = 12857;
                  t["ideographicresourceparen"] = 12862;
                  t["ideographicrightcircle"] = 12968;
                  t["ideographicsecretcircle"] = 12953;
                  t["ideographicselfparen"] = 12866;
                  t["ideographicsocietyparen"] = 12851;
                  t["ideographicspace"] = 12288;
                  t["ideographicspecialparen"] = 12853;
                  t["ideographicstockparen"] = 12849;
                  t["ideographicstudyparen"] = 12859;
                  t["ideographicsunparen"] = 12848;
                  t["ideographicsuperviseparen"] = 12860;
                  t["ideographicwaterparen"] = 12844;
                  t["ideographicwoodparen"] = 12845;
                  t["ideographiczero"] = 12295;
                  t["ideographmetalcircle"] = 12942;
                  t["ideographmooncircle"] = 12938;
                  t["ideographnamecircle"] = 12948;
                  t["ideographsuncircle"] = 12944;
                  t["ideographwatercircle"] = 12940;
                  t["ideographwoodcircle"] = 12941;
                  t["ideva"] = 2311;
                  t["idieresis"] = 239;
                  t["idieresisacute"] = 7727;
                  t["idieresiscyrillic"] = 1253;
                  t["idotbelow"] = 7883;
                  t["iebrevecyrillic"] = 1239;
                  t["iecyrillic"] = 1077;
                  t["ieungacirclekorean"] = 12917;
                  t["ieungaparenkorean"] = 12821;
                  t["ieungcirclekorean"] = 12903;
                  t["ieungkorean"] = 12615;
                  t["ieungparenkorean"] = 12807;
                  t["igrave"] = 236;
                  t["igujarati"] = 2695;
                  t["igurmukhi"] = 2567;
                  t["ihiragana"] = 12356;
                  t["ihookabove"] = 7881;
                  t["iibengali"] = 2440;
                  t["iicyrillic"] = 1080;
                  t["iideva"] = 2312;
                  t["iigujarati"] = 2696;
                  t["iigurmukhi"] = 2568;
                  t["iimatragurmukhi"] = 2624;
                  t["iinvertedbreve"] = 523;
                  t["iishortcyrillic"] = 1081;
                  t["iivowelsignbengali"] = 2496;
                  t["iivowelsigndeva"] = 2368;
                  t["iivowelsigngujarati"] = 2752;
                  t["ij"] = 307;
                  t["ikatakana"] = 12452;
                  t["ikatakanahalfwidth"] = 65394;
                  t["ikorean"] = 12643;
                  t["ilde"] = 732;
                  t["iluyhebrew"] = 1452;
                  t["imacron"] = 299;
                  t["imacroncyrillic"] = 1251;
                  t["imageorapproximatelyequal"] = 8787;
                  t["imatragurmukhi"] = 2623;
                  t["imonospace"] = 65353;
                  t["increment"] = 8710;
                  t["infinity"] = 8734;
                  t["iniarmenian"] = 1387;
                  t["integral"] = 8747;
                  t["integralbottom"] = 8993;
                  t["integralbt"] = 8993;
                  t["integralex"] = 63733;
                  t["integraltop"] = 8992;
                  t["integraltp"] = 8992;
                  t["intersection"] = 8745;
                  t["intisquare"] = 13061;
                  t["invbullet"] = 9688;
                  t["invcircle"] = 9689;
                  t["invsmileface"] = 9787;
                  t["iocyrillic"] = 1105;
                  t["iogonek"] = 303;
                  t["iota"] = 953;
                  t["iotadieresis"] = 970;
                  t["iotadieresistonos"] = 912;
                  t["iotalatin"] = 617;
                  t["iotatonos"] = 943;
                  t["iparen"] = 9380;
                  t["irigurmukhi"] = 2674;
                  t["ismallhiragana"] = 12355;
                  t["ismallkatakana"] = 12451;
                  t["ismallkatakanahalfwidth"] = 65384;
                  t["issharbengali"] = 2554;
                  t["istroke"] = 616;
                  t["isuperior"] = 63213;
                  t["iterationhiragana"] = 12445;
                  t["iterationkatakana"] = 12541;
                  t["itilde"] = 297;
                  t["itildebelow"] = 7725;
                  t["iubopomofo"] = 12585;
                  t["iucyrillic"] = 1102;
                  t["ivowelsignbengali"] = 2495;
                  t["ivowelsigndeva"] = 2367;
                  t["ivowelsigngujarati"] = 2751;
                  t["izhitsacyrillic"] = 1141;
                  t["izhitsadblgravecyrillic"] = 1143;
                  t["j"] = 106;
                  t["jaarmenian"] = 1393;
                  t["jabengali"] = 2460;
                  t["jadeva"] = 2332;
                  t["jagujarati"] = 2716;
                  t["jagurmukhi"] = 2588;
                  t["jbopomofo"] = 12560;
                  t["jcaron"] = 496;
                  t["jcircle"] = 9433;
                  t["jcircumflex"] = 309;
                  t["jcrossedtail"] = 669;
                  t["jdotlessstroke"] = 607;
                  t["jecyrillic"] = 1112;
                  t["jeemarabic"] = 1580;
                  t["jeemfinalarabic"] = 65182;
                  t["jeeminitialarabic"] = 65183;
                  t["jeemmedialarabic"] = 65184;
                  t["jeharabic"] = 1688;
                  t["jehfinalarabic"] = 64395;
                  t["jhabengali"] = 2461;
                  t["jhadeva"] = 2333;
                  t["jhagujarati"] = 2717;
                  t["jhagurmukhi"] = 2589;
                  t["jheharmenian"] = 1403;
                  t["jis"] = 12292;
                  t["jmonospace"] = 65354;
                  t["jparen"] = 9381;
                  t["jsuperior"] = 690;
                  t["k"] = 107;
                  t["kabashkircyrillic"] = 1185;
                  t["kabengali"] = 2453;
                  t["kacute"] = 7729;
                  t["kacyrillic"] = 1082;
                  t["kadescendercyrillic"] = 1179;
                  t["kadeva"] = 2325;
                  t["kaf"] = 1499;
                  t["kafarabic"] = 1603;
                  t["kafdagesh"] = 64315;
                  t["kafdageshhebrew"] = 64315;
                  t["kaffinalarabic"] = 65242;
                  t["kafhebrew"] = 1499;
                  t["kafinitialarabic"] = 65243;
                  t["kafmedialarabic"] = 65244;
                  t["kafrafehebrew"] = 64333;
                  t["kagujarati"] = 2709;
                  t["kagurmukhi"] = 2581;
                  t["kahiragana"] = 12363;
                  t["kahookcyrillic"] = 1220;
                  t["kakatakana"] = 12459;
                  t["kakatakanahalfwidth"] = 65398;
                  t["kappa"] = 954;
                  t["kappasymbolgreek"] = 1008;
                  t["kapyeounmieumkorean"] = 12657;
                  t["kapyeounphieuphkorean"] = 12676;
                  t["kapyeounpieupkorean"] = 12664;
                  t["kapyeounssangpieupkorean"] = 12665;
                  t["karoriisquare"] = 13069;
                  t["kashidaautoarabic"] = 1600;
                  t["kashidaautonosidebearingarabic"] = 1600;
                  t["kasmallkatakana"] = 12533;
                  t["kasquare"] = 13188;
                  t["kasraarabic"] = 1616;
                  t["kasratanarabic"] = 1613;
                  t["kastrokecyrillic"] = 1183;
                  t["katahiraprolongmarkhalfwidth"] = 65392;
                  t["kaverticalstrokecyrillic"] = 1181;
                  t["kbopomofo"] = 12558;
                  t["kcalsquare"] = 13193;
                  t["kcaron"] = 489;
                  t["kcedilla"] = 311;
                  t["kcircle"] = 9434;
                  t["kcommaaccent"] = 311;
                  t["kdotbelow"] = 7731;
                  t["keharmenian"] = 1412;
                  t["kehiragana"] = 12369;
                  t["kekatakana"] = 12465;
                  t["kekatakanahalfwidth"] = 65401;
                  t["kenarmenian"] = 1391;
                  t["kesmallkatakana"] = 12534;
                  t["kgreenlandic"] = 312;
                  t["khabengali"] = 2454;
                  t["khacyrillic"] = 1093;
                  t["khadeva"] = 2326;
                  t["khagujarati"] = 2710;
                  t["khagurmukhi"] = 2582;
                  t["khaharabic"] = 1582;
                  t["khahfinalarabic"] = 65190;
                  t["khahinitialarabic"] = 65191;
                  t["khahmedialarabic"] = 65192;
                  t["kheicoptic"] = 999;
                  t["khhadeva"] = 2393;
                  t["khhagurmukhi"] = 2649;
                  t["khieukhacirclekorean"] = 12920;
                  t["khieukhaparenkorean"] = 12824;
                  t["khieukhcirclekorean"] = 12906;
                  t["khieukhkorean"] = 12619;
                  t["khieukhparenkorean"] = 12810;
                  t["khokhaithai"] = 3586;
                  t["khokhonthai"] = 3589;
                  t["khokhuatthai"] = 3587;
                  t["khokhwaithai"] = 3588;
                  t["khomutthai"] = 3675;
                  t["khook"] = 409;
                  t["khorakhangthai"] = 3590;
                  t["khzsquare"] = 13201;
                  t["kihiragana"] = 12365;
                  t["kikatakana"] = 12461;
                  t["kikatakanahalfwidth"] = 65399;
                  t["kiroguramusquare"] = 13077;
                  t["kiromeetorusquare"] = 13078;
                  t["kirosquare"] = 13076;
                  t["kiyeokacirclekorean"] = 12910;
                  t["kiyeokaparenkorean"] = 12814;
                  t["kiyeokcirclekorean"] = 12896;
                  t["kiyeokkorean"] = 12593;
                  t["kiyeokparenkorean"] = 12800;
                  t["kiyeoksioskorean"] = 12595;
                  t["kjecyrillic"] = 1116;
                  t["klinebelow"] = 7733;
                  t["klsquare"] = 13208;
                  t["kmcubedsquare"] = 13222;
                  t["kmonospace"] = 65355;
                  t["kmsquaredsquare"] = 13218;
                  t["kohiragana"] = 12371;
                  t["kohmsquare"] = 13248;
                  t["kokaithai"] = 3585;
                  t["kokatakana"] = 12467;
                  t["kokatakanahalfwidth"] = 65402;
                  t["kooposquare"] = 13086;
                  t["koppacyrillic"] = 1153;
                  t["koreanstandardsymbol"] = 12927;
                  t["koroniscmb"] = 835;
                  t["kparen"] = 9382;
                  t["kpasquare"] = 13226;
                  t["ksicyrillic"] = 1135;
                  t["ktsquare"] = 13263;
                  t["kturned"] = 670;
                  t["kuhiragana"] = 12367;
                  t["kukatakana"] = 12463;
                  t["kukatakanahalfwidth"] = 65400;
                  t["kvsquare"] = 13240;
                  t["kwsquare"] = 13246;
                  t["l"] = 108;
                  t["labengali"] = 2482;
                  t["lacute"] = 314;
                  t["ladeva"] = 2354;
                  t["lagujarati"] = 2738;
                  t["lagurmukhi"] = 2610;
                  t["lakkhangyaothai"] = 3653;
                  t["lamaleffinalarabic"] = 65276;
                  t["lamalefhamzaabovefinalarabic"] = 65272;
                  t["lamalefhamzaaboveisolatedarabic"] = 65271;
                  t["lamalefhamzabelowfinalarabic"] = 65274;
                  t["lamalefhamzabelowisolatedarabic"] = 65273;
                  t["lamalefisolatedarabic"] = 65275;
                  t["lamalefmaddaabovefinalarabic"] = 65270;
                  t["lamalefmaddaaboveisolatedarabic"] = 65269;
                  t["lamarabic"] = 1604;
                  t["lambda"] = 955;
                  t["lambdastroke"] = 411;
                  t["lamed"] = 1500;
                  t["lameddagesh"] = 64316;
                  t["lameddageshhebrew"] = 64316;
                  t["lamedhebrew"] = 1500;
                  t["lamfinalarabic"] = 65246;
                  t["lamhahinitialarabic"] = 64714;
                  t["laminitialarabic"] = 65247;
                  t["lamjeeminitialarabic"] = 64713;
                  t["lamkhahinitialarabic"] = 64715;
                  t["lamlamhehisolatedarabic"] = 65010;
                  t["lammedialarabic"] = 65248;
                  t["lammeemhahinitialarabic"] = 64904;
                  t["lammeeminitialarabic"] = 64716;
                  t["largecircle"] = 9711;
                  t["lbar"] = 410;
                  t["lbelt"] = 620;
                  t["lbopomofo"] = 12556;
                  t["lcaron"] = 318;
                  t["lcedilla"] = 316;
                  t["lcircle"] = 9435;
                  t["lcircumflexbelow"] = 7741;
                  t["lcommaaccent"] = 316;
                  t["ldot"] = 320;
                  t["ldotaccent"] = 320;
                  t["ldotbelow"] = 7735;
                  t["ldotbelowmacron"] = 7737;
                  t["leftangleabovecmb"] = 794;
                  t["lefttackbelowcmb"] = 792;
                  t["less"] = 60;
                  t["lessequal"] = 8804;
                  t["lessequalorgreater"] = 8922;
                  t["lessmonospace"] = 65308;
                  t["lessorequivalent"] = 8818;
                  t["lessorgreater"] = 8822;
                  t["lessoverequal"] = 8806;
                  t["lesssmall"] = 65124;
                  t["lezh"] = 622;
                  t["lfblock"] = 9612;
                  t["lhookretroflex"] = 621;
                  t["lira"] = 8356;
                  t["liwnarmenian"] = 1388;
                  t["lj"] = 457;
                  t["ljecyrillic"] = 1113;
                  t["ll"] = 63168;
                  t["lladeva"] = 2355;
                  t["llagujarati"] = 2739;
                  t["llinebelow"] = 7739;
                  t["llladeva"] = 2356;
                  t["llvocalicbengali"] = 2529;
                  t["llvocalicdeva"] = 2401;
                  t["llvocalicvowelsignbengali"] = 2531;
                  t["llvocalicvowelsigndeva"] = 2403;
                  t["lmiddletilde"] = 619;
                  t["lmonospace"] = 65356;
                  t["lmsquare"] = 13264;
                  t["lochulathai"] = 3628;
                  t["logicaland"] = 8743;
                  t["logicalnot"] = 172;
                  t["logicalnotreversed"] = 8976;
                  t["logicalor"] = 8744;
                  t["lolingthai"] = 3621;
                  t["longs"] = 383;
                  t["lowlinecenterline"] = 65102;
                  t["lowlinecmb"] = 818;
                  t["lowlinedashed"] = 65101;
                  t["lozenge"] = 9674;
                  t["lparen"] = 9383;
                  t["lslash"] = 322;
                  t["lsquare"] = 8467;
                  t["lsuperior"] = 63214;
                  t["ltshade"] = 9617;
                  t["luthai"] = 3622;
                  t["lvocalicbengali"] = 2444;
                  t["lvocalicdeva"] = 2316;
                  t["lvocalicvowelsignbengali"] = 2530;
                  t["lvocalicvowelsigndeva"] = 2402;
                  t["lxsquare"] = 13267;
                  t["m"] = 109;
                  t["mabengali"] = 2478;
                  t["macron"] = 175;
                  t["macronbelowcmb"] = 817;
                  t["macroncmb"] = 772;
                  t["macronlowmod"] = 717;
                  t["macronmonospace"] = 65507;
                  t["macute"] = 7743;
                  t["madeva"] = 2350;
                  t["magujarati"] = 2734;
                  t["magurmukhi"] = 2606;
                  t["mahapakhhebrew"] = 1444;
                  t["mahapakhlefthebrew"] = 1444;
                  t["mahiragana"] = 12414;
                  t["maichattawalowleftthai"] = 63637;
                  t["maichattawalowrightthai"] = 63636;
                  t["maichattawathai"] = 3659;
                  t["maichattawaupperleftthai"] = 63635;
                  t["maieklowleftthai"] = 63628;
                  t["maieklowrightthai"] = 63627;
                  t["maiekthai"] = 3656;
                  t["maiekupperleftthai"] = 63626;
                  t["maihanakatleftthai"] = 63620;
                  t["maihanakatthai"] = 3633;
                  t["maitaikhuleftthai"] = 63625;
                  t["maitaikhuthai"] = 3655;
                  t["maitholowleftthai"] = 63631;
                  t["maitholowrightthai"] = 63630;
                  t["maithothai"] = 3657;
                  t["maithoupperleftthai"] = 63629;
                  t["maitrilowleftthai"] = 63634;
                  t["maitrilowrightthai"] = 63633;
                  t["maitrithai"] = 3658;
                  t["maitriupperleftthai"] = 63632;
                  t["maiyamokthai"] = 3654;
                  t["makatakana"] = 12510;
                  t["makatakanahalfwidth"] = 65423;
                  t["male"] = 9794;
                  t["mansyonsquare"] = 13127;
                  t["maqafhebrew"] = 1470;
                  t["mars"] = 9794;
                  t["masoracirclehebrew"] = 1455;
                  t["masquare"] = 13187;
                  t["mbopomofo"] = 12551;
                  t["mbsquare"] = 13268;
                  t["mcircle"] = 9436;
                  t["mcubedsquare"] = 13221;
                  t["mdotaccent"] = 7745;
                  t["mdotbelow"] = 7747;
                  t["meemarabic"] = 1605;
                  t["meemfinalarabic"] = 65250;
                  t["meeminitialarabic"] = 65251;
                  t["meemmedialarabic"] = 65252;
                  t["meemmeeminitialarabic"] = 64721;
                  t["meemmeemisolatedarabic"] = 64584;
                  t["meetorusquare"] = 13133;
                  t["mehiragana"] = 12417;
                  t["meizierasquare"] = 13182;
                  t["mekatakana"] = 12513;
                  t["mekatakanahalfwidth"] = 65426;
                  t["mem"] = 1502;
                  t["memdagesh"] = 64318;
                  t["memdageshhebrew"] = 64318;
                  t["memhebrew"] = 1502;
                  t["menarmenian"] = 1396;
                  t["merkhahebrew"] = 1445;
                  t["merkhakefulahebrew"] = 1446;
                  t["merkhakefulalefthebrew"] = 1446;
                  t["merkhalefthebrew"] = 1445;
                  t["mhook"] = 625;
                  t["mhzsquare"] = 13202;
                  t["middledotkatakanahalfwidth"] = 65381;
                  t["middot"] = 183;
                  t["mieumacirclekorean"] = 12914;
                  t["mieumaparenkorean"] = 12818;
                  t["mieumcirclekorean"] = 12900;
                  t["mieumkorean"] = 12609;
                  t["mieumpansioskorean"] = 12656;
                  t["mieumparenkorean"] = 12804;
                  t["mieumpieupkorean"] = 12654;
                  t["mieumsioskorean"] = 12655;
                  t["mihiragana"] = 12415;
                  t["mikatakana"] = 12511;
                  t["mikatakanahalfwidth"] = 65424;
                  t["minus"] = 8722;
                  t["minusbelowcmb"] = 800;
                  t["minuscircle"] = 8854;
                  t["minusmod"] = 727;
                  t["minusplus"] = 8723;
                  t["minute"] = 8242;
                  t["miribaarusquare"] = 13130;
                  t["mirisquare"] = 13129;
                  t["mlonglegturned"] = 624;
                  t["mlsquare"] = 13206;
                  t["mmcubedsquare"] = 13219;
                  t["mmonospace"] = 65357;
                  t["mmsquaredsquare"] = 13215;
                  t["mohiragana"] = 12418;
                  t["mohmsquare"] = 13249;
                  t["mokatakana"] = 12514;
                  t["mokatakanahalfwidth"] = 65427;
                  t["molsquare"] = 13270;
                  t["momathai"] = 3617;
                  t["moverssquare"] = 13223;
                  t["moverssquaredsquare"] = 13224;
                  t["mparen"] = 9384;
                  t["mpasquare"] = 13227;
                  t["mssquare"] = 13235;
                  t["msuperior"] = 63215;
                  t["mturned"] = 623;
                  t["mu"] = 181;
                  t["mu1"] = 181;
                  t["muasquare"] = 13186;
                  t["muchgreater"] = 8811;
                  t["muchless"] = 8810;
                  t["mufsquare"] = 13196;
                  t["mugreek"] = 956;
                  t["mugsquare"] = 13197;
                  t["muhiragana"] = 12416;
                  t["mukatakana"] = 12512;
                  t["mukatakanahalfwidth"] = 65425;
                  t["mulsquare"] = 13205;
                  t["multiply"] = 215;
                  t["mumsquare"] = 13211;
                  t["munahhebrew"] = 1443;
                  t["munahlefthebrew"] = 1443;
                  t["musicalnote"] = 9834;
                  t["musicalnotedbl"] = 9835;
                  t["musicflatsign"] = 9837;
                  t["musicsharpsign"] = 9839;
                  t["mussquare"] = 13234;
                  t["muvsquare"] = 13238;
                  t["muwsquare"] = 13244;
                  t["mvmegasquare"] = 13241;
                  t["mvsquare"] = 13239;
                  t["mwmegasquare"] = 13247;
                  t["mwsquare"] = 13245;
                  t["n"] = 110;
                  t["nabengali"] = 2472;
                  t["nabla"] = 8711;
                  t["nacute"] = 324;
                  t["nadeva"] = 2344;
                  t["nagujarati"] = 2728;
                  t["nagurmukhi"] = 2600;
                  t["nahiragana"] = 12394;
                  t["nakatakana"] = 12490;
                  t["nakatakanahalfwidth"] = 65413;
                  t["napostrophe"] = 329;
                  t["nasquare"] = 13185;
                  t["nbopomofo"] = 12555;
                  t["nbspace"] = 160;
                  t["ncaron"] = 328;
                  t["ncedilla"] = 326;
                  t["ncircle"] = 9437;
                  t["ncircumflexbelow"] = 7755;
                  t["ncommaaccent"] = 326;
                  t["ndotaccent"] = 7749;
                  t["ndotbelow"] = 7751;
                  t["nehiragana"] = 12397;
                  t["nekatakana"] = 12493;
                  t["nekatakanahalfwidth"] = 65416;
                  t["newsheqelsign"] = 8362;
                  t["nfsquare"] = 13195;
                  t["ngabengali"] = 2457;
                  t["ngadeva"] = 2329;
                  t["ngagujarati"] = 2713;
                  t["ngagurmukhi"] = 2585;
                  t["ngonguthai"] = 3591;
                  t["nhiragana"] = 12435;
                  t["nhookleft"] = 626;
                  t["nhookretroflex"] = 627;
                  t["nieunacirclekorean"] = 12911;
                  t["nieunaparenkorean"] = 12815;
                  t["nieuncieuckorean"] = 12597;
                  t["nieuncirclekorean"] = 12897;
                  t["nieunhieuhkorean"] = 12598;
                  t["nieunkorean"] = 12596;
                  t["nieunpansioskorean"] = 12648;
                  t["nieunparenkorean"] = 12801;
                  t["nieunsioskorean"] = 12647;
                  t["nieuntikeutkorean"] = 12646;
                  t["nihiragana"] = 12395;
                  t["nikatakana"] = 12491;
                  t["nikatakanahalfwidth"] = 65414;
                  t["nikhahitleftthai"] = 63641;
                  t["nikhahitthai"] = 3661;
                  t["nine"] = 57;
                  t["ninearabic"] = 1641;
                  t["ninebengali"] = 2543;
                  t["ninecircle"] = 9320;
                  t["ninecircleinversesansserif"] = 10130;
                  t["ninedeva"] = 2415;
                  t["ninegujarati"] = 2799;
                  t["ninegurmukhi"] = 2671;
                  t["ninehackarabic"] = 1641;
                  t["ninehangzhou"] = 12329;
                  t["nineideographicparen"] = 12840;
                  t["nineinferior"] = 8329;
                  t["ninemonospace"] = 65305;
                  t["nineoldstyle"] = 63289;
                  t["nineparen"] = 9340;
                  t["nineperiod"] = 9360;
                  t["ninepersian"] = 1785;
                  t["nineroman"] = 8568;
                  t["ninesuperior"] = 8313;
                  t["nineteencircle"] = 9330;
                  t["nineteenparen"] = 9350;
                  t["nineteenperiod"] = 9370;
                  t["ninethai"] = 3673;
                  t["nj"] = 460;
                  t["njecyrillic"] = 1114;
                  t["nkatakana"] = 12531;
                  t["nkatakanahalfwidth"] = 65437;
                  t["nlegrightlong"] = 414;
                  t["nlinebelow"] = 7753;
                  t["nmonospace"] = 65358;
                  t["nmsquare"] = 13210;
                  t["nnabengali"] = 2467;
                  t["nnadeva"] = 2339;
                  t["nnagujarati"] = 2723;
                  t["nnagurmukhi"] = 2595;
                  t["nnnadeva"] = 2345;
                  t["nohiragana"] = 12398;
                  t["nokatakana"] = 12494;
                  t["nokatakanahalfwidth"] = 65417;
                  t["nonbreakingspace"] = 160;
                  t["nonenthai"] = 3603;
                  t["nonuthai"] = 3609;
                  t["noonarabic"] = 1606;
                  t["noonfinalarabic"] = 65254;
                  t["noonghunnaarabic"] = 1722;
                  t["noonghunnafinalarabic"] = 64415;
                  t["nooninitialarabic"] = 65255;
                  t["noonjeeminitialarabic"] = 64722;
                  t["noonjeemisolatedarabic"] = 64587;
                  t["noonmedialarabic"] = 65256;
                  t["noonmeeminitialarabic"] = 64725;
                  t["noonmeemisolatedarabic"] = 64590;
                  t["noonnoonfinalarabic"] = 64653;
                  t["notcontains"] = 8716;
                  t["notelement"] = 8713;
                  t["notelementof"] = 8713;
                  t["notequal"] = 8800;
                  t["notgreater"] = 8815;
                  t["notgreaternorequal"] = 8817;
                  t["notgreaternorless"] = 8825;
                  t["notidentical"] = 8802;
                  t["notless"] = 8814;
                  t["notlessnorequal"] = 8816;
                  t["notparallel"] = 8742;
                  t["notprecedes"] = 8832;
                  t["notsubset"] = 8836;
                  t["notsucceeds"] = 8833;
                  t["notsuperset"] = 8837;
                  t["nowarmenian"] = 1398;
                  t["nparen"] = 9385;
                  t["nssquare"] = 13233;
                  t["nsuperior"] = 8319;
                  t["ntilde"] = 241;
                  t["nu"] = 957;
                  t["nuhiragana"] = 12396;
                  t["nukatakana"] = 12492;
                  t["nukatakanahalfwidth"] = 65415;
                  t["nuktabengali"] = 2492;
                  t["nuktadeva"] = 2364;
                  t["nuktagujarati"] = 2748;
                  t["nuktagurmukhi"] = 2620;
                  t["numbersign"] = 35;
                  t["numbersignmonospace"] = 65283;
                  t["numbersignsmall"] = 65119;
                  t["numeralsigngreek"] = 884;
                  t["numeralsignlowergreek"] = 885;
                  t["numero"] = 8470;
                  t["nun"] = 1504;
                  t["nundagesh"] = 64320;
                  t["nundageshhebrew"] = 64320;
                  t["nunhebrew"] = 1504;
                  t["nvsquare"] = 13237;
                  t["nwsquare"] = 13243;
                  t["nyabengali"] = 2462;
                  t["nyadeva"] = 2334;
                  t["nyagujarati"] = 2718;
                  t["nyagurmukhi"] = 2590;
                  t["o"] = 111;
                  t["oacute"] = 243;
                  t["oangthai"] = 3629;
                  t["obarred"] = 629;
                  t["obarredcyrillic"] = 1257;
                  t["obarreddieresiscyrillic"] = 1259;
                  t["obengali"] = 2451;
                  t["obopomofo"] = 12571;
                  t["obreve"] = 335;
                  t["ocandradeva"] = 2321;
                  t["ocandragujarati"] = 2705;
                  t["ocandravowelsigndeva"] = 2377;
                  t["ocandravowelsigngujarati"] = 2761;
                  t["ocaron"] = 466;
                  t["ocircle"] = 9438;
                  t["ocircumflex"] = 244;
                  t["ocircumflexacute"] = 7889;
                  t["ocircumflexdotbelow"] = 7897;
                  t["ocircumflexgrave"] = 7891;
                  t["ocircumflexhookabove"] = 7893;
                  t["ocircumflextilde"] = 7895;
                  t["ocyrillic"] = 1086;
                  t["odblacute"] = 337;
                  t["odblgrave"] = 525;
                  t["odeva"] = 2323;
                  t["odieresis"] = 246;
                  t["odieresiscyrillic"] = 1255;
                  t["odotbelow"] = 7885;
                  t["oe"] = 339;
                  t["oekorean"] = 12634;
                  t["ogonek"] = 731;
                  t["ogonekcmb"] = 808;
                  t["ograve"] = 242;
                  t["ogujarati"] = 2707;
                  t["oharmenian"] = 1413;
                  t["ohiragana"] = 12362;
                  t["ohookabove"] = 7887;
                  t["ohorn"] = 417;
                  t["ohornacute"] = 7899;
                  t["ohorndotbelow"] = 7907;
                  t["ohorngrave"] = 7901;
                  t["ohornhookabove"] = 7903;
                  t["ohorntilde"] = 7905;
                  t["ohungarumlaut"] = 337;
                  t["oi"] = 419;
                  t["oinvertedbreve"] = 527;
                  t["okatakana"] = 12458;
                  t["okatakanahalfwidth"] = 65397;
                  t["okorean"] = 12631;
                  t["olehebrew"] = 1451;
                  t["omacron"] = 333;
                  t["omacronacute"] = 7763;
                  t["omacrongrave"] = 7761;
                  t["omdeva"] = 2384;
                  t["omega"] = 969;
                  t["omega1"] = 982;
                  t["omegacyrillic"] = 1121;
                  t["omegalatinclosed"] = 631;
                  t["omegaroundcyrillic"] = 1147;
                  t["omegatitlocyrillic"] = 1149;
                  t["omegatonos"] = 974;
                  t["omgujarati"] = 2768;
                  t["omicron"] = 959;
                  t["omicrontonos"] = 972;
                  t["omonospace"] = 65359;
                  t["one"] = 49;
                  t["onearabic"] = 1633;
                  t["onebengali"] = 2535;
                  t["onecircle"] = 9312;
                  t["onecircleinversesansserif"] = 10122;
                  t["onedeva"] = 2407;
                  t["onedotenleader"] = 8228;
                  t["oneeighth"] = 8539;
                  t["onefitted"] = 63196;
                  t["onegujarati"] = 2791;
                  t["onegurmukhi"] = 2663;
                  t["onehackarabic"] = 1633;
                  t["onehalf"] = 189;
                  t["onehangzhou"] = 12321;
                  t["oneideographicparen"] = 12832;
                  t["oneinferior"] = 8321;
                  t["onemonospace"] = 65297;
                  t["onenumeratorbengali"] = 2548;
                  t["oneoldstyle"] = 63281;
                  t["oneparen"] = 9332;
                  t["oneperiod"] = 9352;
                  t["onepersian"] = 1777;
                  t["onequarter"] = 188;
                  t["oneroman"] = 8560;
                  t["onesuperior"] = 185;
                  t["onethai"] = 3665;
                  t["onethird"] = 8531;
                  t["oogonek"] = 491;
                  t["oogonekmacron"] = 493;
                  t["oogurmukhi"] = 2579;
                  t["oomatragurmukhi"] = 2635;
                  t["oopen"] = 596;
                  t["oparen"] = 9386;
                  t["openbullet"] = 9702;
                  t["option"] = 8997;
                  t["ordfeminine"] = 170;
                  t["ordmasculine"] = 186;
                  t["orthogonal"] = 8735;
                  t["oshortdeva"] = 2322;
                  t["oshortvowelsigndeva"] = 2378;
                  t["oslash"] = 248;
                  t["oslashacute"] = 511;
                  t["osmallhiragana"] = 12361;
                  t["osmallkatakana"] = 12457;
                  t["osmallkatakanahalfwidth"] = 65387;
                  t["ostrokeacute"] = 511;
                  t["osuperior"] = 63216;
                  t["otcyrillic"] = 1151;
                  t["otilde"] = 245;
                  t["otildeacute"] = 7757;
                  t["otildedieresis"] = 7759;
                  t["oubopomofo"] = 12577;
                  t["overline"] = 8254;
                  t["overlinecenterline"] = 65098;
                  t["overlinecmb"] = 773;
                  t["overlinedashed"] = 65097;
                  t["overlinedblwavy"] = 65100;
                  t["overlinewavy"] = 65099;
                  t["overscore"] = 175;
                  t["ovowelsignbengali"] = 2507;
                  t["ovowelsigndeva"] = 2379;
                  t["ovowelsigngujarati"] = 2763;
                  t["p"] = 112;
                  t["paampssquare"] = 13184;
                  t["paasentosquare"] = 13099;
                  t["pabengali"] = 2474;
                  t["pacute"] = 7765;
                  t["padeva"] = 2346;
                  t["pagedown"] = 8671;
                  t["pageup"] = 8670;
                  t["pagujarati"] = 2730;
                  t["pagurmukhi"] = 2602;
                  t["pahiragana"] = 12401;
                  t["paiyannoithai"] = 3631;
                  t["pakatakana"] = 12497;
                  t["palatalizationcyrilliccmb"] = 1156;
                  t["palochkacyrillic"] = 1216;
                  t["pansioskorean"] = 12671;
                  t["paragraph"] = 182;
                  t["parallel"] = 8741;
                  t["parenleft"] = 40;
                  t["parenleftaltonearabic"] = 64830;
                  t["parenleftbt"] = 63725;
                  t["parenleftex"] = 63724;
                  t["parenleftinferior"] = 8333;
                  t["parenleftmonospace"] = 65288;
                  t["parenleftsmall"] = 65113;
                  t["parenleftsuperior"] = 8317;
                  t["parenlefttp"] = 63723;
                  t["parenleftvertical"] = 65077;
                  t["parenright"] = 41;
                  t["parenrightaltonearabic"] = 64831;
                  t["parenrightbt"] = 63736;
                  t["parenrightex"] = 63735;
                  t["parenrightinferior"] = 8334;
                  t["parenrightmonospace"] = 65289;
                  t["parenrightsmall"] = 65114;
                  t["parenrightsuperior"] = 8318;
                  t["parenrighttp"] = 63734;
                  t["parenrightvertical"] = 65078;
                  t["partialdiff"] = 8706;
                  t["paseqhebrew"] = 1472;
                  t["pashtahebrew"] = 1433;
                  t["pasquare"] = 13225;
                  t["patah"] = 1463;
                  t["patah11"] = 1463;
                  t["patah1d"] = 1463;
                  t["patah2a"] = 1463;
                  t["patahhebrew"] = 1463;
                  t["patahnarrowhebrew"] = 1463;
                  t["patahquarterhebrew"] = 1463;
                  t["patahwidehebrew"] = 1463;
                  t["pazerhebrew"] = 1441;
                  t["pbopomofo"] = 12550;
                  t["pcircle"] = 9439;
                  t["pdotaccent"] = 7767;
                  t["pe"] = 1508;
                  t["pecyrillic"] = 1087;
                  t["pedagesh"] = 64324;
                  t["pedageshhebrew"] = 64324;
                  t["peezisquare"] = 13115;
                  t["pefinaldageshhebrew"] = 64323;
                  t["peharabic"] = 1662;
                  t["peharmenian"] = 1402;
                  t["pehebrew"] = 1508;
                  t["pehfinalarabic"] = 64343;
                  t["pehinitialarabic"] = 64344;
                  t["pehiragana"] = 12410;
                  t["pehmedialarabic"] = 64345;
                  t["pekatakana"] = 12506;
                  t["pemiddlehookcyrillic"] = 1191;
                  t["perafehebrew"] = 64334;
                  t["percent"] = 37;
                  t["percentarabic"] = 1642;
                  t["percentmonospace"] = 65285;
                  t["percentsmall"] = 65130;
                  t["period"] = 46;
                  t["periodarmenian"] = 1417;
                  t["periodcentered"] = 183;
                  t["periodhalfwidth"] = 65377;
                  t["periodinferior"] = 63207;
                  t["periodmonospace"] = 65294;
                  t["periodsmall"] = 65106;
                  t["periodsuperior"] = 63208;
                  t["perispomenigreekcmb"] = 834;
                  t["perpendicular"] = 8869;
                  t["perthousand"] = 8240;
                  t["peseta"] = 8359;
                  t["pfsquare"] = 13194;
                  t["phabengali"] = 2475;
                  t["phadeva"] = 2347;
                  t["phagujarati"] = 2731;
                  t["phagurmukhi"] = 2603;
                  t["phi"] = 966;
                  t["phi1"] = 981;
                  t["phieuphacirclekorean"] = 12922;
                  t["phieuphaparenkorean"] = 12826;
                  t["phieuphcirclekorean"] = 12908;
                  t["phieuphkorean"] = 12621;
                  t["phieuphparenkorean"] = 12812;
                  t["philatin"] = 632;
                  t["phinthuthai"] = 3642;
                  t["phisymbolgreek"] = 981;
                  t["phook"] = 421;
                  t["phophanthai"] = 3614;
                  t["phophungthai"] = 3612;
                  t["phosamphaothai"] = 3616;
                  t["pi"] = 960;
                  t["pieupacirclekorean"] = 12915;
                  t["pieupaparenkorean"] = 12819;
                  t["pieupcieuckorean"] = 12662;
                  t["pieupcirclekorean"] = 12901;
                  t["pieupkiyeokkorean"] = 12658;
                  t["pieupkorean"] = 12610;
                  t["pieupparenkorean"] = 12805;
                  t["pieupsioskiyeokkorean"] = 12660;
                  t["pieupsioskorean"] = 12612;
                  t["pieupsiostikeutkorean"] = 12661;
                  t["pieupthieuthkorean"] = 12663;
                  t["pieuptikeutkorean"] = 12659;
                  t["pihiragana"] = 12404;
                  t["pikatakana"] = 12500;
                  t["pisymbolgreek"] = 982;
                  t["piwrarmenian"] = 1411;
                  t["plus"] = 43;
                  t["plusbelowcmb"] = 799;
                  t["pluscircle"] = 8853;
                  t["plusminus"] = 177;
                  t["plusmod"] = 726;
                  t["plusmonospace"] = 65291;
                  t["plussmall"] = 65122;
                  t["plussuperior"] = 8314;
                  t["pmonospace"] = 65360;
                  t["pmsquare"] = 13272;
                  t["pohiragana"] = 12413;
                  t["pointingindexdownwhite"] = 9759;
                  t["pointingindexleftwhite"] = 9756;
                  t["pointingindexrightwhite"] = 9758;
                  t["pointingindexupwhite"] = 9757;
                  t["pokatakana"] = 12509;
                  t["poplathai"] = 3611;
                  t["postalmark"] = 12306;
                  t["postalmarkface"] = 12320;
                  t["pparen"] = 9387;
                  t["precedes"] = 8826;
                  t["prescription"] = 8478;
                  t["primemod"] = 697;
                  t["primereversed"] = 8245;
                  t["product"] = 8719;
                  t["projective"] = 8965;
                  t["prolongedkana"] = 12540;
                  t["propellor"] = 8984;
                  t["propersubset"] = 8834;
                  t["propersuperset"] = 8835;
                  t["proportion"] = 8759;
                  t["proportional"] = 8733;
                  t["psi"] = 968;
                  t["psicyrillic"] = 1137;
                  t["psilipneumatacyrilliccmb"] = 1158;
                  t["pssquare"] = 13232;
                  t["puhiragana"] = 12407;
                  t["pukatakana"] = 12503;
                  t["pvsquare"] = 13236;
                  t["pwsquare"] = 13242;
                  t["q"] = 113;
                  t["qadeva"] = 2392;
                  t["qadmahebrew"] = 1448;
                  t["qafarabic"] = 1602;
                  t["qaffinalarabic"] = 65238;
                  t["qafinitialarabic"] = 65239;
                  t["qafmedialarabic"] = 65240;
                  t["qamats"] = 1464;
                  t["qamats10"] = 1464;
                  t["qamats1a"] = 1464;
                  t["qamats1c"] = 1464;
                  t["qamats27"] = 1464;
                  t["qamats29"] = 1464;
                  t["qamats33"] = 1464;
                  t["qamatsde"] = 1464;
                  t["qamatshebrew"] = 1464;
                  t["qamatsnarrowhebrew"] = 1464;
                  t["qamatsqatanhebrew"] = 1464;
                  t["qamatsqatannarrowhebrew"] = 1464;
                  t["qamatsqatanquarterhebrew"] = 1464;
                  t["qamatsqatanwidehebrew"] = 1464;
                  t["qamatsquarterhebrew"] = 1464;
                  t["qamatswidehebrew"] = 1464;
                  t["qarneyparahebrew"] = 1439;
                  t["qbopomofo"] = 12561;
                  t["qcircle"] = 9440;
                  t["qhook"] = 672;
                  t["qmonospace"] = 65361;
                  t["qof"] = 1511;
                  t["qofdagesh"] = 64327;
                  t["qofdageshhebrew"] = 64327;
                  t["qofhebrew"] = 1511;
                  t["qparen"] = 9388;
                  t["quarternote"] = 9833;
                  t["qubuts"] = 1467;
                  t["qubuts18"] = 1467;
                  t["qubuts25"] = 1467;
                  t["qubuts31"] = 1467;
                  t["qubutshebrew"] = 1467;
                  t["qubutsnarrowhebrew"] = 1467;
                  t["qubutsquarterhebrew"] = 1467;
                  t["qubutswidehebrew"] = 1467;
                  t["question"] = 63;
                  t["questionarabic"] = 1567;
                  t["questionarmenian"] = 1374;
                  t["questiondown"] = 191;
                  t["questiondownsmall"] = 63423;
                  t["questiongreek"] = 894;
                  t["questionmonospace"] = 65311;
                  t["questionsmall"] = 63295;
                  t["quotedbl"] = 34;
                  t["quotedblbase"] = 8222;
                  t["quotedblleft"] = 8220;
                  t["quotedblmonospace"] = 65282;
                  t["quotedblprime"] = 12318;
                  t["quotedblprimereversed"] = 12317;
                  t["quotedblright"] = 8221;
                  t["quoteleft"] = 8216;
                  t["quoteleftreversed"] = 8219;
                  t["quotereversed"] = 8219;
                  t["quoteright"] = 8217;
                  t["quoterightn"] = 329;
                  t["quotesinglbase"] = 8218;
                  t["quotesingle"] = 39;
                  t["quotesinglemonospace"] = 65287;
                  t["r"] = 114;
                  t["raarmenian"] = 1404;
                  t["rabengali"] = 2480;
                  t["racute"] = 341;
                  t["radeva"] = 2352;
                  t["radical"] = 8730;
                  t["radicalex"] = 63717;
                  t["radoverssquare"] = 13230;
                  t["radoverssquaredsquare"] = 13231;
                  t["radsquare"] = 13229;
                  t["rafe"] = 1471;
                  t["rafehebrew"] = 1471;
                  t["ragujarati"] = 2736;
                  t["ragurmukhi"] = 2608;
                  t["rahiragana"] = 12425;
                  t["rakatakana"] = 12521;
                  t["rakatakanahalfwidth"] = 65431;
                  t["ralowerdiagonalbengali"] = 2545;
                  t["ramiddlediagonalbengali"] = 2544;
                  t["ramshorn"] = 612;
                  t["ratio"] = 8758;
                  t["rbopomofo"] = 12566;
                  t["rcaron"] = 345;
                  t["rcedilla"] = 343;
                  t["rcircle"] = 9441;
                  t["rcommaaccent"] = 343;
                  t["rdblgrave"] = 529;
                  t["rdotaccent"] = 7769;
                  t["rdotbelow"] = 7771;
                  t["rdotbelowmacron"] = 7773;
                  t["referencemark"] = 8251;
                  t["reflexsubset"] = 8838;
                  t["reflexsuperset"] = 8839;
                  t["registered"] = 174;
                  t["registersans"] = 63720;
                  t["registerserif"] = 63194;
                  t["reharabic"] = 1585;
                  t["reharmenian"] = 1408;
                  t["rehfinalarabic"] = 65198;
                  t["rehiragana"] = 12428;
                  t["rekatakana"] = 12524;
                  t["rekatakanahalfwidth"] = 65434;
                  t["resh"] = 1512;
                  t["reshdageshhebrew"] = 64328;
                  t["reshhebrew"] = 1512;
                  t["reversedtilde"] = 8765;
                  t["reviahebrew"] = 1431;
                  t["reviamugrashhebrew"] = 1431;
                  t["revlogicalnot"] = 8976;
                  t["rfishhook"] = 638;
                  t["rfishhookreversed"] = 639;
                  t["rhabengali"] = 2525;
                  t["rhadeva"] = 2397;
                  t["rho"] = 961;
                  t["rhook"] = 637;
                  t["rhookturned"] = 635;
                  t["rhookturnedsuperior"] = 693;
                  t["rhosymbolgreek"] = 1009;
                  t["rhotichookmod"] = 734;
                  t["rieulacirclekorean"] = 12913;
                  t["rieulaparenkorean"] = 12817;
                  t["rieulcirclekorean"] = 12899;
                  t["rieulhieuhkorean"] = 12608;
                  t["rieulkiyeokkorean"] = 12602;
                  t["rieulkiyeoksioskorean"] = 12649;
                  t["rieulkorean"] = 12601;
                  t["rieulmieumkorean"] = 12603;
                  t["rieulpansioskorean"] = 12652;
                  t["rieulparenkorean"] = 12803;
                  t["rieulphieuphkorean"] = 12607;
                  t["rieulpieupkorean"] = 12604;
                  t["rieulpieupsioskorean"] = 12651;
                  t["rieulsioskorean"] = 12605;
                  t["rieulthieuthkorean"] = 12606;
                  t["rieultikeutkorean"] = 12650;
                  t["rieulyeorinhieuhkorean"] = 12653;
                  t["rightangle"] = 8735;
                  t["righttackbelowcmb"] = 793;
                  t["righttriangle"] = 8895;
                  t["rihiragana"] = 12426;
                  t["rikatakana"] = 12522;
                  t["rikatakanahalfwidth"] = 65432;
                  t["ring"] = 730;
                  t["ringbelowcmb"] = 805;
                  t["ringcmb"] = 778;
                  t["ringhalfleft"] = 703;
                  t["ringhalfleftarmenian"] = 1369;
                  t["ringhalfleftbelowcmb"] = 796;
                  t["ringhalfleftcentered"] = 723;
                  t["ringhalfright"] = 702;
                  t["ringhalfrightbelowcmb"] = 825;
                  t["ringhalfrightcentered"] = 722;
                  t["rinvertedbreve"] = 531;
                  t["rittorusquare"] = 13137;
                  t["rlinebelow"] = 7775;
                  t["rlongleg"] = 636;
                  t["rlonglegturned"] = 634;
                  t["rmonospace"] = 65362;
                  t["rohiragana"] = 12429;
                  t["rokatakana"] = 12525;
                  t["rokatakanahalfwidth"] = 65435;
                  t["roruathai"] = 3619;
                  t["rparen"] = 9389;
                  t["rrabengali"] = 2524;
                  t["rradeva"] = 2353;
                  t["rragurmukhi"] = 2652;
                  t["rreharabic"] = 1681;
                  t["rrehfinalarabic"] = 64397;
                  t["rrvocalicbengali"] = 2528;
                  t["rrvocalicdeva"] = 2400;
                  t["rrvocalicgujarati"] = 2784;
                  t["rrvocalicvowelsignbengali"] = 2500;
                  t["rrvocalicvowelsigndeva"] = 2372;
                  t["rrvocalicvowelsigngujarati"] = 2756;
                  t["rsuperior"] = 63217;
                  t["rtblock"] = 9616;
                  t["rturned"] = 633;
                  t["rturnedsuperior"] = 692;
                  t["ruhiragana"] = 12427;
                  t["rukatakana"] = 12523;
                  t["rukatakanahalfwidth"] = 65433;
                  t["rupeemarkbengali"] = 2546;
                  t["rupeesignbengali"] = 2547;
                  t["rupiah"] = 63197;
                  t["ruthai"] = 3620;
                  t["rvocalicbengali"] = 2443;
                  t["rvocalicdeva"] = 2315;
                  t["rvocalicgujarati"] = 2699;
                  t["rvocalicvowelsignbengali"] = 2499;
                  t["rvocalicvowelsigndeva"] = 2371;
                  t["rvocalicvowelsigngujarati"] = 2755;
                  t["s"] = 115;
                  t["sabengali"] = 2488;
                  t["sacute"] = 347;
                  t["sacutedotaccent"] = 7781;
                  t["sadarabic"] = 1589;
                  t["sadeva"] = 2360;
                  t["sadfinalarabic"] = 65210;
                  t["sadinitialarabic"] = 65211;
                  t["sadmedialarabic"] = 65212;
                  t["sagujarati"] = 2744;
                  t["sagurmukhi"] = 2616;
                  t["sahiragana"] = 12373;
                  t["sakatakana"] = 12469;
                  t["sakatakanahalfwidth"] = 65403;
                  t["sallallahoualayhewasallamarabic"] = 65018;
                  t["samekh"] = 1505;
                  t["samekhdagesh"] = 64321;
                  t["samekhdageshhebrew"] = 64321;
                  t["samekhhebrew"] = 1505;
                  t["saraaathai"] = 3634;
                  t["saraaethai"] = 3649;
                  t["saraaimaimalaithai"] = 3652;
                  t["saraaimaimuanthai"] = 3651;
                  t["saraamthai"] = 3635;
                  t["saraathai"] = 3632;
                  t["saraethai"] = 3648;
                  t["saraiileftthai"] = 63622;
                  t["saraiithai"] = 3637;
                  t["saraileftthai"] = 63621;
                  t["saraithai"] = 3636;
                  t["saraothai"] = 3650;
                  t["saraueeleftthai"] = 63624;
                  t["saraueethai"] = 3639;
                  t["saraueleftthai"] = 63623;
                  t["sarauethai"] = 3638;
                  t["sarauthai"] = 3640;
                  t["sarauuthai"] = 3641;
                  t["sbopomofo"] = 12569;
                  t["scaron"] = 353;
                  t["scarondotaccent"] = 7783;
                  t["scedilla"] = 351;
                  t["schwa"] = 601;
                  t["schwacyrillic"] = 1241;
                  t["schwadieresiscyrillic"] = 1243;
                  t["schwahook"] = 602;
                  t["scircle"] = 9442;
                  t["scircumflex"] = 349;
                  t["scommaaccent"] = 537;
                  t["sdotaccent"] = 7777;
                  t["sdotbelow"] = 7779;
                  t["sdotbelowdotaccent"] = 7785;
                  t["seagullbelowcmb"] = 828;
                  t["second"] = 8243;
                  t["secondtonechinese"] = 714;
                  t["section"] = 167;
                  t["seenarabic"] = 1587;
                  t["seenfinalarabic"] = 65202;
                  t["seeninitialarabic"] = 65203;
                  t["seenmedialarabic"] = 65204;
                  t["segol"] = 1462;
                  t["segol13"] = 1462;
                  t["segol1f"] = 1462;
                  t["segol2c"] = 1462;
                  t["segolhebrew"] = 1462;
                  t["segolnarrowhebrew"] = 1462;
                  t["segolquarterhebrew"] = 1462;
                  t["segoltahebrew"] = 1426;
                  t["segolwidehebrew"] = 1462;
                  t["seharmenian"] = 1405;
                  t["sehiragana"] = 12379;
                  t["sekatakana"] = 12475;
                  t["sekatakanahalfwidth"] = 65406;
                  t["semicolon"] = 59;
                  t["semicolonarabic"] = 1563;
                  t["semicolonmonospace"] = 65307;
                  t["semicolonsmall"] = 65108;
                  t["semivoicedmarkkana"] = 12444;
                  t["semivoicedmarkkanahalfwidth"] = 65439;
                  t["sentisquare"] = 13090;
                  t["sentosquare"] = 13091;
                  t["seven"] = 55;
                  t["sevenarabic"] = 1639;
                  t["sevenbengali"] = 2541;
                  t["sevencircle"] = 9318;
                  t["sevencircleinversesansserif"] = 10128;
                  t["sevendeva"] = 2413;
                  t["seveneighths"] = 8542;
                  t["sevengujarati"] = 2797;
                  t["sevengurmukhi"] = 2669;
                  t["sevenhackarabic"] = 1639;
                  t["sevenhangzhou"] = 12327;
                  t["sevenideographicparen"] = 12838;
                  t["seveninferior"] = 8327;
                  t["sevenmonospace"] = 65303;
                  t["sevenoldstyle"] = 63287;
                  t["sevenparen"] = 9338;
                  t["sevenperiod"] = 9358;
                  t["sevenpersian"] = 1783;
                  t["sevenroman"] = 8566;
                  t["sevensuperior"] = 8311;
                  t["seventeencircle"] = 9328;
                  t["seventeenparen"] = 9348;
                  t["seventeenperiod"] = 9368;
                  t["seventhai"] = 3671;
                  t["sfthyphen"] = 173;
                  t["shaarmenian"] = 1399;
                  t["shabengali"] = 2486;
                  t["shacyrillic"] = 1096;
                  t["shaddaarabic"] = 1617;
                  t["shaddadammaarabic"] = 64609;
                  t["shaddadammatanarabic"] = 64606;
                  t["shaddafathaarabic"] = 64608;
                  t["shaddakasraarabic"] = 64610;
                  t["shaddakasratanarabic"] = 64607;
                  t["shade"] = 9618;
                  t["shadedark"] = 9619;
                  t["shadelight"] = 9617;
                  t["shademedium"] = 9618;
                  t["shadeva"] = 2358;
                  t["shagujarati"] = 2742;
                  t["shagurmukhi"] = 2614;
                  t["shalshelethebrew"] = 1427;
                  t["shbopomofo"] = 12565;
                  t["shchacyrillic"] = 1097;
                  t["sheenarabic"] = 1588;
                  t["sheenfinalarabic"] = 65206;
                  t["sheeninitialarabic"] = 65207;
                  t["sheenmedialarabic"] = 65208;
                  t["sheicoptic"] = 995;
                  t["sheqel"] = 8362;
                  t["sheqelhebrew"] = 8362;
                  t["sheva"] = 1456;
                  t["sheva115"] = 1456;
                  t["sheva15"] = 1456;
                  t["sheva22"] = 1456;
                  t["sheva2e"] = 1456;
                  t["shevahebrew"] = 1456;
                  t["shevanarrowhebrew"] = 1456;
                  t["shevaquarterhebrew"] = 1456;
                  t["shevawidehebrew"] = 1456;
                  t["shhacyrillic"] = 1211;
                  t["shimacoptic"] = 1005;
                  t["shin"] = 1513;
                  t["shindagesh"] = 64329;
                  t["shindageshhebrew"] = 64329;
                  t["shindageshshindot"] = 64300;
                  t["shindageshshindothebrew"] = 64300;
                  t["shindageshsindot"] = 64301;
                  t["shindageshsindothebrew"] = 64301;
                  t["shindothebrew"] = 1473;
                  t["shinhebrew"] = 1513;
                  t["shinshindot"] = 64298;
                  t["shinshindothebrew"] = 64298;
                  t["shinsindot"] = 64299;
                  t["shinsindothebrew"] = 64299;
                  t["shook"] = 642;
                  t["sigma"] = 963;
                  t["sigma1"] = 962;
                  t["sigmafinal"] = 962;
                  t["sigmalunatesymbolgreek"] = 1010;
                  t["sihiragana"] = 12375;
                  t["sikatakana"] = 12471;
                  t["sikatakanahalfwidth"] = 65404;
                  t["siluqhebrew"] = 1469;
                  t["siluqlefthebrew"] = 1469;
                  t["similar"] = 8764;
                  t["sindothebrew"] = 1474;
                  t["siosacirclekorean"] = 12916;
                  t["siosaparenkorean"] = 12820;
                  t["sioscieuckorean"] = 12670;
                  t["sioscirclekorean"] = 12902;
                  t["sioskiyeokkorean"] = 12666;
                  t["sioskorean"] = 12613;
                  t["siosnieunkorean"] = 12667;
                  t["siosparenkorean"] = 12806;
                  t["siospieupkorean"] = 12669;
                  t["siostikeutkorean"] = 12668;
                  t["six"] = 54;
                  t["sixarabic"] = 1638;
                  t["sixbengali"] = 2540;
                  t["sixcircle"] = 9317;
                  t["sixcircleinversesansserif"] = 10127;
                  t["sixdeva"] = 2412;
                  t["sixgujarati"] = 2796;
                  t["sixgurmukhi"] = 2668;
                  t["sixhackarabic"] = 1638;
                  t["sixhangzhou"] = 12326;
                  t["sixideographicparen"] = 12837;
                  t["sixinferior"] = 8326;
                  t["sixmonospace"] = 65302;
                  t["sixoldstyle"] = 63286;
                  t["sixparen"] = 9337;
                  t["sixperiod"] = 9357;
                  t["sixpersian"] = 1782;
                  t["sixroman"] = 8565;
                  t["sixsuperior"] = 8310;
                  t["sixteencircle"] = 9327;
                  t["sixteencurrencydenominatorbengali"] = 2553;
                  t["sixteenparen"] = 9347;
                  t["sixteenperiod"] = 9367;
                  t["sixthai"] = 3670;
                  t["slash"] = 47;
                  t["slashmonospace"] = 65295;
                  t["slong"] = 383;
                  t["slongdotaccent"] = 7835;
                  t["smileface"] = 9786;
                  t["smonospace"] = 65363;
                  t["sofpasuqhebrew"] = 1475;
                  t["softhyphen"] = 173;
                  t["softsigncyrillic"] = 1100;
                  t["sohiragana"] = 12381;
                  t["sokatakana"] = 12477;
                  t["sokatakanahalfwidth"] = 65407;
                  t["soliduslongoverlaycmb"] = 824;
                  t["solidusshortoverlaycmb"] = 823;
                  t["sorusithai"] = 3625;
                  t["sosalathai"] = 3624;
                  t["sosothai"] = 3595;
                  t["sosuathai"] = 3626;
                  t["space"] = 32;
                  t["spacehackarabic"] = 32;
                  t["spade"] = 9824;
                  t["spadesuitblack"] = 9824;
                  t["spadesuitwhite"] = 9828;
                  t["sparen"] = 9390;
                  t["squarebelowcmb"] = 827;
                  t["squarecc"] = 13252;
                  t["squarecm"] = 13213;
                  t["squarediagonalcrosshatchfill"] = 9641;
                  t["squarehorizontalfill"] = 9636;
                  t["squarekg"] = 13199;
                  t["squarekm"] = 13214;
                  t["squarekmcapital"] = 13262;
                  t["squareln"] = 13265;
                  t["squarelog"] = 13266;
                  t["squaremg"] = 13198;
                  t["squaremil"] = 13269;
                  t["squaremm"] = 13212;
                  t["squaremsquared"] = 13217;
                  t["squareorthogonalcrosshatchfill"] = 9638;
                  t["squareupperlefttolowerrightfill"] = 9639;
                  t["squareupperrighttolowerleftfill"] = 9640;
                  t["squareverticalfill"] = 9637;
                  t["squarewhitewithsmallblack"] = 9635;
                  t["srsquare"] = 13275;
                  t["ssabengali"] = 2487;
                  t["ssadeva"] = 2359;
                  t["ssagujarati"] = 2743;
                  t["ssangcieuckorean"] = 12617;
                  t["ssanghieuhkorean"] = 12677;
                  t["ssangieungkorean"] = 12672;
                  t["ssangkiyeokkorean"] = 12594;
                  t["ssangnieunkorean"] = 12645;
                  t["ssangpieupkorean"] = 12611;
                  t["ssangsioskorean"] = 12614;
                  t["ssangtikeutkorean"] = 12600;
                  t["ssuperior"] = 63218;
                  t["sterling"] = 163;
                  t["sterlingmonospace"] = 65505;
                  t["strokelongoverlaycmb"] = 822;
                  t["strokeshortoverlaycmb"] = 821;
                  t["subset"] = 8834;
                  t["subsetnotequal"] = 8842;
                  t["subsetorequal"] = 8838;
                  t["succeeds"] = 8827;
                  t["suchthat"] = 8715;
                  t["suhiragana"] = 12377;
                  t["sukatakana"] = 12473;
                  t["sukatakanahalfwidth"] = 65405;
                  t["sukunarabic"] = 1618;
                  t["summation"] = 8721;
                  t["sun"] = 9788;
                  t["superset"] = 8835;
                  t["supersetnotequal"] = 8843;
                  t["supersetorequal"] = 8839;
                  t["svsquare"] = 13276;
                  t["syouwaerasquare"] = 13180;
                  t["t"] = 116;
                  t["tabengali"] = 2468;
                  t["tackdown"] = 8868;
                  t["tackleft"] = 8867;
                  t["tadeva"] = 2340;
                  t["tagujarati"] = 2724;
                  t["tagurmukhi"] = 2596;
                  t["taharabic"] = 1591;
                  t["tahfinalarabic"] = 65218;
                  t["tahinitialarabic"] = 65219;
                  t["tahiragana"] = 12383;
                  t["tahmedialarabic"] = 65220;
                  t["taisyouerasquare"] = 13181;
                  t["takatakana"] = 12479;
                  t["takatakanahalfwidth"] = 65408;
                  t["tatweelarabic"] = 1600;
                  t["tau"] = 964;
                  t["tav"] = 1514;
                  t["tavdages"] = 64330;
                  t["tavdagesh"] = 64330;
                  t["tavdageshhebrew"] = 64330;
                  t["tavhebrew"] = 1514;
                  t["tbar"] = 359;
                  t["tbopomofo"] = 12554;
                  t["tcaron"] = 357;
                  t["tccurl"] = 680;
                  t["tcedilla"] = 355;
                  t["tcheharabic"] = 1670;
                  t["tchehfinalarabic"] = 64379;
                  t["tchehinitialarabic"] = 64380;
                  t["tchehmedialarabic"] = 64381;
                  t["tcircle"] = 9443;
                  t["tcircumflexbelow"] = 7793;
                  t["tcommaaccent"] = 355;
                  t["tdieresis"] = 7831;
                  t["tdotaccent"] = 7787;
                  t["tdotbelow"] = 7789;
                  t["tecyrillic"] = 1090;
                  t["tedescendercyrillic"] = 1197;
                  t["teharabic"] = 1578;
                  t["tehfinalarabic"] = 65174;
                  t["tehhahinitialarabic"] = 64674;
                  t["tehhahisolatedarabic"] = 64524;
                  t["tehinitialarabic"] = 65175;
                  t["tehiragana"] = 12390;
                  t["tehjeeminitialarabic"] = 64673;
                  t["tehjeemisolatedarabic"] = 64523;
                  t["tehmarbutaarabic"] = 1577;
                  t["tehmarbutafinalarabic"] = 65172;
                  t["tehmedialarabic"] = 65176;
                  t["tehmeeminitialarabic"] = 64676;
                  t["tehmeemisolatedarabic"] = 64526;
                  t["tehnoonfinalarabic"] = 64627;
                  t["tekatakana"] = 12486;
                  t["tekatakanahalfwidth"] = 65411;
                  t["telephone"] = 8481;
                  t["telephoneblack"] = 9742;
                  t["telishagedolahebrew"] = 1440;
                  t["telishaqetanahebrew"] = 1449;
                  t["tencircle"] = 9321;
                  t["tenideographicparen"] = 12841;
                  t["tenparen"] = 9341;
                  t["tenperiod"] = 9361;
                  t["tenroman"] = 8569;
                  t["tesh"] = 679;
                  t["tet"] = 1496;
                  t["tetdagesh"] = 64312;
                  t["tetdageshhebrew"] = 64312;
                  t["tethebrew"] = 1496;
                  t["tetsecyrillic"] = 1205;
                  t["tevirhebrew"] = 1435;
                  t["tevirlefthebrew"] = 1435;
                  t["thabengali"] = 2469;
                  t["thadeva"] = 2341;
                  t["thagujarati"] = 2725;
                  t["thagurmukhi"] = 2597;
                  t["thalarabic"] = 1584;
                  t["thalfinalarabic"] = 65196;
                  t["thanthakhatlowleftthai"] = 63640;
                  t["thanthakhatlowrightthai"] = 63639;
                  t["thanthakhatthai"] = 3660;
                  t["thanthakhatupperleftthai"] = 63638;
                  t["theharabic"] = 1579;
                  t["thehfinalarabic"] = 65178;
                  t["thehinitialarabic"] = 65179;
                  t["thehmedialarabic"] = 65180;
                  t["thereexists"] = 8707;
                  t["therefore"] = 8756;
                  t["theta"] = 952;
                  t["theta1"] = 977;
                  t["thetasymbolgreek"] = 977;
                  t["thieuthacirclekorean"] = 12921;
                  t["thieuthaparenkorean"] = 12825;
                  t["thieuthcirclekorean"] = 12907;
                  t["thieuthkorean"] = 12620;
                  t["thieuthparenkorean"] = 12811;
                  t["thirteencircle"] = 9324;
                  t["thirteenparen"] = 9344;
                  t["thirteenperiod"] = 9364;
                  t["thonangmonthothai"] = 3601;
                  t["thook"] = 429;
                  t["thophuthaothai"] = 3602;
                  t["thorn"] = 254;
                  t["thothahanthai"] = 3607;
                  t["thothanthai"] = 3600;
                  t["thothongthai"] = 3608;
                  t["thothungthai"] = 3606;
                  t["thousandcyrillic"] = 1154;
                  t["thousandsseparatorarabic"] = 1644;
                  t["thousandsseparatorpersian"] = 1644;
                  t["three"] = 51;
                  t["threearabic"] = 1635;
                  t["threebengali"] = 2537;
                  t["threecircle"] = 9314;
                  t["threecircleinversesansserif"] = 10124;
                  t["threedeva"] = 2409;
                  t["threeeighths"] = 8540;
                  t["threegujarati"] = 2793;
                  t["threegurmukhi"] = 2665;
                  t["threehackarabic"] = 1635;
                  t["threehangzhou"] = 12323;
                  t["threeideographicparen"] = 12834;
                  t["threeinferior"] = 8323;
                  t["threemonospace"] = 65299;
                  t["threenumeratorbengali"] = 2550;
                  t["threeoldstyle"] = 63283;
                  t["threeparen"] = 9334;
                  t["threeperiod"] = 9354;
                  t["threepersian"] = 1779;
                  t["threequarters"] = 190;
                  t["threequartersemdash"] = 63198;
                  t["threeroman"] = 8562;
                  t["threesuperior"] = 179;
                  t["threethai"] = 3667;
                  t["thzsquare"] = 13204;
                  t["tihiragana"] = 12385;
                  t["tikatakana"] = 12481;
                  t["tikatakanahalfwidth"] = 65409;
                  t["tikeutacirclekorean"] = 12912;
                  t["tikeutaparenkorean"] = 12816;
                  t["tikeutcirclekorean"] = 12898;
                  t["tikeutkorean"] = 12599;
                  t["tikeutparenkorean"] = 12802;
                  t["tilde"] = 732;
                  t["tildebelowcmb"] = 816;
                  t["tildecmb"] = 771;
                  t["tildecomb"] = 771;
                  t["tildedoublecmb"] = 864;
                  t["tildeoperator"] = 8764;
                  t["tildeoverlaycmb"] = 820;
                  t["tildeverticalcmb"] = 830;
                  t["timescircle"] = 8855;
                  t["tipehahebrew"] = 1430;
                  t["tipehalefthebrew"] = 1430;
                  t["tippigurmukhi"] = 2672;
                  t["titlocyrilliccmb"] = 1155;
                  t["tiwnarmenian"] = 1407;
                  t["tlinebelow"] = 7791;
                  t["tmonospace"] = 65364;
                  t["toarmenian"] = 1385;
                  t["tohiragana"] = 12392;
                  t["tokatakana"] = 12488;
                  t["tokatakanahalfwidth"] = 65412;
                  t["tonebarextrahighmod"] = 741;
                  t["tonebarextralowmod"] = 745;
                  t["tonebarhighmod"] = 742;
                  t["tonebarlowmod"] = 744;
                  t["tonebarmidmod"] = 743;
                  t["tonefive"] = 445;
                  t["tonesix"] = 389;
                  t["tonetwo"] = 424;
                  t["tonos"] = 900;
                  t["tonsquare"] = 13095;
                  t["topatakthai"] = 3599;
                  t["tortoiseshellbracketleft"] = 12308;
                  t["tortoiseshellbracketleftsmall"] = 65117;
                  t["tortoiseshellbracketleftvertical"] = 65081;
                  t["tortoiseshellbracketright"] = 12309;
                  t["tortoiseshellbracketrightsmall"] = 65118;
                  t["tortoiseshellbracketrightvertical"] = 65082;
                  t["totaothai"] = 3605;
                  t["tpalatalhook"] = 427;
                  t["tparen"] = 9391;
                  t["trademark"] = 8482;
                  t["trademarksans"] = 63722;
                  t["trademarkserif"] = 63195;
                  t["tretroflexhook"] = 648;
                  t["triagdn"] = 9660;
                  t["triaglf"] = 9668;
                  t["triagrt"] = 9658;
                  t["triagup"] = 9650;
                  t["ts"] = 678;
                  t["tsadi"] = 1510;
                  t["tsadidagesh"] = 64326;
                  t["tsadidageshhebrew"] = 64326;
                  t["tsadihebrew"] = 1510;
                  t["tsecyrillic"] = 1094;
                  t["tsere"] = 1461;
                  t["tsere12"] = 1461;
                  t["tsere1e"] = 1461;
                  t["tsere2b"] = 1461;
                  t["tserehebrew"] = 1461;
                  t["tserenarrowhebrew"] = 1461;
                  t["tserequarterhebrew"] = 1461;
                  t["tserewidehebrew"] = 1461;
                  t["tshecyrillic"] = 1115;
                  t["tsuperior"] = 63219;
                  t["ttabengali"] = 2463;
                  t["ttadeva"] = 2335;
                  t["ttagujarati"] = 2719;
                  t["ttagurmukhi"] = 2591;
                  t["tteharabic"] = 1657;
                  t["ttehfinalarabic"] = 64359;
                  t["ttehinitialarabic"] = 64360;
                  t["ttehmedialarabic"] = 64361;
                  t["tthabengali"] = 2464;
                  t["tthadeva"] = 2336;
                  t["tthagujarati"] = 2720;
                  t["tthagurmukhi"] = 2592;
                  t["tturned"] = 647;
                  t["tuhiragana"] = 12388;
                  t["tukatakana"] = 12484;
                  t["tukatakanahalfwidth"] = 65410;
                  t["tusmallhiragana"] = 12387;
                  t["tusmallkatakana"] = 12483;
                  t["tusmallkatakanahalfwidth"] = 65391;
                  t["twelvecircle"] = 9323;
                  t["twelveparen"] = 9343;
                  t["twelveperiod"] = 9363;
                  t["twelveroman"] = 8571;
                  t["twentycircle"] = 9331;
                  t["twentyhangzhou"] = 21316;
                  t["twentyparen"] = 9351;
                  t["twentyperiod"] = 9371;
                  t["two"] = 50;
                  t["twoarabic"] = 1634;
                  t["twobengali"] = 2536;
                  t["twocircle"] = 9313;
                  t["twocircleinversesansserif"] = 10123;
                  t["twodeva"] = 2408;
                  t["twodotenleader"] = 8229;
                  t["twodotleader"] = 8229;
                  t["twodotleadervertical"] = 65072;
                  t["twogujarati"] = 2792;
                  t["twogurmukhi"] = 2664;
                  t["twohackarabic"] = 1634;
                  t["twohangzhou"] = 12322;
                  t["twoideographicparen"] = 12833;
                  t["twoinferior"] = 8322;
                  t["twomonospace"] = 65298;
                  t["twonumeratorbengali"] = 2549;
                  t["twooldstyle"] = 63282;
                  t["twoparen"] = 9333;
                  t["twoperiod"] = 9353;
                  t["twopersian"] = 1778;
                  t["tworoman"] = 8561;
                  t["twostroke"] = 443;
                  t["twosuperior"] = 178;
                  t["twothai"] = 3666;
                  t["twothirds"] = 8532;
                  t["u"] = 117;
                  t["uacute"] = 250;
                  t["ubar"] = 649;
                  t["ubengali"] = 2441;
                  t["ubopomofo"] = 12584;
                  t["ubreve"] = 365;
                  t["ucaron"] = 468;
                  t["ucircle"] = 9444;
                  t["ucircumflex"] = 251;
                  t["ucircumflexbelow"] = 7799;
                  t["ucyrillic"] = 1091;
                  t["udattadeva"] = 2385;
                  t["udblacute"] = 369;
                  t["udblgrave"] = 533;
                  t["udeva"] = 2313;
                  t["udieresis"] = 252;
                  t["udieresisacute"] = 472;
                  t["udieresisbelow"] = 7795;
                  t["udieresiscaron"] = 474;
                  t["udieresiscyrillic"] = 1265;
                  t["udieresisgrave"] = 476;
                  t["udieresismacron"] = 470;
                  t["udotbelow"] = 7909;
                  t["ugrave"] = 249;
                  t["ugujarati"] = 2697;
                  t["ugurmukhi"] = 2569;
                  t["uhiragana"] = 12358;
                  t["uhookabove"] = 7911;
                  t["uhorn"] = 432;
                  t["uhornacute"] = 7913;
                  t["uhorndotbelow"] = 7921;
                  t["uhorngrave"] = 7915;
                  t["uhornhookabove"] = 7917;
                  t["uhorntilde"] = 7919;
                  t["uhungarumlaut"] = 369;
                  t["uhungarumlautcyrillic"] = 1267;
                  t["uinvertedbreve"] = 535;
                  t["ukatakana"] = 12454;
                  t["ukatakanahalfwidth"] = 65395;
                  t["ukcyrillic"] = 1145;
                  t["ukorean"] = 12636;
                  t["umacron"] = 363;
                  t["umacroncyrillic"] = 1263;
                  t["umacrondieresis"] = 7803;
                  t["umatragurmukhi"] = 2625;
                  t["umonospace"] = 65365;
                  t["underscore"] = 95;
                  t["underscoredbl"] = 8215;
                  t["underscoremonospace"] = 65343;
                  t["underscorevertical"] = 65075;
                  t["underscorewavy"] = 65103;
                  t["union"] = 8746;
                  t["universal"] = 8704;
                  t["uogonek"] = 371;
                  t["uparen"] = 9392;
                  t["upblock"] = 9600;
                  t["upperdothebrew"] = 1476;
                  t["upsilon"] = 965;
                  t["upsilondieresis"] = 971;
                  t["upsilondieresistonos"] = 944;
                  t["upsilonlatin"] = 650;
                  t["upsilontonos"] = 973;
                  t["uptackbelowcmb"] = 797;
                  t["uptackmod"] = 724;
                  t["uragurmukhi"] = 2675;
                  t["uring"] = 367;
                  t["ushortcyrillic"] = 1118;
                  t["usmallhiragana"] = 12357;
                  t["usmallkatakana"] = 12453;
                  t["usmallkatakanahalfwidth"] = 65385;
                  t["ustraightcyrillic"] = 1199;
                  t["ustraightstrokecyrillic"] = 1201;
                  t["utilde"] = 361;
                  t["utildeacute"] = 7801;
                  t["utildebelow"] = 7797;
                  t["uubengali"] = 2442;
                  t["uudeva"] = 2314;
                  t["uugujarati"] = 2698;
                  t["uugurmukhi"] = 2570;
                  t["uumatragurmukhi"] = 2626;
                  t["uuvowelsignbengali"] = 2498;
                  t["uuvowelsigndeva"] = 2370;
                  t["uuvowelsigngujarati"] = 2754;
                  t["uvowelsignbengali"] = 2497;
                  t["uvowelsigndeva"] = 2369;
                  t["uvowelsigngujarati"] = 2753;
                  t["v"] = 118;
                  t["vadeva"] = 2357;
                  t["vagujarati"] = 2741;
                  t["vagurmukhi"] = 2613;
                  t["vakatakana"] = 12535;
                  t["vav"] = 1493;
                  t["vavdagesh"] = 64309;
                  t["vavdagesh65"] = 64309;
                  t["vavdageshhebrew"] = 64309;
                  t["vavhebrew"] = 1493;
                  t["vavholam"] = 64331;
                  t["vavholamhebrew"] = 64331;
                  t["vavvavhebrew"] = 1520;
                  t["vavyodhebrew"] = 1521;
                  t["vcircle"] = 9445;
                  t["vdotbelow"] = 7807;
                  t["vecyrillic"] = 1074;
                  t["veharabic"] = 1700;
                  t["vehfinalarabic"] = 64363;
                  t["vehinitialarabic"] = 64364;
                  t["vehmedialarabic"] = 64365;
                  t["vekatakana"] = 12537;
                  t["venus"] = 9792;
                  t["verticalbar"] = 124;
                  t["verticallineabovecmb"] = 781;
                  t["verticallinebelowcmb"] = 809;
                  t["verticallinelowmod"] = 716;
                  t["verticallinemod"] = 712;
                  t["vewarmenian"] = 1406;
                  t["vhook"] = 651;
                  t["vikatakana"] = 12536;
                  t["viramabengali"] = 2509;
                  t["viramadeva"] = 2381;
                  t["viramagujarati"] = 2765;
                  t["visargabengali"] = 2435;
                  t["visargadeva"] = 2307;
                  t["visargagujarati"] = 2691;
                  t["vmonospace"] = 65366;
                  t["voarmenian"] = 1400;
                  t["voicediterationhiragana"] = 12446;
                  t["voicediterationkatakana"] = 12542;
                  t["voicedmarkkana"] = 12443;
                  t["voicedmarkkanahalfwidth"] = 65438;
                  t["vokatakana"] = 12538;
                  t["vparen"] = 9393;
                  t["vtilde"] = 7805;
                  t["vturned"] = 652;
                  t["vuhiragana"] = 12436;
                  t["vukatakana"] = 12532;
                  t["w"] = 119;
                  t["wacute"] = 7811;
                  t["waekorean"] = 12633;
                  t["wahiragana"] = 12431;
                  t["wakatakana"] = 12527;
                  t["wakatakanahalfwidth"] = 65436;
                  t["wakorean"] = 12632;
                  t["wasmallhiragana"] = 12430;
                  t["wasmallkatakana"] = 12526;
                  t["wattosquare"] = 13143;
                  t["wavedash"] = 12316;
                  t["wavyunderscorevertical"] = 65076;
                  t["wawarabic"] = 1608;
                  t["wawfinalarabic"] = 65262;
                  t["wawhamzaabovearabic"] = 1572;
                  t["wawhamzaabovefinalarabic"] = 65158;
                  t["wbsquare"] = 13277;
                  t["wcircle"] = 9446;
                  t["wcircumflex"] = 373;
                  t["wdieresis"] = 7813;
                  t["wdotaccent"] = 7815;
                  t["wdotbelow"] = 7817;
                  t["wehiragana"] = 12433;
                  t["weierstrass"] = 8472;
                  t["wekatakana"] = 12529;
                  t["wekorean"] = 12638;
                  t["weokorean"] = 12637;
                  t["wgrave"] = 7809;
                  t["whitebullet"] = 9702;
                  t["whitecircle"] = 9675;
                  t["whitecircleinverse"] = 9689;
                  t["whitecornerbracketleft"] = 12302;
                  t["whitecornerbracketleftvertical"] = 65091;
                  t["whitecornerbracketright"] = 12303;
                  t["whitecornerbracketrightvertical"] = 65092;
                  t["whitediamond"] = 9671;
                  t["whitediamondcontainingblacksmalldiamond"] = 9672;
                  t["whitedownpointingsmalltriangle"] = 9663;
                  t["whitedownpointingtriangle"] = 9661;
                  t["whiteleftpointingsmalltriangle"] = 9667;
                  t["whiteleftpointingtriangle"] = 9665;
                  t["whitelenticularbracketleft"] = 12310;
                  t["whitelenticularbracketright"] = 12311;
                  t["whiterightpointingsmalltriangle"] = 9657;
                  t["whiterightpointingtriangle"] = 9655;
                  t["whitesmallsquare"] = 9643;
                  t["whitesmilingface"] = 9786;
                  t["whitesquare"] = 9633;
                  t["whitestar"] = 9734;
                  t["whitetelephone"] = 9743;
                  t["whitetortoiseshellbracketleft"] = 12312;
                  t["whitetortoiseshellbracketright"] = 12313;
                  t["whiteuppointingsmalltriangle"] = 9653;
                  t["whiteuppointingtriangle"] = 9651;
                  t["wihiragana"] = 12432;
                  t["wikatakana"] = 12528;
                  t["wikorean"] = 12639;
                  t["wmonospace"] = 65367;
                  t["wohiragana"] = 12434;
                  t["wokatakana"] = 12530;
                  t["wokatakanahalfwidth"] = 65382;
                  t["won"] = 8361;
                  t["wonmonospace"] = 65510;
                  t["wowaenthai"] = 3623;
                  t["wparen"] = 9394;
                  t["wring"] = 7832;
                  t["wsuperior"] = 695;
                  t["wturned"] = 653;
                  t["wynn"] = 447;
                  t["x"] = 120;
                  t["xabovecmb"] = 829;
                  t["xbopomofo"] = 12562;
                  t["xcircle"] = 9447;
                  t["xdieresis"] = 7821;
                  t["xdotaccent"] = 7819;
                  t["xeharmenian"] = 1389;
                  t["xi"] = 958;
                  t["xmonospace"] = 65368;
                  t["xparen"] = 9395;
                  t["xsuperior"] = 739;
                  t["y"] = 121;
                  t["yaadosquare"] = 13134;
                  t["yabengali"] = 2479;
                  t["yacute"] = 253;
                  t["yadeva"] = 2351;
                  t["yaekorean"] = 12626;
                  t["yagujarati"] = 2735;
                  t["yagurmukhi"] = 2607;
                  t["yahiragana"] = 12420;
                  t["yakatakana"] = 12516;
                  t["yakatakanahalfwidth"] = 65428;
                  t["yakorean"] = 12625;
                  t["yamakkanthai"] = 3662;
                  t["yasmallhiragana"] = 12419;
                  t["yasmallkatakana"] = 12515;
                  t["yasmallkatakanahalfwidth"] = 65388;
                  t["yatcyrillic"] = 1123;
                  t["ycircle"] = 9448;
                  t["ycircumflex"] = 375;
                  t["ydieresis"] = 255;
                  t["ydotaccent"] = 7823;
                  t["ydotbelow"] = 7925;
                  t["yeharabic"] = 1610;
                  t["yehbarreearabic"] = 1746;
                  t["yehbarreefinalarabic"] = 64431;
                  t["yehfinalarabic"] = 65266;
                  t["yehhamzaabovearabic"] = 1574;
                  t["yehhamzaabovefinalarabic"] = 65162;
                  t["yehhamzaaboveinitialarabic"] = 65163;
                  t["yehhamzaabovemedialarabic"] = 65164;
                  t["yehinitialarabic"] = 65267;
                  t["yehmedialarabic"] = 65268;
                  t["yehmeeminitialarabic"] = 64733;
                  t["yehmeemisolatedarabic"] = 64600;
                  t["yehnoonfinalarabic"] = 64660;
                  t["yehthreedotsbelowarabic"] = 1745;
                  t["yekorean"] = 12630;
                  t["yen"] = 165;
                  t["yenmonospace"] = 65509;
                  t["yeokorean"] = 12629;
                  t["yeorinhieuhkorean"] = 12678;
                  t["yerahbenyomohebrew"] = 1450;
                  t["yerahbenyomolefthebrew"] = 1450;
                  t["yericyrillic"] = 1099;
                  t["yerudieresiscyrillic"] = 1273;
                  t["yesieungkorean"] = 12673;
                  t["yesieungpansioskorean"] = 12675;
                  t["yesieungsioskorean"] = 12674;
                  t["yetivhebrew"] = 1434;
                  t["ygrave"] = 7923;
                  t["yhook"] = 436;
                  t["yhookabove"] = 7927;
                  t["yiarmenian"] = 1397;
                  t["yicyrillic"] = 1111;
                  t["yikorean"] = 12642;
                  t["yinyang"] = 9775;
                  t["yiwnarmenian"] = 1410;
                  t["ymonospace"] = 65369;
                  t["yod"] = 1497;
                  t["yoddagesh"] = 64313;
                  t["yoddageshhebrew"] = 64313;
                  t["yodhebrew"] = 1497;
                  t["yodyodhebrew"] = 1522;
                  t["yodyodpatahhebrew"] = 64287;
                  t["yohiragana"] = 12424;
                  t["yoikorean"] = 12681;
                  t["yokatakana"] = 12520;
                  t["yokatakanahalfwidth"] = 65430;
                  t["yokorean"] = 12635;
                  t["yosmallhiragana"] = 12423;
                  t["yosmallkatakana"] = 12519;
                  t["yosmallkatakanahalfwidth"] = 65390;
                  t["yotgreek"] = 1011;
                  t["yoyaekorean"] = 12680;
                  t["yoyakorean"] = 12679;
                  t["yoyakthai"] = 3618;
                  t["yoyingthai"] = 3597;
                  t["yparen"] = 9396;
                  t["ypogegrammeni"] = 890;
                  t["ypogegrammenigreekcmb"] = 837;
                  t["yr"] = 422;
                  t["yring"] = 7833;
                  t["ysuperior"] = 696;
                  t["ytilde"] = 7929;
                  t["yturned"] = 654;
                  t["yuhiragana"] = 12422;
                  t["yuikorean"] = 12684;
                  t["yukatakana"] = 12518;
                  t["yukatakanahalfwidth"] = 65429;
                  t["yukorean"] = 12640;
                  t["yusbigcyrillic"] = 1131;
                  t["yusbigiotifiedcyrillic"] = 1133;
                  t["yuslittlecyrillic"] = 1127;
                  t["yuslittleiotifiedcyrillic"] = 1129;
                  t["yusmallhiragana"] = 12421;
                  t["yusmallkatakana"] = 12517;
                  t["yusmallkatakanahalfwidth"] = 65389;
                  t["yuyekorean"] = 12683;
                  t["yuyeokorean"] = 12682;
                  t["yyabengali"] = 2527;
                  t["yyadeva"] = 2399;
                  t["z"] = 122;
                  t["zaarmenian"] = 1382;
                  t["zacute"] = 378;
                  t["zadeva"] = 2395;
                  t["zagurmukhi"] = 2651;
                  t["zaharabic"] = 1592;
                  t["zahfinalarabic"] = 65222;
                  t["zahinitialarabic"] = 65223;
                  t["zahiragana"] = 12374;
                  t["zahmedialarabic"] = 65224;
                  t["zainarabic"] = 1586;
                  t["zainfinalarabic"] = 65200;
                  t["zakatakana"] = 12470;
                  t["zaqefgadolhebrew"] = 1429;
                  t["zaqefqatanhebrew"] = 1428;
                  t["zarqahebrew"] = 1432;
                  t["zayin"] = 1494;
                  t["zayindagesh"] = 64310;
                  t["zayindageshhebrew"] = 64310;
                  t["zayinhebrew"] = 1494;
                  t["zbopomofo"] = 12567;
                  t["zcaron"] = 382;
                  t["zcircle"] = 9449;
                  t["zcircumflex"] = 7825;
                  t["zcurl"] = 657;
                  t["zdot"] = 380;
                  t["zdotaccent"] = 380;
                  t["zdotbelow"] = 7827;
                  t["zecyrillic"] = 1079;
                  t["zedescendercyrillic"] = 1177;
                  t["zedieresiscyrillic"] = 1247;
                  t["zehiragana"] = 12380;
                  t["zekatakana"] = 12476;
                  t["zero"] = 48;
                  t["zeroarabic"] = 1632;
                  t["zerobengali"] = 2534;
                  t["zerodeva"] = 2406;
                  t["zerogujarati"] = 2790;
                  t["zerogurmukhi"] = 2662;
                  t["zerohackarabic"] = 1632;
                  t["zeroinferior"] = 8320;
                  t["zeromonospace"] = 65296;
                  t["zerooldstyle"] = 63280;
                  t["zeropersian"] = 1776;
                  t["zerosuperior"] = 8304;
                  t["zerothai"] = 3664;
                  t["zerowidthjoiner"] = 65279;
                  t["zerowidthnonjoiner"] = 8204;
                  t["zerowidthspace"] = 8203;
                  t["zeta"] = 950;
                  t["zhbopomofo"] = 12563;
                  t["zhearmenian"] = 1386;
                  t["zhebrevecyrillic"] = 1218;
                  t["zhecyrillic"] = 1078;
                  t["zhedescendercyrillic"] = 1175;
                  t["zhedieresiscyrillic"] = 1245;
                  t["zihiragana"] = 12376;
                  t["zikatakana"] = 12472;
                  t["zinorhebrew"] = 1454;
                  t["zlinebelow"] = 7829;
                  t["zmonospace"] = 65370;
                  t["zohiragana"] = 12382;
                  t["zokatakana"] = 12478;
                  t["zparen"] = 9397;
                  t["zretroflexhook"] = 656;
                  t["zstroke"] = 438;
                  t["zuhiragana"] = 12378;
                  t["zukatakana"] = 12474;
                  t[".notdef"] = 0;
                  t["angbracketleftbig"] = 9001;
                  t["angbracketleftBig"] = 9001;
                  t["angbracketleftbigg"] = 9001;
                  t["angbracketleftBigg"] = 9001;
                  t["angbracketrightBig"] = 9002;
                  t["angbracketrightbig"] = 9002;
                  t["angbracketrightBigg"] = 9002;
                  t["angbracketrightbigg"] = 9002;
                  t["arrowhookleft"] = 8618;
                  t["arrowhookright"] = 8617;
                  t["arrowlefttophalf"] = 8636;
                  t["arrowleftbothalf"] = 8637;
                  t["arrownortheast"] = 8599;
                  t["arrownorthwest"] = 8598;
                  t["arrowrighttophalf"] = 8640;
                  t["arrowrightbothalf"] = 8641;
                  t["arrowsoutheast"] = 8600;
                  t["arrowsouthwest"] = 8601;
                  t["backslashbig"] = 8726;
                  t["backslashBig"] = 8726;
                  t["backslashBigg"] = 8726;
                  t["backslashbigg"] = 8726;
                  t["bardbl"] = 8214;
                  t["bracehtipdownleft"] = 65079;
                  t["bracehtipdownright"] = 65079;
                  t["bracehtipupleft"] = 65080;
                  t["bracehtipupright"] = 65080;
                  t["braceleftBig"] = 123;
                  t["braceleftbig"] = 123;
                  t["braceleftbigg"] = 123;
                  t["braceleftBigg"] = 123;
                  t["bracerightBig"] = 125;
                  t["bracerightbig"] = 125;
                  t["bracerightbigg"] = 125;
                  t["bracerightBigg"] = 125;
                  t["bracketleftbig"] = 91;
                  t["bracketleftBig"] = 91;
                  t["bracketleftbigg"] = 91;
                  t["bracketleftBigg"] = 91;
                  t["bracketrightBig"] = 93;
                  t["bracketrightbig"] = 93;
                  t["bracketrightbigg"] = 93;
                  t["bracketrightBigg"] = 93;
                  t["ceilingleftbig"] = 8968;
                  t["ceilingleftBig"] = 8968;
                  t["ceilingleftBigg"] = 8968;
                  t["ceilingleftbigg"] = 8968;
                  t["ceilingrightbig"] = 8969;
                  t["ceilingrightBig"] = 8969;
                  t["ceilingrightbigg"] = 8969;
                  t["ceilingrightBigg"] = 8969;
                  t["circledotdisplay"] = 8857;
                  t["circledottext"] = 8857;
                  t["circlemultiplydisplay"] = 8855;
                  t["circlemultiplytext"] = 8855;
                  t["circleplusdisplay"] = 8853;
                  t["circleplustext"] = 8853;
                  t["contintegraldisplay"] = 8750;
                  t["contintegraltext"] = 8750;
                  t["coproductdisplay"] = 8720;
                  t["coproducttext"] = 8720;
                  t["floorleftBig"] = 8970;
                  t["floorleftbig"] = 8970;
                  t["floorleftbigg"] = 8970;
                  t["floorleftBigg"] = 8970;
                  t["floorrightbig"] = 8971;
                  t["floorrightBig"] = 8971;
                  t["floorrightBigg"] = 8971;
                  t["floorrightbigg"] = 8971;
                  t["hatwide"] = 770;
                  t["hatwider"] = 770;
                  t["hatwidest"] = 770;
                  t["intercal"] = 7488;
                  t["integraldisplay"] = 8747;
                  t["integraltext"] = 8747;
                  t["intersectiondisplay"] = 8898;
                  t["intersectiontext"] = 8898;
                  t["logicalanddisplay"] = 8743;
                  t["logicalandtext"] = 8743;
                  t["logicalordisplay"] = 8744;
                  t["logicalortext"] = 8744;
                  t["parenleftBig"] = 40;
                  t["parenleftbig"] = 40;
                  t["parenleftBigg"] = 40;
                  t["parenleftbigg"] = 40;
                  t["parenrightBig"] = 41;
                  t["parenrightbig"] = 41;
                  t["parenrightBigg"] = 41;
                  t["parenrightbigg"] = 41;
                  t["prime"] = 8242;
                  t["productdisplay"] = 8719;
                  t["producttext"] = 8719;
                  t["radicalbig"] = 8730;
                  t["radicalBig"] = 8730;
                  t["radicalBigg"] = 8730;
                  t["radicalbigg"] = 8730;
                  t["radicalbt"] = 8730;
                  t["radicaltp"] = 8730;
                  t["radicalvertex"] = 8730;
                  t["slashbig"] = 47;
                  t["slashBig"] = 47;
                  t["slashBigg"] = 47;
                  t["slashbigg"] = 47;
                  t["summationdisplay"] = 8721;
                  t["summationtext"] = 8721;
                  t["tildewide"] = 732;
                  t["tildewider"] = 732;
                  t["tildewidest"] = 732;
                  t["uniondisplay"] = 8899;
                  t["unionmultidisplay"] = 8846;
                  t["unionmultitext"] = 8846;
                  t["unionsqdisplay"] = 8852;
                  t["unionsqtext"] = 8852;
                  t["uniontext"] = 8899;
                  t["vextenddouble"] = 8741;
                  t["vextendsingle"] = 8739;
                });
                var getDingbatsGlyphsUnicode = getLookupTableFactory(function(t) {
                  t["space"] = 32;
                  t["a1"] = 9985;
                  t["a2"] = 9986;
                  t["a202"] = 9987;
                  t["a3"] = 9988;
                  t["a4"] = 9742;
                  t["a5"] = 9990;
                  t["a119"] = 9991;
                  t["a118"] = 9992;
                  t["a117"] = 9993;
                  t["a11"] = 9755;
                  t["a12"] = 9758;
                  t["a13"] = 9996;
                  t["a14"] = 9997;
                  t["a15"] = 9998;
                  t["a16"] = 9999;
                  t["a105"] = 1e4;
                  t["a17"] = 10001;
                  t["a18"] = 10002;
                  t["a19"] = 10003;
                  t["a20"] = 10004;
                  t["a21"] = 10005;
                  t["a22"] = 10006;
                  t["a23"] = 10007;
                  t["a24"] = 10008;
                  t["a25"] = 10009;
                  t["a26"] = 10010;
                  t["a27"] = 10011;
                  t["a28"] = 10012;
                  t["a6"] = 10013;
                  t["a7"] = 10014;
                  t["a8"] = 10015;
                  t["a9"] = 10016;
                  t["a10"] = 10017;
                  t["a29"] = 10018;
                  t["a30"] = 10019;
                  t["a31"] = 10020;
                  t["a32"] = 10021;
                  t["a33"] = 10022;
                  t["a34"] = 10023;
                  t["a35"] = 9733;
                  t["a36"] = 10025;
                  t["a37"] = 10026;
                  t["a38"] = 10027;
                  t["a39"] = 10028;
                  t["a40"] = 10029;
                  t["a41"] = 10030;
                  t["a42"] = 10031;
                  t["a43"] = 10032;
                  t["a44"] = 10033;
                  t["a45"] = 10034;
                  t["a46"] = 10035;
                  t["a47"] = 10036;
                  t["a48"] = 10037;
                  t["a49"] = 10038;
                  t["a50"] = 10039;
                  t["a51"] = 10040;
                  t["a52"] = 10041;
                  t["a53"] = 10042;
                  t["a54"] = 10043;
                  t["a55"] = 10044;
                  t["a56"] = 10045;
                  t["a57"] = 10046;
                  t["a58"] = 10047;
                  t["a59"] = 10048;
                  t["a60"] = 10049;
                  t["a61"] = 10050;
                  t["a62"] = 10051;
                  t["a63"] = 10052;
                  t["a64"] = 10053;
                  t["a65"] = 10054;
                  t["a66"] = 10055;
                  t["a67"] = 10056;
                  t["a68"] = 10057;
                  t["a69"] = 10058;
                  t["a70"] = 10059;
                  t["a71"] = 9679;
                  t["a72"] = 10061;
                  t["a73"] = 9632;
                  t["a74"] = 10063;
                  t["a203"] = 10064;
                  t["a75"] = 10065;
                  t["a204"] = 10066;
                  t["a76"] = 9650;
                  t["a77"] = 9660;
                  t["a78"] = 9670;
                  t["a79"] = 10070;
                  t["a81"] = 9687;
                  t["a82"] = 10072;
                  t["a83"] = 10073;
                  t["a84"] = 10074;
                  t["a97"] = 10075;
                  t["a98"] = 10076;
                  t["a99"] = 10077;
                  t["a100"] = 10078;
                  t["a101"] = 10081;
                  t["a102"] = 10082;
                  t["a103"] = 10083;
                  t["a104"] = 10084;
                  t["a106"] = 10085;
                  t["a107"] = 10086;
                  t["a108"] = 10087;
                  t["a112"] = 9827;
                  t["a111"] = 9830;
                  t["a110"] = 9829;
                  t["a109"] = 9824;
                  t["a120"] = 9312;
                  t["a121"] = 9313;
                  t["a122"] = 9314;
                  t["a123"] = 9315;
                  t["a124"] = 9316;
                  t["a125"] = 9317;
                  t["a126"] = 9318;
                  t["a127"] = 9319;
                  t["a128"] = 9320;
                  t["a129"] = 9321;
                  t["a130"] = 10102;
                  t["a131"] = 10103;
                  t["a132"] = 10104;
                  t["a133"] = 10105;
                  t["a134"] = 10106;
                  t["a135"] = 10107;
                  t["a136"] = 10108;
                  t["a137"] = 10109;
                  t["a138"] = 10110;
                  t["a139"] = 10111;
                  t["a140"] = 10112;
                  t["a141"] = 10113;
                  t["a142"] = 10114;
                  t["a143"] = 10115;
                  t["a144"] = 10116;
                  t["a145"] = 10117;
                  t["a146"] = 10118;
                  t["a147"] = 10119;
                  t["a148"] = 10120;
                  t["a149"] = 10121;
                  t["a150"] = 10122;
                  t["a151"] = 10123;
                  t["a152"] = 10124;
                  t["a153"] = 10125;
                  t["a154"] = 10126;
                  t["a155"] = 10127;
                  t["a156"] = 10128;
                  t["a157"] = 10129;
                  t["a158"] = 10130;
                  t["a159"] = 10131;
                  t["a160"] = 10132;
                  t["a161"] = 8594;
                  t["a163"] = 8596;
                  t["a164"] = 8597;
                  t["a196"] = 10136;
                  t["a165"] = 10137;
                  t["a192"] = 10138;
                  t["a166"] = 10139;
                  t["a167"] = 10140;
                  t["a168"] = 10141;
                  t["a169"] = 10142;
                  t["a170"] = 10143;
                  t["a171"] = 10144;
                  t["a172"] = 10145;
                  t["a173"] = 10146;
                  t["a162"] = 10147;
                  t["a174"] = 10148;
                  t["a175"] = 10149;
                  t["a176"] = 10150;
                  t["a177"] = 10151;
                  t["a178"] = 10152;
                  t["a179"] = 10153;
                  t["a193"] = 10154;
                  t["a180"] = 10155;
                  t["a199"] = 10156;
                  t["a181"] = 10157;
                  t["a200"] = 10158;
                  t["a182"] = 10159;
                  t["a201"] = 10161;
                  t["a183"] = 10162;
                  t["a184"] = 10163;
                  t["a197"] = 10164;
                  t["a185"] = 10165;
                  t["a194"] = 10166;
                  t["a198"] = 10167;
                  t["a186"] = 10168;
                  t["a195"] = 10169;
                  t["a187"] = 10170;
                  t["a188"] = 10171;
                  t["a189"] = 10172;
                  t["a190"] = 10173;
                  t["a191"] = 10174;
                  t["a89"] = 10088;
                  t["a90"] = 10089;
                  t["a93"] = 10090;
                  t["a94"] = 10091;
                  t["a91"] = 10092;
                  t["a92"] = 10093;
                  t["a205"] = 10094;
                  t["a85"] = 10095;
                  t["a206"] = 10096;
                  t["a86"] = 10097;
                  t["a87"] = 10098;
                  t["a88"] = 10099;
                  t["a95"] = 10100;
                  t["a96"] = 10101;
                  t[".notdef"] = 0;
                });
                exports2.getGlyphsUnicode = getGlyphsUnicode;
                exports2.getDingbatsGlyphsUnicode = getDingbatsGlyphsUnicode;
              }, function(module3, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.getSupplementalGlyphMapForCalibri = exports2.getSupplementalGlyphMapForArialBlack = exports2.getGlyphMapForStandardFonts = exports2.getSymbolsFonts = exports2.getSerifFonts = exports2.getNonStdFontMap = exports2.getStdFontMap = void 0;
                var _core_utils = __w_pdfjs_require__2(7);
                const getStdFontMap = (0, _core_utils.getLookupTableFactory)(function(t) {
                  t["ArialNarrow"] = "Helvetica";
                  t["ArialNarrow-Bold"] = "Helvetica-Bold";
                  t["ArialNarrow-BoldItalic"] = "Helvetica-BoldOblique";
                  t["ArialNarrow-Italic"] = "Helvetica-Oblique";
                  t["ArialBlack"] = "Helvetica";
                  t["ArialBlack-Bold"] = "Helvetica-Bold";
                  t["ArialBlack-BoldItalic"] = "Helvetica-BoldOblique";
                  t["ArialBlack-Italic"] = "Helvetica-Oblique";
                  t["Arial-Black"] = "Helvetica";
                  t["Arial-Black-Bold"] = "Helvetica-Bold";
                  t["Arial-Black-BoldItalic"] = "Helvetica-BoldOblique";
                  t["Arial-Black-Italic"] = "Helvetica-Oblique";
                  t["Arial"] = "Helvetica";
                  t["Arial-Bold"] = "Helvetica-Bold";
                  t["Arial-BoldItalic"] = "Helvetica-BoldOblique";
                  t["Arial-Italic"] = "Helvetica-Oblique";
                  t["Arial-BoldItalicMT"] = "Helvetica-BoldOblique";
                  t["Arial-BoldMT"] = "Helvetica-Bold";
                  t["Arial-ItalicMT"] = "Helvetica-Oblique";
                  t["ArialMT"] = "Helvetica";
                  t["Courier-Bold"] = "Courier-Bold";
                  t["Courier-BoldItalic"] = "Courier-BoldOblique";
                  t["Courier-Italic"] = "Courier-Oblique";
                  t["CourierNew"] = "Courier";
                  t["CourierNew-Bold"] = "Courier-Bold";
                  t["CourierNew-BoldItalic"] = "Courier-BoldOblique";
                  t["CourierNew-Italic"] = "Courier-Oblique";
                  t["CourierNewPS-BoldItalicMT"] = "Courier-BoldOblique";
                  t["CourierNewPS-BoldMT"] = "Courier-Bold";
                  t["CourierNewPS-ItalicMT"] = "Courier-Oblique";
                  t["CourierNewPSMT"] = "Courier";
                  t["Helvetica"] = "Helvetica";
                  t["Helvetica-Bold"] = "Helvetica-Bold";
                  t["Helvetica-BoldItalic"] = "Helvetica-BoldOblique";
                  t["Helvetica-BoldOblique"] = "Helvetica-BoldOblique";
                  t["Helvetica-Italic"] = "Helvetica-Oblique";
                  t["Helvetica-Oblique"] = "Helvetica-Oblique";
                  t["Symbol-Bold"] = "Symbol";
                  t["Symbol-BoldItalic"] = "Symbol";
                  t["Symbol-Italic"] = "Symbol";
                  t["TimesNewRoman"] = "Times-Roman";
                  t["TimesNewRoman-Bold"] = "Times-Bold";
                  t["TimesNewRoman-BoldItalic"] = "Times-BoldItalic";
                  t["TimesNewRoman-Italic"] = "Times-Italic";
                  t["TimesNewRomanPS"] = "Times-Roman";
                  t["TimesNewRomanPS-Bold"] = "Times-Bold";
                  t["TimesNewRomanPS-BoldItalic"] = "Times-BoldItalic";
                  t["TimesNewRomanPS-BoldItalicMT"] = "Times-BoldItalic";
                  t["TimesNewRomanPS-BoldMT"] = "Times-Bold";
                  t["TimesNewRomanPS-Italic"] = "Times-Italic";
                  t["TimesNewRomanPS-ItalicMT"] = "Times-Italic";
                  t["TimesNewRomanPSMT"] = "Times-Roman";
                  t["TimesNewRomanPSMT-Bold"] = "Times-Bold";
                  t["TimesNewRomanPSMT-BoldItalic"] = "Times-BoldItalic";
                  t["TimesNewRomanPSMT-Italic"] = "Times-Italic";
                });
                exports2.getStdFontMap = getStdFontMap;
                const getNonStdFontMap = (0, _core_utils.getLookupTableFactory)(function(t) {
                  t["Calibri"] = "Helvetica";
                  t["Calibri-Bold"] = "Helvetica-Bold";
                  t["Calibri-BoldItalic"] = "Helvetica-BoldOblique";
                  t["Calibri-Italic"] = "Helvetica-Oblique";
                  t["CenturyGothic"] = "Helvetica";
                  t["CenturyGothic-Bold"] = "Helvetica-Bold";
                  t["CenturyGothic-BoldItalic"] = "Helvetica-BoldOblique";
                  t["CenturyGothic-Italic"] = "Helvetica-Oblique";
                  t["ComicSansMS"] = "Comic Sans MS";
                  t["ComicSansMS-Bold"] = "Comic Sans MS-Bold";
                  t["ComicSansMS-BoldItalic"] = "Comic Sans MS-BoldItalic";
                  t["ComicSansMS-Italic"] = "Comic Sans MS-Italic";
                  t["LucidaConsole"] = "Courier";
                  t["LucidaConsole-Bold"] = "Courier-Bold";
                  t["LucidaConsole-BoldItalic"] = "Courier-BoldOblique";
                  t["LucidaConsole-Italic"] = "Courier-Oblique";
                  t["LucidaSans-Demi"] = "Helvetica-Bold";
                  t["MS-Gothic"] = "MS Gothic";
                  t["MS-Gothic-Bold"] = "MS Gothic-Bold";
                  t["MS-Gothic-BoldItalic"] = "MS Gothic-BoldItalic";
                  t["MS-Gothic-Italic"] = "MS Gothic-Italic";
                  t["MS-Mincho"] = "MS Mincho";
                  t["MS-Mincho-Bold"] = "MS Mincho-Bold";
                  t["MS-Mincho-BoldItalic"] = "MS Mincho-BoldItalic";
                  t["MS-Mincho-Italic"] = "MS Mincho-Italic";
                  t["MS-PGothic"] = "MS PGothic";
                  t["MS-PGothic-Bold"] = "MS PGothic-Bold";
                  t["MS-PGothic-BoldItalic"] = "MS PGothic-BoldItalic";
                  t["MS-PGothic-Italic"] = "MS PGothic-Italic";
                  t["MS-PMincho"] = "MS PMincho";
                  t["MS-PMincho-Bold"] = "MS PMincho-Bold";
                  t["MS-PMincho-BoldItalic"] = "MS PMincho-BoldItalic";
                  t["MS-PMincho-Italic"] = "MS PMincho-Italic";
                  t["NuptialScript"] = "Times-Italic";
                  t["SegoeUISymbol"] = "Helvetica";
                  t["Wingdings"] = "ZapfDingbats";
                  t["Wingdings-Regular"] = "ZapfDingbats";
                });
                exports2.getNonStdFontMap = getNonStdFontMap;
                const getSerifFonts = (0, _core_utils.getLookupTableFactory)(function(t) {
                  t["Adobe Jenson"] = true;
                  t["Adobe Text"] = true;
                  t["Albertus"] = true;
                  t["Aldus"] = true;
                  t["Alexandria"] = true;
                  t["Algerian"] = true;
                  t["American Typewriter"] = true;
                  t["Antiqua"] = true;
                  t["Apex"] = true;
                  t["Arno"] = true;
                  t["Aster"] = true;
                  t["Aurora"] = true;
                  t["Baskerville"] = true;
                  t["Bell"] = true;
                  t["Bembo"] = true;
                  t["Bembo Schoolbook"] = true;
                  t["Benguiat"] = true;
                  t["Berkeley Old Style"] = true;
                  t["Bernhard Modern"] = true;
                  t["Berthold City"] = true;
                  t["Bodoni"] = true;
                  t["Bauer Bodoni"] = true;
                  t["Book Antiqua"] = true;
                  t["Bookman"] = true;
                  t["Bordeaux Roman"] = true;
                  t["Californian FB"] = true;
                  t["Calisto"] = true;
                  t["Calvert"] = true;
                  t["Capitals"] = true;
                  t["Cambria"] = true;
                  t["Cartier"] = true;
                  t["Caslon"] = true;
                  t["Catull"] = true;
                  t["Centaur"] = true;
                  t["Century Old Style"] = true;
                  t["Century Schoolbook"] = true;
                  t["Chaparral"] = true;
                  t["Charis SIL"] = true;
                  t["Cheltenham"] = true;
                  t["Cholla Slab"] = true;
                  t["Clarendon"] = true;
                  t["Clearface"] = true;
                  t["Cochin"] = true;
                  t["Colonna"] = true;
                  t["Computer Modern"] = true;
                  t["Concrete Roman"] = true;
                  t["Constantia"] = true;
                  t["Cooper Black"] = true;
                  t["Corona"] = true;
                  t["Ecotype"] = true;
                  t["Egyptienne"] = true;
                  t["Elephant"] = true;
                  t["Excelsior"] = true;
                  t["Fairfield"] = true;
                  t["FF Scala"] = true;
                  t["Folkard"] = true;
                  t["Footlight"] = true;
                  t["FreeSerif"] = true;
                  t["Friz Quadrata"] = true;
                  t["Garamond"] = true;
                  t["Gentium"] = true;
                  t["Georgia"] = true;
                  t["Gloucester"] = true;
                  t["Goudy Old Style"] = true;
                  t["Goudy Schoolbook"] = true;
                  t["Goudy Pro Font"] = true;
                  t["Granjon"] = true;
                  t["Guardian Egyptian"] = true;
                  t["Heather"] = true;
                  t["Hercules"] = true;
                  t["High Tower Text"] = true;
                  t["Hiroshige"] = true;
                  t["Hoefler Text"] = true;
                  t["Humana Serif"] = true;
                  t["Imprint"] = true;
                  t["Ionic No. 5"] = true;
                  t["Janson"] = true;
                  t["Joanna"] = true;
                  t["Korinna"] = true;
                  t["Lexicon"] = true;
                  t["Liberation Serif"] = true;
                  t["Linux Libertine"] = true;
                  t["Literaturnaya"] = true;
                  t["Lucida"] = true;
                  t["Lucida Bright"] = true;
                  t["Melior"] = true;
                  t["Memphis"] = true;
                  t["Miller"] = true;
                  t["Minion"] = true;
                  t["Modern"] = true;
                  t["Mona Lisa"] = true;
                  t["Mrs Eaves"] = true;
                  t["MS Serif"] = true;
                  t["Museo Slab"] = true;
                  t["New York"] = true;
                  t["Nimbus Roman"] = true;
                  t["NPS Rawlinson Roadway"] = true;
                  t["NuptialScript"] = true;
                  t["Palatino"] = true;
                  t["Perpetua"] = true;
                  t["Plantin"] = true;
                  t["Plantin Schoolbook"] = true;
                  t["Playbill"] = true;
                  t["Poor Richard"] = true;
                  t["Rawlinson Roadway"] = true;
                  t["Renault"] = true;
                  t["Requiem"] = true;
                  t["Rockwell"] = true;
                  t["Roman"] = true;
                  t["Rotis Serif"] = true;
                  t["Sabon"] = true;
                  t["Scala"] = true;
                  t["Seagull"] = true;
                  t["Sistina"] = true;
                  t["Souvenir"] = true;
                  t["STIX"] = true;
                  t["Stone Informal"] = true;
                  t["Stone Serif"] = true;
                  t["Sylfaen"] = true;
                  t["Times"] = true;
                  t["Trajan"] = true;
                  t["Trinit\xE9"] = true;
                  t["Trump Mediaeval"] = true;
                  t["Utopia"] = true;
                  t["Vale Type"] = true;
                  t["Bitstream Vera"] = true;
                  t["Vera Serif"] = true;
                  t["Versailles"] = true;
                  t["Wanted"] = true;
                  t["Weiss"] = true;
                  t["Wide Latin"] = true;
                  t["Windsor"] = true;
                  t["XITS"] = true;
                });
                exports2.getSerifFonts = getSerifFonts;
                const getSymbolsFonts = (0, _core_utils.getLookupTableFactory)(function(t) {
                  t["Dingbats"] = true;
                  t["Symbol"] = true;
                  t["ZapfDingbats"] = true;
                });
                exports2.getSymbolsFonts = getSymbolsFonts;
                const getGlyphMapForStandardFonts = (0, _core_utils.getLookupTableFactory)(function(t) {
                  t[2] = 10;
                  t[3] = 32;
                  t[4] = 33;
                  t[5] = 34;
                  t[6] = 35;
                  t[7] = 36;
                  t[8] = 37;
                  t[9] = 38;
                  t[10] = 39;
                  t[11] = 40;
                  t[12] = 41;
                  t[13] = 42;
                  t[14] = 43;
                  t[15] = 44;
                  t[16] = 45;
                  t[17] = 46;
                  t[18] = 47;
                  t[19] = 48;
                  t[20] = 49;
                  t[21] = 50;
                  t[22] = 51;
                  t[23] = 52;
                  t[24] = 53;
                  t[25] = 54;
                  t[26] = 55;
                  t[27] = 56;
                  t[28] = 57;
                  t[29] = 58;
                  t[30] = 894;
                  t[31] = 60;
                  t[32] = 61;
                  t[33] = 62;
                  t[34] = 63;
                  t[35] = 64;
                  t[36] = 65;
                  t[37] = 66;
                  t[38] = 67;
                  t[39] = 68;
                  t[40] = 69;
                  t[41] = 70;
                  t[42] = 71;
                  t[43] = 72;
                  t[44] = 73;
                  t[45] = 74;
                  t[46] = 75;
                  t[47] = 76;
                  t[48] = 77;
                  t[49] = 78;
                  t[50] = 79;
                  t[51] = 80;
                  t[52] = 81;
                  t[53] = 82;
                  t[54] = 83;
                  t[55] = 84;
                  t[56] = 85;
                  t[57] = 86;
                  t[58] = 87;
                  t[59] = 88;
                  t[60] = 89;
                  t[61] = 90;
                  t[62] = 91;
                  t[63] = 92;
                  t[64] = 93;
                  t[65] = 94;
                  t[66] = 95;
                  t[67] = 96;
                  t[68] = 97;
                  t[69] = 98;
                  t[70] = 99;
                  t[71] = 100;
                  t[72] = 101;
                  t[73] = 102;
                  t[74] = 103;
                  t[75] = 104;
                  t[76] = 105;
                  t[77] = 106;
                  t[78] = 107;
                  t[79] = 108;
                  t[80] = 109;
                  t[81] = 110;
                  t[82] = 111;
                  t[83] = 112;
                  t[84] = 113;
                  t[85] = 114;
                  t[86] = 115;
                  t[87] = 116;
                  t[88] = 117;
                  t[89] = 118;
                  t[90] = 119;
                  t[91] = 120;
                  t[92] = 121;
                  t[93] = 122;
                  t[94] = 123;
                  t[95] = 124;
                  t[96] = 125;
                  t[97] = 126;
                  t[98] = 196;
                  t[99] = 197;
                  t[100] = 199;
                  t[101] = 201;
                  t[102] = 209;
                  t[103] = 214;
                  t[104] = 220;
                  t[105] = 225;
                  t[106] = 224;
                  t[107] = 226;
                  t[108] = 228;
                  t[109] = 227;
                  t[110] = 229;
                  t[111] = 231;
                  t[112] = 233;
                  t[113] = 232;
                  t[114] = 234;
                  t[115] = 235;
                  t[116] = 237;
                  t[117] = 236;
                  t[118] = 238;
                  t[119] = 239;
                  t[120] = 241;
                  t[121] = 243;
                  t[122] = 242;
                  t[123] = 244;
                  t[124] = 246;
                  t[125] = 245;
                  t[126] = 250;
                  t[127] = 249;
                  t[128] = 251;
                  t[129] = 252;
                  t[130] = 8224;
                  t[131] = 176;
                  t[132] = 162;
                  t[133] = 163;
                  t[134] = 167;
                  t[135] = 8226;
                  t[136] = 182;
                  t[137] = 223;
                  t[138] = 174;
                  t[139] = 169;
                  t[140] = 8482;
                  t[141] = 180;
                  t[142] = 168;
                  t[143] = 8800;
                  t[144] = 198;
                  t[145] = 216;
                  t[146] = 8734;
                  t[147] = 177;
                  t[148] = 8804;
                  t[149] = 8805;
                  t[150] = 165;
                  t[151] = 181;
                  t[152] = 8706;
                  t[153] = 8721;
                  t[154] = 8719;
                  t[156] = 8747;
                  t[157] = 170;
                  t[158] = 186;
                  t[159] = 8486;
                  t[160] = 230;
                  t[161] = 248;
                  t[162] = 191;
                  t[163] = 161;
                  t[164] = 172;
                  t[165] = 8730;
                  t[166] = 402;
                  t[167] = 8776;
                  t[168] = 8710;
                  t[169] = 171;
                  t[170] = 187;
                  t[171] = 8230;
                  t[210] = 218;
                  t[223] = 711;
                  t[224] = 321;
                  t[225] = 322;
                  t[227] = 353;
                  t[229] = 382;
                  t[234] = 253;
                  t[252] = 263;
                  t[253] = 268;
                  t[254] = 269;
                  t[258] = 258;
                  t[260] = 260;
                  t[261] = 261;
                  t[265] = 280;
                  t[266] = 281;
                  t[268] = 283;
                  t[269] = 313;
                  t[275] = 323;
                  t[276] = 324;
                  t[278] = 328;
                  t[284] = 345;
                  t[285] = 346;
                  t[286] = 347;
                  t[292] = 367;
                  t[295] = 377;
                  t[296] = 378;
                  t[298] = 380;
                  t[305] = 963;
                  t[306] = 964;
                  t[307] = 966;
                  t[308] = 8215;
                  t[309] = 8252;
                  t[310] = 8319;
                  t[311] = 8359;
                  t[312] = 8592;
                  t[313] = 8593;
                  t[337] = 9552;
                  t[493] = 1039;
                  t[494] = 1040;
                  t[705] = 1524;
                  t[706] = 8362;
                  t[710] = 64288;
                  t[711] = 64298;
                  t[759] = 1617;
                  t[761] = 1776;
                  t[763] = 1778;
                  t[775] = 1652;
                  t[777] = 1764;
                  t[778] = 1780;
                  t[779] = 1781;
                  t[780] = 1782;
                  t[782] = 771;
                  t[783] = 64726;
                  t[786] = 8363;
                  t[788] = 8532;
                  t[790] = 768;
                  t[791] = 769;
                  t[792] = 768;
                  t[795] = 803;
                  t[797] = 64336;
                  t[798] = 64337;
                  t[799] = 64342;
                  t[800] = 64343;
                  t[801] = 64344;
                  t[802] = 64345;
                  t[803] = 64362;
                  t[804] = 64363;
                  t[805] = 64364;
                  t[2424] = 7821;
                  t[2425] = 7822;
                  t[2426] = 7823;
                  t[2427] = 7824;
                  t[2428] = 7825;
                  t[2429] = 7826;
                  t[2430] = 7827;
                  t[2433] = 7682;
                  t[2678] = 8045;
                  t[2679] = 8046;
                  t[2830] = 1552;
                  t[2838] = 686;
                  t[2840] = 751;
                  t[2842] = 753;
                  t[2843] = 754;
                  t[2844] = 755;
                  t[2846] = 757;
                  t[2856] = 767;
                  t[2857] = 848;
                  t[2858] = 849;
                  t[2862] = 853;
                  t[2863] = 854;
                  t[2864] = 855;
                  t[2865] = 861;
                  t[2866] = 862;
                  t[2906] = 7460;
                  t[2908] = 7462;
                  t[2909] = 7463;
                  t[2910] = 7464;
                  t[2912] = 7466;
                  t[2913] = 7467;
                  t[2914] = 7468;
                  t[2916] = 7470;
                  t[2917] = 7471;
                  t[2918] = 7472;
                  t[2920] = 7474;
                  t[2921] = 7475;
                  t[2922] = 7476;
                  t[2924] = 7478;
                  t[2925] = 7479;
                  t[2926] = 7480;
                  t[2928] = 7482;
                  t[2929] = 7483;
                  t[2930] = 7484;
                  t[2932] = 7486;
                  t[2933] = 7487;
                  t[2934] = 7488;
                  t[2936] = 7490;
                  t[2937] = 7491;
                  t[2938] = 7492;
                  t[2940] = 7494;
                  t[2941] = 7495;
                  t[2942] = 7496;
                  t[2944] = 7498;
                  t[2946] = 7500;
                  t[2948] = 7502;
                  t[2950] = 7504;
                  t[2951] = 7505;
                  t[2952] = 7506;
                  t[2954] = 7508;
                  t[2955] = 7509;
                  t[2956] = 7510;
                  t[2958] = 7512;
                  t[2959] = 7513;
                  t[2960] = 7514;
                  t[2962] = 7516;
                  t[2963] = 7517;
                  t[2964] = 7518;
                  t[2966] = 7520;
                  t[2967] = 7521;
                  t[2968] = 7522;
                  t[2970] = 7524;
                  t[2971] = 7525;
                  t[2972] = 7526;
                  t[2974] = 7528;
                  t[2975] = 7529;
                  t[2976] = 7530;
                  t[2978] = 1537;
                  t[2979] = 1538;
                  t[2980] = 1539;
                  t[2982] = 1549;
                  t[2983] = 1551;
                  t[2984] = 1552;
                  t[2986] = 1554;
                  t[2987] = 1555;
                  t[2988] = 1556;
                  t[2990] = 1623;
                  t[2991] = 1624;
                  t[2995] = 1775;
                  t[2999] = 1791;
                  t[3002] = 64290;
                  t[3003] = 64291;
                  t[3004] = 64292;
                  t[3006] = 64294;
                  t[3007] = 64295;
                  t[3008] = 64296;
                  t[3011] = 1900;
                  t[3014] = 8223;
                  t[3015] = 8244;
                  t[3017] = 7532;
                  t[3018] = 7533;
                  t[3019] = 7534;
                  t[3075] = 7590;
                  t[3076] = 7591;
                  t[3079] = 7594;
                  t[3080] = 7595;
                  t[3083] = 7598;
                  t[3084] = 7599;
                  t[3087] = 7602;
                  t[3088] = 7603;
                  t[3091] = 7606;
                  t[3092] = 7607;
                  t[3095] = 7610;
                  t[3096] = 7611;
                  t[3099] = 7614;
                  t[3100] = 7615;
                  t[3103] = 7618;
                  t[3104] = 7619;
                  t[3107] = 8337;
                  t[3108] = 8338;
                  t[3116] = 1884;
                  t[3119] = 1885;
                  t[3120] = 1885;
                  t[3123] = 1886;
                  t[3124] = 1886;
                  t[3127] = 1887;
                  t[3128] = 1887;
                  t[3131] = 1888;
                  t[3132] = 1888;
                  t[3135] = 1889;
                  t[3136] = 1889;
                  t[3139] = 1890;
                  t[3140] = 1890;
                  t[3143] = 1891;
                  t[3144] = 1891;
                  t[3147] = 1892;
                  t[3148] = 1892;
                  t[3153] = 580;
                  t[3154] = 581;
                  t[3157] = 584;
                  t[3158] = 585;
                  t[3161] = 588;
                  t[3162] = 589;
                  t[3165] = 891;
                  t[3166] = 892;
                  t[3169] = 1274;
                  t[3170] = 1275;
                  t[3173] = 1278;
                  t[3174] = 1279;
                  t[3181] = 7622;
                  t[3182] = 7623;
                  t[3282] = 11799;
                  t[3316] = 578;
                  t[3379] = 42785;
                  t[3393] = 1159;
                  t[3416] = 8377;
                });
                exports2.getGlyphMapForStandardFonts = getGlyphMapForStandardFonts;
                const getSupplementalGlyphMapForArialBlack = (0, _core_utils.getLookupTableFactory)(function(t) {
                  t[227] = 322;
                  t[264] = 261;
                  t[291] = 346;
                });
                exports2.getSupplementalGlyphMapForArialBlack = getSupplementalGlyphMapForArialBlack;
                const getSupplementalGlyphMapForCalibri = (0, _core_utils.getLookupTableFactory)(function(t) {
                  t[1] = 32;
                  t[4] = 65;
                  t[17] = 66;
                  t[18] = 67;
                  t[24] = 68;
                  t[28] = 69;
                  t[38] = 70;
                  t[39] = 71;
                  t[44] = 72;
                  t[47] = 73;
                  t[58] = 74;
                  t[60] = 75;
                  t[62] = 76;
                  t[68] = 77;
                  t[69] = 78;
                  t[75] = 79;
                  t[87] = 80;
                  t[89] = 81;
                  t[90] = 82;
                  t[94] = 83;
                  t[100] = 84;
                  t[104] = 85;
                  t[115] = 86;
                  t[116] = 87;
                  t[121] = 88;
                  t[122] = 89;
                  t[127] = 90;
                  t[258] = 97;
                  t[268] = 261;
                  t[271] = 98;
                  t[272] = 99;
                  t[273] = 263;
                  t[282] = 100;
                  t[286] = 101;
                  t[295] = 281;
                  t[296] = 102;
                  t[336] = 103;
                  t[346] = 104;
                  t[349] = 105;
                  t[361] = 106;
                  t[364] = 107;
                  t[367] = 108;
                  t[371] = 322;
                  t[373] = 109;
                  t[374] = 110;
                  t[381] = 111;
                  t[383] = 243;
                  t[393] = 112;
                  t[395] = 113;
                  t[396] = 114;
                  t[400] = 115;
                  t[401] = 347;
                  t[410] = 116;
                  t[437] = 117;
                  t[448] = 118;
                  t[449] = 119;
                  t[454] = 120;
                  t[455] = 121;
                  t[460] = 122;
                  t[463] = 380;
                  t[853] = 44;
                  t[855] = 58;
                  t[856] = 46;
                  t[876] = 47;
                  t[878] = 45;
                  t[882] = 45;
                  t[894] = 40;
                  t[895] = 41;
                  t[896] = 91;
                  t[897] = 93;
                  t[923] = 64;
                  t[1004] = 48;
                  t[1005] = 49;
                  t[1006] = 50;
                  t[1007] = 51;
                  t[1008] = 52;
                  t[1009] = 53;
                  t[1010] = 54;
                  t[1011] = 55;
                  t[1012] = 56;
                  t[1013] = 57;
                  t[1081] = 37;
                  t[1085] = 43;
                  t[1086] = 45;
                });
                exports2.getSupplementalGlyphMapForCalibri = getSupplementalGlyphMapForCalibri;
              }, function(module3, exports2, __w_pdfjs_require__2) {
                var getLookupTableFactory = __w_pdfjs_require__2(7).getLookupTableFactory;
                var getSpecialPUASymbols = getLookupTableFactory(function(t) {
                  t[63721] = 169;
                  t[63193] = 169;
                  t[63720] = 174;
                  t[63194] = 174;
                  t[63722] = 8482;
                  t[63195] = 8482;
                  t[63729] = 9127;
                  t[63730] = 9128;
                  t[63731] = 9129;
                  t[63740] = 9131;
                  t[63741] = 9132;
                  t[63742] = 9133;
                  t[63726] = 9121;
                  t[63727] = 9122;
                  t[63728] = 9123;
                  t[63737] = 9124;
                  t[63738] = 9125;
                  t[63739] = 9126;
                  t[63723] = 9115;
                  t[63724] = 9116;
                  t[63725] = 9117;
                  t[63734] = 9118;
                  t[63735] = 9119;
                  t[63736] = 9120;
                });
                function mapSpecialUnicodeValues(code) {
                  if (code >= 65520 && code <= 65535) {
                    return 0;
                  } else if (code >= 62976 && code <= 63743) {
                    return getSpecialPUASymbols()[code] || code;
                  } else if (code === 173) {
                    return 45;
                  }
                  return code;
                }
                function getUnicodeForGlyph(name, glyphsUnicodeMap) {
                  var unicode = glyphsUnicodeMap[name];
                  if (unicode !== void 0) {
                    return unicode;
                  }
                  if (!name) {
                    return -1;
                  }
                  if (name[0] === "u") {
                    var nameLen = name.length, hexStr;
                    if (nameLen === 7 && name[1] === "n" && name[2] === "i") {
                      hexStr = name.substring(3);
                    } else if (nameLen >= 5 && nameLen <= 7) {
                      hexStr = name.substring(1);
                    } else {
                      return -1;
                    }
                    if (hexStr === hexStr.toUpperCase()) {
                      unicode = parseInt(hexStr, 16);
                      if (unicode >= 0) {
                        return unicode;
                      }
                    }
                  }
                  return -1;
                }
                var UnicodeRanges = [{ begin: 0, end: 127 }, { begin: 128, end: 255 }, { begin: 256, end: 383 }, { begin: 384, end: 591 }, { begin: 592, end: 687 }, { begin: 688, end: 767 }, { begin: 768, end: 879 }, { begin: 880, end: 1023 }, { begin: 11392, end: 11519 }, { begin: 1024, end: 1279 }, { begin: 1328, end: 1423 }, { begin: 1424, end: 1535 }, { begin: 42240, end: 42559 }, { begin: 1536, end: 1791 }, { begin: 1984, end: 2047 }, { begin: 2304, end: 2431 }, { begin: 2432, end: 2559 }, { begin: 2560, end: 2687 }, { begin: 2688, end: 2815 }, { begin: 2816, end: 2943 }, { begin: 2944, end: 3071 }, { begin: 3072, end: 3199 }, { begin: 3200, end: 3327 }, { begin: 3328, end: 3455 }, { begin: 3584, end: 3711 }, { begin: 3712, end: 3839 }, { begin: 4256, end: 4351 }, { begin: 6912, end: 7039 }, { begin: 4352, end: 4607 }, { begin: 7680, end: 7935 }, { begin: 7936, end: 8191 }, { begin: 8192, end: 8303 }, { begin: 8304, end: 8351 }, { begin: 8352, end: 8399 }, { begin: 8400, end: 8447 }, { begin: 8448, end: 8527 }, { begin: 8528, end: 8591 }, { begin: 8592, end: 8703 }, { begin: 8704, end: 8959 }, { begin: 8960, end: 9215 }, { begin: 9216, end: 9279 }, { begin: 9280, end: 9311 }, { begin: 9312, end: 9471 }, { begin: 9472, end: 9599 }, { begin: 9600, end: 9631 }, { begin: 9632, end: 9727 }, { begin: 9728, end: 9983 }, { begin: 9984, end: 10175 }, { begin: 12288, end: 12351 }, { begin: 12352, end: 12447 }, { begin: 12448, end: 12543 }, { begin: 12544, end: 12591 }, { begin: 12592, end: 12687 }, { begin: 43072, end: 43135 }, { begin: 12800, end: 13055 }, { begin: 13056, end: 13311 }, { begin: 44032, end: 55215 }, { begin: 55296, end: 57343 }, { begin: 67840, end: 67871 }, { begin: 19968, end: 40959 }, { begin: 57344, end: 63743 }, { begin: 12736, end: 12783 }, { begin: 64256, end: 64335 }, { begin: 64336, end: 65023 }, { begin: 65056, end: 65071 }, { begin: 65040, end: 65055 }, { begin: 65104, end: 65135 }, { begin: 65136, end: 65279 }, { begin: 65280, end: 65519 }, { begin: 65520, end: 65535 }, { begin: 3840, end: 4095 }, { begin: 1792, end: 1871 }, { begin: 1920, end: 1983 }, { begin: 3456, end: 3583 }, { begin: 4096, end: 4255 }, { begin: 4608, end: 4991 }, { begin: 5024, end: 5119 }, { begin: 5120, end: 5759 }, { begin: 5760, end: 5791 }, { begin: 5792, end: 5887 }, { begin: 6016, end: 6143 }, { begin: 6144, end: 6319 }, { begin: 10240, end: 10495 }, { begin: 40960, end: 42127 }, { begin: 5888, end: 5919 }, { begin: 66304, end: 66351 }, { begin: 66352, end: 66383 }, { begin: 66560, end: 66639 }, { begin: 118784, end: 119039 }, { begin: 119808, end: 120831 }, { begin: 1044480, end: 1048573 }, { begin: 65024, end: 65039 }, { begin: 917504, end: 917631 }, { begin: 6400, end: 6479 }, { begin: 6480, end: 6527 }, { begin: 6528, end: 6623 }, { begin: 6656, end: 6687 }, { begin: 11264, end: 11359 }, { begin: 11568, end: 11647 }, { begin: 19904, end: 19967 }, { begin: 43008, end: 43055 }, { begin: 65536, end: 65663 }, { begin: 65856, end: 65935 }, { begin: 66432, end: 66463 }, { begin: 66464, end: 66527 }, { begin: 66640, end: 66687 }, { begin: 66688, end: 66735 }, { begin: 67584, end: 67647 }, { begin: 68096, end: 68191 }, { begin: 119552, end: 119647 }, { begin: 73728, end: 74751 }, { begin: 119648, end: 119679 }, { begin: 7040, end: 7103 }, { begin: 7168, end: 7247 }, { begin: 7248, end: 7295 }, { begin: 43136, end: 43231 }, { begin: 43264, end: 43311 }, { begin: 43312, end: 43359 }, { begin: 43520, end: 43615 }, { begin: 65936, end: 65999 }, { begin: 66e3, end: 66047 }, { begin: 66208, end: 66271 }, { begin: 127024, end: 127135 }];
                function getUnicodeRangeFor(value) {
                  for (var i = 0, ii = UnicodeRanges.length; i < ii; i++) {
                    var range = UnicodeRanges[i];
                    if (value >= range.begin && value < range.end) {
                      return i;
                    }
                  }
                  return -1;
                }
                function isRTLRangeFor(value) {
                  var range = UnicodeRanges[13];
                  if (value >= range.begin && value < range.end) {
                    return true;
                  }
                  range = UnicodeRanges[11];
                  if (value >= range.begin && value < range.end) {
                    return true;
                  }
                  return false;
                }
                var getNormalizedUnicodes = getLookupTableFactory(function(t) {
                  t["\xA8"] = " \u0308";
                  t["\xAF"] = " \u0304";
                  t["\xB4"] = " \u0301";
                  t["\xB5"] = "\u03BC";
                  t["\xB8"] = " \u0327";
                  t["\u0132"] = "IJ";
                  t["\u0133"] = "ij";
                  t["\u013F"] = "L\xB7";
                  t["\u0140"] = "l\xB7";
                  t["\u0149"] = "\u02BCn";
                  t["\u017F"] = "s";
                  t["\u01C4"] = "D\u017D";
                  t["\u01C5"] = "D\u017E";
                  t["\u01C6"] = "d\u017E";
                  t["\u01C7"] = "LJ";
                  t["\u01C8"] = "Lj";
                  t["\u01C9"] = "lj";
                  t["\u01CA"] = "NJ";
                  t["\u01CB"] = "Nj";
                  t["\u01CC"] = "nj";
                  t["\u01F1"] = "DZ";
                  t["\u01F2"] = "Dz";
                  t["\u01F3"] = "dz";
                  t["\u02D8"] = " \u0306";
                  t["\u02D9"] = " \u0307";
                  t["\u02DA"] = " \u030A";
                  t["\u02DB"] = " \u0328";
                  t["\u02DC"] = " \u0303";
                  t["\u02DD"] = " \u030B";
                  t["\u037A"] = " \u0345";
                  t["\u0384"] = " \u0301";
                  t["\u03D0"] = "\u03B2";
                  t["\u03D1"] = "\u03B8";
                  t["\u03D2"] = "\u03A5";
                  t["\u03D5"] = "\u03C6";
                  t["\u03D6"] = "\u03C0";
                  t["\u03F0"] = "\u03BA";
                  t["\u03F1"] = "\u03C1";
                  t["\u03F2"] = "\u03C2";
                  t["\u03F4"] = "\u0398";
                  t["\u03F5"] = "\u03B5";
                  t["\u03F9"] = "\u03A3";
                  t["\u0587"] = "\u0565\u0582";
                  t["\u0675"] = "\u0627\u0674";
                  t["\u0676"] = "\u0648\u0674";
                  t["\u0677"] = "\u06C7\u0674";
                  t["\u0678"] = "\u064A\u0674";
                  t["\u0E33"] = "\u0E4D\u0E32";
                  t["\u0EB3"] = "\u0ECD\u0EB2";
                  t["\u0EDC"] = "\u0EAB\u0E99";
                  t["\u0EDD"] = "\u0EAB\u0EA1";
                  t["\u0F77"] = "\u0FB2\u0F81";
                  t["\u0F79"] = "\u0FB3\u0F81";
                  t["\u1E9A"] = "a\u02BE";
                  t["\u1FBD"] = " \u0313";
                  t["\u1FBF"] = " \u0313";
                  t["\u1FC0"] = " \u0342";
                  t["\u1FFE"] = " \u0314";
                  t["\u2002"] = " ";
                  t["\u2003"] = " ";
                  t["\u2004"] = " ";
                  t["\u2005"] = " ";
                  t["\u2006"] = " ";
                  t["\u2008"] = " ";
                  t["\u2009"] = " ";
                  t["\u200A"] = " ";
                  t["\u2017"] = " \u0333";
                  t["\u2024"] = ".";
                  t["\u2025"] = "..";
                  t["\u2026"] = "...";
                  t["\u2033"] = "\u2032\u2032";
                  t["\u2034"] = "\u2032\u2032\u2032";
                  t["\u2036"] = "\u2035\u2035";
                  t["\u2037"] = "\u2035\u2035\u2035";
                  t["\u203C"] = "!!";
                  t["\u203E"] = " \u0305";
                  t["\u2047"] = "??";
                  t["\u2048"] = "?!";
                  t["\u2049"] = "!?";
                  t["\u2057"] = "\u2032\u2032\u2032\u2032";
                  t["\u205F"] = " ";
                  t["\u20A8"] = "Rs";
                  t["\u2100"] = "a/c";
                  t["\u2101"] = "a/s";
                  t["\u2103"] = "\xB0C";
                  t["\u2105"] = "c/o";
                  t["\u2106"] = "c/u";
                  t["\u2107"] = "\u0190";
                  t["\u2109"] = "\xB0F";
                  t["\u2116"] = "No";
                  t["\u2121"] = "TEL";
                  t["\u2135"] = "\u05D0";
                  t["\u2136"] = "\u05D1";
                  t["\u2137"] = "\u05D2";
                  t["\u2138"] = "\u05D3";
                  t["\u213B"] = "FAX";
                  t["\u2160"] = "I";
                  t["\u2161"] = "II";
                  t["\u2162"] = "III";
                  t["\u2163"] = "IV";
                  t["\u2164"] = "V";
                  t["\u2165"] = "VI";
                  t["\u2166"] = "VII";
                  t["\u2167"] = "VIII";
                  t["\u2168"] = "IX";
                  t["\u2169"] = "X";
                  t["\u216A"] = "XI";
                  t["\u216B"] = "XII";
                  t["\u216C"] = "L";
                  t["\u216D"] = "C";
                  t["\u216E"] = "D";
                  t["\u216F"] = "M";
                  t["\u2170"] = "i";
                  t["\u2171"] = "ii";
                  t["\u2172"] = "iii";
                  t["\u2173"] = "iv";
                  t["\u2174"] = "v";
                  t["\u2175"] = "vi";
                  t["\u2176"] = "vii";
                  t["\u2177"] = "viii";
                  t["\u2178"] = "ix";
                  t["\u2179"] = "x";
                  t["\u217A"] = "xi";
                  t["\u217B"] = "xii";
                  t["\u217C"] = "l";
                  t["\u217D"] = "c";
                  t["\u217E"] = "d";
                  t["\u217F"] = "m";
                  t["\u222C"] = "\u222B\u222B";
                  t["\u222D"] = "\u222B\u222B\u222B";
                  t["\u222F"] = "\u222E\u222E";
                  t["\u2230"] = "\u222E\u222E\u222E";
                  t["\u2474"] = "(1)";
                  t["\u2475"] = "(2)";
                  t["\u2476"] = "(3)";
                  t["\u2477"] = "(4)";
                  t["\u2478"] = "(5)";
                  t["\u2479"] = "(6)";
                  t["\u247A"] = "(7)";
                  t["\u247B"] = "(8)";
                  t["\u247C"] = "(9)";
                  t["\u247D"] = "(10)";
                  t["\u247E"] = "(11)";
                  t["\u247F"] = "(12)";
                  t["\u2480"] = "(13)";
                  t["\u2481"] = "(14)";
                  t["\u2482"] = "(15)";
                  t["\u2483"] = "(16)";
                  t["\u2484"] = "(17)";
                  t["\u2485"] = "(18)";
                  t["\u2486"] = "(19)";
                  t["\u2487"] = "(20)";
                  t["\u2488"] = "1.";
                  t["\u2489"] = "2.";
                  t["\u248A"] = "3.";
                  t["\u248B"] = "4.";
                  t["\u248C"] = "5.";
                  t["\u248D"] = "6.";
                  t["\u248E"] = "7.";
                  t["\u248F"] = "8.";
                  t["\u2490"] = "9.";
                  t["\u2491"] = "10.";
                  t["\u2492"] = "11.";
                  t["\u2493"] = "12.";
                  t["\u2494"] = "13.";
                  t["\u2495"] = "14.";
                  t["\u2496"] = "15.";
                  t["\u2497"] = "16.";
                  t["\u2498"] = "17.";
                  t["\u2499"] = "18.";
                  t["\u249A"] = "19.";
                  t["\u249B"] = "20.";
                  t["\u249C"] = "(a)";
                  t["\u249D"] = "(b)";
                  t["\u249E"] = "(c)";
                  t["\u249F"] = "(d)";
                  t["\u24A0"] = "(e)";
                  t["\u24A1"] = "(f)";
                  t["\u24A2"] = "(g)";
                  t["\u24A3"] = "(h)";
                  t["\u24A4"] = "(i)";
                  t["\u24A5"] = "(j)";
                  t["\u24A6"] = "(k)";
                  t["\u24A7"] = "(l)";
                  t["\u24A8"] = "(m)";
                  t["\u24A9"] = "(n)";
                  t["\u24AA"] = "(o)";
                  t["\u24AB"] = "(p)";
                  t["\u24AC"] = "(q)";
                  t["\u24AD"] = "(r)";
                  t["\u24AE"] = "(s)";
                  t["\u24AF"] = "(t)";
                  t["\u24B0"] = "(u)";
                  t["\u24B1"] = "(v)";
                  t["\u24B2"] = "(w)";
                  t["\u24B3"] = "(x)";
                  t["\u24B4"] = "(y)";
                  t["\u24B5"] = "(z)";
                  t["\u2A0C"] = "\u222B\u222B\u222B\u222B";
                  t["\u2A74"] = "::=";
                  t["\u2A75"] = "==";
                  t["\u2A76"] = "===";
                  t["\u2E9F"] = "\u6BCD";
                  t["\u2EF3"] = "\u9F9F";
                  t["\u2F00"] = "\u4E00";
                  t["\u2F01"] = "\u4E28";
                  t["\u2F02"] = "\u4E36";
                  t["\u2F03"] = "\u4E3F";
                  t["\u2F04"] = "\u4E59";
                  t["\u2F05"] = "\u4E85";
                  t["\u2F06"] = "\u4E8C";
                  t["\u2F07"] = "\u4EA0";
                  t["\u2F08"] = "\u4EBA";
                  t["\u2F09"] = "\u513F";
                  t["\u2F0A"] = "\u5165";
                  t["\u2F0B"] = "\u516B";
                  t["\u2F0C"] = "\u5182";
                  t["\u2F0D"] = "\u5196";
                  t["\u2F0E"] = "\u51AB";
                  t["\u2F0F"] = "\u51E0";
                  t["\u2F10"] = "\u51F5";
                  t["\u2F11"] = "\u5200";
                  t["\u2F12"] = "\u529B";
                  t["\u2F13"] = "\u52F9";
                  t["\u2F14"] = "\u5315";
                  t["\u2F15"] = "\u531A";
                  t["\u2F16"] = "\u5338";
                  t["\u2F17"] = "\u5341";
                  t["\u2F18"] = "\u535C";
                  t["\u2F19"] = "\u5369";
                  t["\u2F1A"] = "\u5382";
                  t["\u2F1B"] = "\u53B6";
                  t["\u2F1C"] = "\u53C8";
                  t["\u2F1D"] = "\u53E3";
                  t["\u2F1E"] = "\u56D7";
                  t["\u2F1F"] = "\u571F";
                  t["\u2F20"] = "\u58EB";
                  t["\u2F21"] = "\u5902";
                  t["\u2F22"] = "\u590A";
                  t["\u2F23"] = "\u5915";
                  t["\u2F24"] = "\u5927";
                  t["\u2F25"] = "\u5973";
                  t["\u2F26"] = "\u5B50";
                  t["\u2F27"] = "\u5B80";
                  t["\u2F28"] = "\u5BF8";
                  t["\u2F29"] = "\u5C0F";
                  t["\u2F2A"] = "\u5C22";
                  t["\u2F2B"] = "\u5C38";
                  t["\u2F2C"] = "\u5C6E";
                  t["\u2F2D"] = "\u5C71";
                  t["\u2F2E"] = "\u5DDB";
                  t["\u2F2F"] = "\u5DE5";
                  t["\u2F30"] = "\u5DF1";
                  t["\u2F31"] = "\u5DFE";
                  t["\u2F32"] = "\u5E72";
                  t["\u2F33"] = "\u5E7A";
                  t["\u2F34"] = "\u5E7F";
                  t["\u2F35"] = "\u5EF4";
                  t["\u2F36"] = "\u5EFE";
                  t["\u2F37"] = "\u5F0B";
                  t["\u2F38"] = "\u5F13";
                  t["\u2F39"] = "\u5F50";
                  t["\u2F3A"] = "\u5F61";
                  t["\u2F3B"] = "\u5F73";
                  t["\u2F3C"] = "\u5FC3";
                  t["\u2F3D"] = "\u6208";
                  t["\u2F3E"] = "\u6236";
                  t["\u2F3F"] = "\u624B";
                  t["\u2F40"] = "\u652F";
                  t["\u2F41"] = "\u6534";
                  t["\u2F42"] = "\u6587";
                  t["\u2F43"] = "\u6597";
                  t["\u2F44"] = "\u65A4";
                  t["\u2F45"] = "\u65B9";
                  t["\u2F46"] = "\u65E0";
                  t["\u2F47"] = "\u65E5";
                  t["\u2F48"] = "\u66F0";
                  t["\u2F49"] = "\u6708";
                  t["\u2F4A"] = "\u6728";
                  t["\u2F4B"] = "\u6B20";
                  t["\u2F4C"] = "\u6B62";
                  t["\u2F4D"] = "\u6B79";
                  t["\u2F4E"] = "\u6BB3";
                  t["\u2F4F"] = "\u6BCB";
                  t["\u2F50"] = "\u6BD4";
                  t["\u2F51"] = "\u6BDB";
                  t["\u2F52"] = "\u6C0F";
                  t["\u2F53"] = "\u6C14";
                  t["\u2F54"] = "\u6C34";
                  t["\u2F55"] = "\u706B";
                  t["\u2F56"] = "\u722A";
                  t["\u2F57"] = "\u7236";
                  t["\u2F58"] = "\u723B";
                  t["\u2F59"] = "\u723F";
                  t["\u2F5A"] = "\u7247";
                  t["\u2F5B"] = "\u7259";
                  t["\u2F5C"] = "\u725B";
                  t["\u2F5D"] = "\u72AC";
                  t["\u2F5E"] = "\u7384";
                  t["\u2F5F"] = "\u7389";
                  t["\u2F60"] = "\u74DC";
                  t["\u2F61"] = "\u74E6";
                  t["\u2F62"] = "\u7518";
                  t["\u2F63"] = "\u751F";
                  t["\u2F64"] = "\u7528";
                  t["\u2F65"] = "\u7530";
                  t["\u2F66"] = "\u758B";
                  t["\u2F67"] = "\u7592";
                  t["\u2F68"] = "\u7676";
                  t["\u2F69"] = "\u767D";
                  t["\u2F6A"] = "\u76AE";
                  t["\u2F6B"] = "\u76BF";
                  t["\u2F6C"] = "\u76EE";
                  t["\u2F6D"] = "\u77DB";
                  t["\u2F6E"] = "\u77E2";
                  t["\u2F6F"] = "\u77F3";
                  t["\u2F70"] = "\u793A";
                  t["\u2F71"] = "\u79B8";
                  t["\u2F72"] = "\u79BE";
                  t["\u2F73"] = "\u7A74";
                  t["\u2F74"] = "\u7ACB";
                  t["\u2F75"] = "\u7AF9";
                  t["\u2F76"] = "\u7C73";
                  t["\u2F77"] = "\u7CF8";
                  t["\u2F78"] = "\u7F36";
                  t["\u2F79"] = "\u7F51";
                  t["\u2F7A"] = "\u7F8A";
                  t["\u2F7B"] = "\u7FBD";
                  t["\u2F7C"] = "\u8001";
                  t["\u2F7D"] = "\u800C";
                  t["\u2F7E"] = "\u8012";
                  t["\u2F7F"] = "\u8033";
                  t["\u2F80"] = "\u807F";
                  t["\u2F81"] = "\u8089";
                  t["\u2F82"] = "\u81E3";
                  t["\u2F83"] = "\u81EA";
                  t["\u2F84"] = "\u81F3";
                  t["\u2F85"] = "\u81FC";
                  t["\u2F86"] = "\u820C";
                  t["\u2F87"] = "\u821B";
                  t["\u2F88"] = "\u821F";
                  t["\u2F89"] = "\u826E";
                  t["\u2F8A"] = "\u8272";
                  t["\u2F8B"] = "\u8278";
                  t["\u2F8C"] = "\u864D";
                  t["\u2F8D"] = "\u866B";
                  t["\u2F8E"] = "\u8840";
                  t["\u2F8F"] = "\u884C";
                  t["\u2F90"] = "\u8863";
                  t["\u2F91"] = "\u897E";
                  t["\u2F92"] = "\u898B";
                  t["\u2F93"] = "\u89D2";
                  t["\u2F94"] = "\u8A00";
                  t["\u2F95"] = "\u8C37";
                  t["\u2F96"] = "\u8C46";
                  t["\u2F97"] = "\u8C55";
                  t["\u2F98"] = "\u8C78";
                  t["\u2F99"] = "\u8C9D";
                  t["\u2F9A"] = "\u8D64";
                  t["\u2F9B"] = "\u8D70";
                  t["\u2F9C"] = "\u8DB3";
                  t["\u2F9D"] = "\u8EAB";
                  t["\u2F9E"] = "\u8ECA";
                  t["\u2F9F"] = "\u8F9B";
                  t["\u2FA0"] = "\u8FB0";
                  t["\u2FA1"] = "\u8FB5";
                  t["\u2FA2"] = "\u9091";
                  t["\u2FA3"] = "\u9149";
                  t["\u2FA4"] = "\u91C6";
                  t["\u2FA5"] = "\u91CC";
                  t["\u2FA6"] = "\u91D1";
                  t["\u2FA7"] = "\u9577";
                  t["\u2FA8"] = "\u9580";
                  t["\u2FA9"] = "\u961C";
                  t["\u2FAA"] = "\u96B6";
                  t["\u2FAB"] = "\u96B9";
                  t["\u2FAC"] = "\u96E8";
                  t["\u2FAD"] = "\u9751";
                  t["\u2FAE"] = "\u975E";
                  t["\u2FAF"] = "\u9762";
                  t["\u2FB0"] = "\u9769";
                  t["\u2FB1"] = "\u97CB";
                  t["\u2FB2"] = "\u97ED";
                  t["\u2FB3"] = "\u97F3";
                  t["\u2FB4"] = "\u9801";
                  t["\u2FB5"] = "\u98A8";
                  t["\u2FB6"] = "\u98DB";
                  t["\u2FB7"] = "\u98DF";
                  t["\u2FB8"] = "\u9996";
                  t["\u2FB9"] = "\u9999";
                  t["\u2FBA"] = "\u99AC";
                  t["\u2FBB"] = "\u9AA8";
                  t["\u2FBC"] = "\u9AD8";
                  t["\u2FBD"] = "\u9ADF";
                  t["\u2FBE"] = "\u9B25";
                  t["\u2FBF"] = "\u9B2F";
                  t["\u2FC0"] = "\u9B32";
                  t["\u2FC1"] = "\u9B3C";
                  t["\u2FC2"] = "\u9B5A";
                  t["\u2FC3"] = "\u9CE5";
                  t["\u2FC4"] = "\u9E75";
                  t["\u2FC5"] = "\u9E7F";
                  t["\u2FC6"] = "\u9EA5";
                  t["\u2FC7"] = "\u9EBB";
                  t["\u2FC8"] = "\u9EC3";
                  t["\u2FC9"] = "\u9ECD";
                  t["\u2FCA"] = "\u9ED1";
                  t["\u2FCB"] = "\u9EF9";
                  t["\u2FCC"] = "\u9EFD";
                  t["\u2FCD"] = "\u9F0E";
                  t["\u2FCE"] = "\u9F13";
                  t["\u2FCF"] = "\u9F20";
                  t["\u2FD0"] = "\u9F3B";
                  t["\u2FD1"] = "\u9F4A";
                  t["\u2FD2"] = "\u9F52";
                  t["\u2FD3"] = "\u9F8D";
                  t["\u2FD4"] = "\u9F9C";
                  t["\u2FD5"] = "\u9FA0";
                  t["\u3036"] = "\u3012";
                  t["\u3038"] = "\u5341";
                  t["\u3039"] = "\u5344";
                  t["\u303A"] = "\u5345";
                  t["\u309B"] = " \u3099";
                  t["\u309C"] = " \u309A";
                  t["\u3131"] = "\u1100";
                  t["\u3132"] = "\u1101";
                  t["\u3133"] = "\u11AA";
                  t["\u3134"] = "\u1102";
                  t["\u3135"] = "\u11AC";
                  t["\u3136"] = "\u11AD";
                  t["\u3137"] = "\u1103";
                  t["\u3138"] = "\u1104";
                  t["\u3139"] = "\u1105";
                  t["\u313A"] = "\u11B0";
                  t["\u313B"] = "\u11B1";
                  t["\u313C"] = "\u11B2";
                  t["\u313D"] = "\u11B3";
                  t["\u313E"] = "\u11B4";
                  t["\u313F"] = "\u11B5";
                  t["\u3140"] = "\u111A";
                  t["\u3141"] = "\u1106";
                  t["\u3142"] = "\u1107";
                  t["\u3143"] = "\u1108";
                  t["\u3144"] = "\u1121";
                  t["\u3145"] = "\u1109";
                  t["\u3146"] = "\u110A";
                  t["\u3147"] = "\u110B";
                  t["\u3148"] = "\u110C";
                  t["\u3149"] = "\u110D";
                  t["\u314A"] = "\u110E";
                  t["\u314B"] = "\u110F";
                  t["\u314C"] = "\u1110";
                  t["\u314D"] = "\u1111";
                  t["\u314E"] = "\u1112";
                  t["\u314F"] = "\u1161";
                  t["\u3150"] = "\u1162";
                  t["\u3151"] = "\u1163";
                  t["\u3152"] = "\u1164";
                  t["\u3153"] = "\u1165";
                  t["\u3154"] = "\u1166";
                  t["\u3155"] = "\u1167";
                  t["\u3156"] = "\u1168";
                  t["\u3157"] = "\u1169";
                  t["\u3158"] = "\u116A";
                  t["\u3159"] = "\u116B";
                  t["\u315A"] = "\u116C";
                  t["\u315B"] = "\u116D";
                  t["\u315C"] = "\u116E";
                  t["\u315D"] = "\u116F";
                  t["\u315E"] = "\u1170";
                  t["\u315F"] = "\u1171";
                  t["\u3160"] = "\u1172";
                  t["\u3161"] = "\u1173";
                  t["\u3162"] = "\u1174";
                  t["\u3163"] = "\u1175";
                  t["\u3164"] = "\u1160";
                  t["\u3165"] = "\u1114";
                  t["\u3166"] = "\u1115";
                  t["\u3167"] = "\u11C7";
                  t["\u3168"] = "\u11C8";
                  t["\u3169"] = "\u11CC";
                  t["\u316A"] = "\u11CE";
                  t["\u316B"] = "\u11D3";
                  t["\u316C"] = "\u11D7";
                  t["\u316D"] = "\u11D9";
                  t["\u316E"] = "\u111C";
                  t["\u316F"] = "\u11DD";
                  t["\u3170"] = "\u11DF";
                  t["\u3171"] = "\u111D";
                  t["\u3172"] = "\u111E";
                  t["\u3173"] = "\u1120";
                  t["\u3174"] = "\u1122";
                  t["\u3175"] = "\u1123";
                  t["\u3176"] = "\u1127";
                  t["\u3177"] = "\u1129";
                  t["\u3178"] = "\u112B";
                  t["\u3179"] = "\u112C";
                  t["\u317A"] = "\u112D";
                  t["\u317B"] = "\u112E";
                  t["\u317C"] = "\u112F";
                  t["\u317D"] = "\u1132";
                  t["\u317E"] = "\u1136";
                  t["\u317F"] = "\u1140";
                  t["\u3180"] = "\u1147";
                  t["\u3181"] = "\u114C";
                  t["\u3182"] = "\u11F1";
                  t["\u3183"] = "\u11F2";
                  t["\u3184"] = "\u1157";
                  t["\u3185"] = "\u1158";
                  t["\u3186"] = "\u1159";
                  t["\u3187"] = "\u1184";
                  t["\u3188"] = "\u1185";
                  t["\u3189"] = "\u1188";
                  t["\u318A"] = "\u1191";
                  t["\u318B"] = "\u1192";
                  t["\u318C"] = "\u1194";
                  t["\u318D"] = "\u119E";
                  t["\u318E"] = "\u11A1";
                  t["\u3200"] = "(\u1100)";
                  t["\u3201"] = "(\u1102)";
                  t["\u3202"] = "(\u1103)";
                  t["\u3203"] = "(\u1105)";
                  t["\u3204"] = "(\u1106)";
                  t["\u3205"] = "(\u1107)";
                  t["\u3206"] = "(\u1109)";
                  t["\u3207"] = "(\u110B)";
                  t["\u3208"] = "(\u110C)";
                  t["\u3209"] = "(\u110E)";
                  t["\u320A"] = "(\u110F)";
                  t["\u320B"] = "(\u1110)";
                  t["\u320C"] = "(\u1111)";
                  t["\u320D"] = "(\u1112)";
                  t["\u320E"] = "(\u1100\u1161)";
                  t["\u320F"] = "(\u1102\u1161)";
                  t["\u3210"] = "(\u1103\u1161)";
                  t["\u3211"] = "(\u1105\u1161)";
                  t["\u3212"] = "(\u1106\u1161)";
                  t["\u3213"] = "(\u1107\u1161)";
                  t["\u3214"] = "(\u1109\u1161)";
                  t["\u3215"] = "(\u110B\u1161)";
                  t["\u3216"] = "(\u110C\u1161)";
                  t["\u3217"] = "(\u110E\u1161)";
                  t["\u3218"] = "(\u110F\u1161)";
                  t["\u3219"] = "(\u1110\u1161)";
                  t["\u321A"] = "(\u1111\u1161)";
                  t["\u321B"] = "(\u1112\u1161)";
                  t["\u321C"] = "(\u110C\u116E)";
                  t["\u321D"] = "(\u110B\u1169\u110C\u1165\u11AB)";
                  t["\u321E"] = "(\u110B\u1169\u1112\u116E)";
                  t["\u3220"] = "(\u4E00)";
                  t["\u3221"] = "(\u4E8C)";
                  t["\u3222"] = "(\u4E09)";
                  t["\u3223"] = "(\u56DB)";
                  t["\u3224"] = "(\u4E94)";
                  t["\u3225"] = "(\u516D)";
                  t["\u3226"] = "(\u4E03)";
                  t["\u3227"] = "(\u516B)";
                  t["\u3228"] = "(\u4E5D)";
                  t["\u3229"] = "(\u5341)";
                  t["\u322A"] = "(\u6708)";
                  t["\u322B"] = "(\u706B)";
                  t["\u322C"] = "(\u6C34)";
                  t["\u322D"] = "(\u6728)";
                  t["\u322E"] = "(\u91D1)";
                  t["\u322F"] = "(\u571F)";
                  t["\u3230"] = "(\u65E5)";
                  t["\u3231"] = "(\u682A)";
                  t["\u3232"] = "(\u6709)";
                  t["\u3233"] = "(\u793E)";
                  t["\u3234"] = "(\u540D)";
                  t["\u3235"] = "(\u7279)";
                  t["\u3236"] = "(\u8CA1)";
                  t["\u3237"] = "(\u795D)";
                  t["\u3238"] = "(\u52B4)";
                  t["\u3239"] = "(\u4EE3)";
                  t["\u323A"] = "(\u547C)";
                  t["\u323B"] = "(\u5B66)";
                  t["\u323C"] = "(\u76E3)";
                  t["\u323D"] = "(\u4F01)";
                  t["\u323E"] = "(\u8CC7)";
                  t["\u323F"] = "(\u5354)";
                  t["\u3240"] = "(\u796D)";
                  t["\u3241"] = "(\u4F11)";
                  t["\u3242"] = "(\u81EA)";
                  t["\u3243"] = "(\u81F3)";
                  t["\u32C0"] = "1\u6708";
                  t["\u32C1"] = "2\u6708";
                  t["\u32C2"] = "3\u6708";
                  t["\u32C3"] = "4\u6708";
                  t["\u32C4"] = "5\u6708";
                  t["\u32C5"] = "6\u6708";
                  t["\u32C6"] = "7\u6708";
                  t["\u32C7"] = "8\u6708";
                  t["\u32C8"] = "9\u6708";
                  t["\u32C9"] = "10\u6708";
                  t["\u32CA"] = "11\u6708";
                  t["\u32CB"] = "12\u6708";
                  t["\u3358"] = "0\u70B9";
                  t["\u3359"] = "1\u70B9";
                  t["\u335A"] = "2\u70B9";
                  t["\u335B"] = "3\u70B9";
                  t["\u335C"] = "4\u70B9";
                  t["\u335D"] = "5\u70B9";
                  t["\u335E"] = "6\u70B9";
                  t["\u335F"] = "7\u70B9";
                  t["\u3360"] = "8\u70B9";
                  t["\u3361"] = "9\u70B9";
                  t["\u3362"] = "10\u70B9";
                  t["\u3363"] = "11\u70B9";
                  t["\u3364"] = "12\u70B9";
                  t["\u3365"] = "13\u70B9";
                  t["\u3366"] = "14\u70B9";
                  t["\u3367"] = "15\u70B9";
                  t["\u3368"] = "16\u70B9";
                  t["\u3369"] = "17\u70B9";
                  t["\u336A"] = "18\u70B9";
                  t["\u336B"] = "19\u70B9";
                  t["\u336C"] = "20\u70B9";
                  t["\u336D"] = "21\u70B9";
                  t["\u336E"] = "22\u70B9";
                  t["\u336F"] = "23\u70B9";
                  t["\u3370"] = "24\u70B9";
                  t["\u33E0"] = "1\u65E5";
                  t["\u33E1"] = "2\u65E5";
                  t["\u33E2"] = "3\u65E5";
                  t["\u33E3"] = "4\u65E5";
                  t["\u33E4"] = "5\u65E5";
                  t["\u33E5"] = "6\u65E5";
                  t["\u33E6"] = "7\u65E5";
                  t["\u33E7"] = "8\u65E5";
                  t["\u33E8"] = "9\u65E5";
                  t["\u33E9"] = "10\u65E5";
                  t["\u33EA"] = "11\u65E5";
                  t["\u33EB"] = "12\u65E5";
                  t["\u33EC"] = "13\u65E5";
                  t["\u33ED"] = "14\u65E5";
                  t["\u33EE"] = "15\u65E5";
                  t["\u33EF"] = "16\u65E5";
                  t["\u33F0"] = "17\u65E5";
                  t["\u33F1"] = "18\u65E5";
                  t["\u33F2"] = "19\u65E5";
                  t["\u33F3"] = "20\u65E5";
                  t["\u33F4"] = "21\u65E5";
                  t["\u33F5"] = "22\u65E5";
                  t["\u33F6"] = "23\u65E5";
                  t["\u33F7"] = "24\u65E5";
                  t["\u33F8"] = "25\u65E5";
                  t["\u33F9"] = "26\u65E5";
                  t["\u33FA"] = "27\u65E5";
                  t["\u33FB"] = "28\u65E5";
                  t["\u33FC"] = "29\u65E5";
                  t["\u33FD"] = "30\u65E5";
                  t["\u33FE"] = "31\u65E5";
                  t["\uFB00"] = "ff";
                  t["\uFB01"] = "fi";
                  t["\uFB02"] = "fl";
                  t["\uFB03"] = "ffi";
                  t["\uFB04"] = "ffl";
                  t["\uFB05"] = "\u017Ft";
                  t["\uFB06"] = "st";
                  t["\uFB13"] = "\u0574\u0576";
                  t["\uFB14"] = "\u0574\u0565";
                  t["\uFB15"] = "\u0574\u056B";
                  t["\uFB16"] = "\u057E\u0576";
                  t["\uFB17"] = "\u0574\u056D";
                  t["\uFB4F"] = "\u05D0\u05DC";
                  t["\uFB50"] = "\u0671";
                  t["\uFB51"] = "\u0671";
                  t["\uFB52"] = "\u067B";
                  t["\uFB53"] = "\u067B";
                  t["\uFB54"] = "\u067B";
                  t["\uFB55"] = "\u067B";
                  t["\uFB56"] = "\u067E";
                  t["\uFB57"] = "\u067E";
                  t["\uFB58"] = "\u067E";
                  t["\uFB59"] = "\u067E";
                  t["\uFB5A"] = "\u0680";
                  t["\uFB5B"] = "\u0680";
                  t["\uFB5C"] = "\u0680";
                  t["\uFB5D"] = "\u0680";
                  t["\uFB5E"] = "\u067A";
                  t["\uFB5F"] = "\u067A";
                  t["\uFB60"] = "\u067A";
                  t["\uFB61"] = "\u067A";
                  t["\uFB62"] = "\u067F";
                  t["\uFB63"] = "\u067F";
                  t["\uFB64"] = "\u067F";
                  t["\uFB65"] = "\u067F";
                  t["\uFB66"] = "\u0679";
                  t["\uFB67"] = "\u0679";
                  t["\uFB68"] = "\u0679";
                  t["\uFB69"] = "\u0679";
                  t["\uFB6A"] = "\u06A4";
                  t["\uFB6B"] = "\u06A4";
                  t["\uFB6C"] = "\u06A4";
                  t["\uFB6D"] = "\u06A4";
                  t["\uFB6E"] = "\u06A6";
                  t["\uFB6F"] = "\u06A6";
                  t["\uFB70"] = "\u06A6";
                  t["\uFB71"] = "\u06A6";
                  t["\uFB72"] = "\u0684";
                  t["\uFB73"] = "\u0684";
                  t["\uFB74"] = "\u0684";
                  t["\uFB75"] = "\u0684";
                  t["\uFB76"] = "\u0683";
                  t["\uFB77"] = "\u0683";
                  t["\uFB78"] = "\u0683";
                  t["\uFB79"] = "\u0683";
                  t["\uFB7A"] = "\u0686";
                  t["\uFB7B"] = "\u0686";
                  t["\uFB7C"] = "\u0686";
                  t["\uFB7D"] = "\u0686";
                  t["\uFB7E"] = "\u0687";
                  t["\uFB7F"] = "\u0687";
                  t["\uFB80"] = "\u0687";
                  t["\uFB81"] = "\u0687";
                  t["\uFB82"] = "\u068D";
                  t["\uFB83"] = "\u068D";
                  t["\uFB84"] = "\u068C";
                  t["\uFB85"] = "\u068C";
                  t["\uFB86"] = "\u068E";
                  t["\uFB87"] = "\u068E";
                  t["\uFB88"] = "\u0688";
                  t["\uFB89"] = "\u0688";
                  t["\uFB8A"] = "\u0698";
                  t["\uFB8B"] = "\u0698";
                  t["\uFB8C"] = "\u0691";
                  t["\uFB8D"] = "\u0691";
                  t["\uFB8E"] = "\u06A9";
                  t["\uFB8F"] = "\u06A9";
                  t["\uFB90"] = "\u06A9";
                  t["\uFB91"] = "\u06A9";
                  t["\uFB92"] = "\u06AF";
                  t["\uFB93"] = "\u06AF";
                  t["\uFB94"] = "\u06AF";
                  t["\uFB95"] = "\u06AF";
                  t["\uFB96"] = "\u06B3";
                  t["\uFB97"] = "\u06B3";
                  t["\uFB98"] = "\u06B3";
                  t["\uFB99"] = "\u06B3";
                  t["\uFB9A"] = "\u06B1";
                  t["\uFB9B"] = "\u06B1";
                  t["\uFB9C"] = "\u06B1";
                  t["\uFB9D"] = "\u06B1";
                  t["\uFB9E"] = "\u06BA";
                  t["\uFB9F"] = "\u06BA";
                  t["\uFBA0"] = "\u06BB";
                  t["\uFBA1"] = "\u06BB";
                  t["\uFBA2"] = "\u06BB";
                  t["\uFBA3"] = "\u06BB";
                  t["\uFBA4"] = "\u06C0";
                  t["\uFBA5"] = "\u06C0";
                  t["\uFBA6"] = "\u06C1";
                  t["\uFBA7"] = "\u06C1";
                  t["\uFBA8"] = "\u06C1";
                  t["\uFBA9"] = "\u06C1";
                  t["\uFBAA"] = "\u06BE";
                  t["\uFBAB"] = "\u06BE";
                  t["\uFBAC"] = "\u06BE";
                  t["\uFBAD"] = "\u06BE";
                  t["\uFBAE"] = "\u06D2";
                  t["\uFBAF"] = "\u06D2";
                  t["\uFBB0"] = "\u06D3";
                  t["\uFBB1"] = "\u06D3";
                  t["\uFBD3"] = "\u06AD";
                  t["\uFBD4"] = "\u06AD";
                  t["\uFBD5"] = "\u06AD";
                  t["\uFBD6"] = "\u06AD";
                  t["\uFBD7"] = "\u06C7";
                  t["\uFBD8"] = "\u06C7";
                  t["\uFBD9"] = "\u06C6";
                  t["\uFBDA"] = "\u06C6";
                  t["\uFBDB"] = "\u06C8";
                  t["\uFBDC"] = "\u06C8";
                  t["\uFBDD"] = "\u0677";
                  t["\uFBDE"] = "\u06CB";
                  t["\uFBDF"] = "\u06CB";
                  t["\uFBE0"] = "\u06C5";
                  t["\uFBE1"] = "\u06C5";
                  t["\uFBE2"] = "\u06C9";
                  t["\uFBE3"] = "\u06C9";
                  t["\uFBE4"] = "\u06D0";
                  t["\uFBE5"] = "\u06D0";
                  t["\uFBE6"] = "\u06D0";
                  t["\uFBE7"] = "\u06D0";
                  t["\uFBE8"] = "\u0649";
                  t["\uFBE9"] = "\u0649";
                  t["\uFBEA"] = "\u0626\u0627";
                  t["\uFBEB"] = "\u0626\u0627";
                  t["\uFBEC"] = "\u0626\u06D5";
                  t["\uFBED"] = "\u0626\u06D5";
                  t["\uFBEE"] = "\u0626\u0648";
                  t["\uFBEF"] = "\u0626\u0648";
                  t["\uFBF0"] = "\u0626\u06C7";
                  t["\uFBF1"] = "\u0626\u06C7";
                  t["\uFBF2"] = "\u0626\u06C6";
                  t["\uFBF3"] = "\u0626\u06C6";
                  t["\uFBF4"] = "\u0626\u06C8";
                  t["\uFBF5"] = "\u0626\u06C8";
                  t["\uFBF6"] = "\u0626\u06D0";
                  t["\uFBF7"] = "\u0626\u06D0";
                  t["\uFBF8"] = "\u0626\u06D0";
                  t["\uFBF9"] = "\u0626\u0649";
                  t["\uFBFA"] = "\u0626\u0649";
                  t["\uFBFB"] = "\u0626\u0649";
                  t["\uFBFC"] = "\u06CC";
                  t["\uFBFD"] = "\u06CC";
                  t["\uFBFE"] = "\u06CC";
                  t["\uFBFF"] = "\u06CC";
                  t["\uFC00"] = "\u0626\u062C";
                  t["\uFC01"] = "\u0626\u062D";
                  t["\uFC02"] = "\u0626\u0645";
                  t["\uFC03"] = "\u0626\u0649";
                  t["\uFC04"] = "\u0626\u064A";
                  t["\uFC05"] = "\u0628\u062C";
                  t["\uFC06"] = "\u0628\u062D";
                  t["\uFC07"] = "\u0628\u062E";
                  t["\uFC08"] = "\u0628\u0645";
                  t["\uFC09"] = "\u0628\u0649";
                  t["\uFC0A"] = "\u0628\u064A";
                  t["\uFC0B"] = "\u062A\u062C";
                  t["\uFC0C"] = "\u062A\u062D";
                  t["\uFC0D"] = "\u062A\u062E";
                  t["\uFC0E"] = "\u062A\u0645";
                  t["\uFC0F"] = "\u062A\u0649";
                  t["\uFC10"] = "\u062A\u064A";
                  t["\uFC11"] = "\u062B\u062C";
                  t["\uFC12"] = "\u062B\u0645";
                  t["\uFC13"] = "\u062B\u0649";
                  t["\uFC14"] = "\u062B\u064A";
                  t["\uFC15"] = "\u062C\u062D";
                  t["\uFC16"] = "\u062C\u0645";
                  t["\uFC17"] = "\u062D\u062C";
                  t["\uFC18"] = "\u062D\u0645";
                  t["\uFC19"] = "\u062E\u062C";
                  t["\uFC1A"] = "\u062E\u062D";
                  t["\uFC1B"] = "\u062E\u0645";
                  t["\uFC1C"] = "\u0633\u062C";
                  t["\uFC1D"] = "\u0633\u062D";
                  t["\uFC1E"] = "\u0633\u062E";
                  t["\uFC1F"] = "\u0633\u0645";
                  t["\uFC20"] = "\u0635\u062D";
                  t["\uFC21"] = "\u0635\u0645";
                  t["\uFC22"] = "\u0636\u062C";
                  t["\uFC23"] = "\u0636\u062D";
                  t["\uFC24"] = "\u0636\u062E";
                  t["\uFC25"] = "\u0636\u0645";
                  t["\uFC26"] = "\u0637\u062D";
                  t["\uFC27"] = "\u0637\u0645";
                  t["\uFC28"] = "\u0638\u0645";
                  t["\uFC29"] = "\u0639\u062C";
                  t["\uFC2A"] = "\u0639\u0645";
                  t["\uFC2B"] = "\u063A\u062C";
                  t["\uFC2C"] = "\u063A\u0645";
                  t["\uFC2D"] = "\u0641\u062C";
                  t["\uFC2E"] = "\u0641\u062D";
                  t["\uFC2F"] = "\u0641\u062E";
                  t["\uFC30"] = "\u0641\u0645";
                  t["\uFC31"] = "\u0641\u0649";
                  t["\uFC32"] = "\u0641\u064A";
                  t["\uFC33"] = "\u0642\u062D";
                  t["\uFC34"] = "\u0642\u0645";
                  t["\uFC35"] = "\u0642\u0649";
                  t["\uFC36"] = "\u0642\u064A";
                  t["\uFC37"] = "\u0643\u0627";
                  t["\uFC38"] = "\u0643\u062C";
                  t["\uFC39"] = "\u0643\u062D";
                  t["\uFC3A"] = "\u0643\u062E";
                  t["\uFC3B"] = "\u0643\u0644";
                  t["\uFC3C"] = "\u0643\u0645";
                  t["\uFC3D"] = "\u0643\u0649";
                  t["\uFC3E"] = "\u0643\u064A";
                  t["\uFC3F"] = "\u0644\u062C";
                  t["\uFC40"] = "\u0644\u062D";
                  t["\uFC41"] = "\u0644\u062E";
                  t["\uFC42"] = "\u0644\u0645";
                  t["\uFC43"] = "\u0644\u0649";
                  t["\uFC44"] = "\u0644\u064A";
                  t["\uFC45"] = "\u0645\u062C";
                  t["\uFC46"] = "\u0645\u062D";
                  t["\uFC47"] = "\u0645\u062E";
                  t["\uFC48"] = "\u0645\u0645";
                  t["\uFC49"] = "\u0645\u0649";
                  t["\uFC4A"] = "\u0645\u064A";
                  t["\uFC4B"] = "\u0646\u062C";
                  t["\uFC4C"] = "\u0646\u062D";
                  t["\uFC4D"] = "\u0646\u062E";
                  t["\uFC4E"] = "\u0646\u0645";
                  t["\uFC4F"] = "\u0646\u0649";
                  t["\uFC50"] = "\u0646\u064A";
                  t["\uFC51"] = "\u0647\u062C";
                  t["\uFC52"] = "\u0647\u0645";
                  t["\uFC53"] = "\u0647\u0649";
                  t["\uFC54"] = "\u0647\u064A";
                  t["\uFC55"] = "\u064A\u062C";
                  t["\uFC56"] = "\u064A\u062D";
                  t["\uFC57"] = "\u064A\u062E";
                  t["\uFC58"] = "\u064A\u0645";
                  t["\uFC59"] = "\u064A\u0649";
                  t["\uFC5A"] = "\u064A\u064A";
                  t["\uFC5B"] = "\u0630\u0670";
                  t["\uFC5C"] = "\u0631\u0670";
                  t["\uFC5D"] = "\u0649\u0670";
                  t["\uFC5E"] = " \u064C\u0651";
                  t["\uFC5F"] = " \u064D\u0651";
                  t["\uFC60"] = " \u064E\u0651";
                  t["\uFC61"] = " \u064F\u0651";
                  t["\uFC62"] = " \u0650\u0651";
                  t["\uFC63"] = " \u0651\u0670";
                  t["\uFC64"] = "\u0626\u0631";
                  t["\uFC65"] = "\u0626\u0632";
                  t["\uFC66"] = "\u0626\u0645";
                  t["\uFC67"] = "\u0626\u0646";
                  t["\uFC68"] = "\u0626\u0649";
                  t["\uFC69"] = "\u0626\u064A";
                  t["\uFC6A"] = "\u0628\u0631";
                  t["\uFC6B"] = "\u0628\u0632";
                  t["\uFC6C"] = "\u0628\u0645";
                  t["\uFC6D"] = "\u0628\u0646";
                  t["\uFC6E"] = "\u0628\u0649";
                  t["\uFC6F"] = "\u0628\u064A";
                  t["\uFC70"] = "\u062A\u0631";
                  t["\uFC71"] = "\u062A\u0632";
                  t["\uFC72"] = "\u062A\u0645";
                  t["\uFC73"] = "\u062A\u0646";
                  t["\uFC74"] = "\u062A\u0649";
                  t["\uFC75"] = "\u062A\u064A";
                  t["\uFC76"] = "\u062B\u0631";
                  t["\uFC77"] = "\u062B\u0632";
                  t["\uFC78"] = "\u062B\u0645";
                  t["\uFC79"] = "\u062B\u0646";
                  t["\uFC7A"] = "\u062B\u0649";
                  t["\uFC7B"] = "\u062B\u064A";
                  t["\uFC7C"] = "\u0641\u0649";
                  t["\uFC7D"] = "\u0641\u064A";
                  t["\uFC7E"] = "\u0642\u0649";
                  t["\uFC7F"] = "\u0642\u064A";
                  t["\uFC80"] = "\u0643\u0627";
                  t["\uFC81"] = "\u0643\u0644";
                  t["\uFC82"] = "\u0643\u0645";
                  t["\uFC83"] = "\u0643\u0649";
                  t["\uFC84"] = "\u0643\u064A";
                  t["\uFC85"] = "\u0644\u0645";
                  t["\uFC86"] = "\u0644\u0649";
                  t["\uFC87"] = "\u0644\u064A";
                  t["\uFC88"] = "\u0645\u0627";
                  t["\uFC89"] = "\u0645\u0645";
                  t["\uFC8A"] = "\u0646\u0631";
                  t["\uFC8B"] = "\u0646\u0632";
                  t["\uFC8C"] = "\u0646\u0645";
                  t["\uFC8D"] = "\u0646\u0646";
                  t["\uFC8E"] = "\u0646\u0649";
                  t["\uFC8F"] = "\u0646\u064A";
                  t["\uFC90"] = "\u0649\u0670";
                  t["\uFC91"] = "\u064A\u0631";
                  t["\uFC92"] = "\u064A\u0632";
                  t["\uFC93"] = "\u064A\u0645";
                  t["\uFC94"] = "\u064A\u0646";
                  t["\uFC95"] = "\u064A\u0649";
                  t["\uFC96"] = "\u064A\u064A";
                  t["\uFC97"] = "\u0626\u062C";
                  t["\uFC98"] = "\u0626\u062D";
                  t["\uFC99"] = "\u0626\u062E";
                  t["\uFC9A"] = "\u0626\u0645";
                  t["\uFC9B"] = "\u0626\u0647";
                  t["\uFC9C"] = "\u0628\u062C";
                  t["\uFC9D"] = "\u0628\u062D";
                  t["\uFC9E"] = "\u0628\u062E";
                  t["\uFC9F"] = "\u0628\u0645";
                  t["\uFCA0"] = "\u0628\u0647";
                  t["\uFCA1"] = "\u062A\u062C";
                  t["\uFCA2"] = "\u062A\u062D";
                  t["\uFCA3"] = "\u062A\u062E";
                  t["\uFCA4"] = "\u062A\u0645";
                  t["\uFCA5"] = "\u062A\u0647";
                  t["\uFCA6"] = "\u062B\u0645";
                  t["\uFCA7"] = "\u062C\u062D";
                  t["\uFCA8"] = "\u062C\u0645";
                  t["\uFCA9"] = "\u062D\u062C";
                  t["\uFCAA"] = "\u062D\u0645";
                  t["\uFCAB"] = "\u062E\u062C";
                  t["\uFCAC"] = "\u062E\u0645";
                  t["\uFCAD"] = "\u0633\u062C";
                  t["\uFCAE"] = "\u0633\u062D";
                  t["\uFCAF"] = "\u0633\u062E";
                  t["\uFCB0"] = "\u0633\u0645";
                  t["\uFCB1"] = "\u0635\u062D";
                  t["\uFCB2"] = "\u0635\u062E";
                  t["\uFCB3"] = "\u0635\u0645";
                  t["\uFCB4"] = "\u0636\u062C";
                  t["\uFCB5"] = "\u0636\u062D";
                  t["\uFCB6"] = "\u0636\u062E";
                  t["\uFCB7"] = "\u0636\u0645";
                  t["\uFCB8"] = "\u0637\u062D";
                  t["\uFCB9"] = "\u0638\u0645";
                  t["\uFCBA"] = "\u0639\u062C";
                  t["\uFCBB"] = "\u0639\u0645";
                  t["\uFCBC"] = "\u063A\u062C";
                  t["\uFCBD"] = "\u063A\u0645";
                  t["\uFCBE"] = "\u0641\u062C";
                  t["\uFCBF"] = "\u0641\u062D";
                  t["\uFCC0"] = "\u0641\u062E";
                  t["\uFCC1"] = "\u0641\u0645";
                  t["\uFCC2"] = "\u0642\u062D";
                  t["\uFCC3"] = "\u0642\u0645";
                  t["\uFCC4"] = "\u0643\u062C";
                  t["\uFCC5"] = "\u0643\u062D";
                  t["\uFCC6"] = "\u0643\u062E";
                  t["\uFCC7"] = "\u0643\u0644";
                  t["\uFCC8"] = "\u0643\u0645";
                  t["\uFCC9"] = "\u0644\u062C";
                  t["\uFCCA"] = "\u0644\u062D";
                  t["\uFCCB"] = "\u0644\u062E";
                  t["\uFCCC"] = "\u0644\u0645";
                  t["\uFCCD"] = "\u0644\u0647";
                  t["\uFCCE"] = "\u0645\u062C";
                  t["\uFCCF"] = "\u0645\u062D";
                  t["\uFCD0"] = "\u0645\u062E";
                  t["\uFCD1"] = "\u0645\u0645";
                  t["\uFCD2"] = "\u0646\u062C";
                  t["\uFCD3"] = "\u0646\u062D";
                  t["\uFCD4"] = "\u0646\u062E";
                  t["\uFCD5"] = "\u0646\u0645";
                  t["\uFCD6"] = "\u0646\u0647";
                  t["\uFCD7"] = "\u0647\u062C";
                  t["\uFCD8"] = "\u0647\u0645";
                  t["\uFCD9"] = "\u0647\u0670";
                  t["\uFCDA"] = "\u064A\u062C";
                  t["\uFCDB"] = "\u064A\u062D";
                  t["\uFCDC"] = "\u064A\u062E";
                  t["\uFCDD"] = "\u064A\u0645";
                  t["\uFCDE"] = "\u064A\u0647";
                  t["\uFCDF"] = "\u0626\u0645";
                  t["\uFCE0"] = "\u0626\u0647";
                  t["\uFCE1"] = "\u0628\u0645";
                  t["\uFCE2"] = "\u0628\u0647";
                  t["\uFCE3"] = "\u062A\u0645";
                  t["\uFCE4"] = "\u062A\u0647";
                  t["\uFCE5"] = "\u062B\u0645";
                  t["\uFCE6"] = "\u062B\u0647";
                  t["\uFCE7"] = "\u0633\u0645";
                  t["\uFCE8"] = "\u0633\u0647";
                  t["\uFCE9"] = "\u0634\u0645";
                  t["\uFCEA"] = "\u0634\u0647";
                  t["\uFCEB"] = "\u0643\u0644";
                  t["\uFCEC"] = "\u0643\u0645";
                  t["\uFCED"] = "\u0644\u0645";
                  t["\uFCEE"] = "\u0646\u0645";
                  t["\uFCEF"] = "\u0646\u0647";
                  t["\uFCF0"] = "\u064A\u0645";
                  t["\uFCF1"] = "\u064A\u0647";
                  t["\uFCF2"] = "\u0640\u064E\u0651";
                  t["\uFCF3"] = "\u0640\u064F\u0651";
                  t["\uFCF4"] = "\u0640\u0650\u0651";
                  t["\uFCF5"] = "\u0637\u0649";
                  t["\uFCF6"] = "\u0637\u064A";
                  t["\uFCF7"] = "\u0639\u0649";
                  t["\uFCF8"] = "\u0639\u064A";
                  t["\uFCF9"] = "\u063A\u0649";
                  t["\uFCFA"] = "\u063A\u064A";
                  t["\uFCFB"] = "\u0633\u0649";
                  t["\uFCFC"] = "\u0633\u064A";
                  t["\uFCFD"] = "\u0634\u0649";
                  t["\uFCFE"] = "\u0634\u064A";
                  t["\uFCFF"] = "\u062D\u0649";
                  t["\uFD00"] = "\u062D\u064A";
                  t["\uFD01"] = "\u062C\u0649";
                  t["\uFD02"] = "\u062C\u064A";
                  t["\uFD03"] = "\u062E\u0649";
                  t["\uFD04"] = "\u062E\u064A";
                  t["\uFD05"] = "\u0635\u0649";
                  t["\uFD06"] = "\u0635\u064A";
                  t["\uFD07"] = "\u0636\u0649";
                  t["\uFD08"] = "\u0636\u064A";
                  t["\uFD09"] = "\u0634\u062C";
                  t["\uFD0A"] = "\u0634\u062D";
                  t["\uFD0B"] = "\u0634\u062E";
                  t["\uFD0C"] = "\u0634\u0645";
                  t["\uFD0D"] = "\u0634\u0631";
                  t["\uFD0E"] = "\u0633\u0631";
                  t["\uFD0F"] = "\u0635\u0631";
                  t["\uFD10"] = "\u0636\u0631";
                  t["\uFD11"] = "\u0637\u0649";
                  t["\uFD12"] = "\u0637\u064A";
                  t["\uFD13"] = "\u0639\u0649";
                  t["\uFD14"] = "\u0639\u064A";
                  t["\uFD15"] = "\u063A\u0649";
                  t["\uFD16"] = "\u063A\u064A";
                  t["\uFD17"] = "\u0633\u0649";
                  t["\uFD18"] = "\u0633\u064A";
                  t["\uFD19"] = "\u0634\u0649";
                  t["\uFD1A"] = "\u0634\u064A";
                  t["\uFD1B"] = "\u062D\u0649";
                  t["\uFD1C"] = "\u062D\u064A";
                  t["\uFD1D"] = "\u062C\u0649";
                  t["\uFD1E"] = "\u062C\u064A";
                  t["\uFD1F"] = "\u062E\u0649";
                  t["\uFD20"] = "\u062E\u064A";
                  t["\uFD21"] = "\u0635\u0649";
                  t["\uFD22"] = "\u0635\u064A";
                  t["\uFD23"] = "\u0636\u0649";
                  t["\uFD24"] = "\u0636\u064A";
                  t["\uFD25"] = "\u0634\u062C";
                  t["\uFD26"] = "\u0634\u062D";
                  t["\uFD27"] = "\u0634\u062E";
                  t["\uFD28"] = "\u0634\u0645";
                  t["\uFD29"] = "\u0634\u0631";
                  t["\uFD2A"] = "\u0633\u0631";
                  t["\uFD2B"] = "\u0635\u0631";
                  t["\uFD2C"] = "\u0636\u0631";
                  t["\uFD2D"] = "\u0634\u062C";
                  t["\uFD2E"] = "\u0634\u062D";
                  t["\uFD2F"] = "\u0634\u062E";
                  t["\uFD30"] = "\u0634\u0645";
                  t["\uFD31"] = "\u0633\u0647";
                  t["\uFD32"] = "\u0634\u0647";
                  t["\uFD33"] = "\u0637\u0645";
                  t["\uFD34"] = "\u0633\u062C";
                  t["\uFD35"] = "\u0633\u062D";
                  t["\uFD36"] = "\u0633\u062E";
                  t["\uFD37"] = "\u0634\u062C";
                  t["\uFD38"] = "\u0634\u062D";
                  t["\uFD39"] = "\u0634\u062E";
                  t["\uFD3A"] = "\u0637\u0645";
                  t["\uFD3B"] = "\u0638\u0645";
                  t["\uFD3C"] = "\u0627\u064B";
                  t["\uFD3D"] = "\u0627\u064B";
                  t["\uFD50"] = "\u062A\u062C\u0645";
                  t["\uFD51"] = "\u062A\u062D\u062C";
                  t["\uFD52"] = "\u062A\u062D\u062C";
                  t["\uFD53"] = "\u062A\u062D\u0645";
                  t["\uFD54"] = "\u062A\u062E\u0645";
                  t["\uFD55"] = "\u062A\u0645\u062C";
                  t["\uFD56"] = "\u062A\u0645\u062D";
                  t["\uFD57"] = "\u062A\u0645\u062E";
                  t["\uFD58"] = "\u062C\u0645\u062D";
                  t["\uFD59"] = "\u062C\u0645\u062D";
                  t["\uFD5A"] = "\u062D\u0645\u064A";
                  t["\uFD5B"] = "\u062D\u0645\u0649";
                  t["\uFD5C"] = "\u0633\u062D\u062C";
                  t["\uFD5D"] = "\u0633\u062C\u062D";
                  t["\uFD5E"] = "\u0633\u062C\u0649";
                  t["\uFD5F"] = "\u0633\u0645\u062D";
                  t["\uFD60"] = "\u0633\u0645\u062D";
                  t["\uFD61"] = "\u0633\u0645\u062C";
                  t["\uFD62"] = "\u0633\u0645\u0645";
                  t["\uFD63"] = "\u0633\u0645\u0645";
                  t["\uFD64"] = "\u0635\u062D\u062D";
                  t["\uFD65"] = "\u0635\u062D\u062D";
                  t["\uFD66"] = "\u0635\u0645\u0645";
                  t["\uFD67"] = "\u0634\u062D\u0645";
                  t["\uFD68"] = "\u0634\u062D\u0645";
                  t["\uFD69"] = "\u0634\u062C\u064A";
                  t["\uFD6A"] = "\u0634\u0645\u062E";
                  t["\uFD6B"] = "\u0634\u0645\u062E";
                  t["\uFD6C"] = "\u0634\u0645\u0645";
                  t["\uFD6D"] = "\u0634\u0645\u0645";
                  t["\uFD6E"] = "\u0636\u062D\u0649";
                  t["\uFD6F"] = "\u0636\u062E\u0645";
                  t["\uFD70"] = "\u0636\u062E\u0645";
                  t["\uFD71"] = "\u0637\u0645\u062D";
                  t["\uFD72"] = "\u0637\u0645\u062D";
                  t["\uFD73"] = "\u0637\u0645\u0645";
                  t["\uFD74"] = "\u0637\u0645\u064A";
                  t["\uFD75"] = "\u0639\u062C\u0645";
                  t["\uFD76"] = "\u0639\u0645\u0645";
                  t["\uFD77"] = "\u0639\u0645\u0645";
                  t["\uFD78"] = "\u0639\u0645\u0649";
                  t["\uFD79"] = "\u063A\u0645\u0645";
                  t["\uFD7A"] = "\u063A\u0645\u064A";
                  t["\uFD7B"] = "\u063A\u0645\u0649";
                  t["\uFD7C"] = "\u0641\u062E\u0645";
                  t["\uFD7D"] = "\u0641\u062E\u0645";
                  t["\uFD7E"] = "\u0642\u0645\u062D";
                  t["\uFD7F"] = "\u0642\u0645\u0645";
                  t["\uFD80"] = "\u0644\u062D\u0645";
                  t["\uFD81"] = "\u0644\u062D\u064A";
                  t["\uFD82"] = "\u0644\u062D\u0649";
                  t["\uFD83"] = "\u0644\u062C\u062C";
                  t["\uFD84"] = "\u0644\u062C\u062C";
                  t["\uFD85"] = "\u0644\u062E\u0645";
                  t["\uFD86"] = "\u0644\u062E\u0645";
                  t["\uFD87"] = "\u0644\u0645\u062D";
                  t["\uFD88"] = "\u0644\u0645\u062D";
                  t["\uFD89"] = "\u0645\u062D\u062C";
                  t["\uFD8A"] = "\u0645\u062D\u0645";
                  t["\uFD8B"] = "\u0645\u062D\u064A";
                  t["\uFD8C"] = "\u0645\u062C\u062D";
                  t["\uFD8D"] = "\u0645\u062C\u0645";
                  t["\uFD8E"] = "\u0645\u062E\u062C";
                  t["\uFD8F"] = "\u0645\u062E\u0645";
                  t["\uFD92"] = "\u0645\u062C\u062E";
                  t["\uFD93"] = "\u0647\u0645\u062C";
                  t["\uFD94"] = "\u0647\u0645\u0645";
                  t["\uFD95"] = "\u0646\u062D\u0645";
                  t["\uFD96"] = "\u0646\u062D\u0649";
                  t["\uFD97"] = "\u0646\u062C\u0645";
                  t["\uFD98"] = "\u0646\u062C\u0645";
                  t["\uFD99"] = "\u0646\u062C\u0649";
                  t["\uFD9A"] = "\u0646\u0645\u064A";
                  t["\uFD9B"] = "\u0646\u0645\u0649";
                  t["\uFD9C"] = "\u064A\u0645\u0645";
                  t["\uFD9D"] = "\u064A\u0645\u0645";
                  t["\uFD9E"] = "\u0628\u062E\u064A";
                  t["\uFD9F"] = "\u062A\u062C\u064A";
                  t["\uFDA0"] = "\u062A\u062C\u0649";
                  t["\uFDA1"] = "\u062A\u062E\u064A";
                  t["\uFDA2"] = "\u062A\u062E\u0649";
                  t["\uFDA3"] = "\u062A\u0645\u064A";
                  t["\uFDA4"] = "\u062A\u0645\u0649";
                  t["\uFDA5"] = "\u062C\u0645\u064A";
                  t["\uFDA6"] = "\u062C\u062D\u0649";
                  t["\uFDA7"] = "\u062C\u0645\u0649";
                  t["\uFDA8"] = "\u0633\u062E\u0649";
                  t["\uFDA9"] = "\u0635\u062D\u064A";
                  t["\uFDAA"] = "\u0634\u062D\u064A";
                  t["\uFDAB"] = "\u0636\u062D\u064A";
                  t["\uFDAC"] = "\u0644\u062C\u064A";
                  t["\uFDAD"] = "\u0644\u0645\u064A";
                  t["\uFDAE"] = "\u064A\u062D\u064A";
                  t["\uFDAF"] = "\u064A\u062C\u064A";
                  t["\uFDB0"] = "\u064A\u0645\u064A";
                  t["\uFDB1"] = "\u0645\u0645\u064A";
                  t["\uFDB2"] = "\u0642\u0645\u064A";
                  t["\uFDB3"] = "\u0646\u062D\u064A";
                  t["\uFDB4"] = "\u0642\u0645\u062D";
                  t["\uFDB5"] = "\u0644\u062D\u0645";
                  t["\uFDB6"] = "\u0639\u0645\u064A";
                  t["\uFDB7"] = "\u0643\u0645\u064A";
                  t["\uFDB8"] = "\u0646\u062C\u062D";
                  t["\uFDB9"] = "\u0645\u062E\u064A";
                  t["\uFDBA"] = "\u0644\u062C\u0645";
                  t["\uFDBB"] = "\u0643\u0645\u0645";
                  t["\uFDBC"] = "\u0644\u062C\u0645";
                  t["\uFDBD"] = "\u0646\u062C\u062D";
                  t["\uFDBE"] = "\u062C\u062D\u064A";
                  t["\uFDBF"] = "\u062D\u062C\u064A";
                  t["\uFDC0"] = "\u0645\u062C\u064A";
                  t["\uFDC1"] = "\u0641\u0645\u064A";
                  t["\uFDC2"] = "\u0628\u062D\u064A";
                  t["\uFDC3"] = "\u0643\u0645\u0645";
                  t["\uFDC4"] = "\u0639\u062C\u0645";
                  t["\uFDC5"] = "\u0635\u0645\u0645";
                  t["\uFDC6"] = "\u0633\u062E\u064A";
                  t["\uFDC7"] = "\u0646\u062C\u064A";
                  t["\uFE49"] = "\u203E";
                  t["\uFE4A"] = "\u203E";
                  t["\uFE4B"] = "\u203E";
                  t["\uFE4C"] = "\u203E";
                  t["\uFE4D"] = "_";
                  t["\uFE4E"] = "_";
                  t["\uFE4F"] = "_";
                  t["\uFE80"] = "\u0621";
                  t["\uFE81"] = "\u0622";
                  t["\uFE82"] = "\u0622";
                  t["\uFE83"] = "\u0623";
                  t["\uFE84"] = "\u0623";
                  t["\uFE85"] = "\u0624";
                  t["\uFE86"] = "\u0624";
                  t["\uFE87"] = "\u0625";
                  t["\uFE88"] = "\u0625";
                  t["\uFE89"] = "\u0626";
                  t["\uFE8A"] = "\u0626";
                  t["\uFE8B"] = "\u0626";
                  t["\uFE8C"] = "\u0626";
                  t["\uFE8D"] = "\u0627";
                  t["\uFE8E"] = "\u0627";
                  t["\uFE8F"] = "\u0628";
                  t["\uFE90"] = "\u0628";
                  t["\uFE91"] = "\u0628";
                  t["\uFE92"] = "\u0628";
                  t["\uFE93"] = "\u0629";
                  t["\uFE94"] = "\u0629";
                  t["\uFE95"] = "\u062A";
                  t["\uFE96"] = "\u062A";
                  t["\uFE97"] = "\u062A";
                  t["\uFE98"] = "\u062A";
                  t["\uFE99"] = "\u062B";
                  t["\uFE9A"] = "\u062B";
                  t["\uFE9B"] = "\u062B";
                  t["\uFE9C"] = "\u062B";
                  t["\uFE9D"] = "\u062C";
                  t["\uFE9E"] = "\u062C";
                  t["\uFE9F"] = "\u062C";
                  t["\uFEA0"] = "\u062C";
                  t["\uFEA1"] = "\u062D";
                  t["\uFEA2"] = "\u062D";
                  t["\uFEA3"] = "\u062D";
                  t["\uFEA4"] = "\u062D";
                  t["\uFEA5"] = "\u062E";
                  t["\uFEA6"] = "\u062E";
                  t["\uFEA7"] = "\u062E";
                  t["\uFEA8"] = "\u062E";
                  t["\uFEA9"] = "\u062F";
                  t["\uFEAA"] = "\u062F";
                  t["\uFEAB"] = "\u0630";
                  t["\uFEAC"] = "\u0630";
                  t["\uFEAD"] = "\u0631";
                  t["\uFEAE"] = "\u0631";
                  t["\uFEAF"] = "\u0632";
                  t["\uFEB0"] = "\u0632";
                  t["\uFEB1"] = "\u0633";
                  t["\uFEB2"] = "\u0633";
                  t["\uFEB3"] = "\u0633";
                  t["\uFEB4"] = "\u0633";
                  t["\uFEB5"] = "\u0634";
                  t["\uFEB6"] = "\u0634";
                  t["\uFEB7"] = "\u0634";
                  t["\uFEB8"] = "\u0634";
                  t["\uFEB9"] = "\u0635";
                  t["\uFEBA"] = "\u0635";
                  t["\uFEBB"] = "\u0635";
                  t["\uFEBC"] = "\u0635";
                  t["\uFEBD"] = "\u0636";
                  t["\uFEBE"] = "\u0636";
                  t["\uFEBF"] = "\u0636";
                  t["\uFEC0"] = "\u0636";
                  t["\uFEC1"] = "\u0637";
                  t["\uFEC2"] = "\u0637";
                  t["\uFEC3"] = "\u0637";
                  t["\uFEC4"] = "\u0637";
                  t["\uFEC5"] = "\u0638";
                  t["\uFEC6"] = "\u0638";
                  t["\uFEC7"] = "\u0638";
                  t["\uFEC8"] = "\u0638";
                  t["\uFEC9"] = "\u0639";
                  t["\uFECA"] = "\u0639";
                  t["\uFECB"] = "\u0639";
                  t["\uFECC"] = "\u0639";
                  t["\uFECD"] = "\u063A";
                  t["\uFECE"] = "\u063A";
                  t["\uFECF"] = "\u063A";
                  t["\uFED0"] = "\u063A";
                  t["\uFED1"] = "\u0641";
                  t["\uFED2"] = "\u0641";
                  t["\uFED3"] = "\u0641";
                  t["\uFED4"] = "\u0641";
                  t["\uFED5"] = "\u0642";
                  t["\uFED6"] = "\u0642";
                  t["\uFED7"] = "\u0642";
                  t["\uFED8"] = "\u0642";
                  t["\uFED9"] = "\u0643";
                  t["\uFEDA"] = "\u0643";
                  t["\uFEDB"] = "\u0643";
                  t["\uFEDC"] = "\u0643";
                  t["\uFEDD"] = "\u0644";
                  t["\uFEDE"] = "\u0644";
                  t["\uFEDF"] = "\u0644";
                  t["\uFEE0"] = "\u0644";
                  t["\uFEE1"] = "\u0645";
                  t["\uFEE2"] = "\u0645";
                  t["\uFEE3"] = "\u0645";
                  t["\uFEE4"] = "\u0645";
                  t["\uFEE5"] = "\u0646";
                  t["\uFEE6"] = "\u0646";
                  t["\uFEE7"] = "\u0646";
                  t["\uFEE8"] = "\u0646";
                  t["\uFEE9"] = "\u0647";
                  t["\uFEEA"] = "\u0647";
                  t["\uFEEB"] = "\u0647";
                  t["\uFEEC"] = "\u0647";
                  t["\uFEED"] = "\u0648";
                  t["\uFEEE"] = "\u0648";
                  t["\uFEEF"] = "\u0649";
                  t["\uFEF0"] = "\u0649";
                  t["\uFEF1"] = "\u064A";
                  t["\uFEF2"] = "\u064A";
                  t["\uFEF3"] = "\u064A";
                  t["\uFEF4"] = "\u064A";
                  t["\uFEF5"] = "\u0644\u0622";
                  t["\uFEF6"] = "\u0644\u0622";
                  t["\uFEF7"] = "\u0644\u0623";
                  t["\uFEF8"] = "\u0644\u0623";
                  t["\uFEF9"] = "\u0644\u0625";
                  t["\uFEFA"] = "\u0644\u0625";
                  t["\uFEFB"] = "\u0644\u0627";
                  t["\uFEFC"] = "\u0644\u0627";
                });
                function reverseIfRtl(chars) {
                  var charsLength = chars.length;
                  if (charsLength <= 1 || !isRTLRangeFor(chars.charCodeAt(0))) {
                    return chars;
                  }
                  var s = "";
                  for (var ii = charsLength - 1; ii >= 0; ii--) {
                    s += chars[ii];
                  }
                  return s;
                }
                exports2.mapSpecialUnicodeValues = mapSpecialUnicodeValues;
                exports2.reverseIfRtl = reverseIfRtl;
                exports2.getUnicodeRangeFor = getUnicodeRangeFor;
                exports2.getNormalizedUnicodes = getNormalizedUnicodes;
                exports2.getUnicodeForGlyph = getUnicodeForGlyph;
              }, function(module3, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.FontRendererFactory = void 0;
                var _util2 = __w_pdfjs_require__2(2);
                var _cff_parser = __w_pdfjs_require__2(28);
                var _glyphlist = __w_pdfjs_require__2(31);
                var _encodings = __w_pdfjs_require__2(30);
                var _stream = __w_pdfjs_require__2(11);
                var FontRendererFactory = function FontRendererFactoryClosure() {
                  function getLong(data, offset) {
                    return data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3];
                  }
                  function getUshort(data, offset) {
                    return data[offset] << 8 | data[offset + 1];
                  }
                  function getSubroutineBias(subrs) {
                    const numSubrs = subrs.length;
                    let bias = 32768;
                    if (numSubrs < 1240) {
                      bias = 107;
                    } else if (numSubrs < 33900) {
                      bias = 1131;
                    }
                    return bias;
                  }
                  function parseCmap(data, start, end) {
                    var offset = getUshort(data, start + 2) === 1 ? getLong(data, start + 8) : getLong(data, start + 16);
                    var format = getUshort(data, start + offset);
                    var ranges, p, i;
                    if (format === 4) {
                      getUshort(data, start + offset + 2);
                      var segCount = getUshort(data, start + offset + 6) >> 1;
                      p = start + offset + 14;
                      ranges = [];
                      for (i = 0; i < segCount; i++, p += 2) {
                        ranges[i] = { end: getUshort(data, p) };
                      }
                      p += 2;
                      for (i = 0; i < segCount; i++, p += 2) {
                        ranges[i].start = getUshort(data, p);
                      }
                      for (i = 0; i < segCount; i++, p += 2) {
                        ranges[i].idDelta = getUshort(data, p);
                      }
                      for (i = 0; i < segCount; i++, p += 2) {
                        var idOffset = getUshort(data, p);
                        if (idOffset === 0) {
                          continue;
                        }
                        ranges[i].ids = [];
                        for (var j = 0, jj = ranges[i].end - ranges[i].start + 1; j < jj; j++) {
                          ranges[i].ids[j] = getUshort(data, p + idOffset);
                          idOffset += 2;
                        }
                      }
                      return ranges;
                    } else if (format === 12) {
                      getLong(data, start + offset + 4);
                      var groups = getLong(data, start + offset + 12);
                      p = start + offset + 16;
                      ranges = [];
                      for (i = 0; i < groups; i++) {
                        ranges.push({ start: getLong(data, p), end: getLong(data, p + 4), idDelta: getLong(data, p + 8) - getLong(data, p) });
                        p += 12;
                      }
                      return ranges;
                    }
                    throw new _util2.FormatError(`unsupported cmap: ${format}`);
                  }
                  function parseCff(data, start, end, seacAnalysisEnabled) {
                    var properties = {};
                    var parser = new _cff_parser.CFFParser(new _stream.Stream(data, start, end - start), properties, seacAnalysisEnabled);
                    var cff = parser.parse();
                    return { glyphs: cff.charStrings.objects, subrs: cff.topDict.privateDict && cff.topDict.privateDict.subrsIndex && cff.topDict.privateDict.subrsIndex.objects, gsubrs: cff.globalSubrIndex && cff.globalSubrIndex.objects, isCFFCIDFont: cff.isCIDFont, fdSelect: cff.fdSelect, fdArray: cff.fdArray };
                  }
                  function parseGlyfTable(glyf, loca, isGlyphLocationsLong) {
                    var itemSize, itemDecode;
                    if (isGlyphLocationsLong) {
                      itemSize = 4;
                      itemDecode = function fontItemDecodeLong(data, offset) {
                        return data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3];
                      };
                    } else {
                      itemSize = 2;
                      itemDecode = function fontItemDecode(data, offset) {
                        return data[offset] << 9 | data[offset + 1] << 1;
                      };
                    }
                    var glyphs = [];
                    var startOffset = itemDecode(loca, 0);
                    for (var j = itemSize; j < loca.length; j += itemSize) {
                      var endOffset = itemDecode(loca, j);
                      glyphs.push(glyf.subarray(startOffset, endOffset));
                      startOffset = endOffset;
                    }
                    return glyphs;
                  }
                  function lookupCmap(ranges, unicode) {
                    var code = unicode.codePointAt(0), gid = 0;
                    var l = 0, r = ranges.length - 1;
                    while (l < r) {
                      var c = l + r + 1 >> 1;
                      if (code < ranges[c].start) {
                        r = c - 1;
                      } else {
                        l = c;
                      }
                    }
                    if (ranges[l].start <= code && code <= ranges[l].end) {
                      gid = ranges[l].idDelta + (ranges[l].ids ? ranges[l].ids[code - ranges[l].start] : code) & 65535;
                    }
                    return { charCode: code, glyphId: gid };
                  }
                  function compileGlyf(code, cmds, font) {
                    function moveTo(x2, y2) {
                      cmds.push({ cmd: "moveTo", args: [x2, y2] });
                    }
                    function lineTo(x2, y2) {
                      cmds.push({ cmd: "lineTo", args: [x2, y2] });
                    }
                    function quadraticCurveTo(xa, ya, x2, y2) {
                      cmds.push({ cmd: "quadraticCurveTo", args: [xa, ya, x2, y2] });
                    }
                    var i = 0;
                    var numberOfContours = (code[i] << 24 | code[i + 1] << 16) >> 16;
                    var flags;
                    var x = 0, y = 0;
                    i += 10;
                    if (numberOfContours < 0) {
                      do {
                        flags = code[i] << 8 | code[i + 1];
                        var glyphIndex = code[i + 2] << 8 | code[i + 3];
                        i += 4;
                        var arg1, arg2;
                        if (flags & 1) {
                          arg1 = (code[i] << 24 | code[i + 1] << 16) >> 16;
                          arg2 = (code[i + 2] << 24 | code[i + 3] << 16) >> 16;
                          i += 4;
                        } else {
                          arg1 = code[i++];
                          arg2 = code[i++];
                        }
                        if (flags & 2) {
                          x = arg1;
                          y = arg2;
                        } else {
                          x = 0;
                          y = 0;
                        }
                        var scaleX = 1, scaleY = 1, scale01 = 0, scale10 = 0;
                        if (flags & 8) {
                          scaleX = scaleY = (code[i] << 24 | code[i + 1] << 16) / 1073741824;
                          i += 2;
                        } else if (flags & 64) {
                          scaleX = (code[i] << 24 | code[i + 1] << 16) / 1073741824;
                          scaleY = (code[i + 2] << 24 | code[i + 3] << 16) / 1073741824;
                          i += 4;
                        } else if (flags & 128) {
                          scaleX = (code[i] << 24 | code[i + 1] << 16) / 1073741824;
                          scale01 = (code[i + 2] << 24 | code[i + 3] << 16) / 1073741824;
                          scale10 = (code[i + 4] << 24 | code[i + 5] << 16) / 1073741824;
                          scaleY = (code[i + 6] << 24 | code[i + 7] << 16) / 1073741824;
                          i += 8;
                        }
                        var subglyph = font.glyphs[glyphIndex];
                        if (subglyph) {
                          cmds.push({ cmd: "save" });
                          cmds.push({ cmd: "transform", args: [scaleX, scale01, scale10, scaleY, x, y] });
                          compileGlyf(subglyph, cmds, font);
                          cmds.push({ cmd: "restore" });
                        }
                      } while (flags & 32);
                    } else {
                      var endPtsOfContours = [];
                      var j, jj;
                      for (j = 0; j < numberOfContours; j++) {
                        endPtsOfContours.push(code[i] << 8 | code[i + 1]);
                        i += 2;
                      }
                      var instructionLength = code[i] << 8 | code[i + 1];
                      i += 2 + instructionLength;
                      var numberOfPoints = endPtsOfContours[endPtsOfContours.length - 1] + 1;
                      var points = [];
                      while (points.length < numberOfPoints) {
                        flags = code[i++];
                        var repeat = 1;
                        if (flags & 8) {
                          repeat += code[i++];
                        }
                        while (repeat-- > 0) {
                          points.push({ flags });
                        }
                      }
                      for (j = 0; j < numberOfPoints; j++) {
                        switch (points[j].flags & 18) {
                          case 0:
                            x += (code[i] << 24 | code[i + 1] << 16) >> 16;
                            i += 2;
                            break;
                          case 2:
                            x -= code[i++];
                            break;
                          case 18:
                            x += code[i++];
                            break;
                        }
                        points[j].x = x;
                      }
                      for (j = 0; j < numberOfPoints; j++) {
                        switch (points[j].flags & 36) {
                          case 0:
                            y += (code[i] << 24 | code[i + 1] << 16) >> 16;
                            i += 2;
                            break;
                          case 4:
                            y -= code[i++];
                            break;
                          case 36:
                            y += code[i++];
                            break;
                        }
                        points[j].y = y;
                      }
                      var startPoint = 0;
                      for (i = 0; i < numberOfContours; i++) {
                        var endPoint = endPtsOfContours[i];
                        var contour = points.slice(startPoint, endPoint + 1);
                        if (contour[0].flags & 1) {
                          contour.push(contour[0]);
                        } else if (contour[contour.length - 1].flags & 1) {
                          contour.unshift(contour[contour.length - 1]);
                        } else {
                          var p = { flags: 1, x: (contour[0].x + contour[contour.length - 1].x) / 2, y: (contour[0].y + contour[contour.length - 1].y) / 2 };
                          contour.unshift(p);
                          contour.push(p);
                        }
                        moveTo(contour[0].x, contour[0].y);
                        for (j = 1, jj = contour.length; j < jj; j++) {
                          if (contour[j].flags & 1) {
                            lineTo(contour[j].x, contour[j].y);
                          } else if (contour[j + 1].flags & 1) {
                            quadraticCurveTo(contour[j].x, contour[j].y, contour[j + 1].x, contour[j + 1].y);
                            j++;
                          } else {
                            quadraticCurveTo(contour[j].x, contour[j].y, (contour[j].x + contour[j + 1].x) / 2, (contour[j].y + contour[j + 1].y) / 2);
                          }
                        }
                        startPoint = endPoint + 1;
                      }
                    }
                  }
                  function compileCharString(code, cmds, font, glyphId) {
                    var stack = [];
                    var x = 0, y = 0;
                    var stems = 0;
                    function moveTo(x2, y2) {
                      cmds.push({ cmd: "moveTo", args: [x2, y2] });
                    }
                    function lineTo(x2, y2) {
                      cmds.push({ cmd: "lineTo", args: [x2, y2] });
                    }
                    function bezierCurveTo(x1, y1, x2, y2, x3, y3) {
                      cmds.push({ cmd: "bezierCurveTo", args: [x1, y1, x2, y2, x3, y3] });
                    }
                    function parse(code2) {
                      var i = 0;
                      while (i < code2.length) {
                        var stackClean = false;
                        var v = code2[i++];
                        var xa, xb, ya, yb, y1, y2, y3, n, subrCode;
                        switch (v) {
                          case 1:
                            stems += stack.length >> 1;
                            stackClean = true;
                            break;
                          case 3:
                            stems += stack.length >> 1;
                            stackClean = true;
                            break;
                          case 4:
                            y += stack.pop();
                            moveTo(x, y);
                            stackClean = true;
                            break;
                          case 5:
                            while (stack.length > 0) {
                              x += stack.shift();
                              y += stack.shift();
                              lineTo(x, y);
                            }
                            break;
                          case 6:
                            while (stack.length > 0) {
                              x += stack.shift();
                              lineTo(x, y);
                              if (stack.length === 0) {
                                break;
                              }
                              y += stack.shift();
                              lineTo(x, y);
                            }
                            break;
                          case 7:
                            while (stack.length > 0) {
                              y += stack.shift();
                              lineTo(x, y);
                              if (stack.length === 0) {
                                break;
                              }
                              x += stack.shift();
                              lineTo(x, y);
                            }
                            break;
                          case 8:
                            while (stack.length > 0) {
                              xa = x + stack.shift();
                              ya = y + stack.shift();
                              xb = xa + stack.shift();
                              yb = ya + stack.shift();
                              x = xb + stack.shift();
                              y = yb + stack.shift();
                              bezierCurveTo(xa, ya, xb, yb, x, y);
                            }
                            break;
                          case 10:
                            n = stack.pop();
                            subrCode = null;
                            if (font.isCFFCIDFont) {
                              const fdIndex = font.fdSelect.getFDIndex(glyphId);
                              if (fdIndex >= 0 && fdIndex < font.fdArray.length) {
                                const fontDict = font.fdArray[fdIndex];
                                let subrs;
                                if (fontDict.privateDict && fontDict.privateDict.subrsIndex) {
                                  subrs = fontDict.privateDict.subrsIndex.objects;
                                }
                                if (subrs) {
                                  n += getSubroutineBias(subrs);
                                  subrCode = subrs[n];
                                }
                              } else {
                                (0, _util2.warn)("Invalid fd index for glyph index.");
                              }
                            } else {
                              subrCode = font.subrs[n + font.subrsBias];
                            }
                            if (subrCode) {
                              parse(subrCode);
                            }
                            break;
                          case 11:
                            return;
                          case 12:
                            v = code2[i++];
                            switch (v) {
                              case 34:
                                xa = x + stack.shift();
                                xb = xa + stack.shift();
                                y1 = y + stack.shift();
                                x = xb + stack.shift();
                                bezierCurveTo(xa, y, xb, y1, x, y1);
                                xa = x + stack.shift();
                                xb = xa + stack.shift();
                                x = xb + stack.shift();
                                bezierCurveTo(xa, y1, xb, y, x, y);
                                break;
                              case 35:
                                xa = x + stack.shift();
                                ya = y + stack.shift();
                                xb = xa + stack.shift();
                                yb = ya + stack.shift();
                                x = xb + stack.shift();
                                y = yb + stack.shift();
                                bezierCurveTo(xa, ya, xb, yb, x, y);
                                xa = x + stack.shift();
                                ya = y + stack.shift();
                                xb = xa + stack.shift();
                                yb = ya + stack.shift();
                                x = xb + stack.shift();
                                y = yb + stack.shift();
                                bezierCurveTo(xa, ya, xb, yb, x, y);
                                stack.pop();
                                break;
                              case 36:
                                xa = x + stack.shift();
                                y1 = y + stack.shift();
                                xb = xa + stack.shift();
                                y2 = y1 + stack.shift();
                                x = xb + stack.shift();
                                bezierCurveTo(xa, y1, xb, y2, x, y2);
                                xa = x + stack.shift();
                                xb = xa + stack.shift();
                                y3 = y2 + stack.shift();
                                x = xb + stack.shift();
                                bezierCurveTo(xa, y2, xb, y3, x, y);
                                break;
                              case 37:
                                var x0 = x, y0 = y;
                                xa = x + stack.shift();
                                ya = y + stack.shift();
                                xb = xa + stack.shift();
                                yb = ya + stack.shift();
                                x = xb + stack.shift();
                                y = yb + stack.shift();
                                bezierCurveTo(xa, ya, xb, yb, x, y);
                                xa = x + stack.shift();
                                ya = y + stack.shift();
                                xb = xa + stack.shift();
                                yb = ya + stack.shift();
                                x = xb;
                                y = yb;
                                if (Math.abs(x - x0) > Math.abs(y - y0)) {
                                  x += stack.shift();
                                } else {
                                  y += stack.shift();
                                }
                                bezierCurveTo(xa, ya, xb, yb, x, y);
                                break;
                              default:
                                throw new _util2.FormatError(`unknown operator: 12 ${v}`);
                            }
                            break;
                          case 14:
                            if (stack.length >= 4) {
                              var achar = stack.pop();
                              var bchar = stack.pop();
                              y = stack.pop();
                              x = stack.pop();
                              cmds.push({ cmd: "save" });
                              cmds.push({ cmd: "translate", args: [x, y] });
                              var cmap = lookupCmap(font.cmap, String.fromCharCode(font.glyphNameMap[_encodings.StandardEncoding[achar]]));
                              compileCharString(font.glyphs[cmap.glyphId], cmds, font, cmap.glyphId);
                              cmds.push({ cmd: "restore" });
                              cmap = lookupCmap(font.cmap, String.fromCharCode(font.glyphNameMap[_encodings.StandardEncoding[bchar]]));
                              compileCharString(font.glyphs[cmap.glyphId], cmds, font, cmap.glyphId);
                            }
                            return;
                          case 18:
                            stems += stack.length >> 1;
                            stackClean = true;
                            break;
                          case 19:
                            stems += stack.length >> 1;
                            i += stems + 7 >> 3;
                            stackClean = true;
                            break;
                          case 20:
                            stems += stack.length >> 1;
                            i += stems + 7 >> 3;
                            stackClean = true;
                            break;
                          case 21:
                            y += stack.pop();
                            x += stack.pop();
                            moveTo(x, y);
                            stackClean = true;
                            break;
                          case 22:
                            x += stack.pop();
                            moveTo(x, y);
                            stackClean = true;
                            break;
                          case 23:
                            stems += stack.length >> 1;
                            stackClean = true;
                            break;
                          case 24:
                            while (stack.length > 2) {
                              xa = x + stack.shift();
                              ya = y + stack.shift();
                              xb = xa + stack.shift();
                              yb = ya + stack.shift();
                              x = xb + stack.shift();
                              y = yb + stack.shift();
                              bezierCurveTo(xa, ya, xb, yb, x, y);
                            }
                            x += stack.shift();
                            y += stack.shift();
                            lineTo(x, y);
                            break;
                          case 25:
                            while (stack.length > 6) {
                              x += stack.shift();
                              y += stack.shift();
                              lineTo(x, y);
                            }
                            xa = x + stack.shift();
                            ya = y + stack.shift();
                            xb = xa + stack.shift();
                            yb = ya + stack.shift();
                            x = xb + stack.shift();
                            y = yb + stack.shift();
                            bezierCurveTo(xa, ya, xb, yb, x, y);
                            break;
                          case 26:
                            if (stack.length % 2) {
                              x += stack.shift();
                            }
                            while (stack.length > 0) {
                              xa = x;
                              ya = y + stack.shift();
                              xb = xa + stack.shift();
                              yb = ya + stack.shift();
                              x = xb;
                              y = yb + stack.shift();
                              bezierCurveTo(xa, ya, xb, yb, x, y);
                            }
                            break;
                          case 27:
                            if (stack.length % 2) {
                              y += stack.shift();
                            }
                            while (stack.length > 0) {
                              xa = x + stack.shift();
                              ya = y;
                              xb = xa + stack.shift();
                              yb = ya + stack.shift();
                              x = xb + stack.shift();
                              y = yb;
                              bezierCurveTo(xa, ya, xb, yb, x, y);
                            }
                            break;
                          case 28:
                            stack.push((code2[i] << 24 | code2[i + 1] << 16) >> 16);
                            i += 2;
                            break;
                          case 29:
                            n = stack.pop() + font.gsubrsBias;
                            subrCode = font.gsubrs[n];
                            if (subrCode) {
                              parse(subrCode);
                            }
                            break;
                          case 30:
                            while (stack.length > 0) {
                              xa = x;
                              ya = y + stack.shift();
                              xb = xa + stack.shift();
                              yb = ya + stack.shift();
                              x = xb + stack.shift();
                              y = yb + (stack.length === 1 ? stack.shift() : 0);
                              bezierCurveTo(xa, ya, xb, yb, x, y);
                              if (stack.length === 0) {
                                break;
                              }
                              xa = x + stack.shift();
                              ya = y;
                              xb = xa + stack.shift();
                              yb = ya + stack.shift();
                              y = yb + stack.shift();
                              x = xb + (stack.length === 1 ? stack.shift() : 0);
                              bezierCurveTo(xa, ya, xb, yb, x, y);
                            }
                            break;
                          case 31:
                            while (stack.length > 0) {
                              xa = x + stack.shift();
                              ya = y;
                              xb = xa + stack.shift();
                              yb = ya + stack.shift();
                              y = yb + stack.shift();
                              x = xb + (stack.length === 1 ? stack.shift() : 0);
                              bezierCurveTo(xa, ya, xb, yb, x, y);
                              if (stack.length === 0) {
                                break;
                              }
                              xa = x;
                              ya = y + stack.shift();
                              xb = xa + stack.shift();
                              yb = ya + stack.shift();
                              x = xb + stack.shift();
                              y = yb + (stack.length === 1 ? stack.shift() : 0);
                              bezierCurveTo(xa, ya, xb, yb, x, y);
                            }
                            break;
                          default:
                            if (v < 32) {
                              throw new _util2.FormatError(`unknown operator: ${v}`);
                            }
                            if (v < 247) {
                              stack.push(v - 139);
                            } else if (v < 251) {
                              stack.push((v - 247) * 256 + code2[i++] + 108);
                            } else if (v < 255) {
                              stack.push(-(v - 251) * 256 - code2[i++] - 108);
                            } else {
                              stack.push((code2[i] << 24 | code2[i + 1] << 16 | code2[i + 2] << 8 | code2[i + 3]) / 65536);
                              i += 4;
                            }
                            break;
                        }
                        if (stackClean) {
                          stack.length = 0;
                        }
                      }
                    }
                    parse(code);
                  }
                  const NOOP = [];
                  class CompiledFont {
                    constructor(fontMatrix) {
                      if (this.constructor === CompiledFont) {
                        (0, _util2.unreachable)("Cannot initialize CompiledFont.");
                      }
                      this.fontMatrix = fontMatrix;
                      this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
                      this.compiledCharCodeToGlyphId = /* @__PURE__ */ Object.create(null);
                    }
                    getPathJs(unicode) {
                      const cmap = lookupCmap(this.cmap, unicode);
                      let fn = this.compiledGlyphs[cmap.glyphId];
                      if (!fn) {
                        fn = this.compileGlyph(this.glyphs[cmap.glyphId], cmap.glyphId);
                        this.compiledGlyphs[cmap.glyphId] = fn;
                      }
                      if (this.compiledCharCodeToGlyphId[cmap.charCode] === void 0) {
                        this.compiledCharCodeToGlyphId[cmap.charCode] = cmap.glyphId;
                      }
                      return fn;
                    }
                    compileGlyph(code, glyphId) {
                      if (!code || code.length === 0 || code[0] === 14) {
                        return NOOP;
                      }
                      let fontMatrix = this.fontMatrix;
                      if (this.isCFFCIDFont) {
                        const fdIndex = this.fdSelect.getFDIndex(glyphId);
                        if (fdIndex >= 0 && fdIndex < this.fdArray.length) {
                          const fontDict = this.fdArray[fdIndex];
                          fontMatrix = fontDict.getByName("FontMatrix") || _util2.FONT_IDENTITY_MATRIX;
                        } else {
                          (0, _util2.warn)("Invalid fd index for glyph index.");
                        }
                      }
                      const cmds = [];
                      cmds.push({ cmd: "save" });
                      cmds.push({ cmd: "transform", args: fontMatrix.slice() });
                      cmds.push({ cmd: "scale", args: ["size", "-size"] });
                      this.compileGlyphImpl(code, cmds, glyphId);
                      cmds.push({ cmd: "restore" });
                      return cmds;
                    }
                    compileGlyphImpl() {
                      (0, _util2.unreachable)("Children classes should implement this.");
                    }
                    hasBuiltPath(unicode) {
                      const cmap = lookupCmap(this.cmap, unicode);
                      return this.compiledGlyphs[cmap.glyphId] !== void 0 && this.compiledCharCodeToGlyphId[cmap.charCode] !== void 0;
                    }
                  }
                  class TrueTypeCompiled extends CompiledFont {
                    constructor(glyphs, cmap, fontMatrix) {
                      super(fontMatrix || [488e-6, 0, 0, 488e-6, 0, 0]);
                      this.glyphs = glyphs;
                      this.cmap = cmap;
                    }
                    compileGlyphImpl(code, cmds) {
                      compileGlyf(code, cmds, this);
                    }
                  }
                  class Type2Compiled extends CompiledFont {
                    constructor(cffInfo, cmap, fontMatrix, glyphNameMap) {
                      super(fontMatrix || [1e-3, 0, 0, 1e-3, 0, 0]);
                      this.glyphs = cffInfo.glyphs;
                      this.gsubrs = cffInfo.gsubrs || [];
                      this.subrs = cffInfo.subrs || [];
                      this.cmap = cmap;
                      this.glyphNameMap = glyphNameMap || (0, _glyphlist.getGlyphsUnicode)();
                      this.gsubrsBias = getSubroutineBias(this.gsubrs);
                      this.subrsBias = getSubroutineBias(this.subrs);
                      this.isCFFCIDFont = cffInfo.isCFFCIDFont;
                      this.fdSelect = cffInfo.fdSelect;
                      this.fdArray = cffInfo.fdArray;
                    }
                    compileGlyphImpl(code, cmds, glyphId) {
                      compileCharString(code, cmds, this, glyphId);
                    }
                  }
                  return { create: function FontRendererFactory_create(font, seacAnalysisEnabled) {
                    var data = new Uint8Array(font.data);
                    var cmap, glyf, loca, cff, indexToLocFormat, unitsPerEm;
                    var numTables = getUshort(data, 4);
                    for (var i = 0, p = 12; i < numTables; i++, p += 16) {
                      var tag = (0, _util2.bytesToString)(data.subarray(p, p + 4));
                      var offset = getLong(data, p + 8);
                      var length = getLong(data, p + 12);
                      switch (tag) {
                        case "cmap":
                          cmap = parseCmap(data, offset, offset + length);
                          break;
                        case "glyf":
                          glyf = data.subarray(offset, offset + length);
                          break;
                        case "loca":
                          loca = data.subarray(offset, offset + length);
                          break;
                        case "head":
                          unitsPerEm = getUshort(data, offset + 18);
                          indexToLocFormat = getUshort(data, offset + 50);
                          break;
                        case "CFF ":
                          cff = parseCff(data, offset, offset + length, seacAnalysisEnabled);
                          break;
                      }
                    }
                    if (glyf) {
                      var fontMatrix = !unitsPerEm ? font.fontMatrix : [1 / unitsPerEm, 0, 0, 1 / unitsPerEm, 0, 0];
                      return new TrueTypeCompiled(parseGlyfTable(glyf, loca, indexToLocFormat), cmap, fontMatrix);
                    }
                    return new Type2Compiled(cff, cmap, font.fontMatrix, font.glyphNameMap);
                  } };
                }();
                exports2.FontRendererFactory = FontRendererFactory;
              }, function(module3, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.Type1Parser = void 0;
                var _encodings = __w_pdfjs_require__2(30);
                var _core_utils = __w_pdfjs_require__2(7);
                var _stream = __w_pdfjs_require__2(11);
                var _util2 = __w_pdfjs_require__2(2);
                var HINTING_ENABLED = false;
                var Type1CharString = function Type1CharStringClosure() {
                  var COMMAND_MAP = { hstem: [1], vstem: [3], vmoveto: [4], rlineto: [5], hlineto: [6], vlineto: [7], rrcurveto: [8], callsubr: [10], flex: [12, 35], drop: [12, 18], endchar: [14], rmoveto: [21], hmoveto: [22], vhcurveto: [30], hvcurveto: [31] };
                  function Type1CharString2() {
                    this.width = 0;
                    this.lsb = 0;
                    this.flexing = false;
                    this.output = [];
                    this.stack = [];
                  }
                  Type1CharString2.prototype = { convert: function Type1CharString_convert(encoded, subrs, seacAnalysisEnabled) {
                    var count = encoded.length;
                    var error = false;
                    var wx, sbx, subrNumber;
                    for (var i = 0; i < count; i++) {
                      var value = encoded[i];
                      if (value < 32) {
                        if (value === 12) {
                          value = (value << 8) + encoded[++i];
                        }
                        switch (value) {
                          case 1:
                            if (!HINTING_ENABLED) {
                              this.stack = [];
                              break;
                            }
                            error = this.executeCommand(2, COMMAND_MAP.hstem);
                            break;
                          case 3:
                            if (!HINTING_ENABLED) {
                              this.stack = [];
                              break;
                            }
                            error = this.executeCommand(2, COMMAND_MAP.vstem);
                            break;
                          case 4:
                            if (this.flexing) {
                              if (this.stack.length < 1) {
                                error = true;
                                break;
                              }
                              var dy = this.stack.pop();
                              this.stack.push(0, dy);
                              break;
                            }
                            error = this.executeCommand(1, COMMAND_MAP.vmoveto);
                            break;
                          case 5:
                            error = this.executeCommand(2, COMMAND_MAP.rlineto);
                            break;
                          case 6:
                            error = this.executeCommand(1, COMMAND_MAP.hlineto);
                            break;
                          case 7:
                            error = this.executeCommand(1, COMMAND_MAP.vlineto);
                            break;
                          case 8:
                            error = this.executeCommand(6, COMMAND_MAP.rrcurveto);
                            break;
                          case 9:
                            this.stack = [];
                            break;
                          case 10:
                            if (this.stack.length < 1) {
                              error = true;
                              break;
                            }
                            subrNumber = this.stack.pop();
                            if (!subrs[subrNumber]) {
                              error = true;
                              break;
                            }
                            error = this.convert(subrs[subrNumber], subrs, seacAnalysisEnabled);
                            break;
                          case 11:
                            return error;
                          case 13:
                            if (this.stack.length < 2) {
                              error = true;
                              break;
                            }
                            wx = this.stack.pop();
                            sbx = this.stack.pop();
                            this.lsb = sbx;
                            this.width = wx;
                            this.stack.push(wx, sbx);
                            error = this.executeCommand(2, COMMAND_MAP.hmoveto);
                            break;
                          case 14:
                            this.output.push(COMMAND_MAP.endchar[0]);
                            break;
                          case 21:
                            if (this.flexing) {
                              break;
                            }
                            error = this.executeCommand(2, COMMAND_MAP.rmoveto);
                            break;
                          case 22:
                            if (this.flexing) {
                              this.stack.push(0);
                              break;
                            }
                            error = this.executeCommand(1, COMMAND_MAP.hmoveto);
                            break;
                          case 30:
                            error = this.executeCommand(4, COMMAND_MAP.vhcurveto);
                            break;
                          case 31:
                            error = this.executeCommand(4, COMMAND_MAP.hvcurveto);
                            break;
                          case (12 << 8) + 0:
                            this.stack = [];
                            break;
                          case (12 << 8) + 1:
                            if (!HINTING_ENABLED) {
                              this.stack = [];
                              break;
                            }
                            error = this.executeCommand(2, COMMAND_MAP.vstem);
                            break;
                          case (12 << 8) + 2:
                            if (!HINTING_ENABLED) {
                              this.stack = [];
                              break;
                            }
                            error = this.executeCommand(2, COMMAND_MAP.hstem);
                            break;
                          case (12 << 8) + 6:
                            if (seacAnalysisEnabled) {
                              this.seac = this.stack.splice(-4, 4);
                              error = this.executeCommand(0, COMMAND_MAP.endchar);
                            } else {
                              error = this.executeCommand(4, COMMAND_MAP.endchar);
                            }
                            break;
                          case (12 << 8) + 7:
                            if (this.stack.length < 4) {
                              error = true;
                              break;
                            }
                            this.stack.pop();
                            wx = this.stack.pop();
                            var sby = this.stack.pop();
                            sbx = this.stack.pop();
                            this.lsb = sbx;
                            this.width = wx;
                            this.stack.push(wx, sbx, sby);
                            error = this.executeCommand(3, COMMAND_MAP.rmoveto);
                            break;
                          case (12 << 8) + 12:
                            if (this.stack.length < 2) {
                              error = true;
                              break;
                            }
                            var num2 = this.stack.pop();
                            var num1 = this.stack.pop();
                            this.stack.push(num1 / num2);
                            break;
                          case (12 << 8) + 16:
                            if (this.stack.length < 2) {
                              error = true;
                              break;
                            }
                            subrNumber = this.stack.pop();
                            var numArgs = this.stack.pop();
                            if (subrNumber === 0 && numArgs === 3) {
                              var flexArgs = this.stack.splice(this.stack.length - 17, 17);
                              this.stack.push(flexArgs[2] + flexArgs[0], flexArgs[3] + flexArgs[1], flexArgs[4], flexArgs[5], flexArgs[6], flexArgs[7], flexArgs[8], flexArgs[9], flexArgs[10], flexArgs[11], flexArgs[12], flexArgs[13], flexArgs[14]);
                              error = this.executeCommand(13, COMMAND_MAP.flex, true);
                              this.flexing = false;
                              this.stack.push(flexArgs[15], flexArgs[16]);
                            } else if (subrNumber === 1 && numArgs === 0) {
                              this.flexing = true;
                            }
                            break;
                          case (12 << 8) + 17:
                            break;
                          case (12 << 8) + 33:
                            this.stack = [];
                            break;
                          default:
                            (0, _util2.warn)('Unknown type 1 charstring command of "' + value + '"');
                            break;
                        }
                        if (error) {
                          break;
                        }
                        continue;
                      } else if (value <= 246) {
                        value = value - 139;
                      } else if (value <= 250) {
                        value = (value - 247) * 256 + encoded[++i] + 108;
                      } else if (value <= 254) {
                        value = -((value - 251) * 256) - encoded[++i] - 108;
                      } else {
                        value = (encoded[++i] & 255) << 24 | (encoded[++i] & 255) << 16 | (encoded[++i] & 255) << 8 | (encoded[++i] & 255) << 0;
                      }
                      this.stack.push(value);
                    }
                    return error;
                  }, executeCommand(howManyArgs, command, keepStack) {
                    var stackLength = this.stack.length;
                    if (howManyArgs > stackLength) {
                      return true;
                    }
                    var start = stackLength - howManyArgs;
                    for (var i = start; i < stackLength; i++) {
                      var value = this.stack[i];
                      if (Number.isInteger(value)) {
                        this.output.push(28, value >> 8 & 255, value & 255);
                      } else {
                        value = 65536 * value | 0;
                        this.output.push(255, value >> 24 & 255, value >> 16 & 255, value >> 8 & 255, value & 255);
                      }
                    }
                    this.output.push.apply(this.output, command);
                    if (keepStack) {
                      this.stack.splice(start, howManyArgs);
                    } else {
                      this.stack.length = 0;
                    }
                    return false;
                  } };
                  return Type1CharString2;
                }();
                var Type1Parser = function Type1ParserClosure() {
                  var EEXEC_ENCRYPT_KEY = 55665;
                  var CHAR_STRS_ENCRYPT_KEY = 4330;
                  function isHexDigit(code) {
                    return code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102;
                  }
                  function decrypt(data, key, discardNumber) {
                    if (discardNumber >= data.length) {
                      return new Uint8Array(0);
                    }
                    var r = key | 0, c1 = 52845, c2 = 22719, i, j;
                    for (i = 0; i < discardNumber; i++) {
                      r = (data[i] + r) * c1 + c2 & (1 << 16) - 1;
                    }
                    var count = data.length - discardNumber;
                    var decrypted = new Uint8Array(count);
                    for (i = discardNumber, j = 0; j < count; i++, j++) {
                      var value = data[i];
                      decrypted[j] = value ^ r >> 8;
                      r = (value + r) * c1 + c2 & (1 << 16) - 1;
                    }
                    return decrypted;
                  }
                  function decryptAscii(data, key, discardNumber) {
                    var r = key | 0, c1 = 52845, c2 = 22719;
                    var count = data.length, maybeLength = count >>> 1;
                    var decrypted = new Uint8Array(maybeLength);
                    var i, j;
                    for (i = 0, j = 0; i < count; i++) {
                      var digit1 = data[i];
                      if (!isHexDigit(digit1)) {
                        continue;
                      }
                      i++;
                      var digit2;
                      while (i < count && !isHexDigit(digit2 = data[i])) {
                        i++;
                      }
                      if (i < count) {
                        var value = parseInt(String.fromCharCode(digit1, digit2), 16);
                        decrypted[j++] = value ^ r >> 8;
                        r = (value + r) * c1 + c2 & (1 << 16) - 1;
                      }
                    }
                    return Array.prototype.slice.call(decrypted, discardNumber, j);
                  }
                  function isSpecial(c) {
                    return c === 47 || c === 91 || c === 93 || c === 123 || c === 125 || c === 40 || c === 41;
                  }
                  function Type1Parser2(stream, encrypted, seacAnalysisEnabled) {
                    if (encrypted) {
                      var data = stream.getBytes();
                      var isBinary = !(isHexDigit(data[0]) && isHexDigit(data[1]) && isHexDigit(data[2]) && isHexDigit(data[3]));
                      stream = new _stream.Stream(isBinary ? decrypt(data, EEXEC_ENCRYPT_KEY, 4) : decryptAscii(data, EEXEC_ENCRYPT_KEY, 4));
                    }
                    this.seacAnalysisEnabled = !!seacAnalysisEnabled;
                    this.stream = stream;
                    this.nextChar();
                  }
                  Type1Parser2.prototype = { readNumberArray: function Type1Parser_readNumberArray() {
                    this.getToken();
                    var array = [];
                    while (true) {
                      var token = this.getToken();
                      if (token === null || token === "]" || token === "}") {
                        break;
                      }
                      array.push(parseFloat(token || 0));
                    }
                    return array;
                  }, readNumber: function Type1Parser_readNumber() {
                    var token = this.getToken();
                    return parseFloat(token || 0);
                  }, readInt: function Type1Parser_readInt() {
                    var token = this.getToken();
                    return parseInt(token || 0, 10) | 0;
                  }, readBoolean: function Type1Parser_readBoolean() {
                    var token = this.getToken();
                    return token === "true" ? 1 : 0;
                  }, nextChar: function Type1_nextChar() {
                    return this.currentChar = this.stream.getByte();
                  }, getToken: function Type1Parser_getToken() {
                    var comment = false;
                    var ch = this.currentChar;
                    while (true) {
                      if (ch === -1) {
                        return null;
                      }
                      if (comment) {
                        if (ch === 10 || ch === 13) {
                          comment = false;
                        }
                      } else if (ch === 37) {
                        comment = true;
                      } else if (!(0, _core_utils.isWhiteSpace)(ch)) {
                        break;
                      }
                      ch = this.nextChar();
                    }
                    if (isSpecial(ch)) {
                      this.nextChar();
                      return String.fromCharCode(ch);
                    }
                    var token = "";
                    do {
                      token += String.fromCharCode(ch);
                      ch = this.nextChar();
                    } while (ch >= 0 && !(0, _core_utils.isWhiteSpace)(ch) && !isSpecial(ch));
                    return token;
                  }, readCharStrings: function Type1Parser_readCharStrings(bytes, lenIV) {
                    if (lenIV === -1) {
                      return bytes;
                    }
                    return decrypt(bytes, CHAR_STRS_ENCRYPT_KEY, lenIV);
                  }, extractFontProgram: function Type1Parser_extractFontProgram(properties) {
                    var stream = this.stream;
                    var subrs = [], charstrings = [];
                    var privateData = /* @__PURE__ */ Object.create(null);
                    privateData["lenIV"] = 4;
                    var program = { subrs: [], charstrings: [], properties: { privateData } };
                    var token, length, data, lenIV, encoded;
                    while ((token = this.getToken()) !== null) {
                      if (token !== "/") {
                        continue;
                      }
                      token = this.getToken();
                      switch (token) {
                        case "CharStrings":
                          this.getToken();
                          this.getToken();
                          this.getToken();
                          this.getToken();
                          while (true) {
                            token = this.getToken();
                            if (token === null || token === "end") {
                              break;
                            }
                            if (token !== "/") {
                              continue;
                            }
                            var glyph = this.getToken();
                            length = this.readInt();
                            this.getToken();
                            data = length > 0 ? stream.getBytes(length) : new Uint8Array(0);
                            lenIV = program.properties.privateData["lenIV"];
                            encoded = this.readCharStrings(data, lenIV);
                            this.nextChar();
                            token = this.getToken();
                            if (token === "noaccess") {
                              this.getToken();
                            }
                            charstrings.push({ glyph, encoded });
                          }
                          break;
                        case "Subrs":
                          this.readInt();
                          this.getToken();
                          while (this.getToken() === "dup") {
                            var index = this.readInt();
                            length = this.readInt();
                            this.getToken();
                            data = length > 0 ? stream.getBytes(length) : new Uint8Array(0);
                            lenIV = program.properties.privateData["lenIV"];
                            encoded = this.readCharStrings(data, lenIV);
                            this.nextChar();
                            token = this.getToken();
                            if (token === "noaccess") {
                              this.getToken();
                            }
                            subrs[index] = encoded;
                          }
                          break;
                        case "BlueValues":
                        case "OtherBlues":
                        case "FamilyBlues":
                        case "FamilyOtherBlues":
                          var blueArray = this.readNumberArray();
                          if (blueArray.length > 0 && blueArray.length % 2 === 0 && HINTING_ENABLED) {
                            program.properties.privateData[token] = blueArray;
                          }
                          break;
                        case "StemSnapH":
                        case "StemSnapV":
                          program.properties.privateData[token] = this.readNumberArray();
                          break;
                        case "StdHW":
                        case "StdVW":
                          program.properties.privateData[token] = this.readNumberArray()[0];
                          break;
                        case "BlueShift":
                        case "lenIV":
                        case "BlueFuzz":
                        case "BlueScale":
                        case "LanguageGroup":
                        case "ExpansionFactor":
                          program.properties.privateData[token] = this.readNumber();
                          break;
                        case "ForceBold":
                          program.properties.privateData[token] = this.readBoolean();
                          break;
                      }
                    }
                    for (var i = 0; i < charstrings.length; i++) {
                      glyph = charstrings[i].glyph;
                      encoded = charstrings[i].encoded;
                      var charString = new Type1CharString();
                      var error = charString.convert(encoded, subrs, this.seacAnalysisEnabled);
                      var output = charString.output;
                      if (error) {
                        output = [14];
                      }
                      const charStringObject = { glyphName: glyph, charstring: output, width: charString.width, lsb: charString.lsb, seac: charString.seac };
                      if (glyph === ".notdef") {
                        program.charstrings.unshift(charStringObject);
                      } else {
                        program.charstrings.push(charStringObject);
                      }
                      if (properties.builtInEncoding) {
                        const index2 = properties.builtInEncoding.indexOf(glyph);
                        if (index2 > -1 && properties.widths[index2] === void 0 && index2 >= properties.firstChar && index2 <= properties.lastChar) {
                          properties.widths[index2] = charString.width;
                        }
                      }
                    }
                    return program;
                  }, extractFontHeader: function Type1Parser_extractFontHeader(properties) {
                    var token;
                    while ((token = this.getToken()) !== null) {
                      if (token !== "/") {
                        continue;
                      }
                      token = this.getToken();
                      switch (token) {
                        case "FontMatrix":
                          var matrix = this.readNumberArray();
                          properties.fontMatrix = matrix;
                          break;
                        case "Encoding":
                          var encodingArg = this.getToken();
                          var encoding;
                          if (!/^\d+$/.test(encodingArg)) {
                            encoding = (0, _encodings.getEncoding)(encodingArg);
                          } else {
                            encoding = [];
                            var size = parseInt(encodingArg, 10) | 0;
                            this.getToken();
                            for (var j = 0; j < size; j++) {
                              token = this.getToken();
                              while (token !== "dup" && token !== "def") {
                                token = this.getToken();
                                if (token === null) {
                                  return;
                                }
                              }
                              if (token === "def") {
                                break;
                              }
                              var index = this.readInt();
                              this.getToken();
                              var glyph = this.getToken();
                              encoding[index] = glyph;
                              this.getToken();
                            }
                          }
                          properties.builtInEncoding = encoding;
                          break;
                        case "FontBBox":
                          var fontBBox = this.readNumberArray();
                          properties.ascent = Math.max(fontBBox[3], fontBBox[1]);
                          properties.descent = Math.min(fontBBox[1], fontBBox[3]);
                          properties.ascentScaled = true;
                          break;
                      }
                    }
                  } };
                  return Type1Parser2;
                }();
                exports2.Type1Parser = Type1Parser;
              }, function(module3, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.getTilingPatternIR = getTilingPatternIR;
                exports2.Pattern = void 0;
                var _util2 = __w_pdfjs_require__2(2);
                var _colorspace = __w_pdfjs_require__2(22);
                var _primitives = __w_pdfjs_require__2(4);
                var _core_utils = __w_pdfjs_require__2(7);
                var ShadingType = { FUNCTION_BASED: 1, AXIAL: 2, RADIAL: 3, FREE_FORM_MESH: 4, LATTICE_FORM_MESH: 5, COONS_PATCH_MESH: 6, TENSOR_PATCH_MESH: 7 };
                var Pattern = function PatternClosure() {
                  function Pattern2() {
                    (0, _util2.unreachable)("should not call Pattern constructor");
                  }
                  Pattern2.prototype = { getPattern: function Pattern_getPattern(ctx) {
                    (0, _util2.unreachable)(`Should not call Pattern.getStyle: ${ctx}`);
                  } };
                  Pattern2.parseShading = function(shading, matrix, xref, res, handler, pdfFunctionFactory) {
                    var dict = (0, _primitives.isStream)(shading) ? shading.dict : shading;
                    var type = dict.get("ShadingType");
                    try {
                      switch (type) {
                        case ShadingType.AXIAL:
                        case ShadingType.RADIAL:
                          return new Shadings.RadialAxial(dict, matrix, xref, res, pdfFunctionFactory);
                        case ShadingType.FREE_FORM_MESH:
                        case ShadingType.LATTICE_FORM_MESH:
                        case ShadingType.COONS_PATCH_MESH:
                        case ShadingType.TENSOR_PATCH_MESH:
                          return new Shadings.Mesh(shading, matrix, xref, res, pdfFunctionFactory);
                        default:
                          throw new _util2.FormatError("Unsupported ShadingType: " + type);
                      }
                    } catch (ex) {
                      if (ex instanceof _core_utils.MissingDataException) {
                        throw ex;
                      }
                      handler.send("UnsupportedFeature", { featureId: _util2.UNSUPPORTED_FEATURES.shadingPattern });
                      (0, _util2.warn)(ex);
                      return new Shadings.Dummy();
                    }
                  };
                  return Pattern2;
                }();
                exports2.Pattern = Pattern;
                var Shadings = {};
                Shadings.SMALL_NUMBER = 1e-6;
                Shadings.RadialAxial = function RadialAxialClosure() {
                  function RadialAxial(dict, matrix, xref, res, pdfFunctionFactory) {
                    this.matrix = matrix;
                    this.coordsArr = dict.getArray("Coords");
                    this.shadingType = dict.get("ShadingType");
                    this.type = "Pattern";
                    var cs = dict.get("ColorSpace", "CS");
                    cs = _colorspace.ColorSpace.parse(cs, xref, res, pdfFunctionFactory);
                    this.cs = cs;
                    const bbox = dict.getArray("BBox");
                    if (Array.isArray(bbox) && bbox.length === 4) {
                      this.bbox = _util2.Util.normalizeRect(bbox);
                    } else {
                      this.bbox = null;
                    }
                    var t0 = 0, t1 = 1;
                    if (dict.has("Domain")) {
                      var domainArr = dict.getArray("Domain");
                      t0 = domainArr[0];
                      t1 = domainArr[1];
                    }
                    var extendStart = false, extendEnd = false;
                    if (dict.has("Extend")) {
                      var extendArr = dict.getArray("Extend");
                      extendStart = extendArr[0];
                      extendEnd = extendArr[1];
                    }
                    if (this.shadingType === ShadingType.RADIAL && (!extendStart || !extendEnd)) {
                      var x1 = this.coordsArr[0];
                      var y1 = this.coordsArr[1];
                      var r1 = this.coordsArr[2];
                      var x2 = this.coordsArr[3];
                      var y2 = this.coordsArr[4];
                      var r2 = this.coordsArr[5];
                      var distance = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
                      if (r1 <= r2 + distance && r2 <= r1 + distance) {
                        (0, _util2.warn)("Unsupported radial gradient.");
                      }
                    }
                    this.extendStart = extendStart;
                    this.extendEnd = extendEnd;
                    var fnObj = dict.get("Function");
                    var fn = pdfFunctionFactory.createFromArray(fnObj);
                    const NUMBER_OF_SAMPLES = 10;
                    const step = (t1 - t0) / NUMBER_OF_SAMPLES;
                    var colorStops = this.colorStops = [];
                    if (t0 >= t1 || step <= 0) {
                      (0, _util2.info)("Bad shading domain.");
                      return;
                    }
                    var color = new Float32Array(cs.numComps), ratio = new Float32Array(1);
                    var rgbColor;
                    for (let i = 0; i <= NUMBER_OF_SAMPLES; i++) {
                      ratio[0] = t0 + i * step;
                      fn(ratio, 0, color, 0);
                      rgbColor = cs.getRgb(color, 0);
                      var cssColor = _util2.Util.makeCssRgb(rgbColor[0], rgbColor[1], rgbColor[2]);
                      colorStops.push([i / NUMBER_OF_SAMPLES, cssColor]);
                    }
                    var background = "transparent";
                    if (dict.has("Background")) {
                      rgbColor = cs.getRgb(dict.get("Background"), 0);
                      background = _util2.Util.makeCssRgb(rgbColor[0], rgbColor[1], rgbColor[2]);
                    }
                    if (!extendStart) {
                      colorStops.unshift([0, background]);
                      colorStops[1][0] += Shadings.SMALL_NUMBER;
                    }
                    if (!extendEnd) {
                      colorStops[colorStops.length - 1][0] -= Shadings.SMALL_NUMBER;
                      colorStops.push([1, background]);
                    }
                    this.colorStops = colorStops;
                  }
                  RadialAxial.prototype = { getIR: function RadialAxial_getIR() {
                    var coordsArr = this.coordsArr;
                    var shadingType = this.shadingType;
                    var type, p0, p1, r0, r1;
                    if (shadingType === ShadingType.AXIAL) {
                      p0 = [coordsArr[0], coordsArr[1]];
                      p1 = [coordsArr[2], coordsArr[3]];
                      r0 = null;
                      r1 = null;
                      type = "axial";
                    } else if (shadingType === ShadingType.RADIAL) {
                      p0 = [coordsArr[0], coordsArr[1]];
                      p1 = [coordsArr[3], coordsArr[4]];
                      r0 = coordsArr[2];
                      r1 = coordsArr[5];
                      type = "radial";
                    } else {
                      (0, _util2.unreachable)(`getPattern type unknown: ${shadingType}`);
                    }
                    var matrix = this.matrix;
                    if (matrix) {
                      p0 = _util2.Util.applyTransform(p0, matrix);
                      p1 = _util2.Util.applyTransform(p1, matrix);
                      if (shadingType === ShadingType.RADIAL) {
                        var scale = _util2.Util.singularValueDecompose2dScale(matrix);
                        r0 *= scale[0];
                        r1 *= scale[1];
                      }
                    }
                    return ["RadialAxial", type, this.bbox, this.colorStops, p0, p1, r0, r1];
                  } };
                  return RadialAxial;
                }();
                Shadings.Mesh = function MeshClosure() {
                  function MeshStreamReader(stream, context) {
                    this.stream = stream;
                    this.context = context;
                    this.buffer = 0;
                    this.bufferLength = 0;
                    var numComps = context.numComps;
                    this.tmpCompsBuf = new Float32Array(numComps);
                    var csNumComps = context.colorSpace.numComps;
                    this.tmpCsCompsBuf = context.colorFn ? new Float32Array(csNumComps) : this.tmpCompsBuf;
                  }
                  MeshStreamReader.prototype = { get hasData() {
                    if (this.stream.end) {
                      return this.stream.pos < this.stream.end;
                    }
                    if (this.bufferLength > 0) {
                      return true;
                    }
                    var nextByte = this.stream.getByte();
                    if (nextByte < 0) {
                      return false;
                    }
                    this.buffer = nextByte;
                    this.bufferLength = 8;
                    return true;
                  }, readBits: function MeshStreamReader_readBits(n) {
                    var buffer = this.buffer;
                    var bufferLength = this.bufferLength;
                    if (n === 32) {
                      if (bufferLength === 0) {
                        return (this.stream.getByte() << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte()) >>> 0;
                      }
                      buffer = buffer << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte();
                      var nextByte = this.stream.getByte();
                      this.buffer = nextByte & (1 << bufferLength) - 1;
                      return (buffer << 8 - bufferLength | (nextByte & 255) >> bufferLength) >>> 0;
                    }
                    if (n === 8 && bufferLength === 0) {
                      return this.stream.getByte();
                    }
                    while (bufferLength < n) {
                      buffer = buffer << 8 | this.stream.getByte();
                      bufferLength += 8;
                    }
                    bufferLength -= n;
                    this.bufferLength = bufferLength;
                    this.buffer = buffer & (1 << bufferLength) - 1;
                    return buffer >> bufferLength;
                  }, align: function MeshStreamReader_align() {
                    this.buffer = 0;
                    this.bufferLength = 0;
                  }, readFlag: function MeshStreamReader_readFlag() {
                    return this.readBits(this.context.bitsPerFlag);
                  }, readCoordinate: function MeshStreamReader_readCoordinate() {
                    var bitsPerCoordinate = this.context.bitsPerCoordinate;
                    var xi = this.readBits(bitsPerCoordinate);
                    var yi = this.readBits(bitsPerCoordinate);
                    var decode = this.context.decode;
                    var scale = bitsPerCoordinate < 32 ? 1 / ((1 << bitsPerCoordinate) - 1) : 23283064365386963e-26;
                    return [xi * scale * (decode[1] - decode[0]) + decode[0], yi * scale * (decode[3] - decode[2]) + decode[2]];
                  }, readComponents: function MeshStreamReader_readComponents() {
                    var numComps = this.context.numComps;
                    var bitsPerComponent = this.context.bitsPerComponent;
                    var scale = bitsPerComponent < 32 ? 1 / ((1 << bitsPerComponent) - 1) : 23283064365386963e-26;
                    var decode = this.context.decode;
                    var components = this.tmpCompsBuf;
                    for (var i = 0, j = 4; i < numComps; i++, j += 2) {
                      var ci = this.readBits(bitsPerComponent);
                      components[i] = ci * scale * (decode[j + 1] - decode[j]) + decode[j];
                    }
                    var color = this.tmpCsCompsBuf;
                    if (this.context.colorFn) {
                      this.context.colorFn(components, 0, color, 0);
                    }
                    return this.context.colorSpace.getRgb(color, 0);
                  } };
                  function decodeType4Shading(mesh, reader) {
                    var coords = mesh.coords;
                    var colors = mesh.colors;
                    var operators = [];
                    var ps = [];
                    var verticesLeft = 0;
                    while (reader.hasData) {
                      var f = reader.readFlag();
                      var coord = reader.readCoordinate();
                      var color = reader.readComponents();
                      if (verticesLeft === 0) {
                        if (!(0 <= f && f <= 2)) {
                          throw new _util2.FormatError("Unknown type4 flag");
                        }
                        switch (f) {
                          case 0:
                            verticesLeft = 3;
                            break;
                          case 1:
                            ps.push(ps[ps.length - 2], ps[ps.length - 1]);
                            verticesLeft = 1;
                            break;
                          case 2:
                            ps.push(ps[ps.length - 3], ps[ps.length - 1]);
                            verticesLeft = 1;
                            break;
                        }
                        operators.push(f);
                      }
                      ps.push(coords.length);
                      coords.push(coord);
                      colors.push(color);
                      verticesLeft--;
                      reader.align();
                    }
                    mesh.figures.push({ type: "triangles", coords: new Int32Array(ps), colors: new Int32Array(ps) });
                  }
                  function decodeType5Shading(mesh, reader, verticesPerRow) {
                    var coords = mesh.coords;
                    var colors = mesh.colors;
                    var ps = [];
                    while (reader.hasData) {
                      var coord = reader.readCoordinate();
                      var color = reader.readComponents();
                      ps.push(coords.length);
                      coords.push(coord);
                      colors.push(color);
                    }
                    mesh.figures.push({ type: "lattice", coords: new Int32Array(ps), colors: new Int32Array(ps), verticesPerRow });
                  }
                  var MIN_SPLIT_PATCH_CHUNKS_AMOUNT = 3;
                  var MAX_SPLIT_PATCH_CHUNKS_AMOUNT = 20;
                  var TRIANGLE_DENSITY = 20;
                  var getB = function getBClosure() {
                    function buildB(count) {
                      var lut = [];
                      for (var i = 0; i <= count; i++) {
                        var t = i / count, t_ = 1 - t;
                        lut.push(new Float32Array([t_ * t_ * t_, 3 * t * t_ * t_, 3 * t * t * t_, t * t * t]));
                      }
                      return lut;
                    }
                    var cache = [];
                    return function getB2(count) {
                      if (!cache[count]) {
                        cache[count] = buildB(count);
                      }
                      return cache[count];
                    };
                  }();
                  function buildFigureFromPatch(mesh, index) {
                    var figure = mesh.figures[index];
                    (0, _util2.assert)(figure.type === "patch", "Unexpected patch mesh figure");
                    var coords = mesh.coords, colors = mesh.colors;
                    var pi = figure.coords;
                    var ci = figure.colors;
                    var figureMinX = Math.min(coords[pi[0]][0], coords[pi[3]][0], coords[pi[12]][0], coords[pi[15]][0]);
                    var figureMinY = Math.min(coords[pi[0]][1], coords[pi[3]][1], coords[pi[12]][1], coords[pi[15]][1]);
                    var figureMaxX = Math.max(coords[pi[0]][0], coords[pi[3]][0], coords[pi[12]][0], coords[pi[15]][0]);
                    var figureMaxY = Math.max(coords[pi[0]][1], coords[pi[3]][1], coords[pi[12]][1], coords[pi[15]][1]);
                    var splitXBy = Math.ceil((figureMaxX - figureMinX) * TRIANGLE_DENSITY / (mesh.bounds[2] - mesh.bounds[0]));
                    splitXBy = Math.max(MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(MAX_SPLIT_PATCH_CHUNKS_AMOUNT, splitXBy));
                    var splitYBy = Math.ceil((figureMaxY - figureMinY) * TRIANGLE_DENSITY / (mesh.bounds[3] - mesh.bounds[1]));
                    splitYBy = Math.max(MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(MAX_SPLIT_PATCH_CHUNKS_AMOUNT, splitYBy));
                    var verticesPerRow = splitXBy + 1;
                    var figureCoords = new Int32Array((splitYBy + 1) * verticesPerRow);
                    var figureColors = new Int32Array((splitYBy + 1) * verticesPerRow);
                    var k = 0;
                    var cl = new Uint8Array(3), cr = new Uint8Array(3);
                    var c0 = colors[ci[0]], c1 = colors[ci[1]], c2 = colors[ci[2]], c3 = colors[ci[3]];
                    var bRow = getB(splitYBy), bCol = getB(splitXBy);
                    for (var row = 0; row <= splitYBy; row++) {
                      cl[0] = (c0[0] * (splitYBy - row) + c2[0] * row) / splitYBy | 0;
                      cl[1] = (c0[1] * (splitYBy - row) + c2[1] * row) / splitYBy | 0;
                      cl[2] = (c0[2] * (splitYBy - row) + c2[2] * row) / splitYBy | 0;
                      cr[0] = (c1[0] * (splitYBy - row) + c3[0] * row) / splitYBy | 0;
                      cr[1] = (c1[1] * (splitYBy - row) + c3[1] * row) / splitYBy | 0;
                      cr[2] = (c1[2] * (splitYBy - row) + c3[2] * row) / splitYBy | 0;
                      for (var col = 0; col <= splitXBy; col++, k++) {
                        if ((row === 0 || row === splitYBy) && (col === 0 || col === splitXBy)) {
                          continue;
                        }
                        var x = 0, y = 0;
                        var q = 0;
                        for (var i = 0; i <= 3; i++) {
                          for (var j = 0; j <= 3; j++, q++) {
                            var m = bRow[row][i] * bCol[col][j];
                            x += coords[pi[q]][0] * m;
                            y += coords[pi[q]][1] * m;
                          }
                        }
                        figureCoords[k] = coords.length;
                        coords.push([x, y]);
                        figureColors[k] = colors.length;
                        var newColor = new Uint8Array(3);
                        newColor[0] = (cl[0] * (splitXBy - col) + cr[0] * col) / splitXBy | 0;
                        newColor[1] = (cl[1] * (splitXBy - col) + cr[1] * col) / splitXBy | 0;
                        newColor[2] = (cl[2] * (splitXBy - col) + cr[2] * col) / splitXBy | 0;
                        colors.push(newColor);
                      }
                    }
                    figureCoords[0] = pi[0];
                    figureColors[0] = ci[0];
                    figureCoords[splitXBy] = pi[3];
                    figureColors[splitXBy] = ci[1];
                    figureCoords[verticesPerRow * splitYBy] = pi[12];
                    figureColors[verticesPerRow * splitYBy] = ci[2];
                    figureCoords[verticesPerRow * splitYBy + splitXBy] = pi[15];
                    figureColors[verticesPerRow * splitYBy + splitXBy] = ci[3];
                    mesh.figures[index] = { type: "lattice", coords: figureCoords, colors: figureColors, verticesPerRow };
                  }
                  function decodeType6Shading(mesh, reader) {
                    var coords = mesh.coords;
                    var colors = mesh.colors;
                    var ps = new Int32Array(16);
                    var cs = new Int32Array(4);
                    while (reader.hasData) {
                      var f = reader.readFlag();
                      if (!(0 <= f && f <= 3)) {
                        throw new _util2.FormatError("Unknown type6 flag");
                      }
                      var i, ii;
                      var pi = coords.length;
                      for (i = 0, ii = f !== 0 ? 8 : 12; i < ii; i++) {
                        coords.push(reader.readCoordinate());
                      }
                      var ci = colors.length;
                      for (i = 0, ii = f !== 0 ? 2 : 4; i < ii; i++) {
                        colors.push(reader.readComponents());
                      }
                      var tmp1, tmp2, tmp3, tmp4;
                      switch (f) {
                        case 0:
                          ps[12] = pi + 3;
                          ps[13] = pi + 4;
                          ps[14] = pi + 5;
                          ps[15] = pi + 6;
                          ps[8] = pi + 2;
                          ps[11] = pi + 7;
                          ps[4] = pi + 1;
                          ps[7] = pi + 8;
                          ps[0] = pi;
                          ps[1] = pi + 11;
                          ps[2] = pi + 10;
                          ps[3] = pi + 9;
                          cs[2] = ci + 1;
                          cs[3] = ci + 2;
                          cs[0] = ci;
                          cs[1] = ci + 3;
                          break;
                        case 1:
                          tmp1 = ps[12];
                          tmp2 = ps[13];
                          tmp3 = ps[14];
                          tmp4 = ps[15];
                          ps[12] = tmp4;
                          ps[13] = pi + 0;
                          ps[14] = pi + 1;
                          ps[15] = pi + 2;
                          ps[8] = tmp3;
                          ps[11] = pi + 3;
                          ps[4] = tmp2;
                          ps[7] = pi + 4;
                          ps[0] = tmp1;
                          ps[1] = pi + 7;
                          ps[2] = pi + 6;
                          ps[3] = pi + 5;
                          tmp1 = cs[2];
                          tmp2 = cs[3];
                          cs[2] = tmp2;
                          cs[3] = ci;
                          cs[0] = tmp1;
                          cs[1] = ci + 1;
                          break;
                        case 2:
                          tmp1 = ps[15];
                          tmp2 = ps[11];
                          ps[12] = ps[3];
                          ps[13] = pi + 0;
                          ps[14] = pi + 1;
                          ps[15] = pi + 2;
                          ps[8] = ps[7];
                          ps[11] = pi + 3;
                          ps[4] = tmp2;
                          ps[7] = pi + 4;
                          ps[0] = tmp1;
                          ps[1] = pi + 7;
                          ps[2] = pi + 6;
                          ps[3] = pi + 5;
                          tmp1 = cs[3];
                          cs[2] = cs[1];
                          cs[3] = ci;
                          cs[0] = tmp1;
                          cs[1] = ci + 1;
                          break;
                        case 3:
                          ps[12] = ps[0];
                          ps[13] = pi + 0;
                          ps[14] = pi + 1;
                          ps[15] = pi + 2;
                          ps[8] = ps[1];
                          ps[11] = pi + 3;
                          ps[4] = ps[2];
                          ps[7] = pi + 4;
                          ps[0] = ps[3];
                          ps[1] = pi + 7;
                          ps[2] = pi + 6;
                          ps[3] = pi + 5;
                          cs[2] = cs[0];
                          cs[3] = ci;
                          cs[0] = cs[1];
                          cs[1] = ci + 1;
                          break;
                      }
                      ps[5] = coords.length;
                      coords.push([(-4 * coords[ps[0]][0] - coords[ps[15]][0] + 6 * (coords[ps[4]][0] + coords[ps[1]][0]) - 2 * (coords[ps[12]][0] + coords[ps[3]][0]) + 3 * (coords[ps[13]][0] + coords[ps[7]][0])) / 9, (-4 * coords[ps[0]][1] - coords[ps[15]][1] + 6 * (coords[ps[4]][1] + coords[ps[1]][1]) - 2 * (coords[ps[12]][1] + coords[ps[3]][1]) + 3 * (coords[ps[13]][1] + coords[ps[7]][1])) / 9]);
                      ps[6] = coords.length;
                      coords.push([(-4 * coords[ps[3]][0] - coords[ps[12]][0] + 6 * (coords[ps[2]][0] + coords[ps[7]][0]) - 2 * (coords[ps[0]][0] + coords[ps[15]][0]) + 3 * (coords[ps[4]][0] + coords[ps[14]][0])) / 9, (-4 * coords[ps[3]][1] - coords[ps[12]][1] + 6 * (coords[ps[2]][1] + coords[ps[7]][1]) - 2 * (coords[ps[0]][1] + coords[ps[15]][1]) + 3 * (coords[ps[4]][1] + coords[ps[14]][1])) / 9]);
                      ps[9] = coords.length;
                      coords.push([(-4 * coords[ps[12]][0] - coords[ps[3]][0] + 6 * (coords[ps[8]][0] + coords[ps[13]][0]) - 2 * (coords[ps[0]][0] + coords[ps[15]][0]) + 3 * (coords[ps[11]][0] + coords[ps[1]][0])) / 9, (-4 * coords[ps[12]][1] - coords[ps[3]][1] + 6 * (coords[ps[8]][1] + coords[ps[13]][1]) - 2 * (coords[ps[0]][1] + coords[ps[15]][1]) + 3 * (coords[ps[11]][1] + coords[ps[1]][1])) / 9]);
                      ps[10] = coords.length;
                      coords.push([(-4 * coords[ps[15]][0] - coords[ps[0]][0] + 6 * (coords[ps[11]][0] + coords[ps[14]][0]) - 2 * (coords[ps[12]][0] + coords[ps[3]][0]) + 3 * (coords[ps[2]][0] + coords[ps[8]][0])) / 9, (-4 * coords[ps[15]][1] - coords[ps[0]][1] + 6 * (coords[ps[11]][1] + coords[ps[14]][1]) - 2 * (coords[ps[12]][1] + coords[ps[3]][1]) + 3 * (coords[ps[2]][1] + coords[ps[8]][1])) / 9]);
                      mesh.figures.push({ type: "patch", coords: new Int32Array(ps), colors: new Int32Array(cs) });
                    }
                  }
                  function decodeType7Shading(mesh, reader) {
                    var coords = mesh.coords;
                    var colors = mesh.colors;
                    var ps = new Int32Array(16);
                    var cs = new Int32Array(4);
                    while (reader.hasData) {
                      var f = reader.readFlag();
                      if (!(0 <= f && f <= 3)) {
                        throw new _util2.FormatError("Unknown type7 flag");
                      }
                      var i, ii;
                      var pi = coords.length;
                      for (i = 0, ii = f !== 0 ? 12 : 16; i < ii; i++) {
                        coords.push(reader.readCoordinate());
                      }
                      var ci = colors.length;
                      for (i = 0, ii = f !== 0 ? 2 : 4; i < ii; i++) {
                        colors.push(reader.readComponents());
                      }
                      var tmp1, tmp2, tmp3, tmp4;
                      switch (f) {
                        case 0:
                          ps[12] = pi + 3;
                          ps[13] = pi + 4;
                          ps[14] = pi + 5;
                          ps[15] = pi + 6;
                          ps[8] = pi + 2;
                          ps[9] = pi + 13;
                          ps[10] = pi + 14;
                          ps[11] = pi + 7;
                          ps[4] = pi + 1;
                          ps[5] = pi + 12;
                          ps[6] = pi + 15;
                          ps[7] = pi + 8;
                          ps[0] = pi;
                          ps[1] = pi + 11;
                          ps[2] = pi + 10;
                          ps[3] = pi + 9;
                          cs[2] = ci + 1;
                          cs[3] = ci + 2;
                          cs[0] = ci;
                          cs[1] = ci + 3;
                          break;
                        case 1:
                          tmp1 = ps[12];
                          tmp2 = ps[13];
                          tmp3 = ps[14];
                          tmp4 = ps[15];
                          ps[12] = tmp4;
                          ps[13] = pi + 0;
                          ps[14] = pi + 1;
                          ps[15] = pi + 2;
                          ps[8] = tmp3;
                          ps[9] = pi + 9;
                          ps[10] = pi + 10;
                          ps[11] = pi + 3;
                          ps[4] = tmp2;
                          ps[5] = pi + 8;
                          ps[6] = pi + 11;
                          ps[7] = pi + 4;
                          ps[0] = tmp1;
                          ps[1] = pi + 7;
                          ps[2] = pi + 6;
                          ps[3] = pi + 5;
                          tmp1 = cs[2];
                          tmp2 = cs[3];
                          cs[2] = tmp2;
                          cs[3] = ci;
                          cs[0] = tmp1;
                          cs[1] = ci + 1;
                          break;
                        case 2:
                          tmp1 = ps[15];
                          tmp2 = ps[11];
                          ps[12] = ps[3];
                          ps[13] = pi + 0;
                          ps[14] = pi + 1;
                          ps[15] = pi + 2;
                          ps[8] = ps[7];
                          ps[9] = pi + 9;
                          ps[10] = pi + 10;
                          ps[11] = pi + 3;
                          ps[4] = tmp2;
                          ps[5] = pi + 8;
                          ps[6] = pi + 11;
                          ps[7] = pi + 4;
                          ps[0] = tmp1;
                          ps[1] = pi + 7;
                          ps[2] = pi + 6;
                          ps[3] = pi + 5;
                          tmp1 = cs[3];
                          cs[2] = cs[1];
                          cs[3] = ci;
                          cs[0] = tmp1;
                          cs[1] = ci + 1;
                          break;
                        case 3:
                          ps[12] = ps[0];
                          ps[13] = pi + 0;
                          ps[14] = pi + 1;
                          ps[15] = pi + 2;
                          ps[8] = ps[1];
                          ps[9] = pi + 9;
                          ps[10] = pi + 10;
                          ps[11] = pi + 3;
                          ps[4] = ps[2];
                          ps[5] = pi + 8;
                          ps[6] = pi + 11;
                          ps[7] = pi + 4;
                          ps[0] = ps[3];
                          ps[1] = pi + 7;
                          ps[2] = pi + 6;
                          ps[3] = pi + 5;
                          cs[2] = cs[0];
                          cs[3] = ci;
                          cs[0] = cs[1];
                          cs[1] = ci + 1;
                          break;
                      }
                      mesh.figures.push({ type: "patch", coords: new Int32Array(ps), colors: new Int32Array(cs) });
                    }
                  }
                  function updateBounds(mesh) {
                    var minX = mesh.coords[0][0], minY = mesh.coords[0][1], maxX = minX, maxY = minY;
                    for (var i = 1, ii = mesh.coords.length; i < ii; i++) {
                      var x = mesh.coords[i][0], y = mesh.coords[i][1];
                      minX = minX > x ? x : minX;
                      minY = minY > y ? y : minY;
                      maxX = maxX < x ? x : maxX;
                      maxY = maxY < y ? y : maxY;
                    }
                    mesh.bounds = [minX, minY, maxX, maxY];
                  }
                  function packData(mesh) {
                    var i, ii, j, jj;
                    var coords = mesh.coords;
                    var coordsPacked = new Float32Array(coords.length * 2);
                    for (i = 0, j = 0, ii = coords.length; i < ii; i++) {
                      var xy = coords[i];
                      coordsPacked[j++] = xy[0];
                      coordsPacked[j++] = xy[1];
                    }
                    mesh.coords = coordsPacked;
                    var colors = mesh.colors;
                    var colorsPacked = new Uint8Array(colors.length * 3);
                    for (i = 0, j = 0, ii = colors.length; i < ii; i++) {
                      var c = colors[i];
                      colorsPacked[j++] = c[0];
                      colorsPacked[j++] = c[1];
                      colorsPacked[j++] = c[2];
                    }
                    mesh.colors = colorsPacked;
                    var figures = mesh.figures;
                    for (i = 0, ii = figures.length; i < ii; i++) {
                      var figure = figures[i], ps = figure.coords, cs = figure.colors;
                      for (j = 0, jj = ps.length; j < jj; j++) {
                        ps[j] *= 2;
                        cs[j] *= 3;
                      }
                    }
                  }
                  function Mesh(stream, matrix, xref, res, pdfFunctionFactory) {
                    if (!(0, _primitives.isStream)(stream)) {
                      throw new _util2.FormatError("Mesh data is not a stream");
                    }
                    var dict = stream.dict;
                    this.matrix = matrix;
                    this.shadingType = dict.get("ShadingType");
                    this.type = "Pattern";
                    const bbox = dict.getArray("BBox");
                    if (Array.isArray(bbox) && bbox.length === 4) {
                      this.bbox = _util2.Util.normalizeRect(bbox);
                    } else {
                      this.bbox = null;
                    }
                    var cs = dict.get("ColorSpace", "CS");
                    cs = _colorspace.ColorSpace.parse(cs, xref, res, pdfFunctionFactory);
                    this.cs = cs;
                    this.background = dict.has("Background") ? cs.getRgb(dict.get("Background"), 0) : null;
                    var fnObj = dict.get("Function");
                    var fn = fnObj ? pdfFunctionFactory.createFromArray(fnObj) : null;
                    this.coords = [];
                    this.colors = [];
                    this.figures = [];
                    var decodeContext = { bitsPerCoordinate: dict.get("BitsPerCoordinate"), bitsPerComponent: dict.get("BitsPerComponent"), bitsPerFlag: dict.get("BitsPerFlag"), decode: dict.getArray("Decode"), colorFn: fn, colorSpace: cs, numComps: fn ? 1 : cs.numComps };
                    var reader = new MeshStreamReader(stream, decodeContext);
                    var patchMesh = false;
                    switch (this.shadingType) {
                      case ShadingType.FREE_FORM_MESH:
                        decodeType4Shading(this, reader);
                        break;
                      case ShadingType.LATTICE_FORM_MESH:
                        var verticesPerRow = dict.get("VerticesPerRow") | 0;
                        if (verticesPerRow < 2) {
                          throw new _util2.FormatError("Invalid VerticesPerRow");
                        }
                        decodeType5Shading(this, reader, verticesPerRow);
                        break;
                      case ShadingType.COONS_PATCH_MESH:
                        decodeType6Shading(this, reader);
                        patchMesh = true;
                        break;
                      case ShadingType.TENSOR_PATCH_MESH:
                        decodeType7Shading(this, reader);
                        patchMesh = true;
                        break;
                      default:
                        (0, _util2.unreachable)("Unsupported mesh type.");
                        break;
                    }
                    if (patchMesh) {
                      updateBounds(this);
                      for (var i = 0, ii = this.figures.length; i < ii; i++) {
                        buildFigureFromPatch(this, i);
                      }
                    }
                    updateBounds(this);
                    packData(this);
                  }
                  Mesh.prototype = { getIR: function Mesh_getIR() {
                    return ["Mesh", this.shadingType, this.coords, this.colors, this.figures, this.bounds, this.matrix, this.bbox, this.background];
                  } };
                  return Mesh;
                }();
                Shadings.Dummy = function DummyClosure() {
                  function Dummy() {
                    this.type = "Pattern";
                  }
                  Dummy.prototype = { getIR: function Dummy_getIR() {
                    return ["Dummy"];
                  } };
                  return Dummy;
                }();
                function getTilingPatternIR(operatorList, dict, args) {
                  const matrix = dict.getArray("Matrix");
                  const bbox = _util2.Util.normalizeRect(dict.getArray("BBox"));
                  const xstep = dict.get("XStep");
                  const ystep = dict.get("YStep");
                  const paintType = dict.get("PaintType");
                  const tilingType = dict.get("TilingType");
                  if (bbox[2] - bbox[0] === 0 || bbox[3] - bbox[1] === 0) {
                    throw new _util2.FormatError(`Invalid getTilingPatternIR /BBox array: [${bbox}].`);
                  }
                  return ["TilingPattern", args, operatorList, matrix, bbox, xstep, ystep, paintType, tilingType];
                }
              }, function(module3, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.bidi = bidi;
                var _util2 = __w_pdfjs_require__2(2);
                var baseTypes = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "ON", "ON", "ET", "ET", "ET", "ON", "ON", "ON", "ON", "ON", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "ON", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "ON", "ON", "ON", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "ON", "ET", "ET", "ET", "ET", "ON", "ON", "ON", "ON", "L", "ON", "ON", "BN", "ON", "ON", "ET", "ET", "EN", "EN", "ON", "L", "ON", "ON", "ON", "EN", "L", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "L", "L", "L", "L", "L", "L", "L", "L"];
                var arabicTypes = ["AN", "AN", "AN", "AN", "AN", "AN", "ON", "ON", "AL", "ET", "ET", "AL", "CS", "AL", "ON", "ON", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "ON", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "ON", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL"];
                function isOdd(i) {
                  return (i & 1) !== 0;
                }
                function isEven(i) {
                  return (i & 1) === 0;
                }
                function findUnequal(arr, start, value) {
                  for (var j = start, jj = arr.length; j < jj; ++j) {
                    if (arr[j] !== value) {
                      return j;
                    }
                  }
                  return j;
                }
                function setValues(arr, start, end, value) {
                  for (var j = start; j < end; ++j) {
                    arr[j] = value;
                  }
                }
                function reverseValues(arr, start, end) {
                  for (var i = start, j = end - 1; i < j; ++i, --j) {
                    var temp = arr[i];
                    arr[i] = arr[j];
                    arr[j] = temp;
                  }
                }
                function createBidiText(str, isLTR, vertical = false) {
                  let dir = "ltr";
                  if (vertical) {
                    dir = "ttb";
                  } else if (!isLTR) {
                    dir = "rtl";
                  }
                  return { str, dir };
                }
                var chars = [];
                var types = [];
                function bidi(str, startLevel, vertical) {
                  var isLTR = true;
                  var strLength = str.length;
                  if (strLength === 0 || vertical) {
                    return createBidiText(str, isLTR, vertical);
                  }
                  chars.length = strLength;
                  types.length = strLength;
                  var numBidi = 0;
                  var i, ii;
                  for (i = 0; i < strLength; ++i) {
                    chars[i] = str.charAt(i);
                    var charCode = str.charCodeAt(i);
                    var charType = "L";
                    if (charCode <= 255) {
                      charType = baseTypes[charCode];
                    } else if (1424 <= charCode && charCode <= 1524) {
                      charType = "R";
                    } else if (1536 <= charCode && charCode <= 1791) {
                      charType = arabicTypes[charCode & 255];
                      if (!charType) {
                        (0, _util2.warn)("Bidi: invalid Unicode character " + charCode.toString(16));
                      }
                    } else if (1792 <= charCode && charCode <= 2220) {
                      charType = "AL";
                    }
                    if (charType === "R" || charType === "AL" || charType === "AN") {
                      numBidi++;
                    }
                    types[i] = charType;
                  }
                  if (numBidi === 0) {
                    isLTR = true;
                    return createBidiText(str, isLTR);
                  }
                  if (startLevel === -1) {
                    if (numBidi / strLength < 0.3) {
                      isLTR = true;
                      startLevel = 0;
                    } else {
                      isLTR = false;
                      startLevel = 1;
                    }
                  }
                  var levels = [];
                  for (i = 0; i < strLength; ++i) {
                    levels[i] = startLevel;
                  }
                  var e = isOdd(startLevel) ? "R" : "L";
                  var sor = e;
                  var eor = sor;
                  var lastType = sor;
                  for (i = 0; i < strLength; ++i) {
                    if (types[i] === "NSM") {
                      types[i] = lastType;
                    } else {
                      lastType = types[i];
                    }
                  }
                  lastType = sor;
                  var t;
                  for (i = 0; i < strLength; ++i) {
                    t = types[i];
                    if (t === "EN") {
                      types[i] = lastType === "AL" ? "AN" : "EN";
                    } else if (t === "R" || t === "L" || t === "AL") {
                      lastType = t;
                    }
                  }
                  for (i = 0; i < strLength; ++i) {
                    t = types[i];
                    if (t === "AL") {
                      types[i] = "R";
                    }
                  }
                  for (i = 1; i < strLength - 1; ++i) {
                    if (types[i] === "ES" && types[i - 1] === "EN" && types[i + 1] === "EN") {
                      types[i] = "EN";
                    }
                    if (types[i] === "CS" && (types[i - 1] === "EN" || types[i - 1] === "AN") && types[i + 1] === types[i - 1]) {
                      types[i] = types[i - 1];
                    }
                  }
                  for (i = 0; i < strLength; ++i) {
                    if (types[i] === "EN") {
                      var j;
                      for (j = i - 1; j >= 0; --j) {
                        if (types[j] !== "ET") {
                          break;
                        }
                        types[j] = "EN";
                      }
                      for (j = i + 1; j < strLength; ++j) {
                        if (types[j] !== "ET") {
                          break;
                        }
                        types[j] = "EN";
                      }
                    }
                  }
                  for (i = 0; i < strLength; ++i) {
                    t = types[i];
                    if (t === "WS" || t === "ES" || t === "ET" || t === "CS") {
                      types[i] = "ON";
                    }
                  }
                  lastType = sor;
                  for (i = 0; i < strLength; ++i) {
                    t = types[i];
                    if (t === "EN") {
                      types[i] = lastType === "L" ? "L" : "EN";
                    } else if (t === "R" || t === "L") {
                      lastType = t;
                    }
                  }
                  for (i = 0; i < strLength; ++i) {
                    if (types[i] === "ON") {
                      var end = findUnequal(types, i + 1, "ON");
                      var before = sor;
                      if (i > 0) {
                        before = types[i - 1];
                      }
                      var after = eor;
                      if (end + 1 < strLength) {
                        after = types[end + 1];
                      }
                      if (before !== "L") {
                        before = "R";
                      }
                      if (after !== "L") {
                        after = "R";
                      }
                      if (before === after) {
                        setValues(types, i, end, before);
                      }
                      i = end - 1;
                    }
                  }
                  for (i = 0; i < strLength; ++i) {
                    if (types[i] === "ON") {
                      types[i] = e;
                    }
                  }
                  for (i = 0; i < strLength; ++i) {
                    t = types[i];
                    if (isEven(levels[i])) {
                      if (t === "R") {
                        levels[i] += 1;
                      } else if (t === "AN" || t === "EN") {
                        levels[i] += 2;
                      }
                    } else {
                      if (t === "L" || t === "AN" || t === "EN") {
                        levels[i] += 1;
                      }
                    }
                  }
                  var highestLevel = -1;
                  var lowestOddLevel = 99;
                  var level;
                  for (i = 0, ii = levels.length; i < ii; ++i) {
                    level = levels[i];
                    if (highestLevel < level) {
                      highestLevel = level;
                    }
                    if (lowestOddLevel > level && isOdd(level)) {
                      lowestOddLevel = level;
                    }
                  }
                  for (level = highestLevel; level >= lowestOddLevel; --level) {
                    var start = -1;
                    for (i = 0, ii = levels.length; i < ii; ++i) {
                      if (levels[i] < level) {
                        if (start >= 0) {
                          reverseValues(chars, start, i);
                          start = -1;
                        }
                      } else if (start < 0) {
                        start = i;
                      }
                    }
                    if (start >= 0) {
                      reverseValues(chars, start, levels.length);
                    }
                  }
                  for (i = 0, ii = chars.length; i < ii; ++i) {
                    var ch = chars[i];
                    if (ch === "<" || ch === ">") {
                      chars[i] = "";
                    }
                  }
                  return createBidiText(chars.join(""), isLTR);
                }
              }, function(module3, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.getMetrics = void 0;
                var _core_utils = __w_pdfjs_require__2(7);
                var getMetrics = (0, _core_utils.getLookupTableFactory)(function(t) {
                  t["Courier"] = 600;
                  t["Courier-Bold"] = 600;
                  t["Courier-BoldOblique"] = 600;
                  t["Courier-Oblique"] = 600;
                  t["Helvetica"] = (0, _core_utils.getLookupTableFactory)(function(t2) {
                    t2["space"] = 278;
                    t2["exclam"] = 278;
                    t2["quotedbl"] = 355;
                    t2["numbersign"] = 556;
                    t2["dollar"] = 556;
                    t2["percent"] = 889;
                    t2["ampersand"] = 667;
                    t2["quoteright"] = 222;
                    t2["parenleft"] = 333;
                    t2["parenright"] = 333;
                    t2["asterisk"] = 389;
                    t2["plus"] = 584;
                    t2["comma"] = 278;
                    t2["hyphen"] = 333;
                    t2["period"] = 278;
                    t2["slash"] = 278;
                    t2["zero"] = 556;
                    t2["one"] = 556;
                    t2["two"] = 556;
                    t2["three"] = 556;
                    t2["four"] = 556;
                    t2["five"] = 556;
                    t2["six"] = 556;
                    t2["seven"] = 556;
                    t2["eight"] = 556;
                    t2["nine"] = 556;
                    t2["colon"] = 278;
                    t2["semicolon"] = 278;
                    t2["less"] = 584;
                    t2["equal"] = 584;
                    t2["greater"] = 584;
                    t2["question"] = 556;
                    t2["at"] = 1015;
                    t2["A"] = 667;
                    t2["B"] = 667;
                    t2["C"] = 722;
                    t2["D"] = 722;
                    t2["E"] = 667;
                    t2["F"] = 611;
                    t2["G"] = 778;
                    t2["H"] = 722;
                    t2["I"] = 278;
                    t2["J"] = 500;
                    t2["K"] = 667;
                    t2["L"] = 556;
                    t2["M"] = 833;
                    t2["N"] = 722;
                    t2["O"] = 778;
                    t2["P"] = 667;
                    t2["Q"] = 778;
                    t2["R"] = 722;
                    t2["S"] = 667;
                    t2["T"] = 611;
                    t2["U"] = 722;
                    t2["V"] = 667;
                    t2["W"] = 944;
                    t2["X"] = 667;
                    t2["Y"] = 667;
                    t2["Z"] = 611;
                    t2["bracketleft"] = 278;
                    t2["backslash"] = 278;
                    t2["bracketright"] = 278;
                    t2["asciicircum"] = 469;
                    t2["underscore"] = 556;
                    t2["quoteleft"] = 222;
                    t2["a"] = 556;
                    t2["b"] = 556;
                    t2["c"] = 500;
                    t2["d"] = 556;
                    t2["e"] = 556;
                    t2["f"] = 278;
                    t2["g"] = 556;
                    t2["h"] = 556;
                    t2["i"] = 222;
                    t2["j"] = 222;
                    t2["k"] = 500;
                    t2["l"] = 222;
                    t2["m"] = 833;
                    t2["n"] = 556;
                    t2["o"] = 556;
                    t2["p"] = 556;
                    t2["q"] = 556;
                    t2["r"] = 333;
                    t2["s"] = 500;
                    t2["t"] = 278;
                    t2["u"] = 556;
                    t2["v"] = 500;
                    t2["w"] = 722;
                    t2["x"] = 500;
                    t2["y"] = 500;
                    t2["z"] = 500;
                    t2["braceleft"] = 334;
                    t2["bar"] = 260;
                    t2["braceright"] = 334;
                    t2["asciitilde"] = 584;
                    t2["exclamdown"] = 333;
                    t2["cent"] = 556;
                    t2["sterling"] = 556;
                    t2["fraction"] = 167;
                    t2["yen"] = 556;
                    t2["florin"] = 556;
                    t2["section"] = 556;
                    t2["currency"] = 556;
                    t2["quotesingle"] = 191;
                    t2["quotedblleft"] = 333;
                    t2["guillemotleft"] = 556;
                    t2["guilsinglleft"] = 333;
                    t2["guilsinglright"] = 333;
                    t2["fi"] = 500;
                    t2["fl"] = 500;
                    t2["endash"] = 556;
                    t2["dagger"] = 556;
                    t2["daggerdbl"] = 556;
                    t2["periodcentered"] = 278;
                    t2["paragraph"] = 537;
                    t2["bullet"] = 350;
                    t2["quotesinglbase"] = 222;
                    t2["quotedblbase"] = 333;
                    t2["quotedblright"] = 333;
                    t2["guillemotright"] = 556;
                    t2["ellipsis"] = 1e3;
                    t2["perthousand"] = 1e3;
                    t2["questiondown"] = 611;
                    t2["grave"] = 333;
                    t2["acute"] = 333;
                    t2["circumflex"] = 333;
                    t2["tilde"] = 333;
                    t2["macron"] = 333;
                    t2["breve"] = 333;
                    t2["dotaccent"] = 333;
                    t2["dieresis"] = 333;
                    t2["ring"] = 333;
                    t2["cedilla"] = 333;
                    t2["hungarumlaut"] = 333;
                    t2["ogonek"] = 333;
                    t2["caron"] = 333;
                    t2["emdash"] = 1e3;
                    t2["AE"] = 1e3;
                    t2["ordfeminine"] = 370;
                    t2["Lslash"] = 556;
                    t2["Oslash"] = 778;
                    t2["OE"] = 1e3;
                    t2["ordmasculine"] = 365;
                    t2["ae"] = 889;
                    t2["dotlessi"] = 278;
                    t2["lslash"] = 222;
                    t2["oslash"] = 611;
                    t2["oe"] = 944;
                    t2["germandbls"] = 611;
                    t2["Idieresis"] = 278;
                    t2["eacute"] = 556;
                    t2["abreve"] = 556;
                    t2["uhungarumlaut"] = 556;
                    t2["ecaron"] = 556;
                    t2["Ydieresis"] = 667;
                    t2["divide"] = 584;
                    t2["Yacute"] = 667;
                    t2["Acircumflex"] = 667;
                    t2["aacute"] = 556;
                    t2["Ucircumflex"] = 722;
                    t2["yacute"] = 500;
                    t2["scommaaccent"] = 500;
                    t2["ecircumflex"] = 556;
                    t2["Uring"] = 722;
                    t2["Udieresis"] = 722;
                    t2["aogonek"] = 556;
                    t2["Uacute"] = 722;
                    t2["uogonek"] = 556;
                    t2["Edieresis"] = 667;
                    t2["Dcroat"] = 722;
                    t2["commaaccent"] = 250;
                    t2["copyright"] = 737;
                    t2["Emacron"] = 667;
                    t2["ccaron"] = 500;
                    t2["aring"] = 556;
                    t2["Ncommaaccent"] = 722;
                    t2["lacute"] = 222;
                    t2["agrave"] = 556;
                    t2["Tcommaaccent"] = 611;
                    t2["Cacute"] = 722;
                    t2["atilde"] = 556;
                    t2["Edotaccent"] = 667;
                    t2["scaron"] = 500;
                    t2["scedilla"] = 500;
                    t2["iacute"] = 278;
                    t2["lozenge"] = 471;
                    t2["Rcaron"] = 722;
                    t2["Gcommaaccent"] = 778;
                    t2["ucircumflex"] = 556;
                    t2["acircumflex"] = 556;
                    t2["Amacron"] = 667;
                    t2["rcaron"] = 333;
                    t2["ccedilla"] = 500;
                    t2["Zdotaccent"] = 611;
                    t2["Thorn"] = 667;
                    t2["Omacron"] = 778;
                    t2["Racute"] = 722;
                    t2["Sacute"] = 667;
                    t2["dcaron"] = 643;
                    t2["Umacron"] = 722;
                    t2["uring"] = 556;
                    t2["threesuperior"] = 333;
                    t2["Ograve"] = 778;
                    t2["Agrave"] = 667;
                    t2["Abreve"] = 667;
                    t2["multiply"] = 584;
                    t2["uacute"] = 556;
                    t2["Tcaron"] = 611;
                    t2["partialdiff"] = 476;
                    t2["ydieresis"] = 500;
                    t2["Nacute"] = 722;
                    t2["icircumflex"] = 278;
                    t2["Ecircumflex"] = 667;
                    t2["adieresis"] = 556;
                    t2["edieresis"] = 556;
                    t2["cacute"] = 500;
                    t2["nacute"] = 556;
                    t2["umacron"] = 556;
                    t2["Ncaron"] = 722;
                    t2["Iacute"] = 278;
                    t2["plusminus"] = 584;
                    t2["brokenbar"] = 260;
                    t2["registered"] = 737;
                    t2["Gbreve"] = 778;
                    t2["Idotaccent"] = 278;
                    t2["summation"] = 600;
                    t2["Egrave"] = 667;
                    t2["racute"] = 333;
                    t2["omacron"] = 556;
                    t2["Zacute"] = 611;
                    t2["Zcaron"] = 611;
                    t2["greaterequal"] = 549;
                    t2["Eth"] = 722;
                    t2["Ccedilla"] = 722;
                    t2["lcommaaccent"] = 222;
                    t2["tcaron"] = 317;
                    t2["eogonek"] = 556;
                    t2["Uogonek"] = 722;
                    t2["Aacute"] = 667;
                    t2["Adieresis"] = 667;
                    t2["egrave"] = 556;
                    t2["zacute"] = 500;
                    t2["iogonek"] = 222;
                    t2["Oacute"] = 778;
                    t2["oacute"] = 556;
                    t2["amacron"] = 556;
                    t2["sacute"] = 500;
                    t2["idieresis"] = 278;
                    t2["Ocircumflex"] = 778;
                    t2["Ugrave"] = 722;
                    t2["Delta"] = 612;
                    t2["thorn"] = 556;
                    t2["twosuperior"] = 333;
                    t2["Odieresis"] = 778;
                    t2["mu"] = 556;
                    t2["igrave"] = 278;
                    t2["ohungarumlaut"] = 556;
                    t2["Eogonek"] = 667;
                    t2["dcroat"] = 556;
                    t2["threequarters"] = 834;
                    t2["Scedilla"] = 667;
                    t2["lcaron"] = 299;
                    t2["Kcommaaccent"] = 667;
                    t2["Lacute"] = 556;
                    t2["trademark"] = 1e3;
                    t2["edotaccent"] = 556;
                    t2["Igrave"] = 278;
                    t2["Imacron"] = 278;
                    t2["Lcaron"] = 556;
                    t2["onehalf"] = 834;
                    t2["lessequal"] = 549;
                    t2["ocircumflex"] = 556;
                    t2["ntilde"] = 556;
                    t2["Uhungarumlaut"] = 722;
                    t2["Eacute"] = 667;
                    t2["emacron"] = 556;
                    t2["gbreve"] = 556;
                    t2["onequarter"] = 834;
                    t2["Scaron"] = 667;
                    t2["Scommaaccent"] = 667;
                    t2["Ohungarumlaut"] = 778;
                    t2["degree"] = 400;
                    t2["ograve"] = 556;
                    t2["Ccaron"] = 722;
                    t2["ugrave"] = 556;
                    t2["radical"] = 453;
                    t2["Dcaron"] = 722;
                    t2["rcommaaccent"] = 333;
                    t2["Ntilde"] = 722;
                    t2["otilde"] = 556;
                    t2["Rcommaaccent"] = 722;
                    t2["Lcommaaccent"] = 556;
                    t2["Atilde"] = 667;
                    t2["Aogonek"] = 667;
                    t2["Aring"] = 667;
                    t2["Otilde"] = 778;
                    t2["zdotaccent"] = 500;
                    t2["Ecaron"] = 667;
                    t2["Iogonek"] = 278;
                    t2["kcommaaccent"] = 500;
                    t2["minus"] = 584;
                    t2["Icircumflex"] = 278;
                    t2["ncaron"] = 556;
                    t2["tcommaaccent"] = 278;
                    t2["logicalnot"] = 584;
                    t2["odieresis"] = 556;
                    t2["udieresis"] = 556;
                    t2["notequal"] = 549;
                    t2["gcommaaccent"] = 556;
                    t2["eth"] = 556;
                    t2["zcaron"] = 500;
                    t2["ncommaaccent"] = 556;
                    t2["onesuperior"] = 333;
                    t2["imacron"] = 278;
                    t2["Euro"] = 556;
                  });
                  t["Helvetica-Bold"] = (0, _core_utils.getLookupTableFactory)(function(t2) {
                    t2["space"] = 278;
                    t2["exclam"] = 333;
                    t2["quotedbl"] = 474;
                    t2["numbersign"] = 556;
                    t2["dollar"] = 556;
                    t2["percent"] = 889;
                    t2["ampersand"] = 722;
                    t2["quoteright"] = 278;
                    t2["parenleft"] = 333;
                    t2["parenright"] = 333;
                    t2["asterisk"] = 389;
                    t2["plus"] = 584;
                    t2["comma"] = 278;
                    t2["hyphen"] = 333;
                    t2["period"] = 278;
                    t2["slash"] = 278;
                    t2["zero"] = 556;
                    t2["one"] = 556;
                    t2["two"] = 556;
                    t2["three"] = 556;
                    t2["four"] = 556;
                    t2["five"] = 556;
                    t2["six"] = 556;
                    t2["seven"] = 556;
                    t2["eight"] = 556;
                    t2["nine"] = 556;
                    t2["colon"] = 333;
                    t2["semicolon"] = 333;
                    t2["less"] = 584;
                    t2["equal"] = 584;
                    t2["greater"] = 584;
                    t2["question"] = 611;
                    t2["at"] = 975;
                    t2["A"] = 722;
                    t2["B"] = 722;
                    t2["C"] = 722;
                    t2["D"] = 722;
                    t2["E"] = 667;
                    t2["F"] = 611;
                    t2["G"] = 778;
                    t2["H"] = 722;
                    t2["I"] = 278;
                    t2["J"] = 556;
                    t2["K"] = 722;
                    t2["L"] = 611;
                    t2["M"] = 833;
                    t2["N"] = 722;
                    t2["O"] = 778;
                    t2["P"] = 667;
                    t2["Q"] = 778;
                    t2["R"] = 722;
                    t2["S"] = 667;
                    t2["T"] = 611;
                    t2["U"] = 722;
                    t2["V"] = 667;
                    t2["W"] = 944;
                    t2["X"] = 667;
                    t2["Y"] = 667;
                    t2["Z"] = 611;
                    t2["bracketleft"] = 333;
                    t2["backslash"] = 278;
                    t2["bracketright"] = 333;
                    t2["asciicircum"] = 584;
                    t2["underscore"] = 556;
                    t2["quoteleft"] = 278;
                    t2["a"] = 556;
                    t2["b"] = 611;
                    t2["c"] = 556;
                    t2["d"] = 611;
                    t2["e"] = 556;
                    t2["f"] = 333;
                    t2["g"] = 611;
                    t2["h"] = 611;
                    t2["i"] = 278;
                    t2["j"] = 278;
                    t2["k"] = 556;
                    t2["l"] = 278;
                    t2["m"] = 889;
                    t2["n"] = 611;
                    t2["o"] = 611;
                    t2["p"] = 611;
                    t2["q"] = 611;
                    t2["r"] = 389;
                    t2["s"] = 556;
                    t2["t"] = 333;
                    t2["u"] = 611;
                    t2["v"] = 556;
                    t2["w"] = 778;
                    t2["x"] = 556;
                    t2["y"] = 556;
                    t2["z"] = 500;
                    t2["braceleft"] = 389;
                    t2["bar"] = 280;
                    t2["braceright"] = 389;
                    t2["asciitilde"] = 584;
                    t2["exclamdown"] = 333;
                    t2["cent"] = 556;
                    t2["sterling"] = 556;
                    t2["fraction"] = 167;
                    t2["yen"] = 556;
                    t2["florin"] = 556;
                    t2["section"] = 556;
                    t2["currency"] = 556;
                    t2["quotesingle"] = 238;
                    t2["quotedblleft"] = 500;
                    t2["guillemotleft"] = 556;
                    t2["guilsinglleft"] = 333;
                    t2["guilsinglright"] = 333;
                    t2["fi"] = 611;
                    t2["fl"] = 611;
                    t2["endash"] = 556;
                    t2["dagger"] = 556;
                    t2["daggerdbl"] = 556;
                    t2["periodcentered"] = 278;
                    t2["paragraph"] = 556;
                    t2["bullet"] = 350;
                    t2["quotesinglbase"] = 278;
                    t2["quotedblbase"] = 500;
                    t2["quotedblright"] = 500;
                    t2["guillemotright"] = 556;
                    t2["ellipsis"] = 1e3;
                    t2["perthousand"] = 1e3;
                    t2["questiondown"] = 611;
                    t2["grave"] = 333;
                    t2["acute"] = 333;
                    t2["circumflex"] = 333;
                    t2["tilde"] = 333;
                    t2["macron"] = 333;
                    t2["breve"] = 333;
                    t2["dotaccent"] = 333;
                    t2["dieresis"] = 333;
                    t2["ring"] = 333;
                    t2["cedilla"] = 333;
                    t2["hungarumlaut"] = 333;
                    t2["ogonek"] = 333;
                    t2["caron"] = 333;
                    t2["emdash"] = 1e3;
                    t2["AE"] = 1e3;
                    t2["ordfeminine"] = 370;
                    t2["Lslash"] = 611;
                    t2["Oslash"] = 778;
                    t2["OE"] = 1e3;
                    t2["ordmasculine"] = 365;
                    t2["ae"] = 889;
                    t2["dotlessi"] = 278;
                    t2["lslash"] = 278;
                    t2["oslash"] = 611;
                    t2["oe"] = 944;
                    t2["germandbls"] = 611;
                    t2["Idieresis"] = 278;
                    t2["eacute"] = 556;
                    t2["abreve"] = 556;
                    t2["uhungarumlaut"] = 611;
                    t2["ecaron"] = 556;
                    t2["Ydieresis"] = 667;
                    t2["divide"] = 584;
                    t2["Yacute"] = 667;
                    t2["Acircumflex"] = 722;
                    t2["aacute"] = 556;
                    t2["Ucircumflex"] = 722;
                    t2["yacute"] = 556;
                    t2["scommaaccent"] = 556;
                    t2["ecircumflex"] = 556;
                    t2["Uring"] = 722;
                    t2["Udieresis"] = 722;
                    t2["aogonek"] = 556;
                    t2["Uacute"] = 722;
                    t2["uogonek"] = 611;
                    t2["Edieresis"] = 667;
                    t2["Dcroat"] = 722;
                    t2["commaaccent"] = 250;
                    t2["copyright"] = 737;
                    t2["Emacron"] = 667;
                    t2["ccaron"] = 556;
                    t2["aring"] = 556;
                    t2["Ncommaaccent"] = 722;
                    t2["lacute"] = 278;
                    t2["agrave"] = 556;
                    t2["Tcommaaccent"] = 611;
                    t2["Cacute"] = 722;
                    t2["atilde"] = 556;
                    t2["Edotaccent"] = 667;
                    t2["scaron"] = 556;
                    t2["scedilla"] = 556;
                    t2["iacute"] = 278;
                    t2["lozenge"] = 494;
                    t2["Rcaron"] = 722;
                    t2["Gcommaaccent"] = 778;
                    t2["ucircumflex"] = 611;
                    t2["acircumflex"] = 556;
                    t2["Amacron"] = 722;
                    t2["rcaron"] = 389;
                    t2["ccedilla"] = 556;
                    t2["Zdotaccent"] = 611;
                    t2["Thorn"] = 667;
                    t2["Omacron"] = 778;
                    t2["Racute"] = 722;
                    t2["Sacute"] = 667;
                    t2["dcaron"] = 743;
                    t2["Umacron"] = 722;
                    t2["uring"] = 611;
                    t2["threesuperior"] = 333;
                    t2["Ograve"] = 778;
                    t2["Agrave"] = 722;
                    t2["Abreve"] = 722;
                    t2["multiply"] = 584;
                    t2["uacute"] = 611;
                    t2["Tcaron"] = 611;
                    t2["partialdiff"] = 494;
                    t2["ydieresis"] = 556;
                    t2["Nacute"] = 722;
                    t2["icircumflex"] = 278;
                    t2["Ecircumflex"] = 667;
                    t2["adieresis"] = 556;
                    t2["edieresis"] = 556;
                    t2["cacute"] = 556;
                    t2["nacute"] = 611;
                    t2["umacron"] = 611;
                    t2["Ncaron"] = 722;
                    t2["Iacute"] = 278;
                    t2["plusminus"] = 584;
                    t2["brokenbar"] = 280;
                    t2["registered"] = 737;
                    t2["Gbreve"] = 778;
                    t2["Idotaccent"] = 278;
                    t2["summation"] = 600;
                    t2["Egrave"] = 667;
                    t2["racute"] = 389;
                    t2["omacron"] = 611;
                    t2["Zacute"] = 611;
                    t2["Zcaron"] = 611;
                    t2["greaterequal"] = 549;
                    t2["Eth"] = 722;
                    t2["Ccedilla"] = 722;
                    t2["lcommaaccent"] = 278;
                    t2["tcaron"] = 389;
                    t2["eogonek"] = 556;
                    t2["Uogonek"] = 722;
                    t2["Aacute"] = 722;
                    t2["Adieresis"] = 722;
                    t2["egrave"] = 556;
                    t2["zacute"] = 500;
                    t2["iogonek"] = 278;
                    t2["Oacute"] = 778;
                    t2["oacute"] = 611;
                    t2["amacron"] = 556;
                    t2["sacute"] = 556;
                    t2["idieresis"] = 278;
                    t2["Ocircumflex"] = 778;
                    t2["Ugrave"] = 722;
                    t2["Delta"] = 612;
                    t2["thorn"] = 611;
                    t2["twosuperior"] = 333;
                    t2["Odieresis"] = 778;
                    t2["mu"] = 611;
                    t2["igrave"] = 278;
                    t2["ohungarumlaut"] = 611;
                    t2["Eogonek"] = 667;
                    t2["dcroat"] = 611;
                    t2["threequarters"] = 834;
                    t2["Scedilla"] = 667;
                    t2["lcaron"] = 400;
                    t2["Kcommaaccent"] = 722;
                    t2["Lacute"] = 611;
                    t2["trademark"] = 1e3;
                    t2["edotaccent"] = 556;
                    t2["Igrave"] = 278;
                    t2["Imacron"] = 278;
                    t2["Lcaron"] = 611;
                    t2["onehalf"] = 834;
                    t2["lessequal"] = 549;
                    t2["ocircumflex"] = 611;
                    t2["ntilde"] = 611;
                    t2["Uhungarumlaut"] = 722;
                    t2["Eacute"] = 667;
                    t2["emacron"] = 556;
                    t2["gbreve"] = 611;
                    t2["onequarter"] = 834;
                    t2["Scaron"] = 667;
                    t2["Scommaaccent"] = 667;
                    t2["Ohungarumlaut"] = 778;
                    t2["degree"] = 400;
                    t2["ograve"] = 611;
                    t2["Ccaron"] = 722;
                    t2["ugrave"] = 611;
                    t2["radical"] = 549;
                    t2["Dcaron"] = 722;
                    t2["rcommaaccent"] = 389;
                    t2["Ntilde"] = 722;
                    t2["otilde"] = 611;
                    t2["Rcommaaccent"] = 722;
                    t2["Lcommaaccent"] = 611;
                    t2["Atilde"] = 722;
                    t2["Aogonek"] = 722;
                    t2["Aring"] = 722;
                    t2["Otilde"] = 778;
                    t2["zdotaccent"] = 500;
                    t2["Ecaron"] = 667;
                    t2["Iogonek"] = 278;
                    t2["kcommaaccent"] = 556;
                    t2["minus"] = 584;
                    t2["Icircumflex"] = 278;
                    t2["ncaron"] = 611;
                    t2["tcommaaccent"] = 333;
                    t2["logicalnot"] = 584;
                    t2["odieresis"] = 611;
                    t2["udieresis"] = 611;
                    t2["notequal"] = 549;
                    t2["gcommaaccent"] = 611;
                    t2["eth"] = 611;
                    t2["zcaron"] = 500;
                    t2["ncommaaccent"] = 611;
                    t2["onesuperior"] = 333;
                    t2["imacron"] = 278;
                    t2["Euro"] = 556;
                  });
                  t["Helvetica-BoldOblique"] = (0, _core_utils.getLookupTableFactory)(function(t2) {
                    t2["space"] = 278;
                    t2["exclam"] = 333;
                    t2["quotedbl"] = 474;
                    t2["numbersign"] = 556;
                    t2["dollar"] = 556;
                    t2["percent"] = 889;
                    t2["ampersand"] = 722;
                    t2["quoteright"] = 278;
                    t2["parenleft"] = 333;
                    t2["parenright"] = 333;
                    t2["asterisk"] = 389;
                    t2["plus"] = 584;
                    t2["comma"] = 278;
                    t2["hyphen"] = 333;
                    t2["period"] = 278;
                    t2["slash"] = 278;
                    t2["zero"] = 556;
                    t2["one"] = 556;
                    t2["two"] = 556;
                    t2["three"] = 556;
                    t2["four"] = 556;
                    t2["five"] = 556;
                    t2["six"] = 556;
                    t2["seven"] = 556;
                    t2["eight"] = 556;
                    t2["nine"] = 556;
                    t2["colon"] = 333;
                    t2["semicolon"] = 333;
                    t2["less"] = 584;
                    t2["equal"] = 584;
                    t2["greater"] = 584;
                    t2["question"] = 611;
                    t2["at"] = 975;
                    t2["A"] = 722;
                    t2["B"] = 722;
                    t2["C"] = 722;
                    t2["D"] = 722;
                    t2["E"] = 667;
                    t2["F"] = 611;
                    t2["G"] = 778;
                    t2["H"] = 722;
                    t2["I"] = 278;
                    t2["J"] = 556;
                    t2["K"] = 722;
                    t2["L"] = 611;
                    t2["M"] = 833;
                    t2["N"] = 722;
                    t2["O"] = 778;
                    t2["P"] = 667;
                    t2["Q"] = 778;
                    t2["R"] = 722;
                    t2["S"] = 667;
                    t2["T"] = 611;
                    t2["U"] = 722;
                    t2["V"] = 667;
                    t2["W"] = 944;
                    t2["X"] = 667;
                    t2["Y"] = 667;
                    t2["Z"] = 611;
                    t2["bracketleft"] = 333;
                    t2["backslash"] = 278;
                    t2["bracketright"] = 333;
                    t2["asciicircum"] = 584;
                    t2["underscore"] = 556;
                    t2["quoteleft"] = 278;
                    t2["a"] = 556;
                    t2["b"] = 611;
                    t2["c"] = 556;
                    t2["d"] = 611;
                    t2["e"] = 556;
                    t2["f"] = 333;
                    t2["g"] = 611;
                    t2["h"] = 611;
                    t2["i"] = 278;
                    t2["j"] = 278;
                    t2["k"] = 556;
                    t2["l"] = 278;
                    t2["m"] = 889;
                    t2["n"] = 611;
                    t2["o"] = 611;
                    t2["p"] = 611;
                    t2["q"] = 611;
                    t2["r"] = 389;
                    t2["s"] = 556;
                    t2["t"] = 333;
                    t2["u"] = 611;
                    t2["v"] = 556;
                    t2["w"] = 778;
                    t2["x"] = 556;
                    t2["y"] = 556;
                    t2["z"] = 500;
                    t2["braceleft"] = 389;
                    t2["bar"] = 280;
                    t2["braceright"] = 389;
                    t2["asciitilde"] = 584;
                    t2["exclamdown"] = 333;
                    t2["cent"] = 556;
                    t2["sterling"] = 556;
                    t2["fraction"] = 167;
                    t2["yen"] = 556;
                    t2["florin"] = 556;
                    t2["section"] = 556;
                    t2["currency"] = 556;
                    t2["quotesingle"] = 238;
                    t2["quotedblleft"] = 500;
                    t2["guillemotleft"] = 556;
                    t2["guilsinglleft"] = 333;
                    t2["guilsinglright"] = 333;
                    t2["fi"] = 611;
                    t2["fl"] = 611;
                    t2["endash"] = 556;
                    t2["dagger"] = 556;
                    t2["daggerdbl"] = 556;
                    t2["periodcentered"] = 278;
                    t2["paragraph"] = 556;
                    t2["bullet"] = 350;
                    t2["quotesinglbase"] = 278;
                    t2["quotedblbase"] = 500;
                    t2["quotedblright"] = 500;
                    t2["guillemotright"] = 556;
                    t2["ellipsis"] = 1e3;
                    t2["perthousand"] = 1e3;
                    t2["questiondown"] = 611;
                    t2["grave"] = 333;
                    t2["acute"] = 333;
                    t2["circumflex"] = 333;
                    t2["tilde"] = 333;
                    t2["macron"] = 333;
                    t2["breve"] = 333;
                    t2["dotaccent"] = 333;
                    t2["dieresis"] = 333;
                    t2["ring"] = 333;
                    t2["cedilla"] = 333;
                    t2["hungarumlaut"] = 333;
                    t2["ogonek"] = 333;
                    t2["caron"] = 333;
                    t2["emdash"] = 1e3;
                    t2["AE"] = 1e3;
                    t2["ordfeminine"] = 370;
                    t2["Lslash"] = 611;
                    t2["Oslash"] = 778;
                    t2["OE"] = 1e3;
                    t2["ordmasculine"] = 365;
                    t2["ae"] = 889;
                    t2["dotlessi"] = 278;
                    t2["lslash"] = 278;
                    t2["oslash"] = 611;
                    t2["oe"] = 944;
                    t2["germandbls"] = 611;
                    t2["Idieresis"] = 278;
                    t2["eacute"] = 556;
                    t2["abreve"] = 556;
                    t2["uhungarumlaut"] = 611;
                    t2["ecaron"] = 556;
                    t2["Ydieresis"] = 667;
                    t2["divide"] = 584;
                    t2["Yacute"] = 667;
                    t2["Acircumflex"] = 722;
                    t2["aacute"] = 556;
                    t2["Ucircumflex"] = 722;
                    t2["yacute"] = 556;
                    t2["scommaaccent"] = 556;
                    t2["ecircumflex"] = 556;
                    t2["Uring"] = 722;
                    t2["Udieresis"] = 722;
                    t2["aogonek"] = 556;
                    t2["Uacute"] = 722;
                    t2["uogonek"] = 611;
                    t2["Edieresis"] = 667;
                    t2["Dcroat"] = 722;
                    t2["commaaccent"] = 250;
                    t2["copyright"] = 737;
                    t2["Emacron"] = 667;
                    t2["ccaron"] = 556;
                    t2["aring"] = 556;
                    t2["Ncommaaccent"] = 722;
                    t2["lacute"] = 278;
                    t2["agrave"] = 556;
                    t2["Tcommaaccent"] = 611;
                    t2["Cacute"] = 722;
                    t2["atilde"] = 556;
                    t2["Edotaccent"] = 667;
                    t2["scaron"] = 556;
                    t2["scedilla"] = 556;
                    t2["iacute"] = 278;
                    t2["lozenge"] = 494;
                    t2["Rcaron"] = 722;
                    t2["Gcommaaccent"] = 778;
                    t2["ucircumflex"] = 611;
                    t2["acircumflex"] = 556;
                    t2["Amacron"] = 722;
                    t2["rcaron"] = 389;
                    t2["ccedilla"] = 556;
                    t2["Zdotaccent"] = 611;
                    t2["Thorn"] = 667;
                    t2["Omacron"] = 778;
                    t2["Racute"] = 722;
                    t2["Sacute"] = 667;
                    t2["dcaron"] = 743;
                    t2["Umacron"] = 722;
                    t2["uring"] = 611;
                    t2["threesuperior"] = 333;
                    t2["Ograve"] = 778;
                    t2["Agrave"] = 722;
                    t2["Abreve"] = 722;
                    t2["multiply"] = 584;
                    t2["uacute"] = 611;
                    t2["Tcaron"] = 611;
                    t2["partialdiff"] = 494;
                    t2["ydieresis"] = 556;
                    t2["Nacute"] = 722;
                    t2["icircumflex"] = 278;
                    t2["Ecircumflex"] = 667;
                    t2["adieresis"] = 556;
                    t2["edieresis"] = 556;
                    t2["cacute"] = 556;
                    t2["nacute"] = 611;
                    t2["umacron"] = 611;
                    t2["Ncaron"] = 722;
                    t2["Iacute"] = 278;
                    t2["plusminus"] = 584;
                    t2["brokenbar"] = 280;
                    t2["registered"] = 737;
                    t2["Gbreve"] = 778;
                    t2["Idotaccent"] = 278;
                    t2["summation"] = 600;
                    t2["Egrave"] = 667;
                    t2["racute"] = 389;
                    t2["omacron"] = 611;
                    t2["Zacute"] = 611;
                    t2["Zcaron"] = 611;
                    t2["greaterequal"] = 549;
                    t2["Eth"] = 722;
                    t2["Ccedilla"] = 722;
                    t2["lcommaaccent"] = 278;
                    t2["tcaron"] = 389;
                    t2["eogonek"] = 556;
                    t2["Uogonek"] = 722;
                    t2["Aacute"] = 722;
                    t2["Adieresis"] = 722;
                    t2["egrave"] = 556;
                    t2["zacute"] = 500;
                    t2["iogonek"] = 278;
                    t2["Oacute"] = 778;
                    t2["oacute"] = 611;
                    t2["amacron"] = 556;
                    t2["sacute"] = 556;
                    t2["idieresis"] = 278;
                    t2["Ocircumflex"] = 778;
                    t2["Ugrave"] = 722;
                    t2["Delta"] = 612;
                    t2["thorn"] = 611;
                    t2["twosuperior"] = 333;
                    t2["Odieresis"] = 778;
                    t2["mu"] = 611;
                    t2["igrave"] = 278;
                    t2["ohungarumlaut"] = 611;
                    t2["Eogonek"] = 667;
                    t2["dcroat"] = 611;
                    t2["threequarters"] = 834;
                    t2["Scedilla"] = 667;
                    t2["lcaron"] = 400;
                    t2["Kcommaaccent"] = 722;
                    t2["Lacute"] = 611;
                    t2["trademark"] = 1e3;
                    t2["edotaccent"] = 556;
                    t2["Igrave"] = 278;
                    t2["Imacron"] = 278;
                    t2["Lcaron"] = 611;
                    t2["onehalf"] = 834;
                    t2["lessequal"] = 549;
                    t2["ocircumflex"] = 611;
                    t2["ntilde"] = 611;
                    t2["Uhungarumlaut"] = 722;
                    t2["Eacute"] = 667;
                    t2["emacron"] = 556;
                    t2["gbreve"] = 611;
                    t2["onequarter"] = 834;
                    t2["Scaron"] = 667;
                    t2["Scommaaccent"] = 667;
                    t2["Ohungarumlaut"] = 778;
                    t2["degree"] = 400;
                    t2["ograve"] = 611;
                    t2["Ccaron"] = 722;
                    t2["ugrave"] = 611;
                    t2["radical"] = 549;
                    t2["Dcaron"] = 722;
                    t2["rcommaaccent"] = 389;
                    t2["Ntilde"] = 722;
                    t2["otilde"] = 611;
                    t2["Rcommaaccent"] = 722;
                    t2["Lcommaaccent"] = 611;
                    t2["Atilde"] = 722;
                    t2["Aogonek"] = 722;
                    t2["Aring"] = 722;
                    t2["Otilde"] = 778;
                    t2["zdotaccent"] = 500;
                    t2["Ecaron"] = 667;
                    t2["Iogonek"] = 278;
                    t2["kcommaaccent"] = 556;
                    t2["minus"] = 584;
                    t2["Icircumflex"] = 278;
                    t2["ncaron"] = 611;
                    t2["tcommaaccent"] = 333;
                    t2["logicalnot"] = 584;
                    t2["odieresis"] = 611;
                    t2["udieresis"] = 611;
                    t2["notequal"] = 549;
                    t2["gcommaaccent"] = 611;
                    t2["eth"] = 611;
                    t2["zcaron"] = 500;
                    t2["ncommaaccent"] = 611;
                    t2["onesuperior"] = 333;
                    t2["imacron"] = 278;
                    t2["Euro"] = 556;
                  });
                  t["Helvetica-Oblique"] = (0, _core_utils.getLookupTableFactory)(function(t2) {
                    t2["space"] = 278;
                    t2["exclam"] = 278;
                    t2["quotedbl"] = 355;
                    t2["numbersign"] = 556;
                    t2["dollar"] = 556;
                    t2["percent"] = 889;
                    t2["ampersand"] = 667;
                    t2["quoteright"] = 222;
                    t2["parenleft"] = 333;
                    t2["parenright"] = 333;
                    t2["asterisk"] = 389;
                    t2["plus"] = 584;
                    t2["comma"] = 278;
                    t2["hyphen"] = 333;
                    t2["period"] = 278;
                    t2["slash"] = 278;
                    t2["zero"] = 556;
                    t2["one"] = 556;
                    t2["two"] = 556;
                    t2["three"] = 556;
                    t2["four"] = 556;
                    t2["five"] = 556;
                    t2["six"] = 556;
                    t2["seven"] = 556;
                    t2["eight"] = 556;
                    t2["nine"] = 556;
                    t2["colon"] = 278;
                    t2["semicolon"] = 278;
                    t2["less"] = 584;
                    t2["equal"] = 584;
                    t2["greater"] = 584;
                    t2["question"] = 556;
                    t2["at"] = 1015;
                    t2["A"] = 667;
                    t2["B"] = 667;
                    t2["C"] = 722;
                    t2["D"] = 722;
                    t2["E"] = 667;
                    t2["F"] = 611;
                    t2["G"] = 778;
                    t2["H"] = 722;
                    t2["I"] = 278;
                    t2["J"] = 500;
                    t2["K"] = 667;
                    t2["L"] = 556;
                    t2["M"] = 833;
                    t2["N"] = 722;
                    t2["O"] = 778;
                    t2["P"] = 667;
                    t2["Q"] = 778;
                    t2["R"] = 722;
                    t2["S"] = 667;
                    t2["T"] = 611;
                    t2["U"] = 722;
                    t2["V"] = 667;
                    t2["W"] = 944;
                    t2["X"] = 667;
                    t2["Y"] = 667;
                    t2["Z"] = 611;
                    t2["bracketleft"] = 278;
                    t2["backslash"] = 278;
                    t2["bracketright"] = 278;
                    t2["asciicircum"] = 469;
                    t2["underscore"] = 556;
                    t2["quoteleft"] = 222;
                    t2["a"] = 556;
                    t2["b"] = 556;
                    t2["c"] = 500;
                    t2["d"] = 556;
                    t2["e"] = 556;
                    t2["f"] = 278;
                    t2["g"] = 556;
                    t2["h"] = 556;
                    t2["i"] = 222;
                    t2["j"] = 222;
                    t2["k"] = 500;
                    t2["l"] = 222;
                    t2["m"] = 833;
                    t2["n"] = 556;
                    t2["o"] = 556;
                    t2["p"] = 556;
                    t2["q"] = 556;
                    t2["r"] = 333;
                    t2["s"] = 500;
                    t2["t"] = 278;
                    t2["u"] = 556;
                    t2["v"] = 500;
                    t2["w"] = 722;
                    t2["x"] = 500;
                    t2["y"] = 500;
                    t2["z"] = 500;
                    t2["braceleft"] = 334;
                    t2["bar"] = 260;
                    t2["braceright"] = 334;
                    t2["asciitilde"] = 584;
                    t2["exclamdown"] = 333;
                    t2["cent"] = 556;
                    t2["sterling"] = 556;
                    t2["fraction"] = 167;
                    t2["yen"] = 556;
                    t2["florin"] = 556;
                    t2["section"] = 556;
                    t2["currency"] = 556;
                    t2["quotesingle"] = 191;
                    t2["quotedblleft"] = 333;
                    t2["guillemotleft"] = 556;
                    t2["guilsinglleft"] = 333;
                    t2["guilsinglright"] = 333;
                    t2["fi"] = 500;
                    t2["fl"] = 500;
                    t2["endash"] = 556;
                    t2["dagger"] = 556;
                    t2["daggerdbl"] = 556;
                    t2["periodcentered"] = 278;
                    t2["paragraph"] = 537;
                    t2["bullet"] = 350;
                    t2["quotesinglbase"] = 222;
                    t2["quotedblbase"] = 333;
                    t2["quotedblright"] = 333;
                    t2["guillemotright"] = 556;
                    t2["ellipsis"] = 1e3;
                    t2["perthousand"] = 1e3;
                    t2["questiondown"] = 611;
                    t2["grave"] = 333;
                    t2["acute"] = 333;
                    t2["circumflex"] = 333;
                    t2["tilde"] = 333;
                    t2["macron"] = 333;
                    t2["breve"] = 333;
                    t2["dotaccent"] = 333;
                    t2["dieresis"] = 333;
                    t2["ring"] = 333;
                    t2["cedilla"] = 333;
                    t2["hungarumlaut"] = 333;
                    t2["ogonek"] = 333;
                    t2["caron"] = 333;
                    t2["emdash"] = 1e3;
                    t2["AE"] = 1e3;
                    t2["ordfeminine"] = 370;
                    t2["Lslash"] = 556;
                    t2["Oslash"] = 778;
                    t2["OE"] = 1e3;
                    t2["ordmasculine"] = 365;
                    t2["ae"] = 889;
                    t2["dotlessi"] = 278;
                    t2["lslash"] = 222;
                    t2["oslash"] = 611;
                    t2["oe"] = 944;
                    t2["germandbls"] = 611;
                    t2["Idieresis"] = 278;
                    t2["eacute"] = 556;
                    t2["abreve"] = 556;
                    t2["uhungarumlaut"] = 556;
                    t2["ecaron"] = 556;
                    t2["Ydieresis"] = 667;
                    t2["divide"] = 584;
                    t2["Yacute"] = 667;
                    t2["Acircumflex"] = 667;
                    t2["aacute"] = 556;
                    t2["Ucircumflex"] = 722;
                    t2["yacute"] = 500;
                    t2["scommaaccent"] = 500;
                    t2["ecircumflex"] = 556;
                    t2["Uring"] = 722;
                    t2["Udieresis"] = 722;
                    t2["aogonek"] = 556;
                    t2["Uacute"] = 722;
                    t2["uogonek"] = 556;
                    t2["Edieresis"] = 667;
                    t2["Dcroat"] = 722;
                    t2["commaaccent"] = 250;
                    t2["copyright"] = 737;
                    t2["Emacron"] = 667;
                    t2["ccaron"] = 500;
                    t2["aring"] = 556;
                    t2["Ncommaaccent"] = 722;
                    t2["lacute"] = 222;
                    t2["agrave"] = 556;
                    t2["Tcommaaccent"] = 611;
                    t2["Cacute"] = 722;
                    t2["atilde"] = 556;
                    t2["Edotaccent"] = 667;
                    t2["scaron"] = 500;
                    t2["scedilla"] = 500;
                    t2["iacute"] = 278;
                    t2["lozenge"] = 471;
                    t2["Rcaron"] = 722;
                    t2["Gcommaaccent"] = 778;
                    t2["ucircumflex"] = 556;
                    t2["acircumflex"] = 556;
                    t2["Amacron"] = 667;
                    t2["rcaron"] = 333;
                    t2["ccedilla"] = 500;
                    t2["Zdotaccent"] = 611;
                    t2["Thorn"] = 667;
                    t2["Omacron"] = 778;
                    t2["Racute"] = 722;
                    t2["Sacute"] = 667;
                    t2["dcaron"] = 643;
                    t2["Umacron"] = 722;
                    t2["uring"] = 556;
                    t2["threesuperior"] = 333;
                    t2["Ograve"] = 778;
                    t2["Agrave"] = 667;
                    t2["Abreve"] = 667;
                    t2["multiply"] = 584;
                    t2["uacute"] = 556;
                    t2["Tcaron"] = 611;
                    t2["partialdiff"] = 476;
                    t2["ydieresis"] = 500;
                    t2["Nacute"] = 722;
                    t2["icircumflex"] = 278;
                    t2["Ecircumflex"] = 667;
                    t2["adieresis"] = 556;
                    t2["edieresis"] = 556;
                    t2["cacute"] = 500;
                    t2["nacute"] = 556;
                    t2["umacron"] = 556;
                    t2["Ncaron"] = 722;
                    t2["Iacute"] = 278;
                    t2["plusminus"] = 584;
                    t2["brokenbar"] = 260;
                    t2["registered"] = 737;
                    t2["Gbreve"] = 778;
                    t2["Idotaccent"] = 278;
                    t2["summation"] = 600;
                    t2["Egrave"] = 667;
                    t2["racute"] = 333;
                    t2["omacron"] = 556;
                    t2["Zacute"] = 611;
                    t2["Zcaron"] = 611;
                    t2["greaterequal"] = 549;
                    t2["Eth"] = 722;
                    t2["Ccedilla"] = 722;
                    t2["lcommaaccent"] = 222;
                    t2["tcaron"] = 317;
                    t2["eogonek"] = 556;
                    t2["Uogonek"] = 722;
                    t2["Aacute"] = 667;
                    t2["Adieresis"] = 667;
                    t2["egrave"] = 556;
                    t2["zacute"] = 500;
                    t2["iogonek"] = 222;
                    t2["Oacute"] = 778;
                    t2["oacute"] = 556;
                    t2["amacron"] = 556;
                    t2["sacute"] = 500;
                    t2["idieresis"] = 278;
                    t2["Ocircumflex"] = 778;
                    t2["Ugrave"] = 722;
                    t2["Delta"] = 612;
                    t2["thorn"] = 556;
                    t2["twosuperior"] = 333;
                    t2["Odieresis"] = 778;
                    t2["mu"] = 556;
                    t2["igrave"] = 278;
                    t2["ohungarumlaut"] = 556;
                    t2["Eogonek"] = 667;
                    t2["dcroat"] = 556;
                    t2["threequarters"] = 834;
                    t2["Scedilla"] = 667;
                    t2["lcaron"] = 299;
                    t2["Kcommaaccent"] = 667;
                    t2["Lacute"] = 556;
                    t2["trademark"] = 1e3;
                    t2["edotaccent"] = 556;
                    t2["Igrave"] = 278;
                    t2["Imacron"] = 278;
                    t2["Lcaron"] = 556;
                    t2["onehalf"] = 834;
                    t2["lessequal"] = 549;
                    t2["ocircumflex"] = 556;
                    t2["ntilde"] = 556;
                    t2["Uhungarumlaut"] = 722;
                    t2["Eacute"] = 667;
                    t2["emacron"] = 556;
                    t2["gbreve"] = 556;
                    t2["onequarter"] = 834;
                    t2["Scaron"] = 667;
                    t2["Scommaaccent"] = 667;
                    t2["Ohungarumlaut"] = 778;
                    t2["degree"] = 400;
                    t2["ograve"] = 556;
                    t2["Ccaron"] = 722;
                    t2["ugrave"] = 556;
                    t2["radical"] = 453;
                    t2["Dcaron"] = 722;
                    t2["rcommaaccent"] = 333;
                    t2["Ntilde"] = 722;
                    t2["otilde"] = 556;
                    t2["Rcommaaccent"] = 722;
                    t2["Lcommaaccent"] = 556;
                    t2["Atilde"] = 667;
                    t2["Aogonek"] = 667;
                    t2["Aring"] = 667;
                    t2["Otilde"] = 778;
                    t2["zdotaccent"] = 500;
                    t2["Ecaron"] = 667;
                    t2["Iogonek"] = 278;
                    t2["kcommaaccent"] = 500;
                    t2["minus"] = 584;
                    t2["Icircumflex"] = 278;
                    t2["ncaron"] = 556;
                    t2["tcommaaccent"] = 278;
                    t2["logicalnot"] = 584;
                    t2["odieresis"] = 556;
                    t2["udieresis"] = 556;
                    t2["notequal"] = 549;
                    t2["gcommaaccent"] = 556;
                    t2["eth"] = 556;
                    t2["zcaron"] = 500;
                    t2["ncommaaccent"] = 556;
                    t2["onesuperior"] = 333;
                    t2["imacron"] = 278;
                    t2["Euro"] = 556;
                  });
                  t["Symbol"] = (0, _core_utils.getLookupTableFactory)(function(t2) {
                    t2["space"] = 250;
                    t2["exclam"] = 333;
                    t2["universal"] = 713;
                    t2["numbersign"] = 500;
                    t2["existential"] = 549;
                    t2["percent"] = 833;
                    t2["ampersand"] = 778;
                    t2["suchthat"] = 439;
                    t2["parenleft"] = 333;
                    t2["parenright"] = 333;
                    t2["asteriskmath"] = 500;
                    t2["plus"] = 549;
                    t2["comma"] = 250;
                    t2["minus"] = 549;
                    t2["period"] = 250;
                    t2["slash"] = 278;
                    t2["zero"] = 500;
                    t2["one"] = 500;
                    t2["two"] = 500;
                    t2["three"] = 500;
                    t2["four"] = 500;
                    t2["five"] = 500;
                    t2["six"] = 500;
                    t2["seven"] = 500;
                    t2["eight"] = 500;
                    t2["nine"] = 500;
                    t2["colon"] = 278;
                    t2["semicolon"] = 278;
                    t2["less"] = 549;
                    t2["equal"] = 549;
                    t2["greater"] = 549;
                    t2["question"] = 444;
                    t2["congruent"] = 549;
                    t2["Alpha"] = 722;
                    t2["Beta"] = 667;
                    t2["Chi"] = 722;
                    t2["Delta"] = 612;
                    t2["Epsilon"] = 611;
                    t2["Phi"] = 763;
                    t2["Gamma"] = 603;
                    t2["Eta"] = 722;
                    t2["Iota"] = 333;
                    t2["theta1"] = 631;
                    t2["Kappa"] = 722;
                    t2["Lambda"] = 686;
                    t2["Mu"] = 889;
                    t2["Nu"] = 722;
                    t2["Omicron"] = 722;
                    t2["Pi"] = 768;
                    t2["Theta"] = 741;
                    t2["Rho"] = 556;
                    t2["Sigma"] = 592;
                    t2["Tau"] = 611;
                    t2["Upsilon"] = 690;
                    t2["sigma1"] = 439;
                    t2["Omega"] = 768;
                    t2["Xi"] = 645;
                    t2["Psi"] = 795;
                    t2["Zeta"] = 611;
                    t2["bracketleft"] = 333;
                    t2["therefore"] = 863;
                    t2["bracketright"] = 333;
                    t2["perpendicular"] = 658;
                    t2["underscore"] = 500;
                    t2["radicalex"] = 500;
                    t2["alpha"] = 631;
                    t2["beta"] = 549;
                    t2["chi"] = 549;
                    t2["delta"] = 494;
                    t2["epsilon"] = 439;
                    t2["phi"] = 521;
                    t2["gamma"] = 411;
                    t2["eta"] = 603;
                    t2["iota"] = 329;
                    t2["phi1"] = 603;
                    t2["kappa"] = 549;
                    t2["lambda"] = 549;
                    t2["mu"] = 576;
                    t2["nu"] = 521;
                    t2["omicron"] = 549;
                    t2["pi"] = 549;
                    t2["theta"] = 521;
                    t2["rho"] = 549;
                    t2["sigma"] = 603;
                    t2["tau"] = 439;
                    t2["upsilon"] = 576;
                    t2["omega1"] = 713;
                    t2["omega"] = 686;
                    t2["xi"] = 493;
                    t2["psi"] = 686;
                    t2["zeta"] = 494;
                    t2["braceleft"] = 480;
                    t2["bar"] = 200;
                    t2["braceright"] = 480;
                    t2["similar"] = 549;
                    t2["Euro"] = 750;
                    t2["Upsilon1"] = 620;
                    t2["minute"] = 247;
                    t2["lessequal"] = 549;
                    t2["fraction"] = 167;
                    t2["infinity"] = 713;
                    t2["florin"] = 500;
                    t2["club"] = 753;
                    t2["diamond"] = 753;
                    t2["heart"] = 753;
                    t2["spade"] = 753;
                    t2["arrowboth"] = 1042;
                    t2["arrowleft"] = 987;
                    t2["arrowup"] = 603;
                    t2["arrowright"] = 987;
                    t2["arrowdown"] = 603;
                    t2["degree"] = 400;
                    t2["plusminus"] = 549;
                    t2["second"] = 411;
                    t2["greaterequal"] = 549;
                    t2["multiply"] = 549;
                    t2["proportional"] = 713;
                    t2["partialdiff"] = 494;
                    t2["bullet"] = 460;
                    t2["divide"] = 549;
                    t2["notequal"] = 549;
                    t2["equivalence"] = 549;
                    t2["approxequal"] = 549;
                    t2["ellipsis"] = 1e3;
                    t2["arrowvertex"] = 603;
                    t2["arrowhorizex"] = 1e3;
                    t2["carriagereturn"] = 658;
                    t2["aleph"] = 823;
                    t2["Ifraktur"] = 686;
                    t2["Rfraktur"] = 795;
                    t2["weierstrass"] = 987;
                    t2["circlemultiply"] = 768;
                    t2["circleplus"] = 768;
                    t2["emptyset"] = 823;
                    t2["intersection"] = 768;
                    t2["union"] = 768;
                    t2["propersuperset"] = 713;
                    t2["reflexsuperset"] = 713;
                    t2["notsubset"] = 713;
                    t2["propersubset"] = 713;
                    t2["reflexsubset"] = 713;
                    t2["element"] = 713;
                    t2["notelement"] = 713;
                    t2["angle"] = 768;
                    t2["gradient"] = 713;
                    t2["registerserif"] = 790;
                    t2["copyrightserif"] = 790;
                    t2["trademarkserif"] = 890;
                    t2["product"] = 823;
                    t2["radical"] = 549;
                    t2["dotmath"] = 250;
                    t2["logicalnot"] = 713;
                    t2["logicaland"] = 603;
                    t2["logicalor"] = 603;
                    t2["arrowdblboth"] = 1042;
                    t2["arrowdblleft"] = 987;
                    t2["arrowdblup"] = 603;
                    t2["arrowdblright"] = 987;
                    t2["arrowdbldown"] = 603;
                    t2["lozenge"] = 494;
                    t2["angleleft"] = 329;
                    t2["registersans"] = 790;
                    t2["copyrightsans"] = 790;
                    t2["trademarksans"] = 786;
                    t2["summation"] = 713;
                    t2["parenlefttp"] = 384;
                    t2["parenleftex"] = 384;
                    t2["parenleftbt"] = 384;
                    t2["bracketlefttp"] = 384;
                    t2["bracketleftex"] = 384;
                    t2["bracketleftbt"] = 384;
                    t2["bracelefttp"] = 494;
                    t2["braceleftmid"] = 494;
                    t2["braceleftbt"] = 494;
                    t2["braceex"] = 494;
                    t2["angleright"] = 329;
                    t2["integral"] = 274;
                    t2["integraltp"] = 686;
                    t2["integralex"] = 686;
                    t2["integralbt"] = 686;
                    t2["parenrighttp"] = 384;
                    t2["parenrightex"] = 384;
                    t2["parenrightbt"] = 384;
                    t2["bracketrighttp"] = 384;
                    t2["bracketrightex"] = 384;
                    t2["bracketrightbt"] = 384;
                    t2["bracerighttp"] = 494;
                    t2["bracerightmid"] = 494;
                    t2["bracerightbt"] = 494;
                    t2["apple"] = 790;
                  });
                  t["Times-Roman"] = (0, _core_utils.getLookupTableFactory)(function(t2) {
                    t2["space"] = 250;
                    t2["exclam"] = 333;
                    t2["quotedbl"] = 408;
                    t2["numbersign"] = 500;
                    t2["dollar"] = 500;
                    t2["percent"] = 833;
                    t2["ampersand"] = 778;
                    t2["quoteright"] = 333;
                    t2["parenleft"] = 333;
                    t2["parenright"] = 333;
                    t2["asterisk"] = 500;
                    t2["plus"] = 564;
                    t2["comma"] = 250;
                    t2["hyphen"] = 333;
                    t2["period"] = 250;
                    t2["slash"] = 278;
                    t2["zero"] = 500;
                    t2["one"] = 500;
                    t2["two"] = 500;
                    t2["three"] = 500;
                    t2["four"] = 500;
                    t2["five"] = 500;
                    t2["six"] = 500;
                    t2["seven"] = 500;
                    t2["eight"] = 500;
                    t2["nine"] = 500;
                    t2["colon"] = 278;
                    t2["semicolon"] = 278;
                    t2["less"] = 564;
                    t2["equal"] = 564;
                    t2["greater"] = 564;
                    t2["question"] = 444;
                    t2["at"] = 921;
                    t2["A"] = 722;
                    t2["B"] = 667;
                    t2["C"] = 667;
                    t2["D"] = 722;
                    t2["E"] = 611;
                    t2["F"] = 556;
                    t2["G"] = 722;
                    t2["H"] = 722;
                    t2["I"] = 333;
                    t2["J"] = 389;
                    t2["K"] = 722;
                    t2["L"] = 611;
                    t2["M"] = 889;
                    t2["N"] = 722;
                    t2["O"] = 722;
                    t2["P"] = 556;
                    t2["Q"] = 722;
                    t2["R"] = 667;
                    t2["S"] = 556;
                    t2["T"] = 611;
                    t2["U"] = 722;
                    t2["V"] = 722;
                    t2["W"] = 944;
                    t2["X"] = 722;
                    t2["Y"] = 722;
                    t2["Z"] = 611;
                    t2["bracketleft"] = 333;
                    t2["backslash"] = 278;
                    t2["bracketright"] = 333;
                    t2["asciicircum"] = 469;
                    t2["underscore"] = 500;
                    t2["quoteleft"] = 333;
                    t2["a"] = 444;
                    t2["b"] = 500;
                    t2["c"] = 444;
                    t2["d"] = 500;
                    t2["e"] = 444;
                    t2["f"] = 333;
                    t2["g"] = 500;
                    t2["h"] = 500;
                    t2["i"] = 278;
                    t2["j"] = 278;
                    t2["k"] = 500;
                    t2["l"] = 278;
                    t2["m"] = 778;
                    t2["n"] = 500;
                    t2["o"] = 500;
                    t2["p"] = 500;
                    t2["q"] = 500;
                    t2["r"] = 333;
                    t2["s"] = 389;
                    t2["t"] = 278;
                    t2["u"] = 500;
                    t2["v"] = 500;
                    t2["w"] = 722;
                    t2["x"] = 500;
                    t2["y"] = 500;
                    t2["z"] = 444;
                    t2["braceleft"] = 480;
                    t2["bar"] = 200;
                    t2["braceright"] = 480;
                    t2["asciitilde"] = 541;
                    t2["exclamdown"] = 333;
                    t2["cent"] = 500;
                    t2["sterling"] = 500;
                    t2["fraction"] = 167;
                    t2["yen"] = 500;
                    t2["florin"] = 500;
                    t2["section"] = 500;
                    t2["currency"] = 500;
                    t2["quotesingle"] = 180;
                    t2["quotedblleft"] = 444;
                    t2["guillemotleft"] = 500;
                    t2["guilsinglleft"] = 333;
                    t2["guilsinglright"] = 333;
                    t2["fi"] = 556;
                    t2["fl"] = 556;
                    t2["endash"] = 500;
                    t2["dagger"] = 500;
                    t2["daggerdbl"] = 500;
                    t2["periodcentered"] = 250;
                    t2["paragraph"] = 453;
                    t2["bullet"] = 350;
                    t2["quotesinglbase"] = 333;
                    t2["quotedblbase"] = 444;
                    t2["quotedblright"] = 444;
                    t2["guillemotright"] = 500;
                    t2["ellipsis"] = 1e3;
                    t2["perthousand"] = 1e3;
                    t2["questiondown"] = 444;
                    t2["grave"] = 333;
                    t2["acute"] = 333;
                    t2["circumflex"] = 333;
                    t2["tilde"] = 333;
                    t2["macron"] = 333;
                    t2["breve"] = 333;
                    t2["dotaccent"] = 333;
                    t2["dieresis"] = 333;
                    t2["ring"] = 333;
                    t2["cedilla"] = 333;
                    t2["hungarumlaut"] = 333;
                    t2["ogonek"] = 333;
                    t2["caron"] = 333;
                    t2["emdash"] = 1e3;
                    t2["AE"] = 889;
                    t2["ordfeminine"] = 276;
                    t2["Lslash"] = 611;
                    t2["Oslash"] = 722;
                    t2["OE"] = 889;
                    t2["ordmasculine"] = 310;
                    t2["ae"] = 667;
                    t2["dotlessi"] = 278;
                    t2["lslash"] = 278;
                    t2["oslash"] = 500;
                    t2["oe"] = 722;
                    t2["germandbls"] = 500;
                    t2["Idieresis"] = 333;
                    t2["eacute"] = 444;
                    t2["abreve"] = 444;
                    t2["uhungarumlaut"] = 500;
                    t2["ecaron"] = 444;
                    t2["Ydieresis"] = 722;
                    t2["divide"] = 564;
                    t2["Yacute"] = 722;
                    t2["Acircumflex"] = 722;
                    t2["aacute"] = 444;
                    t2["Ucircumflex"] = 722;
                    t2["yacute"] = 500;
                    t2["scommaaccent"] = 389;
                    t2["ecircumflex"] = 444;
                    t2["Uring"] = 722;
                    t2["Udieresis"] = 722;
                    t2["aogonek"] = 444;
                    t2["Uacute"] = 722;
                    t2["uogonek"] = 500;
                    t2["Edieresis"] = 611;
                    t2["Dcroat"] = 722;
                    t2["commaaccent"] = 250;
                    t2["copyright"] = 760;
                    t2["Emacron"] = 611;
                    t2["ccaron"] = 444;
                    t2["aring"] = 444;
                    t2["Ncommaaccent"] = 722;
                    t2["lacute"] = 278;
                    t2["agrave"] = 444;
                    t2["Tcommaaccent"] = 611;
                    t2["Cacute"] = 667;
                    t2["atilde"] = 444;
                    t2["Edotaccent"] = 611;
                    t2["scaron"] = 389;
                    t2["scedilla"] = 389;
                    t2["iacute"] = 278;
                    t2["lozenge"] = 471;
                    t2["Rcaron"] = 667;
                    t2["Gcommaaccent"] = 722;
                    t2["ucircumflex"] = 500;
                    t2["acircumflex"] = 444;
                    t2["Amacron"] = 722;
                    t2["rcaron"] = 333;
                    t2["ccedilla"] = 444;
                    t2["Zdotaccent"] = 611;
                    t2["Thorn"] = 556;
                    t2["Omacron"] = 722;
                    t2["Racute"] = 667;
                    t2["Sacute"] = 556;
                    t2["dcaron"] = 588;
                    t2["Umacron"] = 722;
                    t2["uring"] = 500;
                    t2["threesuperior"] = 300;
                    t2["Ograve"] = 722;
                    t2["Agrave"] = 722;
                    t2["Abreve"] = 722;
                    t2["multiply"] = 564;
                    t2["uacute"] = 500;
                    t2["Tcaron"] = 611;
                    t2["partialdiff"] = 476;
                    t2["ydieresis"] = 500;
                    t2["Nacute"] = 722;
                    t2["icircumflex"] = 278;
                    t2["Ecircumflex"] = 611;
                    t2["adieresis"] = 444;
                    t2["edieresis"] = 444;
                    t2["cacute"] = 444;
                    t2["nacute"] = 500;
                    t2["umacron"] = 500;
                    t2["Ncaron"] = 722;
                    t2["Iacute"] = 333;
                    t2["plusminus"] = 564;
                    t2["brokenbar"] = 200;
                    t2["registered"] = 760;
                    t2["Gbreve"] = 722;
                    t2["Idotaccent"] = 333;
                    t2["summation"] = 600;
                    t2["Egrave"] = 611;
                    t2["racute"] = 333;
                    t2["omacron"] = 500;
                    t2["Zacute"] = 611;
                    t2["Zcaron"] = 611;
                    t2["greaterequal"] = 549;
                    t2["Eth"] = 722;
                    t2["Ccedilla"] = 667;
                    t2["lcommaaccent"] = 278;
                    t2["tcaron"] = 326;
                    t2["eogonek"] = 444;
                    t2["Uogonek"] = 722;
                    t2["Aacute"] = 722;
                    t2["Adieresis"] = 722;
                    t2["egrave"] = 444;
                    t2["zacute"] = 444;
                    t2["iogonek"] = 278;
                    t2["Oacute"] = 722;
                    t2["oacute"] = 500;
                    t2["amacron"] = 444;
                    t2["sacute"] = 389;
                    t2["idieresis"] = 278;
                    t2["Ocircumflex"] = 722;
                    t2["Ugrave"] = 722;
                    t2["Delta"] = 612;
                    t2["thorn"] = 500;
                    t2["twosuperior"] = 300;
                    t2["Odieresis"] = 722;
                    t2["mu"] = 500;
                    t2["igrave"] = 278;
                    t2["ohungarumlaut"] = 500;
                    t2["Eogonek"] = 611;
                    t2["dcroat"] = 500;
                    t2["threequarters"] = 750;
                    t2["Scedilla"] = 556;
                    t2["lcaron"] = 344;
                    t2["Kcommaaccent"] = 722;
                    t2["Lacute"] = 611;
                    t2["trademark"] = 980;
                    t2["edotaccent"] = 444;
                    t2["Igrave"] = 333;
                    t2["Imacron"] = 333;
                    t2["Lcaron"] = 611;
                    t2["onehalf"] = 750;
                    t2["lessequal"] = 549;
                    t2["ocircumflex"] = 500;
                    t2["ntilde"] = 500;
                    t2["Uhungarumlaut"] = 722;
                    t2["Eacute"] = 611;
                    t2["emacron"] = 444;
                    t2["gbreve"] = 500;
                    t2["onequarter"] = 750;
                    t2["Scaron"] = 556;
                    t2["Scommaaccent"] = 556;
                    t2["Ohungarumlaut"] = 722;
                    t2["degree"] = 400;
                    t2["ograve"] = 500;
                    t2["Ccaron"] = 667;
                    t2["ugrave"] = 500;
                    t2["radical"] = 453;
                    t2["Dcaron"] = 722;
                    t2["rcommaaccent"] = 333;
                    t2["Ntilde"] = 722;
                    t2["otilde"] = 500;
                    t2["Rcommaaccent"] = 667;
                    t2["Lcommaaccent"] = 611;
                    t2["Atilde"] = 722;
                    t2["Aogonek"] = 722;
                    t2["Aring"] = 722;
                    t2["Otilde"] = 722;
                    t2["zdotaccent"] = 444;
                    t2["Ecaron"] = 611;
                    t2["Iogonek"] = 333;
                    t2["kcommaaccent"] = 500;
                    t2["minus"] = 564;
                    t2["Icircumflex"] = 333;
                    t2["ncaron"] = 500;
                    t2["tcommaaccent"] = 278;
                    t2["logicalnot"] = 564;
                    t2["odieresis"] = 500;
                    t2["udieresis"] = 500;
                    t2["notequal"] = 549;
                    t2["gcommaaccent"] = 500;
                    t2["eth"] = 500;
                    t2["zcaron"] = 444;
                    t2["ncommaaccent"] = 500;
                    t2["onesuperior"] = 300;
                    t2["imacron"] = 278;
                    t2["Euro"] = 500;
                  });
                  t["Times-Bold"] = (0, _core_utils.getLookupTableFactory)(function(t2) {
                    t2["space"] = 250;
                    t2["exclam"] = 333;
                    t2["quotedbl"] = 555;
                    t2["numbersign"] = 500;
                    t2["dollar"] = 500;
                    t2["percent"] = 1e3;
                    t2["ampersand"] = 833;
                    t2["quoteright"] = 333;
                    t2["parenleft"] = 333;
                    t2["parenright"] = 333;
                    t2["asterisk"] = 500;
                    t2["plus"] = 570;
                    t2["comma"] = 250;
                    t2["hyphen"] = 333;
                    t2["period"] = 250;
                    t2["slash"] = 278;
                    t2["zero"] = 500;
                    t2["one"] = 500;
                    t2["two"] = 500;
                    t2["three"] = 500;
                    t2["four"] = 500;
                    t2["five"] = 500;
                    t2["six"] = 500;
                    t2["seven"] = 500;
                    t2["eight"] = 500;
                    t2["nine"] = 500;
                    t2["colon"] = 333;
                    t2["semicolon"] = 333;
                    t2["less"] = 570;
                    t2["equal"] = 570;
                    t2["greater"] = 570;
                    t2["question"] = 500;
                    t2["at"] = 930;
                    t2["A"] = 722;
                    t2["B"] = 667;
                    t2["C"] = 722;
                    t2["D"] = 722;
                    t2["E"] = 667;
                    t2["F"] = 611;
                    t2["G"] = 778;
                    t2["H"] = 778;
                    t2["I"] = 389;
                    t2["J"] = 500;
                    t2["K"] = 778;
                    t2["L"] = 667;
                    t2["M"] = 944;
                    t2["N"] = 722;
                    t2["O"] = 778;
                    t2["P"] = 611;
                    t2["Q"] = 778;
                    t2["R"] = 722;
                    t2["S"] = 556;
                    t2["T"] = 667;
                    t2["U"] = 722;
                    t2["V"] = 722;
                    t2["W"] = 1e3;
                    t2["X"] = 722;
                    t2["Y"] = 722;
                    t2["Z"] = 667;
                    t2["bracketleft"] = 333;
                    t2["backslash"] = 278;
                    t2["bracketright"] = 333;
                    t2["asciicircum"] = 581;
                    t2["underscore"] = 500;
                    t2["quoteleft"] = 333;
                    t2["a"] = 500;
                    t2["b"] = 556;
                    t2["c"] = 444;
                    t2["d"] = 556;
                    t2["e"] = 444;
                    t2["f"] = 333;
                    t2["g"] = 500;
                    t2["h"] = 556;
                    t2["i"] = 278;
                    t2["j"] = 333;
                    t2["k"] = 556;
                    t2["l"] = 278;
                    t2["m"] = 833;
                    t2["n"] = 556;
                    t2["o"] = 500;
                    t2["p"] = 556;
                    t2["q"] = 556;
                    t2["r"] = 444;
                    t2["s"] = 389;
                    t2["t"] = 333;
                    t2["u"] = 556;
                    t2["v"] = 500;
                    t2["w"] = 722;
                    t2["x"] = 500;
                    t2["y"] = 500;
                    t2["z"] = 444;
                    t2["braceleft"] = 394;
                    t2["bar"] = 220;
                    t2["braceright"] = 394;
                    t2["asciitilde"] = 520;
                    t2["exclamdown"] = 333;
                    t2["cent"] = 500;
                    t2["sterling"] = 500;
                    t2["fraction"] = 167;
                    t2["yen"] = 500;
                    t2["florin"] = 500;
                    t2["section"] = 500;
                    t2["currency"] = 500;
                    t2["quotesingle"] = 278;
                    t2["quotedblleft"] = 500;
                    t2["guillemotleft"] = 500;
                    t2["guilsinglleft"] = 333;
                    t2["guilsinglright"] = 333;
                    t2["fi"] = 556;
                    t2["fl"] = 556;
                    t2["endash"] = 500;
                    t2["dagger"] = 500;
                    t2["daggerdbl"] = 500;
                    t2["periodcentered"] = 250;
                    t2["paragraph"] = 540;
                    t2["bullet"] = 350;
                    t2["quotesinglbase"] = 333;
                    t2["quotedblbase"] = 500;
                    t2["quotedblright"] = 500;
                    t2["guillemotright"] = 500;
                    t2["ellipsis"] = 1e3;
                    t2["perthousand"] = 1e3;
                    t2["questiondown"] = 500;
                    t2["grave"] = 333;
                    t2["acute"] = 333;
                    t2["circumflex"] = 333;
                    t2["tilde"] = 333;
                    t2["macron"] = 333;
                    t2["breve"] = 333;
                    t2["dotaccent"] = 333;
                    t2["dieresis"] = 333;
                    t2["ring"] = 333;
                    t2["cedilla"] = 333;
                    t2["hungarumlaut"] = 333;
                    t2["ogonek"] = 333;
                    t2["caron"] = 333;
                    t2["emdash"] = 1e3;
                    t2["AE"] = 1e3;
                    t2["ordfeminine"] = 300;
                    t2["Lslash"] = 667;
                    t2["Oslash"] = 778;
                    t2["OE"] = 1e3;
                    t2["ordmasculine"] = 330;
                    t2["ae"] = 722;
                    t2["dotlessi"] = 278;
                    t2["lslash"] = 278;
                    t2["oslash"] = 500;
                    t2["oe"] = 722;
                    t2["germandbls"] = 556;
                    t2["Idieresis"] = 389;
                    t2["eacute"] = 444;
                    t2["abreve"] = 500;
                    t2["uhungarumlaut"] = 556;
                    t2["ecaron"] = 444;
                    t2["Ydieresis"] = 722;
                    t2["divide"] = 570;
                    t2["Yacute"] = 722;
                    t2["Acircumflex"] = 722;
                    t2["aacute"] = 500;
                    t2["Ucircumflex"] = 722;
                    t2["yacute"] = 500;
                    t2["scommaaccent"] = 389;
                    t2["ecircumflex"] = 444;
                    t2["Uring"] = 722;
                    t2["Udieresis"] = 722;
                    t2["aogonek"] = 500;
                    t2["Uacute"] = 722;
                    t2["uogonek"] = 556;
                    t2["Edieresis"] = 667;
                    t2["Dcroat"] = 722;
                    t2["commaaccent"] = 250;
                    t2["copyright"] = 747;
                    t2["Emacron"] = 667;
                    t2["ccaron"] = 444;
                    t2["aring"] = 500;
                    t2["Ncommaaccent"] = 722;
                    t2["lacute"] = 278;
                    t2["agrave"] = 500;
                    t2["Tcommaaccent"] = 667;
                    t2["Cacute"] = 722;
                    t2["atilde"] = 500;
                    t2["Edotaccent"] = 667;
                    t2["scaron"] = 389;
                    t2["scedilla"] = 389;
                    t2["iacute"] = 278;
                    t2["lozenge"] = 494;
                    t2["Rcaron"] = 722;
                    t2["Gcommaaccent"] = 778;
                    t2["ucircumflex"] = 556;
                    t2["acircumflex"] = 500;
                    t2["Amacron"] = 722;
                    t2["rcaron"] = 444;
                    t2["ccedilla"] = 444;
                    t2["Zdotaccent"] = 667;
                    t2["Thorn"] = 611;
                    t2["Omacron"] = 778;
                    t2["Racute"] = 722;
                    t2["Sacute"] = 556;
                    t2["dcaron"] = 672;
                    t2["Umacron"] = 722;
                    t2["uring"] = 556;
                    t2["threesuperior"] = 300;
                    t2["Ograve"] = 778;
                    t2["Agrave"] = 722;
                    t2["Abreve"] = 722;
                    t2["multiply"] = 570;
                    t2["uacute"] = 556;
                    t2["Tcaron"] = 667;
                    t2["partialdiff"] = 494;
                    t2["ydieresis"] = 500;
                    t2["Nacute"] = 722;
                    t2["icircumflex"] = 278;
                    t2["Ecircumflex"] = 667;
                    t2["adieresis"] = 500;
                    t2["edieresis"] = 444;
                    t2["cacute"] = 444;
                    t2["nacute"] = 556;
                    t2["umacron"] = 556;
                    t2["Ncaron"] = 722;
                    t2["Iacute"] = 389;
                    t2["plusminus"] = 570;
                    t2["brokenbar"] = 220;
                    t2["registered"] = 747;
                    t2["Gbreve"] = 778;
                    t2["Idotaccent"] = 389;
                    t2["summation"] = 600;
                    t2["Egrave"] = 667;
                    t2["racute"] = 444;
                    t2["omacron"] = 500;
                    t2["Zacute"] = 667;
                    t2["Zcaron"] = 667;
                    t2["greaterequal"] = 549;
                    t2["Eth"] = 722;
                    t2["Ccedilla"] = 722;
                    t2["lcommaaccent"] = 278;
                    t2["tcaron"] = 416;
                    t2["eogonek"] = 444;
                    t2["Uogonek"] = 722;
                    t2["Aacute"] = 722;
                    t2["Adieresis"] = 722;
                    t2["egrave"] = 444;
                    t2["zacute"] = 444;
                    t2["iogonek"] = 278;
                    t2["Oacute"] = 778;
                    t2["oacute"] = 500;
                    t2["amacron"] = 500;
                    t2["sacute"] = 389;
                    t2["idieresis"] = 278;
                    t2["Ocircumflex"] = 778;
                    t2["Ugrave"] = 722;
                    t2["Delta"] = 612;
                    t2["thorn"] = 556;
                    t2["twosuperior"] = 300;
                    t2["Odieresis"] = 778;
                    t2["mu"] = 556;
                    t2["igrave"] = 278;
                    t2["ohungarumlaut"] = 500;
                    t2["Eogonek"] = 667;
                    t2["dcroat"] = 556;
                    t2["threequarters"] = 750;
                    t2["Scedilla"] = 556;
                    t2["lcaron"] = 394;
                    t2["Kcommaaccent"] = 778;
                    t2["Lacute"] = 667;
                    t2["trademark"] = 1e3;
                    t2["edotaccent"] = 444;
                    t2["Igrave"] = 389;
                    t2["Imacron"] = 389;
                    t2["Lcaron"] = 667;
                    t2["onehalf"] = 750;
                    t2["lessequal"] = 549;
                    t2["ocircumflex"] = 500;
                    t2["ntilde"] = 556;
                    t2["Uhungarumlaut"] = 722;
                    t2["Eacute"] = 667;
                    t2["emacron"] = 444;
                    t2["gbreve"] = 500;
                    t2["onequarter"] = 750;
                    t2["Scaron"] = 556;
                    t2["Scommaaccent"] = 556;
                    t2["Ohungarumlaut"] = 778;
                    t2["degree"] = 400;
                    t2["ograve"] = 500;
                    t2["Ccaron"] = 722;
                    t2["ugrave"] = 556;
                    t2["radical"] = 549;
                    t2["Dcaron"] = 722;
                    t2["rcommaaccent"] = 444;
                    t2["Ntilde"] = 722;
                    t2["otilde"] = 500;
                    t2["Rcommaaccent"] = 722;
                    t2["Lcommaaccent"] = 667;
                    t2["Atilde"] = 722;
                    t2["Aogonek"] = 722;
                    t2["Aring"] = 722;
                    t2["Otilde"] = 778;
                    t2["zdotaccent"] = 444;
                    t2["Ecaron"] = 667;
                    t2["Iogonek"] = 389;
                    t2["kcommaaccent"] = 556;
                    t2["minus"] = 570;
                    t2["Icircumflex"] = 389;
                    t2["ncaron"] = 556;
                    t2["tcommaaccent"] = 333;
                    t2["logicalnot"] = 570;
                    t2["odieresis"] = 500;
                    t2["udieresis"] = 556;
                    t2["notequal"] = 549;
                    t2["gcommaaccent"] = 500;
                    t2["eth"] = 500;
                    t2["zcaron"] = 444;
                    t2["ncommaaccent"] = 556;
                    t2["onesuperior"] = 300;
                    t2["imacron"] = 278;
                    t2["Euro"] = 500;
                  });
                  t["Times-BoldItalic"] = (0, _core_utils.getLookupTableFactory)(function(t2) {
                    t2["space"] = 250;
                    t2["exclam"] = 389;
                    t2["quotedbl"] = 555;
                    t2["numbersign"] = 500;
                    t2["dollar"] = 500;
                    t2["percent"] = 833;
                    t2["ampersand"] = 778;
                    t2["quoteright"] = 333;
                    t2["parenleft"] = 333;
                    t2["parenright"] = 333;
                    t2["asterisk"] = 500;
                    t2["plus"] = 570;
                    t2["comma"] = 250;
                    t2["hyphen"] = 333;
                    t2["period"] = 250;
                    t2["slash"] = 278;
                    t2["zero"] = 500;
                    t2["one"] = 500;
                    t2["two"] = 500;
                    t2["three"] = 500;
                    t2["four"] = 500;
                    t2["five"] = 500;
                    t2["six"] = 500;
                    t2["seven"] = 500;
                    t2["eight"] = 500;
                    t2["nine"] = 500;
                    t2["colon"] = 333;
                    t2["semicolon"] = 333;
                    t2["less"] = 570;
                    t2["equal"] = 570;
                    t2["greater"] = 570;
                    t2["question"] = 500;
                    t2["at"] = 832;
                    t2["A"] = 667;
                    t2["B"] = 667;
                    t2["C"] = 667;
                    t2["D"] = 722;
                    t2["E"] = 667;
                    t2["F"] = 667;
                    t2["G"] = 722;
                    t2["H"] = 778;
                    t2["I"] = 389;
                    t2["J"] = 500;
                    t2["K"] = 667;
                    t2["L"] = 611;
                    t2["M"] = 889;
                    t2["N"] = 722;
                    t2["O"] = 722;
                    t2["P"] = 611;
                    t2["Q"] = 722;
                    t2["R"] = 667;
                    t2["S"] = 556;
                    t2["T"] = 611;
                    t2["U"] = 722;
                    t2["V"] = 667;
                    t2["W"] = 889;
                    t2["X"] = 667;
                    t2["Y"] = 611;
                    t2["Z"] = 611;
                    t2["bracketleft"] = 333;
                    t2["backslash"] = 278;
                    t2["bracketright"] = 333;
                    t2["asciicircum"] = 570;
                    t2["underscore"] = 500;
                    t2["quoteleft"] = 333;
                    t2["a"] = 500;
                    t2["b"] = 500;
                    t2["c"] = 444;
                    t2["d"] = 500;
                    t2["e"] = 444;
                    t2["f"] = 333;
                    t2["g"] = 500;
                    t2["h"] = 556;
                    t2["i"] = 278;
                    t2["j"] = 278;
                    t2["k"] = 500;
                    t2["l"] = 278;
                    t2["m"] = 778;
                    t2["n"] = 556;
                    t2["o"] = 500;
                    t2["p"] = 500;
                    t2["q"] = 500;
                    t2["r"] = 389;
                    t2["s"] = 389;
                    t2["t"] = 278;
                    t2["u"] = 556;
                    t2["v"] = 444;
                    t2["w"] = 667;
                    t2["x"] = 500;
                    t2["y"] = 444;
                    t2["z"] = 389;
                    t2["braceleft"] = 348;
                    t2["bar"] = 220;
                    t2["braceright"] = 348;
                    t2["asciitilde"] = 570;
                    t2["exclamdown"] = 389;
                    t2["cent"] = 500;
                    t2["sterling"] = 500;
                    t2["fraction"] = 167;
                    t2["yen"] = 500;
                    t2["florin"] = 500;
                    t2["section"] = 500;
                    t2["currency"] = 500;
                    t2["quotesingle"] = 278;
                    t2["quotedblleft"] = 500;
                    t2["guillemotleft"] = 500;
                    t2["guilsinglleft"] = 333;
                    t2["guilsinglright"] = 333;
                    t2["fi"] = 556;
                    t2["fl"] = 556;
                    t2["endash"] = 500;
                    t2["dagger"] = 500;
                    t2["daggerdbl"] = 500;
                    t2["periodcentered"] = 250;
                    t2["paragraph"] = 500;
                    t2["bullet"] = 350;
                    t2["quotesinglbase"] = 333;
                    t2["quotedblbase"] = 500;
                    t2["quotedblright"] = 500;
                    t2["guillemotright"] = 500;
                    t2["ellipsis"] = 1e3;
                    t2["perthousand"] = 1e3;
                    t2["questiondown"] = 500;
                    t2["grave"] = 333;
                    t2["acute"] = 333;
                    t2["circumflex"] = 333;
                    t2["tilde"] = 333;
                    t2["macron"] = 333;
                    t2["breve"] = 333;
                    t2["dotaccent"] = 333;
                    t2["dieresis"] = 333;
                    t2["ring"] = 333;
                    t2["cedilla"] = 333;
                    t2["hungarumlaut"] = 333;
                    t2["ogonek"] = 333;
                    t2["caron"] = 333;
                    t2["emdash"] = 1e3;
                    t2["AE"] = 944;
                    t2["ordfeminine"] = 266;
                    t2["Lslash"] = 611;
                    t2["Oslash"] = 722;
                    t2["OE"] = 944;
                    t2["ordmasculine"] = 300;
                    t2["ae"] = 722;
                    t2["dotlessi"] = 278;
                    t2["lslash"] = 278;
                    t2["oslash"] = 500;
                    t2["oe"] = 722;
                    t2["germandbls"] = 500;
                    t2["Idieresis"] = 389;
                    t2["eacute"] = 444;
                    t2["abreve"] = 500;
                    t2["uhungarumlaut"] = 556;
                    t2["ecaron"] = 444;
                    t2["Ydieresis"] = 611;
                    t2["divide"] = 570;
                    t2["Yacute"] = 611;
                    t2["Acircumflex"] = 667;
                    t2["aacute"] = 500;
                    t2["Ucircumflex"] = 722;
                    t2["yacute"] = 444;
                    t2["scommaaccent"] = 389;
                    t2["ecircumflex"] = 444;
                    t2["Uring"] = 722;
                    t2["Udieresis"] = 722;
                    t2["aogonek"] = 500;
                    t2["Uacute"] = 722;
                    t2["uogonek"] = 556;
                    t2["Edieresis"] = 667;
                    t2["Dcroat"] = 722;
                    t2["commaaccent"] = 250;
                    t2["copyright"] = 747;
                    t2["Emacron"] = 667;
                    t2["ccaron"] = 444;
                    t2["aring"] = 500;
                    t2["Ncommaaccent"] = 722;
                    t2["lacute"] = 278;
                    t2["agrave"] = 500;
                    t2["Tcommaaccent"] = 611;
                    t2["Cacute"] = 667;
                    t2["atilde"] = 500;
                    t2["Edotaccent"] = 667;
                    t2["scaron"] = 389;
                    t2["scedilla"] = 389;
                    t2["iacute"] = 278;
                    t2["lozenge"] = 494;
                    t2["Rcaron"] = 667;
                    t2["Gcommaaccent"] = 722;
                    t2["ucircumflex"] = 556;
                    t2["acircumflex"] = 500;
                    t2["Amacron"] = 667;
                    t2["rcaron"] = 389;
                    t2["ccedilla"] = 444;
                    t2["Zdotaccent"] = 611;
                    t2["Thorn"] = 611;
                    t2["Omacron"] = 722;
                    t2["Racute"] = 667;
                    t2["Sacute"] = 556;
                    t2["dcaron"] = 608;
                    t2["Umacron"] = 722;
                    t2["uring"] = 556;
                    t2["threesuperior"] = 300;
                    t2["Ograve"] = 722;
                    t2["Agrave"] = 667;
                    t2["Abreve"] = 667;
                    t2["multiply"] = 570;
                    t2["uacute"] = 556;
                    t2["Tcaron"] = 611;
                    t2["partialdiff"] = 494;
                    t2["ydieresis"] = 444;
                    t2["Nacute"] = 722;
                    t2["icircumflex"] = 278;
                    t2["Ecircumflex"] = 667;
                    t2["adieresis"] = 500;
                    t2["edieresis"] = 444;
                    t2["cacute"] = 444;
                    t2["nacute"] = 556;
                    t2["umacron"] = 556;
                    t2["Ncaron"] = 722;
                    t2["Iacute"] = 389;
                    t2["plusminus"] = 570;
                    t2["brokenbar"] = 220;
                    t2["registered"] = 747;
                    t2["Gbreve"] = 722;
                    t2["Idotaccent"] = 389;
                    t2["summation"] = 600;
                    t2["Egrave"] = 667;
                    t2["racute"] = 389;
                    t2["omacron"] = 500;
                    t2["Zacute"] = 611;
                    t2["Zcaron"] = 611;
                    t2["greaterequal"] = 549;
                    t2["Eth"] = 722;
                    t2["Ccedilla"] = 667;
                    t2["lcommaaccent"] = 278;
                    t2["tcaron"] = 366;
                    t2["eogonek"] = 444;
                    t2["Uogonek"] = 722;
                    t2["Aacute"] = 667;
                    t2["Adieresis"] = 667;
                    t2["egrave"] = 444;
                    t2["zacute"] = 389;
                    t2["iogonek"] = 278;
                    t2["Oacute"] = 722;
                    t2["oacute"] = 500;
                    t2["amacron"] = 500;
                    t2["sacute"] = 389;
                    t2["idieresis"] = 278;
                    t2["Ocircumflex"] = 722;
                    t2["Ugrave"] = 722;
                    t2["Delta"] = 612;
                    t2["thorn"] = 500;
                    t2["twosuperior"] = 300;
                    t2["Odieresis"] = 722;
                    t2["mu"] = 576;
                    t2["igrave"] = 278;
                    t2["ohungarumlaut"] = 500;
                    t2["Eogonek"] = 667;
                    t2["dcroat"] = 500;
                    t2["threequarters"] = 750;
                    t2["Scedilla"] = 556;
                    t2["lcaron"] = 382;
                    t2["Kcommaaccent"] = 667;
                    t2["Lacute"] = 611;
                    t2["trademark"] = 1e3;
                    t2["edotaccent"] = 444;
                    t2["Igrave"] = 389;
                    t2["Imacron"] = 389;
                    t2["Lcaron"] = 611;
                    t2["onehalf"] = 750;
                    t2["lessequal"] = 549;
                    t2["ocircumflex"] = 500;
                    t2["ntilde"] = 556;
                    t2["Uhungarumlaut"] = 722;
                    t2["Eacute"] = 667;
                    t2["emacron"] = 444;
                    t2["gbreve"] = 500;
                    t2["onequarter"] = 750;
                    t2["Scaron"] = 556;
                    t2["Scommaaccent"] = 556;
                    t2["Ohungarumlaut"] = 722;
                    t2["degree"] = 400;
                    t2["ograve"] = 500;
                    t2["Ccaron"] = 667;
                    t2["ugrave"] = 556;
                    t2["radical"] = 549;
                    t2["Dcaron"] = 722;
                    t2["rcommaaccent"] = 389;
                    t2["Ntilde"] = 722;
                    t2["otilde"] = 500;
                    t2["Rcommaaccent"] = 667;
                    t2["Lcommaaccent"] = 611;
                    t2["Atilde"] = 667;
                    t2["Aogonek"] = 667;
                    t2["Aring"] = 667;
                    t2["Otilde"] = 722;
                    t2["zdotaccent"] = 389;
                    t2["Ecaron"] = 667;
                    t2["Iogonek"] = 389;
                    t2["kcommaaccent"] = 500;
                    t2["minus"] = 606;
                    t2["Icircumflex"] = 389;
                    t2["ncaron"] = 556;
                    t2["tcommaaccent"] = 278;
                    t2["logicalnot"] = 606;
                    t2["odieresis"] = 500;
                    t2["udieresis"] = 556;
                    t2["notequal"] = 549;
                    t2["gcommaaccent"] = 500;
                    t2["eth"] = 500;
                    t2["zcaron"] = 389;
                    t2["ncommaaccent"] = 556;
                    t2["onesuperior"] = 300;
                    t2["imacron"] = 278;
                    t2["Euro"] = 500;
                  });
                  t["Times-Italic"] = (0, _core_utils.getLookupTableFactory)(function(t2) {
                    t2["space"] = 250;
                    t2["exclam"] = 333;
                    t2["quotedbl"] = 420;
                    t2["numbersign"] = 500;
                    t2["dollar"] = 500;
                    t2["percent"] = 833;
                    t2["ampersand"] = 778;
                    t2["quoteright"] = 333;
                    t2["parenleft"] = 333;
                    t2["parenright"] = 333;
                    t2["asterisk"] = 500;
                    t2["plus"] = 675;
                    t2["comma"] = 250;
                    t2["hyphen"] = 333;
                    t2["period"] = 250;
                    t2["slash"] = 278;
                    t2["zero"] = 500;
                    t2["one"] = 500;
                    t2["two"] = 500;
                    t2["three"] = 500;
                    t2["four"] = 500;
                    t2["five"] = 500;
                    t2["six"] = 500;
                    t2["seven"] = 500;
                    t2["eight"] = 500;
                    t2["nine"] = 500;
                    t2["colon"] = 333;
                    t2["semicolon"] = 333;
                    t2["less"] = 675;
                    t2["equal"] = 675;
                    t2["greater"] = 675;
                    t2["question"] = 500;
                    t2["at"] = 920;
                    t2["A"] = 611;
                    t2["B"] = 611;
                    t2["C"] = 667;
                    t2["D"] = 722;
                    t2["E"] = 611;
                    t2["F"] = 611;
                    t2["G"] = 722;
                    t2["H"] = 722;
                    t2["I"] = 333;
                    t2["J"] = 444;
                    t2["K"] = 667;
                    t2["L"] = 556;
                    t2["M"] = 833;
                    t2["N"] = 667;
                    t2["O"] = 722;
                    t2["P"] = 611;
                    t2["Q"] = 722;
                    t2["R"] = 611;
                    t2["S"] = 500;
                    t2["T"] = 556;
                    t2["U"] = 722;
                    t2["V"] = 611;
                    t2["W"] = 833;
                    t2["X"] = 611;
                    t2["Y"] = 556;
                    t2["Z"] = 556;
                    t2["bracketleft"] = 389;
                    t2["backslash"] = 278;
                    t2["bracketright"] = 389;
                    t2["asciicircum"] = 422;
                    t2["underscore"] = 500;
                    t2["quoteleft"] = 333;
                    t2["a"] = 500;
                    t2["b"] = 500;
                    t2["c"] = 444;
                    t2["d"] = 500;
                    t2["e"] = 444;
                    t2["f"] = 278;
                    t2["g"] = 500;
                    t2["h"] = 500;
                    t2["i"] = 278;
                    t2["j"] = 278;
                    t2["k"] = 444;
                    t2["l"] = 278;
                    t2["m"] = 722;
                    t2["n"] = 500;
                    t2["o"] = 500;
                    t2["p"] = 500;
                    t2["q"] = 500;
                    t2["r"] = 389;
                    t2["s"] = 389;
                    t2["t"] = 278;
                    t2["u"] = 500;
                    t2["v"] = 444;
                    t2["w"] = 667;
                    t2["x"] = 444;
                    t2["y"] = 444;
                    t2["z"] = 389;
                    t2["braceleft"] = 400;
                    t2["bar"] = 275;
                    t2["braceright"] = 400;
                    t2["asciitilde"] = 541;
                    t2["exclamdown"] = 389;
                    t2["cent"] = 500;
                    t2["sterling"] = 500;
                    t2["fraction"] = 167;
                    t2["yen"] = 500;
                    t2["florin"] = 500;
                    t2["section"] = 500;
                    t2["currency"] = 500;
                    t2["quotesingle"] = 214;
                    t2["quotedblleft"] = 556;
                    t2["guillemotleft"] = 500;
                    t2["guilsinglleft"] = 333;
                    t2["guilsinglright"] = 333;
                    t2["fi"] = 500;
                    t2["fl"] = 500;
                    t2["endash"] = 500;
                    t2["dagger"] = 500;
                    t2["daggerdbl"] = 500;
                    t2["periodcentered"] = 250;
                    t2["paragraph"] = 523;
                    t2["bullet"] = 350;
                    t2["quotesinglbase"] = 333;
                    t2["quotedblbase"] = 556;
                    t2["quotedblright"] = 556;
                    t2["guillemotright"] = 500;
                    t2["ellipsis"] = 889;
                    t2["perthousand"] = 1e3;
                    t2["questiondown"] = 500;
                    t2["grave"] = 333;
                    t2["acute"] = 333;
                    t2["circumflex"] = 333;
                    t2["tilde"] = 333;
                    t2["macron"] = 333;
                    t2["breve"] = 333;
                    t2["dotaccent"] = 333;
                    t2["dieresis"] = 333;
                    t2["ring"] = 333;
                    t2["cedilla"] = 333;
                    t2["hungarumlaut"] = 333;
                    t2["ogonek"] = 333;
                    t2["caron"] = 333;
                    t2["emdash"] = 889;
                    t2["AE"] = 889;
                    t2["ordfeminine"] = 276;
                    t2["Lslash"] = 556;
                    t2["Oslash"] = 722;
                    t2["OE"] = 944;
                    t2["ordmasculine"] = 310;
                    t2["ae"] = 667;
                    t2["dotlessi"] = 278;
                    t2["lslash"] = 278;
                    t2["oslash"] = 500;
                    t2["oe"] = 667;
                    t2["germandbls"] = 500;
                    t2["Idieresis"] = 333;
                    t2["eacute"] = 444;
                    t2["abreve"] = 500;
                    t2["uhungarumlaut"] = 500;
                    t2["ecaron"] = 444;
                    t2["Ydieresis"] = 556;
                    t2["divide"] = 675;
                    t2["Yacute"] = 556;
                    t2["Acircumflex"] = 611;
                    t2["aacute"] = 500;
                    t2["Ucircumflex"] = 722;
                    t2["yacute"] = 444;
                    t2["scommaaccent"] = 389;
                    t2["ecircumflex"] = 444;
                    t2["Uring"] = 722;
                    t2["Udieresis"] = 722;
                    t2["aogonek"] = 500;
                    t2["Uacute"] = 722;
                    t2["uogonek"] = 500;
                    t2["Edieresis"] = 611;
                    t2["Dcroat"] = 722;
                    t2["commaaccent"] = 250;
                    t2["copyright"] = 760;
                    t2["Emacron"] = 611;
                    t2["ccaron"] = 444;
                    t2["aring"] = 500;
                    t2["Ncommaaccent"] = 667;
                    t2["lacute"] = 278;
                    t2["agrave"] = 500;
                    t2["Tcommaaccent"] = 556;
                    t2["Cacute"] = 667;
                    t2["atilde"] = 500;
                    t2["Edotaccent"] = 611;
                    t2["scaron"] = 389;
                    t2["scedilla"] = 389;
                    t2["iacute"] = 278;
                    t2["lozenge"] = 471;
                    t2["Rcaron"] = 611;
                    t2["Gcommaaccent"] = 722;
                    t2["ucircumflex"] = 500;
                    t2["acircumflex"] = 500;
                    t2["Amacron"] = 611;
                    t2["rcaron"] = 389;
                    t2["ccedilla"] = 444;
                    t2["Zdotaccent"] = 556;
                    t2["Thorn"] = 611;
                    t2["Omacron"] = 722;
                    t2["Racute"] = 611;
                    t2["Sacute"] = 500;
                    t2["dcaron"] = 544;
                    t2["Umacron"] = 722;
                    t2["uring"] = 500;
                    t2["threesuperior"] = 300;
                    t2["Ograve"] = 722;
                    t2["Agrave"] = 611;
                    t2["Abreve"] = 611;
                    t2["multiply"] = 675;
                    t2["uacute"] = 500;
                    t2["Tcaron"] = 556;
                    t2["partialdiff"] = 476;
                    t2["ydieresis"] = 444;
                    t2["Nacute"] = 667;
                    t2["icircumflex"] = 278;
                    t2["Ecircumflex"] = 611;
                    t2["adieresis"] = 500;
                    t2["edieresis"] = 444;
                    t2["cacute"] = 444;
                    t2["nacute"] = 500;
                    t2["umacron"] = 500;
                    t2["Ncaron"] = 667;
                    t2["Iacute"] = 333;
                    t2["plusminus"] = 675;
                    t2["brokenbar"] = 275;
                    t2["registered"] = 760;
                    t2["Gbreve"] = 722;
                    t2["Idotaccent"] = 333;
                    t2["summation"] = 600;
                    t2["Egrave"] = 611;
                    t2["racute"] = 389;
                    t2["omacron"] = 500;
                    t2["Zacute"] = 556;
                    t2["Zcaron"] = 556;
                    t2["greaterequal"] = 549;
                    t2["Eth"] = 722;
                    t2["Ccedilla"] = 667;
                    t2["lcommaaccent"] = 278;
                    t2["tcaron"] = 300;
                    t2["eogonek"] = 444;
                    t2["Uogonek"] = 722;
                    t2["Aacute"] = 611;
                    t2["Adieresis"] = 611;
                    t2["egrave"] = 444;
                    t2["zacute"] = 389;
                    t2["iogonek"] = 278;
                    t2["Oacute"] = 722;
                    t2["oacute"] = 500;
                    t2["amacron"] = 500;
                    t2["sacute"] = 389;
                    t2["idieresis"] = 278;
                    t2["Ocircumflex"] = 722;
                    t2["Ugrave"] = 722;
                    t2["Delta"] = 612;
                    t2["thorn"] = 500;
                    t2["twosuperior"] = 300;
                    t2["Odieresis"] = 722;
                    t2["mu"] = 500;
                    t2["igrave"] = 278;
                    t2["ohungarumlaut"] = 500;
                    t2["Eogonek"] = 611;
                    t2["dcroat"] = 500;
                    t2["threequarters"] = 750;
                    t2["Scedilla"] = 500;
                    t2["lcaron"] = 300;
                    t2["Kcommaaccent"] = 667;
                    t2["Lacute"] = 556;
                    t2["trademark"] = 980;
                    t2["edotaccent"] = 444;
                    t2["Igrave"] = 333;
                    t2["Imacron"] = 333;
                    t2["Lcaron"] = 611;
                    t2["onehalf"] = 750;
                    t2["lessequal"] = 549;
                    t2["ocircumflex"] = 500;
                    t2["ntilde"] = 500;
                    t2["Uhungarumlaut"] = 722;
                    t2["Eacute"] = 611;
                    t2["emacron"] = 444;
                    t2["gbreve"] = 500;
                    t2["onequarter"] = 750;
                    t2["Scaron"] = 500;
                    t2["Scommaaccent"] = 500;
                    t2["Ohungarumlaut"] = 722;
                    t2["degree"] = 400;
                    t2["ograve"] = 500;
                    t2["Ccaron"] = 667;
                    t2["ugrave"] = 500;
                    t2["radical"] = 453;
                    t2["Dcaron"] = 722;
                    t2["rcommaaccent"] = 389;
                    t2["Ntilde"] = 667;
                    t2["otilde"] = 500;
                    t2["Rcommaaccent"] = 611;
                    t2["Lcommaaccent"] = 556;
                    t2["Atilde"] = 611;
                    t2["Aogonek"] = 611;
                    t2["Aring"] = 611;
                    t2["Otilde"] = 722;
                    t2["zdotaccent"] = 389;
                    t2["Ecaron"] = 611;
                    t2["Iogonek"] = 333;
                    t2["kcommaaccent"] = 444;
                    t2["minus"] = 675;
                    t2["Icircumflex"] = 333;
                    t2["ncaron"] = 500;
                    t2["tcommaaccent"] = 278;
                    t2["logicalnot"] = 675;
                    t2["odieresis"] = 500;
                    t2["udieresis"] = 500;
                    t2["notequal"] = 549;
                    t2["gcommaaccent"] = 500;
                    t2["eth"] = 500;
                    t2["zcaron"] = 389;
                    t2["ncommaaccent"] = 500;
                    t2["onesuperior"] = 300;
                    t2["imacron"] = 278;
                    t2["Euro"] = 500;
                  });
                  t["ZapfDingbats"] = (0, _core_utils.getLookupTableFactory)(function(t2) {
                    t2["space"] = 278;
                    t2["a1"] = 974;
                    t2["a2"] = 961;
                    t2["a202"] = 974;
                    t2["a3"] = 980;
                    t2["a4"] = 719;
                    t2["a5"] = 789;
                    t2["a119"] = 790;
                    t2["a118"] = 791;
                    t2["a117"] = 690;
                    t2["a11"] = 960;
                    t2["a12"] = 939;
                    t2["a13"] = 549;
                    t2["a14"] = 855;
                    t2["a15"] = 911;
                    t2["a16"] = 933;
                    t2["a105"] = 911;
                    t2["a17"] = 945;
                    t2["a18"] = 974;
                    t2["a19"] = 755;
                    t2["a20"] = 846;
                    t2["a21"] = 762;
                    t2["a22"] = 761;
                    t2["a23"] = 571;
                    t2["a24"] = 677;
                    t2["a25"] = 763;
                    t2["a26"] = 760;
                    t2["a27"] = 759;
                    t2["a28"] = 754;
                    t2["a6"] = 494;
                    t2["a7"] = 552;
                    t2["a8"] = 537;
                    t2["a9"] = 577;
                    t2["a10"] = 692;
                    t2["a29"] = 786;
                    t2["a30"] = 788;
                    t2["a31"] = 788;
                    t2["a32"] = 790;
                    t2["a33"] = 793;
                    t2["a34"] = 794;
                    t2["a35"] = 816;
                    t2["a36"] = 823;
                    t2["a37"] = 789;
                    t2["a38"] = 841;
                    t2["a39"] = 823;
                    t2["a40"] = 833;
                    t2["a41"] = 816;
                    t2["a42"] = 831;
                    t2["a43"] = 923;
                    t2["a44"] = 744;
                    t2["a45"] = 723;
                    t2["a46"] = 749;
                    t2["a47"] = 790;
                    t2["a48"] = 792;
                    t2["a49"] = 695;
                    t2["a50"] = 776;
                    t2["a51"] = 768;
                    t2["a52"] = 792;
                    t2["a53"] = 759;
                    t2["a54"] = 707;
                    t2["a55"] = 708;
                    t2["a56"] = 682;
                    t2["a57"] = 701;
                    t2["a58"] = 826;
                    t2["a59"] = 815;
                    t2["a60"] = 789;
                    t2["a61"] = 789;
                    t2["a62"] = 707;
                    t2["a63"] = 687;
                    t2["a64"] = 696;
                    t2["a65"] = 689;
                    t2["a66"] = 786;
                    t2["a67"] = 787;
                    t2["a68"] = 713;
                    t2["a69"] = 791;
                    t2["a70"] = 785;
                    t2["a71"] = 791;
                    t2["a72"] = 873;
                    t2["a73"] = 761;
                    t2["a74"] = 762;
                    t2["a203"] = 762;
                    t2["a75"] = 759;
                    t2["a204"] = 759;
                    t2["a76"] = 892;
                    t2["a77"] = 892;
                    t2["a78"] = 788;
                    t2["a79"] = 784;
                    t2["a81"] = 438;
                    t2["a82"] = 138;
                    t2["a83"] = 277;
                    t2["a84"] = 415;
                    t2["a97"] = 392;
                    t2["a98"] = 392;
                    t2["a99"] = 668;
                    t2["a100"] = 668;
                    t2["a89"] = 390;
                    t2["a90"] = 390;
                    t2["a93"] = 317;
                    t2["a94"] = 317;
                    t2["a91"] = 276;
                    t2["a92"] = 276;
                    t2["a205"] = 509;
                    t2["a85"] = 509;
                    t2["a206"] = 410;
                    t2["a86"] = 410;
                    t2["a87"] = 234;
                    t2["a88"] = 234;
                    t2["a95"] = 334;
                    t2["a96"] = 334;
                    t2["a101"] = 732;
                    t2["a102"] = 544;
                    t2["a103"] = 544;
                    t2["a104"] = 910;
                    t2["a106"] = 667;
                    t2["a107"] = 760;
                    t2["a108"] = 760;
                    t2["a112"] = 776;
                    t2["a111"] = 595;
                    t2["a110"] = 694;
                    t2["a109"] = 626;
                    t2["a120"] = 788;
                    t2["a121"] = 788;
                    t2["a122"] = 788;
                    t2["a123"] = 788;
                    t2["a124"] = 788;
                    t2["a125"] = 788;
                    t2["a126"] = 788;
                    t2["a127"] = 788;
                    t2["a128"] = 788;
                    t2["a129"] = 788;
                    t2["a130"] = 788;
                    t2["a131"] = 788;
                    t2["a132"] = 788;
                    t2["a133"] = 788;
                    t2["a134"] = 788;
                    t2["a135"] = 788;
                    t2["a136"] = 788;
                    t2["a137"] = 788;
                    t2["a138"] = 788;
                    t2["a139"] = 788;
                    t2["a140"] = 788;
                    t2["a141"] = 788;
                    t2["a142"] = 788;
                    t2["a143"] = 788;
                    t2["a144"] = 788;
                    t2["a145"] = 788;
                    t2["a146"] = 788;
                    t2["a147"] = 788;
                    t2["a148"] = 788;
                    t2["a149"] = 788;
                    t2["a150"] = 788;
                    t2["a151"] = 788;
                    t2["a152"] = 788;
                    t2["a153"] = 788;
                    t2["a154"] = 788;
                    t2["a155"] = 788;
                    t2["a156"] = 788;
                    t2["a157"] = 788;
                    t2["a158"] = 788;
                    t2["a159"] = 788;
                    t2["a160"] = 894;
                    t2["a161"] = 838;
                    t2["a163"] = 1016;
                    t2["a164"] = 458;
                    t2["a196"] = 748;
                    t2["a165"] = 924;
                    t2["a192"] = 748;
                    t2["a166"] = 918;
                    t2["a167"] = 927;
                    t2["a168"] = 928;
                    t2["a169"] = 928;
                    t2["a170"] = 834;
                    t2["a171"] = 873;
                    t2["a172"] = 828;
                    t2["a173"] = 924;
                    t2["a162"] = 924;
                    t2["a174"] = 917;
                    t2["a175"] = 930;
                    t2["a176"] = 931;
                    t2["a177"] = 463;
                    t2["a178"] = 883;
                    t2["a179"] = 836;
                    t2["a193"] = 836;
                    t2["a180"] = 867;
                    t2["a199"] = 867;
                    t2["a181"] = 696;
                    t2["a200"] = 696;
                    t2["a182"] = 874;
                    t2["a201"] = 874;
                    t2["a183"] = 760;
                    t2["a184"] = 946;
                    t2["a197"] = 771;
                    t2["a185"] = 865;
                    t2["a194"] = 771;
                    t2["a198"] = 888;
                    t2["a186"] = 967;
                    t2["a195"] = 888;
                    t2["a187"] = 831;
                    t2["a188"] = 873;
                    t2["a189"] = 927;
                    t2["a190"] = 970;
                    t2["a191"] = 918;
                  });
                });
                exports2.getMetrics = getMetrics;
              }, function(module3, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.isPDFFunction = isPDFFunction;
                exports2.PostScriptCompiler = exports2.PostScriptEvaluator = exports2.PDFFunctionFactory = void 0;
                var _util2 = __w_pdfjs_require__2(2);
                var _primitives = __w_pdfjs_require__2(4);
                var _ps_parser = __w_pdfjs_require__2(40);
                class PDFFunctionFactory {
                  constructor({ xref, isEvalSupported = true }) {
                    this.xref = xref;
                    this.isEvalSupported = isEvalSupported !== false;
                  }
                  create(fn) {
                    return PDFFunction.parse({ xref: this.xref, isEvalSupported: this.isEvalSupported, fn });
                  }
                  createFromArray(fnObj) {
                    return PDFFunction.parseArray({ xref: this.xref, isEvalSupported: this.isEvalSupported, fnObj });
                  }
                }
                exports2.PDFFunctionFactory = PDFFunctionFactory;
                function toNumberArray(arr) {
                  if (!Array.isArray(arr)) {
                    return null;
                  }
                  const length = arr.length;
                  for (let i = 0; i < length; i++) {
                    if (typeof arr[i] !== "number") {
                      const result = new Array(length);
                      for (let i2 = 0; i2 < length; i2++) {
                        result[i2] = +arr[i2];
                      }
                      return result;
                    }
                  }
                  return arr;
                }
                var PDFFunction = function PDFFunctionClosure() {
                  const CONSTRUCT_SAMPLED = 0;
                  const CONSTRUCT_INTERPOLATED = 2;
                  const CONSTRUCT_STICHED = 3;
                  const CONSTRUCT_POSTSCRIPT = 4;
                  return { getSampleArray(size, outputSize, bps, stream) {
                    var i, ii;
                    var length = 1;
                    for (i = 0, ii = size.length; i < ii; i++) {
                      length *= size[i];
                    }
                    length *= outputSize;
                    var array = new Array(length);
                    var codeSize = 0;
                    var codeBuf = 0;
                    var sampleMul = 1 / (2 ** bps - 1);
                    var strBytes = stream.getBytes((length * bps + 7) / 8);
                    var strIdx = 0;
                    for (i = 0; i < length; i++) {
                      while (codeSize < bps) {
                        codeBuf <<= 8;
                        codeBuf |= strBytes[strIdx++];
                        codeSize += 8;
                      }
                      codeSize -= bps;
                      array[i] = (codeBuf >> codeSize) * sampleMul;
                      codeBuf &= (1 << codeSize) - 1;
                    }
                    return array;
                  }, getIR({ xref, isEvalSupported, fn }) {
                    var dict = fn.dict;
                    if (!dict) {
                      dict = fn;
                    }
                    var types = [this.constructSampled, null, this.constructInterpolated, this.constructStiched, this.constructPostScript];
                    var typeNum = dict.get("FunctionType");
                    var typeFn = types[typeNum];
                    if (!typeFn) {
                      throw new _util2.FormatError("Unknown type of function");
                    }
                    return typeFn.call(this, { xref, isEvalSupported, fn, dict });
                  }, fromIR({ xref, isEvalSupported, IR }) {
                    var type = IR[0];
                    switch (type) {
                      case CONSTRUCT_SAMPLED:
                        return this.constructSampledFromIR({ xref, isEvalSupported, IR });
                      case CONSTRUCT_INTERPOLATED:
                        return this.constructInterpolatedFromIR({ xref, isEvalSupported, IR });
                      case CONSTRUCT_STICHED:
                        return this.constructStichedFromIR({ xref, isEvalSupported, IR });
                      default:
                        return this.constructPostScriptFromIR({ xref, isEvalSupported, IR });
                    }
                  }, parse({ xref, isEvalSupported, fn }) {
                    const IR = this.getIR({ xref, isEvalSupported, fn });
                    return this.fromIR({ xref, isEvalSupported, IR });
                  }, parseArray({ xref, isEvalSupported, fnObj }) {
                    if (!Array.isArray(fnObj)) {
                      return this.parse({ xref, isEvalSupported, fn: fnObj });
                    }
                    var fnArray = [];
                    for (var j = 0, jj = fnObj.length; j < jj; j++) {
                      fnArray.push(this.parse({ xref, isEvalSupported, fn: xref.fetchIfRef(fnObj[j]) }));
                    }
                    return function(src, srcOffset, dest, destOffset) {
                      for (var i = 0, ii = fnArray.length; i < ii; i++) {
                        fnArray[i](src, srcOffset, dest, destOffset + i);
                      }
                    };
                  }, constructSampled({ xref, isEvalSupported, fn, dict }) {
                    function toMultiArray(arr) {
                      var inputLength = arr.length;
                      var out = [];
                      var index = 0;
                      for (var i2 = 0; i2 < inputLength; i2 += 2) {
                        out[index] = [arr[i2], arr[i2 + 1]];
                        ++index;
                      }
                      return out;
                    }
                    var domain = toNumberArray(dict.getArray("Domain"));
                    var range = toNumberArray(dict.getArray("Range"));
                    if (!domain || !range) {
                      throw new _util2.FormatError("No domain or range");
                    }
                    var inputSize = domain.length / 2;
                    var outputSize = range.length / 2;
                    domain = toMultiArray(domain);
                    range = toMultiArray(range);
                    var size = toNumberArray(dict.getArray("Size"));
                    var bps = dict.get("BitsPerSample");
                    var order = dict.get("Order") || 1;
                    if (order !== 1) {
                      (0, _util2.info)("No support for cubic spline interpolation: " + order);
                    }
                    var encode = toNumberArray(dict.getArray("Encode"));
                    if (!encode) {
                      encode = [];
                      for (var i = 0; i < inputSize; ++i) {
                        encode.push([0, size[i] - 1]);
                      }
                    } else {
                      encode = toMultiArray(encode);
                    }
                    var decode = toNumberArray(dict.getArray("Decode"));
                    if (!decode) {
                      decode = range;
                    } else {
                      decode = toMultiArray(decode);
                    }
                    var samples = this.getSampleArray(size, outputSize, bps, fn);
                    return [CONSTRUCT_SAMPLED, inputSize, domain, encode, decode, samples, size, outputSize, 2 ** bps - 1, range];
                  }, constructSampledFromIR({ xref, isEvalSupported, IR }) {
                    function interpolate(x, xmin, xmax, ymin, ymax) {
                      return ymin + (x - xmin) * ((ymax - ymin) / (xmax - xmin));
                    }
                    return function constructSampledFromIRResult(src, srcOffset, dest, destOffset) {
                      var m = IR[1];
                      var domain = IR[2];
                      var encode = IR[3];
                      var decode = IR[4];
                      var samples = IR[5];
                      var size = IR[6];
                      var n = IR[7];
                      var range = IR[9];
                      var cubeVertices = 1 << m;
                      var cubeN = new Float64Array(cubeVertices);
                      var cubeVertex = new Uint32Array(cubeVertices);
                      var i, j;
                      for (j = 0; j < cubeVertices; j++) {
                        cubeN[j] = 1;
                      }
                      var k = n, pos = 1;
                      for (i = 0; i < m; ++i) {
                        var domain_2i = domain[i][0];
                        var domain_2i_1 = domain[i][1];
                        var xi = Math.min(Math.max(src[srcOffset + i], domain_2i), domain_2i_1);
                        var e = interpolate(xi, domain_2i, domain_2i_1, encode[i][0], encode[i][1]);
                        var size_i = size[i];
                        e = Math.min(Math.max(e, 0), size_i - 1);
                        var e0 = e < size_i - 1 ? Math.floor(e) : e - 1;
                        var n0 = e0 + 1 - e;
                        var n1 = e - e0;
                        var offset0 = e0 * k;
                        var offset1 = offset0 + k;
                        for (j = 0; j < cubeVertices; j++) {
                          if (j & pos) {
                            cubeN[j] *= n1;
                            cubeVertex[j] += offset1;
                          } else {
                            cubeN[j] *= n0;
                            cubeVertex[j] += offset0;
                          }
                        }
                        k *= size_i;
                        pos <<= 1;
                      }
                      for (j = 0; j < n; ++j) {
                        var rj = 0;
                        for (i = 0; i < cubeVertices; i++) {
                          rj += samples[cubeVertex[i] + j] * cubeN[i];
                        }
                        rj = interpolate(rj, 0, 1, decode[j][0], decode[j][1]);
                        dest[destOffset + j] = Math.min(Math.max(rj, range[j][0]), range[j][1]);
                      }
                    };
                  }, constructInterpolated({ xref, isEvalSupported, fn, dict }) {
                    var c0 = toNumberArray(dict.getArray("C0")) || [0];
                    var c1 = toNumberArray(dict.getArray("C1")) || [1];
                    var n = dict.get("N");
                    var length = c0.length;
                    var diff = [];
                    for (var i = 0; i < length; ++i) {
                      diff.push(c1[i] - c0[i]);
                    }
                    return [CONSTRUCT_INTERPOLATED, c0, diff, n];
                  }, constructInterpolatedFromIR({ xref, isEvalSupported, IR }) {
                    var c0 = IR[1];
                    var diff = IR[2];
                    var n = IR[3];
                    var length = diff.length;
                    return function constructInterpolatedFromIRResult(src, srcOffset, dest, destOffset) {
                      var x = n === 1 ? src[srcOffset] : src[srcOffset] ** n;
                      for (var j = 0; j < length; ++j) {
                        dest[destOffset + j] = c0[j] + x * diff[j];
                      }
                    };
                  }, constructStiched({ xref, isEvalSupported, fn, dict }) {
                    var domain = toNumberArray(dict.getArray("Domain"));
                    if (!domain) {
                      throw new _util2.FormatError("No domain");
                    }
                    var inputSize = domain.length / 2;
                    if (inputSize !== 1) {
                      throw new _util2.FormatError("Bad domain for stiched function");
                    }
                    var fnRefs = dict.get("Functions");
                    var fns = [];
                    for (var i = 0, ii = fnRefs.length; i < ii; ++i) {
                      fns.push(this.parse({ xref, isEvalSupported, fn: xref.fetchIfRef(fnRefs[i]) }));
                    }
                    var bounds = toNumberArray(dict.getArray("Bounds"));
                    var encode = toNumberArray(dict.getArray("Encode"));
                    return [CONSTRUCT_STICHED, domain, bounds, encode, fns];
                  }, constructStichedFromIR({ xref, isEvalSupported, IR }) {
                    var domain = IR[1];
                    var bounds = IR[2];
                    var encode = IR[3];
                    var fns = IR[4];
                    var tmpBuf = new Float32Array(1);
                    return function constructStichedFromIRResult(src, srcOffset, dest, destOffset) {
                      var clip = function constructStichedFromIRClip(v2, min, max) {
                        if (v2 > max) {
                          v2 = max;
                        } else if (v2 < min) {
                          v2 = min;
                        }
                        return v2;
                      };
                      var v = clip(src[srcOffset], domain[0], domain[1]);
                      for (var i = 0, ii = bounds.length; i < ii; ++i) {
                        if (v < bounds[i]) {
                          break;
                        }
                      }
                      var dmin = domain[0];
                      if (i > 0) {
                        dmin = bounds[i - 1];
                      }
                      var dmax = domain[1];
                      if (i < bounds.length) {
                        dmax = bounds[i];
                      }
                      var rmin = encode[2 * i];
                      var rmax = encode[2 * i + 1];
                      tmpBuf[0] = dmin === dmax ? rmin : rmin + (v - dmin) * (rmax - rmin) / (dmax - dmin);
                      fns[i](tmpBuf, 0, dest, destOffset);
                    };
                  }, constructPostScript({ xref, isEvalSupported, fn, dict }) {
                    var domain = toNumberArray(dict.getArray("Domain"));
                    var range = toNumberArray(dict.getArray("Range"));
                    if (!domain) {
                      throw new _util2.FormatError("No domain.");
                    }
                    if (!range) {
                      throw new _util2.FormatError("No range.");
                    }
                    var lexer = new _ps_parser.PostScriptLexer(fn);
                    var parser = new _ps_parser.PostScriptParser(lexer);
                    var code = parser.parse();
                    return [CONSTRUCT_POSTSCRIPT, domain, range, code];
                  }, constructPostScriptFromIR({ xref, isEvalSupported, IR }) {
                    var domain = IR[1];
                    var range = IR[2];
                    var code = IR[3];
                    if (isEvalSupported && _util2.IsEvalSupportedCached.value) {
                      const compiled = new PostScriptCompiler().compile(code, domain, range);
                      if (compiled) {
                        return new Function("src", "srcOffset", "dest", "destOffset", compiled);
                      }
                    }
                    (0, _util2.info)("Unable to compile PS function");
                    var numOutputs = range.length >> 1;
                    var numInputs = domain.length >> 1;
                    var evaluator = new PostScriptEvaluator(code);
                    var cache = /* @__PURE__ */ Object.create(null);
                    var MAX_CACHE_SIZE = 2048 * 4;
                    var cache_available = MAX_CACHE_SIZE;
                    var tmpBuf = new Float32Array(numInputs);
                    return function constructPostScriptFromIRResult(src, srcOffset, dest, destOffset) {
                      var i, value;
                      var key = "";
                      var input = tmpBuf;
                      for (i = 0; i < numInputs; i++) {
                        value = src[srcOffset + i];
                        input[i] = value;
                        key += value + "_";
                      }
                      var cachedValue = cache[key];
                      if (cachedValue !== void 0) {
                        dest.set(cachedValue, destOffset);
                        return;
                      }
                      var output = new Float32Array(numOutputs);
                      var stack = evaluator.execute(input);
                      var stackIndex = stack.length - numOutputs;
                      for (i = 0; i < numOutputs; i++) {
                        value = stack[stackIndex + i];
                        var bound = range[i * 2];
                        if (value < bound) {
                          value = bound;
                        } else {
                          bound = range[i * 2 + 1];
                          if (value > bound) {
                            value = bound;
                          }
                        }
                        output[i] = value;
                      }
                      if (cache_available > 0) {
                        cache_available--;
                        cache[key] = output;
                      }
                      dest.set(output, destOffset);
                    };
                  } };
                }();
                function isPDFFunction(v) {
                  var fnDict;
                  if (typeof v !== "object") {
                    return false;
                  } else if ((0, _primitives.isDict)(v)) {
                    fnDict = v;
                  } else if ((0, _primitives.isStream)(v)) {
                    fnDict = v.dict;
                  } else {
                    return false;
                  }
                  return fnDict.has("FunctionType");
                }
                var PostScriptStack = function PostScriptStackClosure() {
                  var MAX_STACK_SIZE = 100;
                  function PostScriptStack2(initialStack) {
                    this.stack = !initialStack ? [] : Array.prototype.slice.call(initialStack, 0);
                  }
                  PostScriptStack2.prototype = { push: function PostScriptStack_push(value) {
                    if (this.stack.length >= MAX_STACK_SIZE) {
                      throw new Error("PostScript function stack overflow.");
                    }
                    this.stack.push(value);
                  }, pop: function PostScriptStack_pop() {
                    if (this.stack.length <= 0) {
                      throw new Error("PostScript function stack underflow.");
                    }
                    return this.stack.pop();
                  }, copy: function PostScriptStack_copy(n) {
                    if (this.stack.length + n >= MAX_STACK_SIZE) {
                      throw new Error("PostScript function stack overflow.");
                    }
                    var stack = this.stack;
                    for (var i = stack.length - n, j = n - 1; j >= 0; j--, i++) {
                      stack.push(stack[i]);
                    }
                  }, index: function PostScriptStack_index(n) {
                    this.push(this.stack[this.stack.length - n - 1]);
                  }, roll: function PostScriptStack_roll(n, p) {
                    var stack = this.stack;
                    var l = stack.length - n;
                    var r = stack.length - 1, c = l + (p - Math.floor(p / n) * n), i, j, t;
                    for (i = l, j = r; i < j; i++, j--) {
                      t = stack[i];
                      stack[i] = stack[j];
                      stack[j] = t;
                    }
                    for (i = l, j = c - 1; i < j; i++, j--) {
                      t = stack[i];
                      stack[i] = stack[j];
                      stack[j] = t;
                    }
                    for (i = c, j = r; i < j; i++, j--) {
                      t = stack[i];
                      stack[i] = stack[j];
                      stack[j] = t;
                    }
                  } };
                  return PostScriptStack2;
                }();
                var PostScriptEvaluator = function PostScriptEvaluatorClosure() {
                  function PostScriptEvaluator2(operators) {
                    this.operators = operators;
                  }
                  PostScriptEvaluator2.prototype = { execute: function PostScriptEvaluator_execute(initialStack) {
                    var stack = new PostScriptStack(initialStack);
                    var counter = 0;
                    var operators = this.operators;
                    var length = operators.length;
                    var operator, a, b;
                    while (counter < length) {
                      operator = operators[counter++];
                      if (typeof operator === "number") {
                        stack.push(operator);
                        continue;
                      }
                      switch (operator) {
                        case "jz":
                          b = stack.pop();
                          a = stack.pop();
                          if (!a) {
                            counter = b;
                          }
                          break;
                        case "j":
                          a = stack.pop();
                          counter = a;
                          break;
                        case "abs":
                          a = stack.pop();
                          stack.push(Math.abs(a));
                          break;
                        case "add":
                          b = stack.pop();
                          a = stack.pop();
                          stack.push(a + b);
                          break;
                        case "and":
                          b = stack.pop();
                          a = stack.pop();
                          if ((0, _util2.isBool)(a) && (0, _util2.isBool)(b)) {
                            stack.push(a && b);
                          } else {
                            stack.push(a & b);
                          }
                          break;
                        case "atan":
                          a = stack.pop();
                          stack.push(Math.atan(a));
                          break;
                        case "bitshift":
                          b = stack.pop();
                          a = stack.pop();
                          if (a > 0) {
                            stack.push(a << b);
                          } else {
                            stack.push(a >> b);
                          }
                          break;
                        case "ceiling":
                          a = stack.pop();
                          stack.push(Math.ceil(a));
                          break;
                        case "copy":
                          a = stack.pop();
                          stack.copy(a);
                          break;
                        case "cos":
                          a = stack.pop();
                          stack.push(Math.cos(a));
                          break;
                        case "cvi":
                          a = stack.pop() | 0;
                          stack.push(a);
                          break;
                        case "cvr":
                          break;
                        case "div":
                          b = stack.pop();
                          a = stack.pop();
                          stack.push(a / b);
                          break;
                        case "dup":
                          stack.copy(1);
                          break;
                        case "eq":
                          b = stack.pop();
                          a = stack.pop();
                          stack.push(a === b);
                          break;
                        case "exch":
                          stack.roll(2, 1);
                          break;
                        case "exp":
                          b = stack.pop();
                          a = stack.pop();
                          stack.push(a ** b);
                          break;
                        case "false":
                          stack.push(false);
                          break;
                        case "floor":
                          a = stack.pop();
                          stack.push(Math.floor(a));
                          break;
                        case "ge":
                          b = stack.pop();
                          a = stack.pop();
                          stack.push(a >= b);
                          break;
                        case "gt":
                          b = stack.pop();
                          a = stack.pop();
                          stack.push(a > b);
                          break;
                        case "idiv":
                          b = stack.pop();
                          a = stack.pop();
                          stack.push(a / b | 0);
                          break;
                        case "index":
                          a = stack.pop();
                          stack.index(a);
                          break;
                        case "le":
                          b = stack.pop();
                          a = stack.pop();
                          stack.push(a <= b);
                          break;
                        case "ln":
                          a = stack.pop();
                          stack.push(Math.log(a));
                          break;
                        case "log":
                          a = stack.pop();
                          stack.push(Math.log(a) / Math.LN10);
                          break;
                        case "lt":
                          b = stack.pop();
                          a = stack.pop();
                          stack.push(a < b);
                          break;
                        case "mod":
                          b = stack.pop();
                          a = stack.pop();
                          stack.push(a % b);
                          break;
                        case "mul":
                          b = stack.pop();
                          a = stack.pop();
                          stack.push(a * b);
                          break;
                        case "ne":
                          b = stack.pop();
                          a = stack.pop();
                          stack.push(a !== b);
                          break;
                        case "neg":
                          a = stack.pop();
                          stack.push(-a);
                          break;
                        case "not":
                          a = stack.pop();
                          if ((0, _util2.isBool)(a)) {
                            stack.push(!a);
                          } else {
                            stack.push(~a);
                          }
                          break;
                        case "or":
                          b = stack.pop();
                          a = stack.pop();
                          if ((0, _util2.isBool)(a) && (0, _util2.isBool)(b)) {
                            stack.push(a || b);
                          } else {
                            stack.push(a | b);
                          }
                          break;
                        case "pop":
                          stack.pop();
                          break;
                        case "roll":
                          b = stack.pop();
                          a = stack.pop();
                          stack.roll(a, b);
                          break;
                        case "round":
                          a = stack.pop();
                          stack.push(Math.round(a));
                          break;
                        case "sin":
                          a = stack.pop();
                          stack.push(Math.sin(a));
                          break;
                        case "sqrt":
                          a = stack.pop();
                          stack.push(Math.sqrt(a));
                          break;
                        case "sub":
                          b = stack.pop();
                          a = stack.pop();
                          stack.push(a - b);
                          break;
                        case "true":
                          stack.push(true);
                          break;
                        case "truncate":
                          a = stack.pop();
                          a = a < 0 ? Math.ceil(a) : Math.floor(a);
                          stack.push(a);
                          break;
                        case "xor":
                          b = stack.pop();
                          a = stack.pop();
                          if ((0, _util2.isBool)(a) && (0, _util2.isBool)(b)) {
                            stack.push(a !== b);
                          } else {
                            stack.push(a ^ b);
                          }
                          break;
                        default:
                          throw new _util2.FormatError(`Unknown operator ${operator}`);
                      }
                    }
                    return stack.stack;
                  } };
                  return PostScriptEvaluator2;
                }();
                exports2.PostScriptEvaluator = PostScriptEvaluator;
                var PostScriptCompiler = function PostScriptCompilerClosure() {
                  function AstNode(type) {
                    this.type = type;
                  }
                  AstNode.prototype.visit = function(visitor) {
                    (0, _util2.unreachable)("abstract method");
                  };
                  function AstArgument(index, min, max) {
                    AstNode.call(this, "args");
                    this.index = index;
                    this.min = min;
                    this.max = max;
                  }
                  AstArgument.prototype = Object.create(AstNode.prototype);
                  AstArgument.prototype.visit = function(visitor) {
                    visitor.visitArgument(this);
                  };
                  function AstLiteral(number) {
                    AstNode.call(this, "literal");
                    this.number = number;
                    this.min = number;
                    this.max = number;
                  }
                  AstLiteral.prototype = Object.create(AstNode.prototype);
                  AstLiteral.prototype.visit = function(visitor) {
                    visitor.visitLiteral(this);
                  };
                  function AstBinaryOperation(op, arg1, arg2, min, max) {
                    AstNode.call(this, "binary");
                    this.op = op;
                    this.arg1 = arg1;
                    this.arg2 = arg2;
                    this.min = min;
                    this.max = max;
                  }
                  AstBinaryOperation.prototype = Object.create(AstNode.prototype);
                  AstBinaryOperation.prototype.visit = function(visitor) {
                    visitor.visitBinaryOperation(this);
                  };
                  function AstMin(arg, max) {
                    AstNode.call(this, "max");
                    this.arg = arg;
                    this.min = arg.min;
                    this.max = max;
                  }
                  AstMin.prototype = Object.create(AstNode.prototype);
                  AstMin.prototype.visit = function(visitor) {
                    visitor.visitMin(this);
                  };
                  function AstVariable(index, min, max) {
                    AstNode.call(this, "var");
                    this.index = index;
                    this.min = min;
                    this.max = max;
                  }
                  AstVariable.prototype = Object.create(AstNode.prototype);
                  AstVariable.prototype.visit = function(visitor) {
                    visitor.visitVariable(this);
                  };
                  function AstVariableDefinition(variable, arg) {
                    AstNode.call(this, "definition");
                    this.variable = variable;
                    this.arg = arg;
                  }
                  AstVariableDefinition.prototype = Object.create(AstNode.prototype);
                  AstVariableDefinition.prototype.visit = function(visitor) {
                    visitor.visitVariableDefinition(this);
                  };
                  function ExpressionBuilderVisitor() {
                    this.parts = [];
                  }
                  ExpressionBuilderVisitor.prototype = { visitArgument(arg) {
                    this.parts.push("Math.max(", arg.min, ", Math.min(", arg.max, ", src[srcOffset + ", arg.index, "]))");
                  }, visitVariable(variable) {
                    this.parts.push("v", variable.index);
                  }, visitLiteral(literal) {
                    this.parts.push(literal.number);
                  }, visitBinaryOperation(operation) {
                    this.parts.push("(");
                    operation.arg1.visit(this);
                    this.parts.push(" ", operation.op, " ");
                    operation.arg2.visit(this);
                    this.parts.push(")");
                  }, visitVariableDefinition(definition) {
                    this.parts.push("var ");
                    definition.variable.visit(this);
                    this.parts.push(" = ");
                    definition.arg.visit(this);
                    this.parts.push(";");
                  }, visitMin(max) {
                    this.parts.push("Math.min(");
                    max.arg.visit(this);
                    this.parts.push(", ", max.max, ")");
                  }, toString() {
                    return this.parts.join("");
                  } };
                  function buildAddOperation(num1, num2) {
                    if (num2.type === "literal" && num2.number === 0) {
                      return num1;
                    }
                    if (num1.type === "literal" && num1.number === 0) {
                      return num2;
                    }
                    if (num2.type === "literal" && num1.type === "literal") {
                      return new AstLiteral(num1.number + num2.number);
                    }
                    return new AstBinaryOperation("+", num1, num2, num1.min + num2.min, num1.max + num2.max);
                  }
                  function buildMulOperation(num1, num2) {
                    if (num2.type === "literal") {
                      if (num2.number === 0) {
                        return new AstLiteral(0);
                      } else if (num2.number === 1) {
                        return num1;
                      } else if (num1.type === "literal") {
                        return new AstLiteral(num1.number * num2.number);
                      }
                    }
                    if (num1.type === "literal") {
                      if (num1.number === 0) {
                        return new AstLiteral(0);
                      } else if (num1.number === 1) {
                        return num2;
                      }
                    }
                    var min = Math.min(num1.min * num2.min, num1.min * num2.max, num1.max * num2.min, num1.max * num2.max);
                    var max = Math.max(num1.min * num2.min, num1.min * num2.max, num1.max * num2.min, num1.max * num2.max);
                    return new AstBinaryOperation("*", num1, num2, min, max);
                  }
                  function buildSubOperation(num1, num2) {
                    if (num2.type === "literal") {
                      if (num2.number === 0) {
                        return num1;
                      } else if (num1.type === "literal") {
                        return new AstLiteral(num1.number - num2.number);
                      }
                    }
                    if (num2.type === "binary" && num2.op === "-" && num1.type === "literal" && num1.number === 1 && num2.arg1.type === "literal" && num2.arg1.number === 1) {
                      return num2.arg2;
                    }
                    return new AstBinaryOperation("-", num1, num2, num1.min - num2.max, num1.max - num2.min);
                  }
                  function buildMinOperation(num1, max) {
                    if (num1.min >= max) {
                      return new AstLiteral(max);
                    } else if (num1.max <= max) {
                      return num1;
                    }
                    return new AstMin(num1, max);
                  }
                  function PostScriptCompiler2() {
                  }
                  PostScriptCompiler2.prototype = { compile: function PostScriptCompiler_compile(code, domain, range) {
                    var stack = [];
                    var i, ii;
                    var instructions = [];
                    var inputSize = domain.length >> 1, outputSize = range.length >> 1;
                    var lastRegister = 0;
                    var n, j;
                    var num1, num2, ast1, ast2, tmpVar, item;
                    for (i = 0; i < inputSize; i++) {
                      stack.push(new AstArgument(i, domain[i * 2], domain[i * 2 + 1]));
                    }
                    for (i = 0, ii = code.length; i < ii; i++) {
                      item = code[i];
                      if (typeof item === "number") {
                        stack.push(new AstLiteral(item));
                        continue;
                      }
                      switch (item) {
                        case "add":
                          if (stack.length < 2) {
                            return null;
                          }
                          num2 = stack.pop();
                          num1 = stack.pop();
                          stack.push(buildAddOperation(num1, num2));
                          break;
                        case "cvr":
                          if (stack.length < 1) {
                            return null;
                          }
                          break;
                        case "mul":
                          if (stack.length < 2) {
                            return null;
                          }
                          num2 = stack.pop();
                          num1 = stack.pop();
                          stack.push(buildMulOperation(num1, num2));
                          break;
                        case "sub":
                          if (stack.length < 2) {
                            return null;
                          }
                          num2 = stack.pop();
                          num1 = stack.pop();
                          stack.push(buildSubOperation(num1, num2));
                          break;
                        case "exch":
                          if (stack.length < 2) {
                            return null;
                          }
                          ast1 = stack.pop();
                          ast2 = stack.pop();
                          stack.push(ast1, ast2);
                          break;
                        case "pop":
                          if (stack.length < 1) {
                            return null;
                          }
                          stack.pop();
                          break;
                        case "index":
                          if (stack.length < 1) {
                            return null;
                          }
                          num1 = stack.pop();
                          if (num1.type !== "literal") {
                            return null;
                          }
                          n = num1.number;
                          if (n < 0 || !Number.isInteger(n) || stack.length < n) {
                            return null;
                          }
                          ast1 = stack[stack.length - n - 1];
                          if (ast1.type === "literal" || ast1.type === "var") {
                            stack.push(ast1);
                            break;
                          }
                          tmpVar = new AstVariable(lastRegister++, ast1.min, ast1.max);
                          stack[stack.length - n - 1] = tmpVar;
                          stack.push(tmpVar);
                          instructions.push(new AstVariableDefinition(tmpVar, ast1));
                          break;
                        case "dup":
                          if (stack.length < 1) {
                            return null;
                          }
                          if (typeof code[i + 1] === "number" && code[i + 2] === "gt" && code[i + 3] === i + 7 && code[i + 4] === "jz" && code[i + 5] === "pop" && code[i + 6] === code[i + 1]) {
                            num1 = stack.pop();
                            stack.push(buildMinOperation(num1, code[i + 1]));
                            i += 6;
                            break;
                          }
                          ast1 = stack[stack.length - 1];
                          if (ast1.type === "literal" || ast1.type === "var") {
                            stack.push(ast1);
                            break;
                          }
                          tmpVar = new AstVariable(lastRegister++, ast1.min, ast1.max);
                          stack[stack.length - 1] = tmpVar;
                          stack.push(tmpVar);
                          instructions.push(new AstVariableDefinition(tmpVar, ast1));
                          break;
                        case "roll":
                          if (stack.length < 2) {
                            return null;
                          }
                          num2 = stack.pop();
                          num1 = stack.pop();
                          if (num2.type !== "literal" || num1.type !== "literal") {
                            return null;
                          }
                          j = num2.number;
                          n = num1.number;
                          if (n <= 0 || !Number.isInteger(n) || !Number.isInteger(j) || stack.length < n) {
                            return null;
                          }
                          j = (j % n + n) % n;
                          if (j === 0) {
                            break;
                          }
                          Array.prototype.push.apply(stack, stack.splice(stack.length - n, n - j));
                          break;
                        default:
                          return null;
                      }
                    }
                    if (stack.length !== outputSize) {
                      return null;
                    }
                    var result = [];
                    instructions.forEach(function(instruction) {
                      var statementBuilder = new ExpressionBuilderVisitor();
                      instruction.visit(statementBuilder);
                      result.push(statementBuilder.toString());
                    });
                    stack.forEach(function(expr, i2) {
                      var statementBuilder = new ExpressionBuilderVisitor();
                      expr.visit(statementBuilder);
                      var min = range[i2 * 2], max = range[i2 * 2 + 1];
                      var out = [statementBuilder.toString()];
                      if (min > expr.min) {
                        out.unshift("Math.max(", min, ", ");
                        out.push(")");
                      }
                      if (max < expr.max) {
                        out.unshift("Math.min(", max, ", ");
                        out.push(")");
                      }
                      out.unshift("dest[destOffset + ", i2, "] = ");
                      out.push(";");
                      result.push(out.join(""));
                    });
                    return result.join("\n");
                  } };
                  return PostScriptCompiler2;
                }();
                exports2.PostScriptCompiler = PostScriptCompiler;
              }, function(module3, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.PostScriptParser = exports2.PostScriptLexer = void 0;
                var _util2 = __w_pdfjs_require__2(2);
                var _primitives = __w_pdfjs_require__2(4);
                var _core_utils = __w_pdfjs_require__2(7);
                class PostScriptParser {
                  constructor(lexer) {
                    this.lexer = lexer;
                    this.operators = [];
                    this.token = null;
                    this.prev = null;
                  }
                  nextToken() {
                    this.prev = this.token;
                    this.token = this.lexer.getToken();
                  }
                  accept(type) {
                    if (this.token.type === type) {
                      this.nextToken();
                      return true;
                    }
                    return false;
                  }
                  expect(type) {
                    if (this.accept(type)) {
                      return true;
                    }
                    throw new _util2.FormatError(`Unexpected symbol: found ${this.token.type} expected ${type}.`);
                  }
                  parse() {
                    this.nextToken();
                    this.expect(PostScriptTokenTypes.LBRACE);
                    this.parseBlock();
                    this.expect(PostScriptTokenTypes.RBRACE);
                    return this.operators;
                  }
                  parseBlock() {
                    while (true) {
                      if (this.accept(PostScriptTokenTypes.NUMBER)) {
                        this.operators.push(this.prev.value);
                      } else if (this.accept(PostScriptTokenTypes.OPERATOR)) {
                        this.operators.push(this.prev.value);
                      } else if (this.accept(PostScriptTokenTypes.LBRACE)) {
                        this.parseCondition();
                      } else {
                        return;
                      }
                    }
                  }
                  parseCondition() {
                    const conditionLocation = this.operators.length;
                    this.operators.push(null, null);
                    this.parseBlock();
                    this.expect(PostScriptTokenTypes.RBRACE);
                    if (this.accept(PostScriptTokenTypes.IF)) {
                      this.operators[conditionLocation] = this.operators.length;
                      this.operators[conditionLocation + 1] = "jz";
                    } else if (this.accept(PostScriptTokenTypes.LBRACE)) {
                      const jumpLocation = this.operators.length;
                      this.operators.push(null, null);
                      const endOfTrue = this.operators.length;
                      this.parseBlock();
                      this.expect(PostScriptTokenTypes.RBRACE);
                      this.expect(PostScriptTokenTypes.IFELSE);
                      this.operators[jumpLocation] = this.operators.length;
                      this.operators[jumpLocation + 1] = "j";
                      this.operators[conditionLocation] = endOfTrue;
                      this.operators[conditionLocation + 1] = "jz";
                    } else {
                      throw new _util2.FormatError("PS Function: error parsing conditional.");
                    }
                  }
                }
                exports2.PostScriptParser = PostScriptParser;
                const PostScriptTokenTypes = { LBRACE: 0, RBRACE: 1, NUMBER: 2, OPERATOR: 3, IF: 4, IFELSE: 5 };
                const PostScriptToken = function PostScriptTokenClosure() {
                  const opCache = /* @__PURE__ */ Object.create(null);
                  class PostScriptToken2 {
                    constructor(type, value) {
                      this.type = type;
                      this.value = value;
                    }
                    static getOperator(op) {
                      const opValue = opCache[op];
                      if (opValue) {
                        return opValue;
                      }
                      return opCache[op] = new PostScriptToken2(PostScriptTokenTypes.OPERATOR, op);
                    }
                    static get LBRACE() {
                      return (0, _util2.shadow)(this, "LBRACE", new PostScriptToken2(PostScriptTokenTypes.LBRACE, "{"));
                    }
                    static get RBRACE() {
                      return (0, _util2.shadow)(this, "RBRACE", new PostScriptToken2(PostScriptTokenTypes.RBRACE, "}"));
                    }
                    static get IF() {
                      return (0, _util2.shadow)(this, "IF", new PostScriptToken2(PostScriptTokenTypes.IF, "IF"));
                    }
                    static get IFELSE() {
                      return (0, _util2.shadow)(this, "IFELSE", new PostScriptToken2(PostScriptTokenTypes.IFELSE, "IFELSE"));
                    }
                  }
                  return PostScriptToken2;
                }();
                class PostScriptLexer {
                  constructor(stream) {
                    this.stream = stream;
                    this.nextChar();
                    this.strBuf = [];
                  }
                  nextChar() {
                    return this.currentChar = this.stream.getByte();
                  }
                  getToken() {
                    let comment = false;
                    let ch = this.currentChar;
                    while (true) {
                      if (ch < 0) {
                        return _primitives.EOF;
                      }
                      if (comment) {
                        if (ch === 10 || ch === 13) {
                          comment = false;
                        }
                      } else if (ch === 37) {
                        comment = true;
                      } else if (!(0, _core_utils.isWhiteSpace)(ch)) {
                        break;
                      }
                      ch = this.nextChar();
                    }
                    switch (ch | 0) {
                      case 48:
                      case 49:
                      case 50:
                      case 51:
                      case 52:
                      case 53:
                      case 54:
                      case 55:
                      case 56:
                      case 57:
                      case 43:
                      case 45:
                      case 46:
                        return new PostScriptToken(PostScriptTokenTypes.NUMBER, this.getNumber());
                      case 123:
                        this.nextChar();
                        return PostScriptToken.LBRACE;
                      case 125:
                        this.nextChar();
                        return PostScriptToken.RBRACE;
                    }
                    const strBuf = this.strBuf;
                    strBuf.length = 0;
                    strBuf[0] = String.fromCharCode(ch);
                    while ((ch = this.nextChar()) >= 0 && (ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122)) {
                      strBuf.push(String.fromCharCode(ch));
                    }
                    const str = strBuf.join("");
                    switch (str.toLowerCase()) {
                      case "if":
                        return PostScriptToken.IF;
                      case "ifelse":
                        return PostScriptToken.IFELSE;
                      default:
                        return PostScriptToken.getOperator(str);
                    }
                  }
                  getNumber() {
                    let ch = this.currentChar;
                    const strBuf = this.strBuf;
                    strBuf.length = 0;
                    strBuf[0] = String.fromCharCode(ch);
                    while ((ch = this.nextChar()) >= 0) {
                      if (ch >= 48 && ch <= 57 || ch === 45 || ch === 46) {
                        strBuf.push(String.fromCharCode(ch));
                      } else {
                        break;
                      }
                    }
                    const value = parseFloat(strBuf.join(""));
                    if (isNaN(value)) {
                      throw new _util2.FormatError(`Invalid floating point number: ${value}`);
                    }
                    return value;
                  }
                }
                exports2.PostScriptLexer = PostScriptLexer;
              }, function(module3, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.MurmurHash3_64 = void 0;
                var _util2 = __w_pdfjs_require__2(2);
                const SEED = 3285377520;
                const MASK_HIGH = 4294901760;
                const MASK_LOW = 65535;
                class MurmurHash3_64 {
                  constructor(seed) {
                    this.h1 = seed ? seed & 4294967295 : SEED;
                    this.h2 = seed ? seed & 4294967295 : SEED;
                  }
                  update(input) {
                    let data, length;
                    if ((0, _util2.isString)(input)) {
                      data = new Uint8Array(input.length * 2);
                      length = 0;
                      for (let i = 0, ii = input.length; i < ii; i++) {
                        const code = input.charCodeAt(i);
                        if (code <= 255) {
                          data[length++] = code;
                        } else {
                          data[length++] = code >>> 8;
                          data[length++] = code & 255;
                        }
                      }
                    } else if ((0, _util2.isArrayBuffer)(input)) {
                      data = input;
                      length = data.byteLength;
                    } else {
                      throw new Error("Wrong data format in MurmurHash3_64_update. Input must be a string or array.");
                    }
                    const blockCounts = length >> 2;
                    const tailLength = length - blockCounts * 4;
                    const dataUint32 = new Uint32Array(data.buffer, 0, blockCounts);
                    let k1 = 0, k2 = 0;
                    let h1 = this.h1, h2 = this.h2;
                    const C1 = 3432918353, C2 = 461845907;
                    const C1_LOW = C1 & MASK_LOW, C2_LOW = C2 & MASK_LOW;
                    for (let i = 0; i < blockCounts; i++) {
                      if (i & 1) {
                        k1 = dataUint32[i];
                        k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
                        k1 = k1 << 15 | k1 >>> 17;
                        k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
                        h1 ^= k1;
                        h1 = h1 << 13 | h1 >>> 19;
                        h1 = h1 * 5 + 3864292196;
                      } else {
                        k2 = dataUint32[i];
                        k2 = k2 * C1 & MASK_HIGH | k2 * C1_LOW & MASK_LOW;
                        k2 = k2 << 15 | k2 >>> 17;
                        k2 = k2 * C2 & MASK_HIGH | k2 * C2_LOW & MASK_LOW;
                        h2 ^= k2;
                        h2 = h2 << 13 | h2 >>> 19;
                        h2 = h2 * 5 + 3864292196;
                      }
                    }
                    k1 = 0;
                    switch (tailLength) {
                      case 3:
                        k1 ^= data[blockCounts * 4 + 2] << 16;
                      case 2:
                        k1 ^= data[blockCounts * 4 + 1] << 8;
                      case 1:
                        k1 ^= data[blockCounts * 4];
                        k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
                        k1 = k1 << 15 | k1 >>> 17;
                        k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
                        if (blockCounts & 1) {
                          h1 ^= k1;
                        } else {
                          h2 ^= k1;
                        }
                    }
                    this.h1 = h1;
                    this.h2 = h2;
                  }
                  hexdigest() {
                    let h1 = this.h1, h2 = this.h2;
                    h1 ^= h2 >>> 1;
                    h1 = h1 * 3981806797 & MASK_HIGH | h1 * 36045 & MASK_LOW;
                    h2 = h2 * 4283543511 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 2950163797 & MASK_HIGH) >>> 16;
                    h1 ^= h2 >>> 1;
                    h1 = h1 * 444984403 & MASK_HIGH | h1 * 60499 & MASK_LOW;
                    h2 = h2 * 3301882366 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 3120437893 & MASK_HIGH) >>> 16;
                    h1 ^= h2 >>> 1;
                    const hex1 = (h1 >>> 0).toString(16), hex2 = (h2 >>> 0).toString(16);
                    return hex1.padStart(8, "0") + hex2.padStart(8, "0");
                  }
                }
                exports2.MurmurHash3_64 = MurmurHash3_64;
              }, function(module3, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.NativeImageDecoder = void 0;
                var _colorspace = __w_pdfjs_require__2(22);
                var _jpeg_stream = __w_pdfjs_require__2(17);
                var _stream = __w_pdfjs_require__2(11);
                class NativeImageDecoder {
                  constructor({ xref, resources, handler, forceDataSchema = false, pdfFunctionFactory }) {
                    this.xref = xref;
                    this.resources = resources;
                    this.handler = handler;
                    this.forceDataSchema = forceDataSchema;
                    this.pdfFunctionFactory = pdfFunctionFactory;
                  }
                  canDecode(image) {
                    return image instanceof _jpeg_stream.JpegStream && NativeImageDecoder.isDecodable(image, this.xref, this.resources, this.pdfFunctionFactory) && image.maybeValidDimensions;
                  }
                  decode(image) {
                    const dict = image.dict;
                    let colorSpace = dict.get("ColorSpace", "CS");
                    colorSpace = _colorspace.ColorSpace.parse(colorSpace, this.xref, this.resources, this.pdfFunctionFactory);
                    return this.handler.sendWithPromise("JpegDecode", [image.getIR(this.forceDataSchema), colorSpace.numComps]).then(function({ data, width, height }) {
                      return new _stream.Stream(data, 0, data.length, dict);
                    });
                  }
                  static isSupported(image, xref, res, pdfFunctionFactory) {
                    const dict = image.dict;
                    if (dict.has("DecodeParms") || dict.has("DP")) {
                      return false;
                    }
                    const cs = _colorspace.ColorSpace.parse(dict.get("ColorSpace", "CS"), xref, res, pdfFunctionFactory);
                    return (cs.name === "DeviceGray" || cs.name === "DeviceRGB") && cs.isDefaultDecode(dict.getArray("Decode", "D"));
                  }
                  static isDecodable(image, xref, res, pdfFunctionFactory) {
                    const dict = image.dict;
                    if (dict.has("DecodeParms") || dict.has("DP")) {
                      return false;
                    }
                    const cs = _colorspace.ColorSpace.parse(dict.get("ColorSpace", "CS"), xref, res, pdfFunctionFactory);
                    const bpc = dict.get("BitsPerComponent", "BPC") || 1;
                    return (cs.numComps === 1 || cs.numComps === 3) && cs.isDefaultDecode(dict.getArray("Decode", "D"), bpc);
                  }
                }
                exports2.NativeImageDecoder = NativeImageDecoder;
              }, function(module3, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.PDFImage = void 0;
                var _util2 = __w_pdfjs_require__2(2);
                var _primitives = __w_pdfjs_require__2(4);
                var _colorspace = __w_pdfjs_require__2(22);
                var _stream = __w_pdfjs_require__2(11);
                var _jpeg_stream = __w_pdfjs_require__2(17);
                var _jpx = __w_pdfjs_require__2(20);
                var PDFImage = function PDFImageClosure() {
                  function handleImageData(image, nativeDecoder) {
                    if (nativeDecoder && nativeDecoder.canDecode(image)) {
                      return nativeDecoder.decode(image).catch((reason) => {
                        (0, _util2.warn)("Native image decoding failed -- trying to recover: " + (reason && reason.message));
                        return image;
                      });
                    }
                    return Promise.resolve(image);
                  }
                  function decodeAndClamp(value, addend, coefficient, max) {
                    value = addend + value * coefficient;
                    if (value < 0) {
                      value = 0;
                    } else if (value > max) {
                      value = max;
                    }
                    return value;
                  }
                  function resizeImageMask(src, bpc, w1, h1, w2, h2) {
                    var length = w2 * h2;
                    let dest;
                    if (bpc <= 8) {
                      dest = new Uint8Array(length);
                    } else if (bpc <= 16) {
                      dest = new Uint16Array(length);
                    } else {
                      dest = new Uint32Array(length);
                    }
                    var xRatio = w1 / w2;
                    var yRatio = h1 / h2;
                    var i, j, py, newIndex = 0, oldIndex;
                    var xScaled = new Uint16Array(w2);
                    var w1Scanline = w1;
                    for (i = 0; i < w2; i++) {
                      xScaled[i] = Math.floor(i * xRatio);
                    }
                    for (i = 0; i < h2; i++) {
                      py = Math.floor(i * yRatio) * w1Scanline;
                      for (j = 0; j < w2; j++) {
                        oldIndex = py + xScaled[j];
                        dest[newIndex++] = src[oldIndex];
                      }
                    }
                    return dest;
                  }
                  function PDFImage2({ xref, res, image, isInline = false, smask = null, mask = null, isMask = false, pdfFunctionFactory }) {
                    this.image = image;
                    var dict = image.dict;
                    const filter = dict.get("Filter");
                    if ((0, _primitives.isName)(filter)) {
                      switch (filter.name) {
                        case "JPXDecode":
                          var jpxImage = new _jpx.JpxImage();
                          jpxImage.parseImageProperties(image.stream);
                          image.stream.reset();
                          image.width = jpxImage.width;
                          image.height = jpxImage.height;
                          image.bitsPerComponent = jpxImage.bitsPerComponent;
                          image.numComps = jpxImage.componentsCount;
                          break;
                        case "JBIG2Decode":
                          image.bitsPerComponent = 1;
                          image.numComps = 1;
                          break;
                      }
                    }
                    let width = dict.get("Width", "W");
                    let height = dict.get("Height", "H");
                    if (Number.isInteger(image.width) && image.width > 0 && Number.isInteger(image.height) && image.height > 0 && (image.width !== width || image.height !== height)) {
                      (0, _util2.warn)("PDFImage - using the Width/Height of the image data, rather than the image dictionary.");
                      width = image.width;
                      height = image.height;
                    }
                    if (width < 1 || height < 1) {
                      throw new _util2.FormatError(`Invalid image width: ${width} or height: ${height}`);
                    }
                    this.width = width;
                    this.height = height;
                    this.interpolate = dict.get("Interpolate", "I") || false;
                    this.imageMask = dict.get("ImageMask", "IM") || false;
                    this.matte = dict.get("Matte") || false;
                    var bitsPerComponent = image.bitsPerComponent;
                    if (!bitsPerComponent) {
                      bitsPerComponent = dict.get("BitsPerComponent", "BPC");
                      if (!bitsPerComponent) {
                        if (this.imageMask) {
                          bitsPerComponent = 1;
                        } else {
                          throw new _util2.FormatError(`Bits per component missing in image: ${this.imageMask}`);
                        }
                      }
                    }
                    this.bpc = bitsPerComponent;
                    if (!this.imageMask) {
                      var colorSpace = dict.get("ColorSpace", "CS");
                      if (!colorSpace) {
                        (0, _util2.info)("JPX images (which do not require color spaces)");
                        switch (image.numComps) {
                          case 1:
                            colorSpace = _primitives.Name.get("DeviceGray");
                            break;
                          case 3:
                            colorSpace = _primitives.Name.get("DeviceRGB");
                            break;
                          case 4:
                            colorSpace = _primitives.Name.get("DeviceCMYK");
                            break;
                          default:
                            throw new Error(`JPX images with ${image.numComps} color components not supported.`);
                        }
                      }
                      const resources = isInline ? res : null;
                      this.colorSpace = _colorspace.ColorSpace.parse(colorSpace, xref, resources, pdfFunctionFactory);
                      this.numComps = this.colorSpace.numComps;
                    }
                    this.decode = dict.getArray("Decode", "D");
                    this.needsDecode = false;
                    if (this.decode && (this.colorSpace && !this.colorSpace.isDefaultDecode(this.decode, bitsPerComponent) || isMask && !_colorspace.ColorSpace.isDefaultDecode(this.decode, 1))) {
                      this.needsDecode = true;
                      var max = (1 << bitsPerComponent) - 1;
                      this.decodeCoefficients = [];
                      this.decodeAddends = [];
                      const isIndexed = this.colorSpace && this.colorSpace.name === "Indexed";
                      for (var i = 0, j = 0; i < this.decode.length; i += 2, ++j) {
                        var dmin = this.decode[i];
                        var dmax = this.decode[i + 1];
                        this.decodeCoefficients[j] = isIndexed ? (dmax - dmin) / max : dmax - dmin;
                        this.decodeAddends[j] = isIndexed ? dmin : max * dmin;
                      }
                    }
                    if (smask) {
                      this.smask = new PDFImage2({ xref, res, image: smask, isInline, pdfFunctionFactory });
                    } else if (mask) {
                      if ((0, _primitives.isStream)(mask)) {
                        var maskDict = mask.dict, imageMask = maskDict.get("ImageMask", "IM");
                        if (!imageMask) {
                          (0, _util2.warn)("Ignoring /Mask in image without /ImageMask.");
                        } else {
                          this.mask = new PDFImage2({ xref, res, image: mask, isInline, isMask: true, pdfFunctionFactory });
                        }
                      } else {
                        this.mask = mask;
                      }
                    }
                  }
                  PDFImage2.buildImage = function({ handler, xref, res, image, isInline = false, nativeDecoder = null, pdfFunctionFactory }) {
                    var imagePromise = handleImageData(image, nativeDecoder);
                    var smaskPromise;
                    var maskPromise;
                    var smask = image.dict.get("SMask");
                    var mask = image.dict.get("Mask");
                    if (smask) {
                      smaskPromise = handleImageData(smask, nativeDecoder);
                      maskPromise = Promise.resolve(null);
                    } else {
                      smaskPromise = Promise.resolve(null);
                      if (mask) {
                        if ((0, _primitives.isStream)(mask)) {
                          maskPromise = handleImageData(mask, nativeDecoder);
                        } else if (Array.isArray(mask)) {
                          maskPromise = Promise.resolve(mask);
                        } else {
                          (0, _util2.warn)("Unsupported mask format.");
                          maskPromise = Promise.resolve(null);
                        }
                      } else {
                        maskPromise = Promise.resolve(null);
                      }
                    }
                    return Promise.all([imagePromise, smaskPromise, maskPromise]).then(function([imageData, smaskData, maskData]) {
                      return new PDFImage2({ xref, res, image: imageData, isInline, smask: smaskData, mask: maskData, pdfFunctionFactory });
                    });
                  };
                  PDFImage2.createMask = function({ imgArray, width, height, imageIsFromDecodeStream, inverseDecode }) {
                    var computedLength = (width + 7 >> 3) * height;
                    var actualLength = imgArray.byteLength;
                    var haveFullData = computedLength === actualLength;
                    var data, i;
                    if (imageIsFromDecodeStream && (!inverseDecode || haveFullData)) {
                      data = imgArray;
                    } else if (!inverseDecode) {
                      data = new Uint8ClampedArray(actualLength);
                      data.set(imgArray);
                    } else {
                      data = new Uint8ClampedArray(computedLength);
                      data.set(imgArray);
                      for (i = actualLength; i < computedLength; i++) {
                        data[i] = 255;
                      }
                    }
                    if (inverseDecode) {
                      for (i = 0; i < actualLength; i++) {
                        data[i] ^= 255;
                      }
                    }
                    return { data, width, height };
                  };
                  PDFImage2.prototype = { get drawWidth() {
                    return Math.max(this.width, this.smask && this.smask.width || 0, this.mask && this.mask.width || 0);
                  }, get drawHeight() {
                    return Math.max(this.height, this.smask && this.smask.height || 0, this.mask && this.mask.height || 0);
                  }, decodeBuffer(buffer) {
                    var bpc = this.bpc;
                    var numComps = this.numComps;
                    var decodeAddends = this.decodeAddends;
                    var decodeCoefficients = this.decodeCoefficients;
                    var max = (1 << bpc) - 1;
                    var i, ii;
                    if (bpc === 1) {
                      for (i = 0, ii = buffer.length; i < ii; i++) {
                        buffer[i] = +!buffer[i];
                      }
                      return;
                    }
                    var index = 0;
                    for (i = 0, ii = this.width * this.height; i < ii; i++) {
                      for (var j = 0; j < numComps; j++) {
                        buffer[index] = decodeAndClamp(buffer[index], decodeAddends[j], decodeCoefficients[j], max);
                        index++;
                      }
                    }
                  }, getComponents(buffer) {
                    var bpc = this.bpc;
                    if (bpc === 8) {
                      return buffer;
                    }
                    var width = this.width;
                    var height = this.height;
                    var numComps = this.numComps;
                    var length = width * height * numComps;
                    var bufferPos = 0;
                    let output;
                    if (bpc <= 8) {
                      output = new Uint8Array(length);
                    } else if (bpc <= 16) {
                      output = new Uint16Array(length);
                    } else {
                      output = new Uint32Array(length);
                    }
                    var rowComps = width * numComps;
                    var max = (1 << bpc) - 1;
                    var i = 0, ii, buf;
                    if (bpc === 1) {
                      var mask, loop1End, loop2End;
                      for (var j = 0; j < height; j++) {
                        loop1End = i + (rowComps & ~7);
                        loop2End = i + rowComps;
                        while (i < loop1End) {
                          buf = buffer[bufferPos++];
                          output[i] = buf >> 7 & 1;
                          output[i + 1] = buf >> 6 & 1;
                          output[i + 2] = buf >> 5 & 1;
                          output[i + 3] = buf >> 4 & 1;
                          output[i + 4] = buf >> 3 & 1;
                          output[i + 5] = buf >> 2 & 1;
                          output[i + 6] = buf >> 1 & 1;
                          output[i + 7] = buf & 1;
                          i += 8;
                        }
                        if (i < loop2End) {
                          buf = buffer[bufferPos++];
                          mask = 128;
                          while (i < loop2End) {
                            output[i++] = +!!(buf & mask);
                            mask >>= 1;
                          }
                        }
                      }
                    } else {
                      var bits = 0;
                      buf = 0;
                      for (i = 0, ii = length; i < ii; ++i) {
                        if (i % rowComps === 0) {
                          buf = 0;
                          bits = 0;
                        }
                        while (bits < bpc) {
                          buf = buf << 8 | buffer[bufferPos++];
                          bits += 8;
                        }
                        var remainingBits = bits - bpc;
                        let value = buf >> remainingBits;
                        if (value < 0) {
                          value = 0;
                        } else if (value > max) {
                          value = max;
                        }
                        output[i] = value;
                        buf = buf & (1 << remainingBits) - 1;
                        bits = remainingBits;
                      }
                    }
                    return output;
                  }, fillOpacity(rgbaBuf, width, height, actualHeight, image) {
                    var smask = this.smask;
                    var mask = this.mask;
                    var alphaBuf, sw, sh, i, ii, j;
                    if (smask) {
                      sw = smask.width;
                      sh = smask.height;
                      alphaBuf = new Uint8ClampedArray(sw * sh);
                      smask.fillGrayBuffer(alphaBuf);
                      if (sw !== width || sh !== height) {
                        alphaBuf = resizeImageMask(alphaBuf, smask.bpc, sw, sh, width, height);
                      }
                    } else if (mask) {
                      if (mask instanceof PDFImage2) {
                        sw = mask.width;
                        sh = mask.height;
                        alphaBuf = new Uint8ClampedArray(sw * sh);
                        mask.numComps = 1;
                        mask.fillGrayBuffer(alphaBuf);
                        for (i = 0, ii = sw * sh; i < ii; ++i) {
                          alphaBuf[i] = 255 - alphaBuf[i];
                        }
                        if (sw !== width || sh !== height) {
                          alphaBuf = resizeImageMask(alphaBuf, mask.bpc, sw, sh, width, height);
                        }
                      } else if (Array.isArray(mask)) {
                        alphaBuf = new Uint8ClampedArray(width * height);
                        var numComps = this.numComps;
                        for (i = 0, ii = width * height; i < ii; ++i) {
                          var opacity = 0;
                          var imageOffset = i * numComps;
                          for (j = 0; j < numComps; ++j) {
                            var color = image[imageOffset + j];
                            var maskOffset = j * 2;
                            if (color < mask[maskOffset] || color > mask[maskOffset + 1]) {
                              opacity = 255;
                              break;
                            }
                          }
                          alphaBuf[i] = opacity;
                        }
                      } else {
                        throw new _util2.FormatError("Unknown mask format.");
                      }
                    }
                    if (alphaBuf) {
                      for (i = 0, j = 3, ii = width * actualHeight; i < ii; ++i, j += 4) {
                        rgbaBuf[j] = alphaBuf[i];
                      }
                    } else {
                      for (i = 0, j = 3, ii = width * actualHeight; i < ii; ++i, j += 4) {
                        rgbaBuf[j] = 255;
                      }
                    }
                  }, undoPreblend(buffer, width, height) {
                    var matte = this.smask && this.smask.matte;
                    if (!matte) {
                      return;
                    }
                    var matteRgb = this.colorSpace.getRgb(matte, 0);
                    var matteR = matteRgb[0];
                    var matteG = matteRgb[1];
                    var matteB = matteRgb[2];
                    var length = width * height * 4;
                    for (var i = 0; i < length; i += 4) {
                      var alpha = buffer[i + 3];
                      if (alpha === 0) {
                        buffer[i] = 255;
                        buffer[i + 1] = 255;
                        buffer[i + 2] = 255;
                        continue;
                      }
                      var k = 255 / alpha;
                      buffer[i] = (buffer[i] - matteR) * k + matteR;
                      buffer[i + 1] = (buffer[i + 1] - matteG) * k + matteG;
                      buffer[i + 2] = (buffer[i + 2] - matteB) * k + matteB;
                    }
                  }, createImageData(forceRGBA = false) {
                    var drawWidth = this.drawWidth;
                    var drawHeight = this.drawHeight;
                    var imgData = { width: drawWidth, height: drawHeight, kind: 0, data: null };
                    var numComps = this.numComps;
                    var originalWidth = this.width;
                    var originalHeight = this.height;
                    var bpc = this.bpc;
                    var rowBytes = originalWidth * numComps * bpc + 7 >> 3;
                    var imgArray;
                    if (!forceRGBA) {
                      var kind;
                      if (this.colorSpace.name === "DeviceGray" && bpc === 1) {
                        kind = _util2.ImageKind.GRAYSCALE_1BPP;
                      } else if (this.colorSpace.name === "DeviceRGB" && bpc === 8 && !this.needsDecode) {
                        kind = _util2.ImageKind.RGB_24BPP;
                      }
                      if (kind && !this.smask && !this.mask && drawWidth === originalWidth && drawHeight === originalHeight) {
                        imgData.kind = kind;
                        imgArray = this.getImageBytes(originalHeight * rowBytes);
                        if (this.image instanceof _stream.DecodeStream) {
                          imgData.data = imgArray;
                        } else {
                          var newArray = new Uint8ClampedArray(imgArray.length);
                          newArray.set(imgArray);
                          imgData.data = newArray;
                        }
                        if (this.needsDecode) {
                          (0, _util2.assert)(kind === _util2.ImageKind.GRAYSCALE_1BPP, "PDFImage.createImageData: The image must be grayscale.");
                          var buffer = imgData.data;
                          for (var i = 0, ii = buffer.length; i < ii; i++) {
                            buffer[i] ^= 255;
                          }
                        }
                        return imgData;
                      }
                      if (this.image instanceof _jpeg_stream.JpegStream && !this.smask && !this.mask) {
                        let imageLength = originalHeight * rowBytes;
                        switch (this.colorSpace.name) {
                          case "DeviceGray":
                            imageLength *= 3;
                          case "DeviceRGB":
                          case "DeviceCMYK":
                            imgData.kind = _util2.ImageKind.RGB_24BPP;
                            imgData.data = this.getImageBytes(imageLength, drawWidth, drawHeight, true);
                            return imgData;
                        }
                      }
                    }
                    imgArray = this.getImageBytes(originalHeight * rowBytes);
                    var actualHeight = 0 | imgArray.length / rowBytes * drawHeight / originalHeight;
                    var comps = this.getComponents(imgArray);
                    var alpha01, maybeUndoPreblend;
                    if (!forceRGBA && !this.smask && !this.mask) {
                      imgData.kind = _util2.ImageKind.RGB_24BPP;
                      imgData.data = new Uint8ClampedArray(drawWidth * drawHeight * 3);
                      alpha01 = 0;
                      maybeUndoPreblend = false;
                    } else {
                      imgData.kind = _util2.ImageKind.RGBA_32BPP;
                      imgData.data = new Uint8ClampedArray(drawWidth * drawHeight * 4);
                      alpha01 = 1;
                      maybeUndoPreblend = true;
                      this.fillOpacity(imgData.data, drawWidth, drawHeight, actualHeight, comps);
                    }
                    if (this.needsDecode) {
                      this.decodeBuffer(comps);
                    }
                    this.colorSpace.fillRgb(imgData.data, originalWidth, originalHeight, drawWidth, drawHeight, actualHeight, bpc, comps, alpha01);
                    if (maybeUndoPreblend) {
                      this.undoPreblend(imgData.data, drawWidth, actualHeight);
                    }
                    return imgData;
                  }, fillGrayBuffer(buffer) {
                    var numComps = this.numComps;
                    if (numComps !== 1) {
                      throw new _util2.FormatError(`Reading gray scale from a color image: ${numComps}`);
                    }
                    var width = this.width;
                    var height = this.height;
                    var bpc = this.bpc;
                    var rowBytes = width * numComps * bpc + 7 >> 3;
                    var imgArray = this.getImageBytes(height * rowBytes);
                    var comps = this.getComponents(imgArray);
                    var i, length;
                    if (bpc === 1) {
                      length = width * height;
                      if (this.needsDecode) {
                        for (i = 0; i < length; ++i) {
                          buffer[i] = comps[i] - 1 & 255;
                        }
                      } else {
                        for (i = 0; i < length; ++i) {
                          buffer[i] = -comps[i] & 255;
                        }
                      }
                      return;
                    }
                    if (this.needsDecode) {
                      this.decodeBuffer(comps);
                    }
                    length = width * height;
                    var scale = 255 / ((1 << bpc) - 1);
                    for (i = 0; i < length; ++i) {
                      buffer[i] = scale * comps[i];
                    }
                  }, getImageBytes(length, drawWidth, drawHeight, forceRGB = false) {
                    this.image.reset();
                    this.image.drawWidth = drawWidth || this.width;
                    this.image.drawHeight = drawHeight || this.height;
                    this.image.forceRGB = !!forceRGB;
                    return this.image.getBytes(length, true);
                  } };
                  return PDFImage2;
                }();
                exports2.PDFImage = PDFImage;
              }, function(module3, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.isNodeJS = void 0;
                const isNodeJS = typeof process === "object" && process + "" === "[object process]" && !process.versions["nw"] && !process.versions["electron"];
                exports2.isNodeJS = isNodeJS;
              }, function(module3, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.MessageHandler = void 0;
                var _util2 = __w_pdfjs_require__2(2);
                const CallbackKind = { UNKNOWN: 0, DATA: 1, ERROR: 2 };
                const StreamKind = { UNKNOWN: 0, CANCEL: 1, CANCEL_COMPLETE: 2, CLOSE: 3, ENQUEUE: 4, ERROR: 5, PULL: 6, PULL_COMPLETE: 7, START_COMPLETE: 8 };
                function wrapReason(reason) {
                  if (typeof reason !== "object" || reason === null) {
                    return reason;
                  }
                  switch (reason.name) {
                    case "AbortException":
                      return new _util2.AbortException(reason.message);
                    case "MissingPDFException":
                      return new _util2.MissingPDFException(reason.message);
                    case "UnexpectedResponseException":
                      return new _util2.UnexpectedResponseException(reason.message, reason.status);
                    case "UnknownErrorException":
                      return new _util2.UnknownErrorException(reason.message, reason.details);
                    default:
                      return new _util2.UnknownErrorException(reason.message, reason.toString());
                  }
                }
                class MessageHandler {
                  constructor(sourceName, targetName, comObj) {
                    this.sourceName = sourceName;
                    this.targetName = targetName;
                    this.comObj = comObj;
                    this.callbackId = 1;
                    this.streamId = 1;
                    this.postMessageTransfers = true;
                    this.streamSinks = /* @__PURE__ */ Object.create(null);
                    this.streamControllers = /* @__PURE__ */ Object.create(null);
                    this.callbackCapabilities = /* @__PURE__ */ Object.create(null);
                    this.actionHandler = /* @__PURE__ */ Object.create(null);
                    this._onComObjOnMessage = (event) => {
                      const data = event.data;
                      if (data.targetName !== this.sourceName) {
                        return;
                      }
                      if (data.stream) {
                        this._processStreamMessage(data);
                        return;
                      }
                      if (data.callback) {
                        const callbackId = data.callbackId;
                        const capability = this.callbackCapabilities[callbackId];
                        if (!capability) {
                          throw new Error(`Cannot resolve callback ${callbackId}`);
                        }
                        delete this.callbackCapabilities[callbackId];
                        if (data.callback === CallbackKind.DATA) {
                          capability.resolve(data.data);
                        } else if (data.callback === CallbackKind.ERROR) {
                          capability.reject(wrapReason(data.reason));
                        } else {
                          throw new Error("Unexpected callback case");
                        }
                        return;
                      }
                      const action = this.actionHandler[data.action];
                      if (!action) {
                        throw new Error(`Unknown action from worker: ${data.action}`);
                      }
                      if (data.callbackId) {
                        const sourceName2 = this.sourceName;
                        const targetName2 = data.sourceName;
                        new Promise(function(resolve) {
                          resolve(action(data.data));
                        }).then(function(result) {
                          comObj.postMessage({ sourceName: sourceName2, targetName: targetName2, callback: CallbackKind.DATA, callbackId: data.callbackId, data: result });
                        }, function(reason) {
                          comObj.postMessage({ sourceName: sourceName2, targetName: targetName2, callback: CallbackKind.ERROR, callbackId: data.callbackId, reason: wrapReason(reason) });
                        });
                        return;
                      }
                      if (data.streamId) {
                        this._createStreamSink(data);
                        return;
                      }
                      action(data.data);
                    };
                    comObj.addEventListener("message", this._onComObjOnMessage);
                  }
                  on(actionName, handler) {
                    const ah = this.actionHandler;
                    if (ah[actionName]) {
                      throw new Error(`There is already an actionName called "${actionName}"`);
                    }
                    ah[actionName] = handler;
                  }
                  send(actionName, data, transfers) {
                    this._postMessage({ sourceName: this.sourceName, targetName: this.targetName, action: actionName, data }, transfers);
                  }
                  sendWithPromise(actionName, data, transfers) {
                    const callbackId = this.callbackId++;
                    const capability = (0, _util2.createPromiseCapability)();
                    this.callbackCapabilities[callbackId] = capability;
                    try {
                      this._postMessage({ sourceName: this.sourceName, targetName: this.targetName, action: actionName, callbackId, data }, transfers);
                    } catch (ex) {
                      capability.reject(ex);
                    }
                    return capability.promise;
                  }
                  sendWithStream(actionName, data, queueingStrategy, transfers) {
                    const streamId = this.streamId++;
                    const sourceName = this.sourceName;
                    const targetName = this.targetName;
                    const comObj = this.comObj;
                    return new ReadableStream({ start: (controller) => {
                      const startCapability = (0, _util2.createPromiseCapability)();
                      this.streamControllers[streamId] = { controller, startCall: startCapability, pullCall: null, cancelCall: null, isClosed: false };
                      this._postMessage({ sourceName, targetName, action: actionName, streamId, data, desiredSize: controller.desiredSize }, transfers);
                      return startCapability.promise;
                    }, pull: (controller) => {
                      const pullCapability = (0, _util2.createPromiseCapability)();
                      this.streamControllers[streamId].pullCall = pullCapability;
                      comObj.postMessage({ sourceName, targetName, stream: StreamKind.PULL, streamId, desiredSize: controller.desiredSize });
                      return pullCapability.promise;
                    }, cancel: (reason) => {
                      (0, _util2.assert)(reason instanceof Error, "cancel must have a valid reason");
                      const cancelCapability = (0, _util2.createPromiseCapability)();
                      this.streamControllers[streamId].cancelCall = cancelCapability;
                      this.streamControllers[streamId].isClosed = true;
                      comObj.postMessage({ sourceName, targetName, stream: StreamKind.CANCEL, streamId, reason: wrapReason(reason) });
                      return cancelCapability.promise;
                    } }, queueingStrategy);
                  }
                  _createStreamSink(data) {
                    const self2 = this;
                    const action = this.actionHandler[data.action];
                    const streamId = data.streamId;
                    const sourceName = this.sourceName;
                    const targetName = data.sourceName;
                    const comObj = this.comObj;
                    const streamSink = { enqueue(chunk, size = 1, transfers) {
                      if (this.isCancelled) {
                        return;
                      }
                      const lastDesiredSize = this.desiredSize;
                      this.desiredSize -= size;
                      if (lastDesiredSize > 0 && this.desiredSize <= 0) {
                        this.sinkCapability = (0, _util2.createPromiseCapability)();
                        this.ready = this.sinkCapability.promise;
                      }
                      self2._postMessage({ sourceName, targetName, stream: StreamKind.ENQUEUE, streamId, chunk }, transfers);
                    }, close() {
                      if (this.isCancelled) {
                        return;
                      }
                      this.isCancelled = true;
                      comObj.postMessage({ sourceName, targetName, stream: StreamKind.CLOSE, streamId });
                      delete self2.streamSinks[streamId];
                    }, error(reason) {
                      (0, _util2.assert)(reason instanceof Error, "error must have a valid reason");
                      if (this.isCancelled) {
                        return;
                      }
                      this.isCancelled = true;
                      comObj.postMessage({ sourceName, targetName, stream: StreamKind.ERROR, streamId, reason: wrapReason(reason) });
                    }, sinkCapability: (0, _util2.createPromiseCapability)(), onPull: null, onCancel: null, isCancelled: false, desiredSize: data.desiredSize, ready: null };
                    streamSink.sinkCapability.resolve();
                    streamSink.ready = streamSink.sinkCapability.promise;
                    this.streamSinks[streamId] = streamSink;
                    new Promise(function(resolve) {
                      resolve(action(data.data, streamSink));
                    }).then(function() {
                      comObj.postMessage({ sourceName, targetName, stream: StreamKind.START_COMPLETE, streamId, success: true });
                    }, function(reason) {
                      comObj.postMessage({ sourceName, targetName, stream: StreamKind.START_COMPLETE, streamId, reason: wrapReason(reason) });
                    });
                  }
                  _processStreamMessage(data) {
                    const streamId = data.streamId;
                    const sourceName = this.sourceName;
                    const targetName = data.sourceName;
                    const comObj = this.comObj;
                    switch (data.stream) {
                      case StreamKind.START_COMPLETE:
                        if (data.success) {
                          this.streamControllers[streamId].startCall.resolve();
                        } else {
                          this.streamControllers[streamId].startCall.reject(wrapReason(data.reason));
                        }
                        break;
                      case StreamKind.PULL_COMPLETE:
                        if (data.success) {
                          this.streamControllers[streamId].pullCall.resolve();
                        } else {
                          this.streamControllers[streamId].pullCall.reject(wrapReason(data.reason));
                        }
                        break;
                      case StreamKind.PULL:
                        if (!this.streamSinks[streamId]) {
                          comObj.postMessage({ sourceName, targetName, stream: StreamKind.PULL_COMPLETE, streamId, success: true });
                          break;
                        }
                        if (this.streamSinks[streamId].desiredSize <= 0 && data.desiredSize > 0) {
                          this.streamSinks[streamId].sinkCapability.resolve();
                        }
                        this.streamSinks[streamId].desiredSize = data.desiredSize;
                        const { onPull } = this.streamSinks[data.streamId];
                        new Promise(function(resolve) {
                          resolve(onPull && onPull());
                        }).then(function() {
                          comObj.postMessage({ sourceName, targetName, stream: StreamKind.PULL_COMPLETE, streamId, success: true });
                        }, function(reason) {
                          comObj.postMessage({ sourceName, targetName, stream: StreamKind.PULL_COMPLETE, streamId, reason: wrapReason(reason) });
                        });
                        break;
                      case StreamKind.ENQUEUE:
                        (0, _util2.assert)(this.streamControllers[streamId], "enqueue should have stream controller");
                        if (this.streamControllers[streamId].isClosed) {
                          break;
                        }
                        this.streamControllers[streamId].controller.enqueue(data.chunk);
                        break;
                      case StreamKind.CLOSE:
                        (0, _util2.assert)(this.streamControllers[streamId], "close should have stream controller");
                        if (this.streamControllers[streamId].isClosed) {
                          break;
                        }
                        this.streamControllers[streamId].isClosed = true;
                        this.streamControllers[streamId].controller.close();
                        this._deleteStreamController(streamId);
                        break;
                      case StreamKind.ERROR:
                        (0, _util2.assert)(this.streamControllers[streamId], "error should have stream controller");
                        this.streamControllers[streamId].controller.error(wrapReason(data.reason));
                        this._deleteStreamController(streamId);
                        break;
                      case StreamKind.CANCEL_COMPLETE:
                        if (data.success) {
                          this.streamControllers[streamId].cancelCall.resolve();
                        } else {
                          this.streamControllers[streamId].cancelCall.reject(wrapReason(data.reason));
                        }
                        this._deleteStreamController(streamId);
                        break;
                      case StreamKind.CANCEL:
                        if (!this.streamSinks[streamId]) {
                          break;
                        }
                        const { onCancel } = this.streamSinks[data.streamId];
                        new Promise(function(resolve) {
                          resolve(onCancel && onCancel(wrapReason(data.reason)));
                        }).then(function() {
                          comObj.postMessage({ sourceName, targetName, stream: StreamKind.CANCEL_COMPLETE, streamId, success: true });
                        }, function(reason) {
                          comObj.postMessage({ sourceName, targetName, stream: StreamKind.CANCEL_COMPLETE, streamId, reason: wrapReason(reason) });
                        });
                        this.streamSinks[streamId].sinkCapability.reject(wrapReason(data.reason));
                        this.streamSinks[streamId].isCancelled = true;
                        delete this.streamSinks[streamId];
                        break;
                      default:
                        throw new Error("Unexpected stream case");
                    }
                  }
                  async _deleteStreamController(streamId) {
                    await Promise.allSettled([this.streamControllers[streamId].startCall, this.streamControllers[streamId].pullCall, this.streamControllers[streamId].cancelCall].map(function(capability) {
                      return capability && capability.promise;
                    }));
                    delete this.streamControllers[streamId];
                  }
                  _postMessage(message, transfers) {
                    if (transfers && this.postMessageTransfers) {
                      this.comObj.postMessage(message, transfers);
                    } else {
                      this.comObj.postMessage(message);
                    }
                  }
                  destroy() {
                    this.comObj.removeEventListener("message", this._onComObjOnMessage);
                  }
                }
                exports2.MessageHandler = MessageHandler;
              }, function(module3, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.PDFWorkerStream = void 0;
                var _util2 = __w_pdfjs_require__2(2);
                class PDFWorkerStream {
                  constructor(msgHandler) {
                    this._msgHandler = msgHandler;
                    this._contentLength = null;
                    this._fullRequestReader = null;
                    this._rangeRequestReaders = [];
                  }
                  getFullReader() {
                    (0, _util2.assert)(!this._fullRequestReader);
                    this._fullRequestReader = new PDFWorkerStreamReader(this._msgHandler);
                    return this._fullRequestReader;
                  }
                  getRangeReader(begin, end) {
                    const reader = new PDFWorkerStreamRangeReader(begin, end, this._msgHandler);
                    this._rangeRequestReaders.push(reader);
                    return reader;
                  }
                  cancelAllRequests(reason) {
                    if (this._fullRequestReader) {
                      this._fullRequestReader.cancel(reason);
                    }
                    const readers = this._rangeRequestReaders.slice(0);
                    readers.forEach(function(reader) {
                      reader.cancel(reason);
                    });
                  }
                }
                exports2.PDFWorkerStream = PDFWorkerStream;
                class PDFWorkerStreamReader {
                  constructor(msgHandler) {
                    this._msgHandler = msgHandler;
                    this.onProgress = null;
                    this._contentLength = null;
                    this._isRangeSupported = false;
                    this._isStreamingSupported = false;
                    const readableStream = this._msgHandler.sendWithStream("GetReader");
                    this._reader = readableStream.getReader();
                    this._headersReady = this._msgHandler.sendWithPromise("ReaderHeadersReady").then((data) => {
                      this._isStreamingSupported = data.isStreamingSupported;
                      this._isRangeSupported = data.isRangeSupported;
                      this._contentLength = data.contentLength;
                    });
                  }
                  get headersReady() {
                    return this._headersReady;
                  }
                  get contentLength() {
                    return this._contentLength;
                  }
                  get isStreamingSupported() {
                    return this._isStreamingSupported;
                  }
                  get isRangeSupported() {
                    return this._isRangeSupported;
                  }
                  async read() {
                    const { value, done } = await this._reader.read();
                    if (done) {
                      return { value: void 0, done: true };
                    }
                    return { value: value.buffer, done: false };
                  }
                  cancel(reason) {
                    this._reader.cancel(reason);
                  }
                }
                class PDFWorkerStreamRangeReader {
                  constructor(begin, end, msgHandler) {
                    this._msgHandler = msgHandler;
                    this.onProgress = null;
                    const readableStream = this._msgHandler.sendWithStream("GetRangeReader", { begin, end });
                    this._reader = readableStream.getReader();
                  }
                  get isStreamingSupported() {
                    return false;
                  }
                  async read() {
                    const { value, done } = await this._reader.read();
                    if (done) {
                      return { value: void 0, done: true };
                    }
                    return { value: value.buffer, done: false };
                  }
                  cancel(reason) {
                    this._reader.cancel(reason);
                  }
                }
              }]);
            });
          },
          919: function(module, __unused_webpack_exports, __webpack_require__) {
            __webpack_require__(7658);
            __webpack_require__(3408);
            __webpack_require__(4590);
            __webpack_require__(2801);
            __webpack_require__(541);
            (function webpackUniversalModuleDefinition(root, factory) {
              if (true)
                module.exports = factory();
              else {
              }
            })(this, function() {
              return function(modules) {
                var installedModules = {};
                function __w_pdfjs_require__2(moduleId) {
                  if (installedModules[moduleId]) {
                    return installedModules[moduleId].exports;
                  }
                  var module2 = installedModules[moduleId] = { i: moduleId, l: false, exports: {} };
                  modules[moduleId].call(module2.exports, module2, module2.exports, __w_pdfjs_require__2);
                  module2.l = true;
                  return module2.exports;
                }
                __w_pdfjs_require__2.m = modules;
                __w_pdfjs_require__2.c = installedModules;
                __w_pdfjs_require__2.d = function(exports2, name, getter) {
                  if (!__w_pdfjs_require__2.o(exports2, name)) {
                    Object.defineProperty(exports2, name, { enumerable: true, get: getter });
                  }
                };
                __w_pdfjs_require__2.r = function(exports2) {
                  if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
                    Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
                  }
                  Object.defineProperty(exports2, "__esModule", { value: true });
                };
                __w_pdfjs_require__2.t = function(value, mode) {
                  if (mode & 1)
                    value = __w_pdfjs_require__2(value);
                  if (mode & 8)
                    return value;
                  if (mode & 4 && typeof value === "object" && value && value.__esModule)
                    return value;
                  var ns = /* @__PURE__ */ Object.create(null);
                  __w_pdfjs_require__2.r(ns);
                  Object.defineProperty(ns, "default", { enumerable: true, value });
                  if (mode & 2 && typeof value != "string")
                    for (var key in value)
                      __w_pdfjs_require__2.d(ns, key, function(key2) {
                        return value[key2];
                      }.bind(null, key));
                  return ns;
                };
                __w_pdfjs_require__2.n = function(module2) {
                  var getter = module2 && module2.__esModule ? function getDefault() {
                    return module2["default"];
                  } : function getModuleExports() {
                    return module2;
                  };
                  __w_pdfjs_require__2.d(getter, "a", getter);
                  return getter;
                };
                __w_pdfjs_require__2.o = function(object, property) {
                  return Object.prototype.hasOwnProperty.call(object, property);
                };
                __w_pdfjs_require__2.p = "";
                return __w_pdfjs_require__2(__w_pdfjs_require__2.s = 0);
              }([function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                var pdfjsVersion = "2.4.456";
                var pdfjsBuild = "228a591c";
                var pdfjsSharedUtil = __w_pdfjs_require__2(1);
                var pdfjsDisplayAPI = __w_pdfjs_require__2(190);
                var pdfjsDisplayTextLayer = __w_pdfjs_require__2(205);
                var pdfjsDisplayAnnotationLayer = __w_pdfjs_require__2(206);
                var pdfjsDisplayDisplayUtils = __w_pdfjs_require__2(194);
                var pdfjsDisplaySVG = __w_pdfjs_require__2(207);
                var pdfjsDisplayWorkerOptions = __w_pdfjs_require__2(199);
                var pdfjsDisplayAPICompatibility = __w_pdfjs_require__2(196);
                {
                  var _require = __w_pdfjs_require__2(48), isNodeJS = _require.isNodeJS;
                  if (isNodeJS) {
                    var PDFNodeStream = __w_pdfjs_require__2(208).PDFNodeStream;
                    pdfjsDisplayAPI.setPDFNetworkStreamFactory(function(params) {
                      return new PDFNodeStream(params);
                    });
                  } else {
                    var PDFNetworkStream = __w_pdfjs_require__2(211).PDFNetworkStream;
                    var PDFFetchStream;
                    if (pdfjsDisplayDisplayUtils.isFetchSupported()) {
                      PDFFetchStream = __w_pdfjs_require__2(212).PDFFetchStream;
                    }
                    pdfjsDisplayAPI.setPDFNetworkStreamFactory(function(params) {
                      if (PDFFetchStream && pdfjsDisplayDisplayUtils.isValidFetchUrl(params.url)) {
                        return new PDFFetchStream(params);
                      }
                      return new PDFNetworkStream(params);
                    });
                  }
                }
                exports2.build = pdfjsDisplayAPI.build;
                exports2.version = pdfjsDisplayAPI.version;
                exports2.getDocument = pdfjsDisplayAPI.getDocument;
                exports2.LoopbackPort = pdfjsDisplayAPI.LoopbackPort;
                exports2.PDFDataRangeTransport = pdfjsDisplayAPI.PDFDataRangeTransport;
                exports2.PDFWorker = pdfjsDisplayAPI.PDFWorker;
                exports2.renderTextLayer = pdfjsDisplayTextLayer.renderTextLayer;
                exports2.AnnotationLayer = pdfjsDisplayAnnotationLayer.AnnotationLayer;
                exports2.createPromiseCapability = pdfjsSharedUtil.createPromiseCapability;
                exports2.PasswordResponses = pdfjsSharedUtil.PasswordResponses;
                exports2.InvalidPDFException = pdfjsSharedUtil.InvalidPDFException;
                exports2.MissingPDFException = pdfjsSharedUtil.MissingPDFException;
                exports2.SVGGraphics = pdfjsDisplaySVG.SVGGraphics;
                exports2.NativeImageDecoding = pdfjsSharedUtil.NativeImageDecoding;
                exports2.CMapCompressionType = pdfjsSharedUtil.CMapCompressionType;
                exports2.PermissionFlag = pdfjsSharedUtil.PermissionFlag;
                exports2.UnexpectedResponseException = pdfjsSharedUtil.UnexpectedResponseException;
                exports2.OPS = pdfjsSharedUtil.OPS;
                exports2.VerbosityLevel = pdfjsSharedUtil.VerbosityLevel;
                exports2.UNSUPPORTED_FEATURES = pdfjsSharedUtil.UNSUPPORTED_FEATURES;
                exports2.createValidAbsoluteUrl = pdfjsSharedUtil.createValidAbsoluteUrl;
                exports2.createObjectURL = pdfjsSharedUtil.createObjectURL;
                exports2.removeNullCharacters = pdfjsSharedUtil.removeNullCharacters;
                exports2.shadow = pdfjsSharedUtil.shadow;
                exports2.Util = pdfjsSharedUtil.Util;
                exports2.RenderingCancelledException = pdfjsDisplayDisplayUtils.RenderingCancelledException;
                exports2.getFilenameFromUrl = pdfjsDisplayDisplayUtils.getFilenameFromUrl;
                exports2.LinkTarget = pdfjsDisplayDisplayUtils.LinkTarget;
                exports2.addLinkAttributes = pdfjsDisplayDisplayUtils.addLinkAttributes;
                exports2.loadScript = pdfjsDisplayDisplayUtils.loadScript;
                exports2.PDFDateString = pdfjsDisplayDisplayUtils.PDFDateString;
                exports2.GlobalWorkerOptions = pdfjsDisplayWorkerOptions.GlobalWorkerOptions;
                exports2.apiCompatibilityParams = pdfjsDisplayAPICompatibility.apiCompatibilityParams;
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.arrayByteLength = arrayByteLength;
                exports2.arraysToBytes = arraysToBytes;
                exports2.assert = assert;
                exports2.bytesToString = bytesToString;
                exports2.createPromiseCapability = createPromiseCapability;
                exports2.getVerbosityLevel = getVerbosityLevel;
                exports2.info = info;
                exports2.isArrayBuffer = isArrayBuffer;
                exports2.isArrayEqual = isArrayEqual;
                exports2.isBool = isBool;
                exports2.isEmptyObj = isEmptyObj;
                exports2.isNum = isNum;
                exports2.isString = isString;
                exports2.isSameOrigin = isSameOrigin;
                exports2.createValidAbsoluteUrl = createValidAbsoluteUrl;
                exports2.removeNullCharacters = removeNullCharacters;
                exports2.setVerbosityLevel = setVerbosityLevel;
                exports2.shadow = shadow;
                exports2.string32 = string32;
                exports2.stringToBytes = stringToBytes;
                exports2.stringToPDFString = stringToPDFString;
                exports2.stringToUTF8String = stringToUTF8String;
                exports2.utf8StringToString = utf8StringToString;
                exports2.warn = warn;
                exports2.unreachable = unreachable;
                exports2.IsEvalSupportedCached = exports2.IsLittleEndianCached = exports2.createObjectURL = exports2.FormatError = exports2.Util = exports2.UnknownErrorException = exports2.UnexpectedResponseException = exports2.TextRenderingMode = exports2.StreamType = exports2.PermissionFlag = exports2.PasswordResponses = exports2.PasswordException = exports2.NativeImageDecoding = exports2.MissingPDFException = exports2.InvalidPDFException = exports2.AbortException = exports2.CMapCompressionType = exports2.ImageKind = exports2.FontType = exports2.AnnotationType = exports2.AnnotationStateModelType = exports2.AnnotationReviewState = exports2.AnnotationReplyType = exports2.AnnotationMarkedState = exports2.AnnotationFlag = exports2.AnnotationFieldFlag = exports2.AnnotationBorderStyleType = exports2.UNSUPPORTED_FEATURES = exports2.VerbosityLevel = exports2.OPS = exports2.IDENTITY_MATRIX = exports2.FONT_IDENTITY_MATRIX = exports2.BaseException = void 0;
                __w_pdfjs_require__2(2);
                function _defineProperties2(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                function _createClass2(Constructor, protoProps, staticProps) {
                  if (protoProps)
                    _defineProperties2(Constructor.prototype, protoProps);
                  if (staticProps)
                    _defineProperties2(Constructor, staticProps);
                  return Constructor;
                }
                function _typeof2(obj) {
                  "@babel/helpers - typeof";
                  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                    _typeof2 = function _typeof3(obj2) {
                      return typeof obj2;
                    };
                  } else {
                    _typeof2 = function _typeof3(obj2) {
                      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                    };
                  }
                  return _typeof2(obj);
                }
                function _classCallCheck2(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _possibleConstructorReturn(self2, call) {
                  if (call && (_typeof2(call) === "object" || typeof call === "function")) {
                    return call;
                  }
                  return _assertThisInitialized(self2);
                }
                function _assertThisInitialized(self2) {
                  if (self2 === void 0) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  }
                  return self2;
                }
                function _getPrototypeOf(o) {
                  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                    return o2.__proto__ || Object.getPrototypeOf(o2);
                  };
                  return _getPrototypeOf(o);
                }
                function _inherits(subClass, superClass) {
                  if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function");
                  }
                  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
                  if (superClass)
                    _setPrototypeOf(subClass, superClass);
                }
                function _setPrototypeOf(o, p) {
                  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                    o2.__proto__ = p2;
                    return o2;
                  };
                  return _setPrototypeOf(o, p);
                }
                var IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
                exports2.IDENTITY_MATRIX = IDENTITY_MATRIX;
                var FONT_IDENTITY_MATRIX = [1e-3, 0, 0, 1e-3, 0, 0];
                exports2.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;
                var NativeImageDecoding = { NONE: "none", DECODE: "decode", DISPLAY: "display" };
                exports2.NativeImageDecoding = NativeImageDecoding;
                var PermissionFlag = { PRINT: 4, MODIFY_CONTENTS: 8, COPY: 16, MODIFY_ANNOTATIONS: 32, FILL_INTERACTIVE_FORMS: 256, COPY_FOR_ACCESSIBILITY: 512, ASSEMBLE: 1024, PRINT_HIGH_QUALITY: 2048 };
                exports2.PermissionFlag = PermissionFlag;
                var TextRenderingMode = { FILL: 0, STROKE: 1, FILL_STROKE: 2, INVISIBLE: 3, FILL_ADD_TO_PATH: 4, STROKE_ADD_TO_PATH: 5, FILL_STROKE_ADD_TO_PATH: 6, ADD_TO_PATH: 7, FILL_STROKE_MASK: 3, ADD_TO_PATH_FLAG: 4 };
                exports2.TextRenderingMode = TextRenderingMode;
                var ImageKind = { GRAYSCALE_1BPP: 1, RGB_24BPP: 2, RGBA_32BPP: 3 };
                exports2.ImageKind = ImageKind;
                var AnnotationType = { TEXT: 1, LINK: 2, FREETEXT: 3, LINE: 4, SQUARE: 5, CIRCLE: 6, POLYGON: 7, POLYLINE: 8, HIGHLIGHT: 9, UNDERLINE: 10, SQUIGGLY: 11, STRIKEOUT: 12, STAMP: 13, CARET: 14, INK: 15, POPUP: 16, FILEATTACHMENT: 17, SOUND: 18, MOVIE: 19, WIDGET: 20, SCREEN: 21, PRINTERMARK: 22, TRAPNET: 23, WATERMARK: 24, THREED: 25, REDACT: 26 };
                exports2.AnnotationType = AnnotationType;
                var AnnotationStateModelType = { MARKED: "Marked", REVIEW: "Review" };
                exports2.AnnotationStateModelType = AnnotationStateModelType;
                var AnnotationMarkedState = { MARKED: "Marked", UNMARKED: "Unmarked" };
                exports2.AnnotationMarkedState = AnnotationMarkedState;
                var AnnotationReviewState = { ACCEPTED: "Accepted", REJECTED: "Rejected", CANCELLED: "Cancelled", COMPLETED: "Completed", NONE: "None" };
                exports2.AnnotationReviewState = AnnotationReviewState;
                var AnnotationReplyType = { GROUP: "Group", REPLY: "R" };
                exports2.AnnotationReplyType = AnnotationReplyType;
                var AnnotationFlag = { INVISIBLE: 1, HIDDEN: 2, PRINT: 4, NOZOOM: 8, NOROTATE: 16, NOVIEW: 32, READONLY: 64, LOCKED: 128, TOGGLENOVIEW: 256, LOCKEDCONTENTS: 512 };
                exports2.AnnotationFlag = AnnotationFlag;
                var AnnotationFieldFlag = { READONLY: 1, REQUIRED: 2, NOEXPORT: 4, MULTILINE: 4096, PASSWORD: 8192, NOTOGGLETOOFF: 16384, RADIO: 32768, PUSHBUTTON: 65536, COMBO: 131072, EDIT: 262144, SORT: 524288, FILESELECT: 1048576, MULTISELECT: 2097152, DONOTSPELLCHECK: 4194304, DONOTSCROLL: 8388608, COMB: 16777216, RICHTEXT: 33554432, RADIOSINUNISON: 33554432, COMMITONSELCHANGE: 67108864 };
                exports2.AnnotationFieldFlag = AnnotationFieldFlag;
                var AnnotationBorderStyleType = { SOLID: 1, DASHED: 2, BEVELED: 3, INSET: 4, UNDERLINE: 5 };
                exports2.AnnotationBorderStyleType = AnnotationBorderStyleType;
                var StreamType = { UNKNOWN: "UNKNOWN", FLATE: "FLATE", LZW: "LZW", DCT: "DCT", JPX: "JPX", JBIG: "JBIG", A85: "A85", AHX: "AHX", CCF: "CCF", RLX: "RLX" };
                exports2.StreamType = StreamType;
                var FontType = { UNKNOWN: "UNKNOWN", TYPE1: "TYPE1", TYPE1C: "TYPE1C", CIDFONTTYPE0: "CIDFONTTYPE0", CIDFONTTYPE0C: "CIDFONTTYPE0C", TRUETYPE: "TRUETYPE", CIDFONTTYPE2: "CIDFONTTYPE2", TYPE3: "TYPE3", OPENTYPE: "OPENTYPE", TYPE0: "TYPE0", MMTYPE1: "MMTYPE1" };
                exports2.FontType = FontType;
                var VerbosityLevel = { ERRORS: 0, WARNINGS: 1, INFOS: 5 };
                exports2.VerbosityLevel = VerbosityLevel;
                var CMapCompressionType = { NONE: 0, BINARY: 1, STREAM: 2 };
                exports2.CMapCompressionType = CMapCompressionType;
                var OPS = { dependency: 1, setLineWidth: 2, setLineCap: 3, setLineJoin: 4, setMiterLimit: 5, setDash: 6, setRenderingIntent: 7, setFlatness: 8, setGState: 9, save: 10, restore: 11, transform: 12, moveTo: 13, lineTo: 14, curveTo: 15, curveTo2: 16, curveTo3: 17, closePath: 18, rectangle: 19, stroke: 20, closeStroke: 21, fill: 22, eoFill: 23, fillStroke: 24, eoFillStroke: 25, closeFillStroke: 26, closeEOFillStroke: 27, endPath: 28, clip: 29, eoClip: 30, beginText: 31, endText: 32, setCharSpacing: 33, setWordSpacing: 34, setHScale: 35, setLeading: 36, setFont: 37, setTextRenderingMode: 38, setTextRise: 39, moveText: 40, setLeadingMoveText: 41, setTextMatrix: 42, nextLine: 43, showText: 44, showSpacedText: 45, nextLineShowText: 46, nextLineSetSpacingShowText: 47, setCharWidth: 48, setCharWidthAndBounds: 49, setStrokeColorSpace: 50, setFillColorSpace: 51, setStrokeColor: 52, setStrokeColorN: 53, setFillColor: 54, setFillColorN: 55, setStrokeGray: 56, setFillGray: 57, setStrokeRGBColor: 58, setFillRGBColor: 59, setStrokeCMYKColor: 60, setFillCMYKColor: 61, shadingFill: 62, beginInlineImage: 63, beginImageData: 64, endInlineImage: 65, paintXObject: 66, markPoint: 67, markPointProps: 68, beginMarkedContent: 69, beginMarkedContentProps: 70, endMarkedContent: 71, beginCompat: 72, endCompat: 73, paintFormXObjectBegin: 74, paintFormXObjectEnd: 75, beginGroup: 76, endGroup: 77, beginAnnotations: 78, endAnnotations: 79, beginAnnotation: 80, endAnnotation: 81, paintJpegXObject: 82, paintImageMaskXObject: 83, paintImageMaskXObjectGroup: 84, paintImageXObject: 85, paintInlineImageXObject: 86, paintInlineImageXObjectGroup: 87, paintImageXObjectRepeat: 88, paintImageMaskXObjectRepeat: 89, paintSolidColorImageMask: 90, constructPath: 91 };
                exports2.OPS = OPS;
                var UNSUPPORTED_FEATURES = { unknown: "unknown", forms: "forms", javaScript: "javaScript", smask: "smask", shadingPattern: "shadingPattern", font: "font" };
                exports2.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES;
                var PasswordResponses = { NEED_PASSWORD: 1, INCORRECT_PASSWORD: 2 };
                exports2.PasswordResponses = PasswordResponses;
                var verbosity = VerbosityLevel.WARNINGS;
                function setVerbosityLevel(level) {
                  if (Number.isInteger(level)) {
                    verbosity = level;
                  }
                }
                function getVerbosityLevel() {
                  return verbosity;
                }
                function info(msg) {
                  if (verbosity >= VerbosityLevel.INFOS) {
                    console.log("Info: ".concat(msg));
                  }
                }
                function warn(msg) {
                  if (verbosity >= VerbosityLevel.WARNINGS) {
                    console.log("Warning: ".concat(msg));
                  }
                }
                function unreachable(msg) {
                  throw new Error(msg);
                }
                function assert(cond, msg) {
                  if (!cond) {
                    unreachable(msg);
                  }
                }
                function isSameOrigin(baseUrl, otherUrl) {
                  var base;
                  try {
                    base = new URL(baseUrl);
                    if (!base.origin || base.origin === "null") {
                      return false;
                    }
                  } catch (e) {
                    return false;
                  }
                  var other = new URL(otherUrl, base);
                  return base.origin === other.origin;
                }
                function _isValidProtocol(url) {
                  if (!url) {
                    return false;
                  }
                  switch (url.protocol) {
                    case "http:":
                    case "https:":
                    case "ftp:":
                    case "mailto:":
                    case "tel:":
                      return true;
                    default:
                      return false;
                  }
                }
                function createValidAbsoluteUrl(url, baseUrl) {
                  if (!url) {
                    return null;
                  }
                  try {
                    var absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);
                    if (_isValidProtocol(absoluteUrl)) {
                      return absoluteUrl;
                    }
                  } catch (ex) {
                  }
                  return null;
                }
                function shadow(obj, prop, value) {
                  Object.defineProperty(obj, prop, { value, enumerable: true, configurable: true, writable: false });
                  return value;
                }
                var BaseException = function BaseExceptionClosure() {
                  function BaseException2(message) {
                    if (this.constructor === BaseException2) {
                      unreachable("Cannot initialize BaseException.");
                    }
                    this.message = message;
                    this.name = this.constructor.name;
                  }
                  BaseException2.prototype = new Error();
                  BaseException2.constructor = BaseException2;
                  return BaseException2;
                }();
                exports2.BaseException = BaseException;
                var PasswordException = function(_BaseException) {
                  _inherits(PasswordException2, _BaseException);
                  function PasswordException2(msg, code) {
                    var _this;
                    _classCallCheck2(this, PasswordException2);
                    _this = _possibleConstructorReturn(this, _getPrototypeOf(PasswordException2).call(this, msg));
                    _this.code = code;
                    return _this;
                  }
                  return PasswordException2;
                }(BaseException);
                exports2.PasswordException = PasswordException;
                var UnknownErrorException = function(_BaseException2) {
                  _inherits(UnknownErrorException2, _BaseException2);
                  function UnknownErrorException2(msg, details) {
                    var _this2;
                    _classCallCheck2(this, UnknownErrorException2);
                    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(UnknownErrorException2).call(this, msg));
                    _this2.details = details;
                    return _this2;
                  }
                  return UnknownErrorException2;
                }(BaseException);
                exports2.UnknownErrorException = UnknownErrorException;
                var InvalidPDFException = function(_BaseException3) {
                  _inherits(InvalidPDFException2, _BaseException3);
                  function InvalidPDFException2() {
                    _classCallCheck2(this, InvalidPDFException2);
                    return _possibleConstructorReturn(this, _getPrototypeOf(InvalidPDFException2).apply(this, arguments));
                  }
                  return InvalidPDFException2;
                }(BaseException);
                exports2.InvalidPDFException = InvalidPDFException;
                var MissingPDFException = function(_BaseException4) {
                  _inherits(MissingPDFException2, _BaseException4);
                  function MissingPDFException2() {
                    _classCallCheck2(this, MissingPDFException2);
                    return _possibleConstructorReturn(this, _getPrototypeOf(MissingPDFException2).apply(this, arguments));
                  }
                  return MissingPDFException2;
                }(BaseException);
                exports2.MissingPDFException = MissingPDFException;
                var UnexpectedResponseException = function(_BaseException5) {
                  _inherits(UnexpectedResponseException2, _BaseException5);
                  function UnexpectedResponseException2(msg, status) {
                    var _this3;
                    _classCallCheck2(this, UnexpectedResponseException2);
                    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(UnexpectedResponseException2).call(this, msg));
                    _this3.status = status;
                    return _this3;
                  }
                  return UnexpectedResponseException2;
                }(BaseException);
                exports2.UnexpectedResponseException = UnexpectedResponseException;
                var FormatError = function(_BaseException6) {
                  _inherits(FormatError2, _BaseException6);
                  function FormatError2() {
                    _classCallCheck2(this, FormatError2);
                    return _possibleConstructorReturn(this, _getPrototypeOf(FormatError2).apply(this, arguments));
                  }
                  return FormatError2;
                }(BaseException);
                exports2.FormatError = FormatError;
                var AbortException = function(_BaseException7) {
                  _inherits(AbortException2, _BaseException7);
                  function AbortException2() {
                    _classCallCheck2(this, AbortException2);
                    return _possibleConstructorReturn(this, _getPrototypeOf(AbortException2).apply(this, arguments));
                  }
                  return AbortException2;
                }(BaseException);
                exports2.AbortException = AbortException;
                var NullCharactersRegExp = /\x00/g;
                function removeNullCharacters(str) {
                  if (typeof str !== "string") {
                    warn("The argument for removeNullCharacters must be a string.");
                    return str;
                  }
                  return str.replace(NullCharactersRegExp, "");
                }
                function bytesToString(bytes) {
                  assert(bytes !== null && _typeof2(bytes) === "object" && bytes.length !== void 0, "Invalid argument for bytesToString");
                  var length = bytes.length;
                  var MAX_ARGUMENT_COUNT = 8192;
                  if (length < MAX_ARGUMENT_COUNT) {
                    return String.fromCharCode.apply(null, bytes);
                  }
                  var strBuf = [];
                  for (var i = 0; i < length; i += MAX_ARGUMENT_COUNT) {
                    var chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);
                    var chunk = bytes.subarray(i, chunkEnd);
                    strBuf.push(String.fromCharCode.apply(null, chunk));
                  }
                  return strBuf.join("");
                }
                function stringToBytes(str) {
                  assert(typeof str === "string", "Invalid argument for stringToBytes");
                  var length = str.length;
                  var bytes = new Uint8Array(length);
                  for (var i = 0; i < length; ++i) {
                    bytes[i] = str.charCodeAt(i) & 255;
                  }
                  return bytes;
                }
                function arrayByteLength(arr) {
                  if (arr.length !== void 0) {
                    return arr.length;
                  }
                  assert(arr.byteLength !== void 0);
                  return arr.byteLength;
                }
                function arraysToBytes(arr) {
                  var length = arr.length;
                  if (length === 1 && arr[0] instanceof Uint8Array) {
                    return arr[0];
                  }
                  var resultLength = 0;
                  for (var i = 0; i < length; i++) {
                    resultLength += arrayByteLength(arr[i]);
                  }
                  var pos = 0;
                  var data = new Uint8Array(resultLength);
                  for (var _i = 0; _i < length; _i++) {
                    var item = arr[_i];
                    if (!(item instanceof Uint8Array)) {
                      if (typeof item === "string") {
                        item = stringToBytes(item);
                      } else {
                        item = new Uint8Array(item);
                      }
                    }
                    var itemLength = item.byteLength;
                    data.set(item, pos);
                    pos += itemLength;
                  }
                  return data;
                }
                function string32(value) {
                  return String.fromCharCode(value >> 24 & 255, value >> 16 & 255, value >> 8 & 255, value & 255);
                }
                function isLittleEndian() {
                  var buffer8 = new Uint8Array(4);
                  buffer8[0] = 1;
                  var view32 = new Uint32Array(buffer8.buffer, 0, 1);
                  return view32[0] === 1;
                }
                var IsLittleEndianCached = { get value() {
                  return shadow(this, "value", isLittleEndian());
                } };
                exports2.IsLittleEndianCached = IsLittleEndianCached;
                function isEvalSupported() {
                  try {
                    new Function("");
                    return true;
                  } catch (e) {
                    return false;
                  }
                }
                var IsEvalSupportedCached = { get value() {
                  return shadow(this, "value", isEvalSupported());
                } };
                exports2.IsEvalSupportedCached = IsEvalSupportedCached;
                var rgbBuf = ["rgb(", 0, ",", 0, ",", 0, ")"];
                var Util = function() {
                  function Util2() {
                    _classCallCheck2(this, Util2);
                  }
                  _createClass2(Util2, null, [{ key: "makeCssRgb", value: function makeCssRgb(r, g, b) {
                    rgbBuf[1] = r;
                    rgbBuf[3] = g;
                    rgbBuf[5] = b;
                    return rgbBuf.join("");
                  } }, { key: "transform", value: function transform(m1, m2) {
                    return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
                  } }, { key: "applyTransform", value: function applyTransform(p, m) {
                    var xt = p[0] * m[0] + p[1] * m[2] + m[4];
                    var yt = p[0] * m[1] + p[1] * m[3] + m[5];
                    return [xt, yt];
                  } }, { key: "applyInverseTransform", value: function applyInverseTransform(p, m) {
                    var d = m[0] * m[3] - m[1] * m[2];
                    var xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
                    var yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
                    return [xt, yt];
                  } }, { key: "getAxialAlignedBoundingBox", value: function getAxialAlignedBoundingBox(r, m) {
                    var p1 = Util2.applyTransform(r, m);
                    var p2 = Util2.applyTransform(r.slice(2, 4), m);
                    var p3 = Util2.applyTransform([r[0], r[3]], m);
                    var p4 = Util2.applyTransform([r[2], r[1]], m);
                    return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];
                  } }, { key: "inverseTransform", value: function inverseTransform(m) {
                    var d = m[0] * m[3] - m[1] * m[2];
                    return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
                  } }, { key: "apply3dTransform", value: function apply3dTransform(m, v) {
                    return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]];
                  } }, { key: "singularValueDecompose2dScale", value: function singularValueDecompose2dScale(m) {
                    var transpose = [m[0], m[2], m[1], m[3]];
                    var a = m[0] * transpose[0] + m[1] * transpose[2];
                    var b = m[0] * transpose[1] + m[1] * transpose[3];
                    var c = m[2] * transpose[0] + m[3] * transpose[2];
                    var d = m[2] * transpose[1] + m[3] * transpose[3];
                    var first = (a + d) / 2;
                    var second = Math.sqrt((a + d) * (a + d) - 4 * (a * d - c * b)) / 2;
                    var sx = first + second || 1;
                    var sy = first - second || 1;
                    return [Math.sqrt(sx), Math.sqrt(sy)];
                  } }, { key: "normalizeRect", value: function normalizeRect(rect) {
                    var r = rect.slice(0);
                    if (rect[0] > rect[2]) {
                      r[0] = rect[2];
                      r[2] = rect[0];
                    }
                    if (rect[1] > rect[3]) {
                      r[1] = rect[3];
                      r[3] = rect[1];
                    }
                    return r;
                  } }, { key: "intersect", value: function intersect(rect1, rect2) {
                    function compare(a, b) {
                      return a - b;
                    }
                    var orderedX = [rect1[0], rect1[2], rect2[0], rect2[2]].sort(compare);
                    var orderedY = [rect1[1], rect1[3], rect2[1], rect2[3]].sort(compare);
                    var result = [];
                    rect1 = Util2.normalizeRect(rect1);
                    rect2 = Util2.normalizeRect(rect2);
                    if (orderedX[0] === rect1[0] && orderedX[1] === rect2[0] || orderedX[0] === rect2[0] && orderedX[1] === rect1[0]) {
                      result[0] = orderedX[1];
                      result[2] = orderedX[2];
                    } else {
                      return null;
                    }
                    if (orderedY[0] === rect1[1] && orderedY[1] === rect2[1] || orderedY[0] === rect2[1] && orderedY[1] === rect1[1]) {
                      result[1] = orderedY[1];
                      result[3] = orderedY[2];
                    } else {
                      return null;
                    }
                    return result;
                  } }]);
                  return Util2;
                }();
                exports2.Util = Util;
                var PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364];
                function stringToPDFString(str) {
                  var length = str.length, strBuf = [];
                  if (str[0] === "\xFE" && str[1] === "\xFF") {
                    for (var i = 2; i < length; i += 2) {
                      strBuf.push(String.fromCharCode(str.charCodeAt(i) << 8 | str.charCodeAt(i + 1)));
                    }
                  } else if (str[0] === "\xFF" && str[1] === "\xFE") {
                    for (var _i2 = 2; _i2 < length; _i2 += 2) {
                      strBuf.push(String.fromCharCode(str.charCodeAt(_i2 + 1) << 8 | str.charCodeAt(_i2)));
                    }
                  } else {
                    for (var _i3 = 0; _i3 < length; ++_i3) {
                      var code = PDFStringTranslateTable[str.charCodeAt(_i3)];
                      strBuf.push(code ? String.fromCharCode(code) : str.charAt(_i3));
                    }
                  }
                  return strBuf.join("");
                }
                function stringToUTF8String(str) {
                  return decodeURIComponent(escape(str));
                }
                function utf8StringToString(str) {
                  return unescape(encodeURIComponent(str));
                }
                function isEmptyObj(obj) {
                  for (var key in obj) {
                    return false;
                  }
                  return true;
                }
                function isBool(v) {
                  return typeof v === "boolean";
                }
                function isNum(v) {
                  return typeof v === "number";
                }
                function isString(v) {
                  return typeof v === "string";
                }
                function isArrayBuffer(v) {
                  return _typeof2(v) === "object" && v !== null && v.byteLength !== void 0;
                }
                function isArrayEqual(arr1, arr2) {
                  if (arr1.length !== arr2.length) {
                    return false;
                  }
                  return arr1.every(function(element, index) {
                    return element === arr2[index];
                  });
                }
                function createPromiseCapability() {
                  var capability = /* @__PURE__ */ Object.create(null);
                  var isSettled = false;
                  Object.defineProperty(capability, "settled", { get: function get() {
                    return isSettled;
                  } });
                  capability.promise = new Promise(function(resolve, reject) {
                    capability.resolve = function(data) {
                      isSettled = true;
                      resolve(data);
                    };
                    capability.reject = function(reason) {
                      isSettled = true;
                      reject(reason);
                    };
                  });
                  return capability;
                }
                var createObjectURL = function createObjectURLClosure() {
                  var digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
                  return function createObjectURL2(data, contentType) {
                    var forceDataSchema = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                    if (!forceDataSchema && URL.createObjectURL) {
                      var blob = new Blob([data], { type: contentType });
                      return URL.createObjectURL(blob);
                    }
                    var buffer = "data:".concat(contentType, ";base64,");
                    for (var i = 0, ii = data.length; i < ii; i += 3) {
                      var b1 = data[i] & 255;
                      var b2 = data[i + 1] & 255;
                      var b3 = data[i + 2] & 255;
                      var d1 = b1 >> 2, d2 = (b1 & 3) << 4 | b2 >> 4;
                      var d3 = i + 1 < ii ? (b2 & 15) << 2 | b3 >> 6 : 64;
                      var d4 = i + 2 < ii ? b3 & 63 : 64;
                      buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];
                    }
                    return buffer;
                  };
                }();
                exports2.createObjectURL = createObjectURL;
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                function _typeof2(obj) {
                  "@babel/helpers - typeof";
                  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                    _typeof2 = function _typeof3(obj2) {
                      return typeof obj2;
                    };
                  } else {
                    _typeof2 = function _typeof3(obj2) {
                      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                    };
                  }
                  return _typeof2(obj);
                }
                if (typeof globalThis === "undefined" || !globalThis._pdfjsCompatibilityChecked) {
                  if (typeof globalThis === "undefined" || globalThis.Math !== Math) {
                    globalThis = __w_pdfjs_require__2(3);
                  }
                  globalThis._pdfjsCompatibilityChecked = true;
                  var _require = __w_pdfjs_require__2(48), isNodeJS = _require.isNodeJS;
                  var hasDOM = (typeof window === "undefined" ? "undefined" : _typeof2(window)) === "object" && (typeof document === "undefined" ? "undefined" : _typeof2(document)) === "object";
                  var userAgent = typeof navigator !== "undefined" && navigator.userAgent || "";
                  var isIE = /Trident/.test(userAgent);
                  (function checkNodeBtoa() {
                    if (globalThis.btoa || !isNodeJS) {
                      return;
                    }
                    globalThis.btoa = function(chars) {
                      return Buffer.from(chars, "binary").toString("base64");
                    };
                  })();
                  (function checkNodeAtob() {
                    if (globalThis.atob || !isNodeJS) {
                      return;
                    }
                    globalThis.atob = function(input) {
                      return Buffer.from(input, "base64").toString("binary");
                    };
                  })();
                  (function checkChildNodeRemove() {
                    if (!hasDOM) {
                      return;
                    }
                    if (typeof Element.prototype.remove !== "undefined") {
                      return;
                    }
                    Element.prototype.remove = function() {
                      if (this.parentNode) {
                        this.parentNode.removeChild(this);
                      }
                    };
                  })();
                  (function checkDOMTokenListAddRemove() {
                    if (!hasDOM || isNodeJS) {
                      return;
                    }
                    var div = document.createElement("div");
                    div.classList.add("testOne", "testTwo");
                    if (div.classList.contains("testOne") === true && div.classList.contains("testTwo") === true) {
                      return;
                    }
                    var OriginalDOMTokenListAdd = DOMTokenList.prototype.add;
                    var OriginalDOMTokenListRemove = DOMTokenList.prototype.remove;
                    DOMTokenList.prototype.add = function() {
                      for (var _len = arguments.length, tokens = new Array(_len), _key = 0; _key < _len; _key++) {
                        tokens[_key] = arguments[_key];
                      }
                      for (var _i = 0, _tokens = tokens; _i < _tokens.length; _i++) {
                        var token = _tokens[_i];
                        OriginalDOMTokenListAdd.call(this, token);
                      }
                    };
                    DOMTokenList.prototype.remove = function() {
                      for (var _len2 = arguments.length, tokens = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                        tokens[_key2] = arguments[_key2];
                      }
                      for (var _i2 = 0, _tokens2 = tokens; _i2 < _tokens2.length; _i2++) {
                        var token = _tokens2[_i2];
                        OriginalDOMTokenListRemove.call(this, token);
                      }
                    };
                  })();
                  (function checkDOMTokenListToggle() {
                    if (!hasDOM || isNodeJS) {
                      return;
                    }
                    var div = document.createElement("div");
                    if (div.classList.toggle("test", 0) === false) {
                      return;
                    }
                    DOMTokenList.prototype.toggle = function(token) {
                      var force = arguments.length > 1 ? !!arguments[1] : !this.contains(token);
                      return this[force ? "add" : "remove"](token), force;
                    };
                  })();
                  (function checkWindowHistoryPushStateReplaceState() {
                    if (!hasDOM || !isIE) {
                      return;
                    }
                    var OriginalPushState = window.history.pushState;
                    var OriginalReplaceState = window.history.replaceState;
                    window.history.pushState = function(state, title, url) {
                      var args = url === void 0 ? [state, title] : [state, title, url];
                      OriginalPushState.apply(this, args);
                    };
                    window.history.replaceState = function(state, title, url) {
                      var args = url === void 0 ? [state, title] : [state, title, url];
                      OriginalReplaceState.apply(this, args);
                    };
                  })();
                  (function checkStringStartsWith() {
                    if (String.prototype.startsWith) {
                      return;
                    }
                    __w_pdfjs_require__2(49);
                  })();
                  (function checkStringEndsWith() {
                    if (String.prototype.endsWith) {
                      return;
                    }
                    __w_pdfjs_require__2(60);
                  })();
                  (function checkStringIncludes() {
                    if (String.prototype.includes) {
                      return;
                    }
                    __w_pdfjs_require__2(62);
                  })();
                  (function checkArrayIncludes() {
                    if (Array.prototype.includes) {
                      return;
                    }
                    __w_pdfjs_require__2(64);
                  })();
                  (function checkArrayFrom() {
                    if (Array.from) {
                      return;
                    }
                    __w_pdfjs_require__2(72);
                  })();
                  (function checkObjectAssign() {
                    if (Object.assign) {
                      return;
                    }
                    __w_pdfjs_require__2(94);
                  })();
                  (function checkMathLog2() {
                    if (Math.log2) {
                      return;
                    }
                    Math.log2 = __w_pdfjs_require__2(97);
                  })();
                  (function checkNumberIsNaN() {
                    if (Number.isNaN) {
                      return;
                    }
                    Number.isNaN = __w_pdfjs_require__2(99);
                  })();
                  (function checkNumberIsInteger() {
                    if (Number.isInteger) {
                      return;
                    }
                    Number.isInteger = __w_pdfjs_require__2(101);
                  })();
                  (function checkPromise() {
                    if (globalThis.Promise && globalThis.Promise.allSettled) {
                      return;
                    }
                    globalThis.Promise = __w_pdfjs_require__2(104);
                  })();
                  (function checkURL() {
                    globalThis.URL = __w_pdfjs_require__2(128);
                  })();
                  (function checkReadableStream() {
                    var isReadableStreamSupported = false;
                    if (typeof ReadableStream !== "undefined") {
                      try {
                        new ReadableStream({ start: function start(controller) {
                          controller.close();
                        } });
                        isReadableStreamSupported = true;
                      } catch (e) {
                      }
                    }
                    if (isReadableStreamSupported) {
                      return;
                    }
                    globalThis.ReadableStream = __w_pdfjs_require__2(135).ReadableStream;
                  })();
                  (function checkMapEntries() {
                    if (globalThis.Map && globalThis.Map.prototype.entries) {
                      return;
                    }
                    globalThis.Map = __w_pdfjs_require__2(136);
                  })();
                  (function checkSetEntries() {
                    if (globalThis.Set && globalThis.Set.prototype.entries) {
                      return;
                    }
                    globalThis.Set = __w_pdfjs_require__2(143);
                  })();
                  (function checkWeakMap() {
                    if (globalThis.WeakMap) {
                      return;
                    }
                    globalThis.WeakMap = __w_pdfjs_require__2(145);
                  })();
                  (function checkWeakSet() {
                    if (globalThis.WeakSet) {
                      return;
                    }
                    globalThis.WeakSet = __w_pdfjs_require__2(151);
                  })();
                  (function checkStringCodePointAt() {
                    if (String.prototype.codePointAt) {
                      return;
                    }
                    __w_pdfjs_require__2(153);
                  })();
                  (function checkStringFromCodePoint() {
                    if (String.fromCodePoint) {
                      return;
                    }
                    String.fromCodePoint = __w_pdfjs_require__2(155);
                  })();
                  (function checkSymbol() {
                    if (globalThis.Symbol) {
                      return;
                    }
                    __w_pdfjs_require__2(157);
                  })();
                  (function checkStringPadStart() {
                    if (String.prototype.padStart) {
                      return;
                    }
                    __w_pdfjs_require__2(180);
                  })();
                  (function checkStringPadEnd() {
                    if (String.prototype.padEnd) {
                      return;
                    }
                    __w_pdfjs_require__2(185);
                  })();
                  (function checkObjectValues() {
                    if (Object.values) {
                      return;
                    }
                    Object.values = __w_pdfjs_require__2(187);
                  })();
                }
              }, function(module2, exports2, __w_pdfjs_require__2) {
                __w_pdfjs_require__2(4);
                module2.exports = __w_pdfjs_require__2(6);
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var $ = __w_pdfjs_require__2(5);
                var global = __w_pdfjs_require__2(6);
                $({ global: true }, { globalThis: global });
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var global = __w_pdfjs_require__2(6);
                var getOwnPropertyDescriptor = __w_pdfjs_require__2(7).f;
                var createNonEnumerableProperty = __w_pdfjs_require__2(21);
                var redefine = __w_pdfjs_require__2(24);
                var setGlobal = __w_pdfjs_require__2(25);
                var copyConstructorProperties = __w_pdfjs_require__2(35);
                var isForced = __w_pdfjs_require__2(47);
                module2.exports = function(options, source) {
                  var TARGET = options.target;
                  var GLOBAL = options.global;
                  var STATIC = options.stat;
                  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
                  if (GLOBAL) {
                    target = global;
                  } else if (STATIC) {
                    target = global[TARGET] || setGlobal(TARGET, {});
                  } else {
                    target = (global[TARGET] || {}).prototype;
                  }
                  if (target)
                    for (key in source) {
                      sourceProperty = source[key];
                      if (options.noTargetGet) {
                        descriptor = getOwnPropertyDescriptor(target, key);
                        targetProperty = descriptor && descriptor.value;
                      } else
                        targetProperty = target[key];
                      FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
                      if (!FORCED && targetProperty !== void 0) {
                        if (typeof sourceProperty === typeof targetProperty)
                          continue;
                        copyConstructorProperties(sourceProperty, targetProperty);
                      }
                      if (options.sham || targetProperty && targetProperty.sham) {
                        createNonEnumerableProperty(sourceProperty, "sham", true);
                      }
                      redefine(target, key, sourceProperty, options);
                    }
                };
              }, function(module2, exports2) {
                var check = function(it) {
                  return it && it.Math == Math && it;
                };
                module2.exports = check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || check(typeof self == "object" && self) || check(typeof __webpack_require__.g == "object" && __webpack_require__.g) || Function("return this")();
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var DESCRIPTORS = __w_pdfjs_require__2(8);
                var propertyIsEnumerableModule = __w_pdfjs_require__2(10);
                var createPropertyDescriptor = __w_pdfjs_require__2(11);
                var toIndexedObject = __w_pdfjs_require__2(12);
                var toPrimitive = __w_pdfjs_require__2(16);
                var has = __w_pdfjs_require__2(18);
                var IE8_DOM_DEFINE = __w_pdfjs_require__2(19);
                var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
                exports2.f = DESCRIPTORS ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
                  O = toIndexedObject(O);
                  P = toPrimitive(P, true);
                  if (IE8_DOM_DEFINE)
                    try {
                      return nativeGetOwnPropertyDescriptor(O, P);
                    } catch (error) {
                    }
                  if (has(O, P))
                    return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var fails = __w_pdfjs_require__2(9);
                module2.exports = !fails(function() {
                  return Object.defineProperty({}, 1, { get: function() {
                    return 7;
                  } })[1] != 7;
                });
              }, function(module2, exports2) {
                module2.exports = function(exec) {
                  try {
                    return !!exec();
                  } catch (error) {
                    return true;
                  }
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
                var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
                var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);
                exports2.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
                  var descriptor = getOwnPropertyDescriptor(this, V);
                  return !!descriptor && descriptor.enumerable;
                } : nativePropertyIsEnumerable;
              }, function(module2, exports2) {
                module2.exports = function(bitmap, value) {
                  return { enumerable: !(bitmap & 1), configurable: !(bitmap & 2), writable: !(bitmap & 4), value };
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var IndexedObject = __w_pdfjs_require__2(13);
                var requireObjectCoercible = __w_pdfjs_require__2(15);
                module2.exports = function(it) {
                  return IndexedObject(requireObjectCoercible(it));
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var fails = __w_pdfjs_require__2(9);
                var classof = __w_pdfjs_require__2(14);
                var split = "".split;
                module2.exports = fails(function() {
                  return !Object("z").propertyIsEnumerable(0);
                }) ? function(it) {
                  return classof(it) == "String" ? split.call(it, "") : Object(it);
                } : Object;
              }, function(module2, exports2) {
                var toString = {}.toString;
                module2.exports = function(it) {
                  return toString.call(it).slice(8, -1);
                };
              }, function(module2, exports2) {
                module2.exports = function(it) {
                  if (it == void 0)
                    throw TypeError("Can't call method on " + it);
                  return it;
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var isObject = __w_pdfjs_require__2(17);
                module2.exports = function(input, PREFERRED_STRING) {
                  if (!isObject(input))
                    return input;
                  var fn, val;
                  if (PREFERRED_STRING && typeof (fn = input.toString) == "function" && !isObject(val = fn.call(input)))
                    return val;
                  if (typeof (fn = input.valueOf) == "function" && !isObject(val = fn.call(input)))
                    return val;
                  if (!PREFERRED_STRING && typeof (fn = input.toString) == "function" && !isObject(val = fn.call(input)))
                    return val;
                  throw TypeError("Can't convert object to primitive value");
                };
              }, function(module2, exports2) {
                module2.exports = function(it) {
                  return typeof it === "object" ? it !== null : typeof it === "function";
                };
              }, function(module2, exports2) {
                var hasOwnProperty = {}.hasOwnProperty;
                module2.exports = function(it, key) {
                  return hasOwnProperty.call(it, key);
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var DESCRIPTORS = __w_pdfjs_require__2(8);
                var fails = __w_pdfjs_require__2(9);
                var createElement = __w_pdfjs_require__2(20);
                module2.exports = !DESCRIPTORS && !fails(function() {
                  return Object.defineProperty(createElement("div"), "a", { get: function() {
                    return 7;
                  } }).a != 7;
                });
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var global = __w_pdfjs_require__2(6);
                var isObject = __w_pdfjs_require__2(17);
                var document2 = global.document;
                var EXISTS = isObject(document2) && isObject(document2.createElement);
                module2.exports = function(it) {
                  return EXISTS ? document2.createElement(it) : {};
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var DESCRIPTORS = __w_pdfjs_require__2(8);
                var definePropertyModule = __w_pdfjs_require__2(22);
                var createPropertyDescriptor = __w_pdfjs_require__2(11);
                module2.exports = DESCRIPTORS ? function(object, key, value) {
                  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
                } : function(object, key, value) {
                  object[key] = value;
                  return object;
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var DESCRIPTORS = __w_pdfjs_require__2(8);
                var IE8_DOM_DEFINE = __w_pdfjs_require__2(19);
                var anObject = __w_pdfjs_require__2(23);
                var toPrimitive = __w_pdfjs_require__2(16);
                var nativeDefineProperty = Object.defineProperty;
                exports2.f = DESCRIPTORS ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
                  anObject(O);
                  P = toPrimitive(P, true);
                  anObject(Attributes);
                  if (IE8_DOM_DEFINE)
                    try {
                      return nativeDefineProperty(O, P, Attributes);
                    } catch (error) {
                    }
                  if ("get" in Attributes || "set" in Attributes)
                    throw TypeError("Accessors not supported");
                  if ("value" in Attributes)
                    O[P] = Attributes.value;
                  return O;
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var isObject = __w_pdfjs_require__2(17);
                module2.exports = function(it) {
                  if (!isObject(it)) {
                    throw TypeError(String(it) + " is not an object");
                  }
                  return it;
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var global = __w_pdfjs_require__2(6);
                var createNonEnumerableProperty = __w_pdfjs_require__2(21);
                var has = __w_pdfjs_require__2(18);
                var setGlobal = __w_pdfjs_require__2(25);
                var inspectSource = __w_pdfjs_require__2(26);
                var InternalStateModule = __w_pdfjs_require__2(28);
                var getInternalState = InternalStateModule.get;
                var enforceInternalState = InternalStateModule.enforce;
                var TEMPLATE = String(String).split("String");
                (module2.exports = function(O, key, value, options) {
                  var unsafe = options ? !!options.unsafe : false;
                  var simple = options ? !!options.enumerable : false;
                  var noTargetGet = options ? !!options.noTargetGet : false;
                  if (typeof value == "function") {
                    if (typeof key == "string" && !has(value, "name"))
                      createNonEnumerableProperty(value, "name", key);
                    enforceInternalState(value).source = TEMPLATE.join(typeof key == "string" ? key : "");
                  }
                  if (O === global) {
                    if (simple)
                      O[key] = value;
                    else
                      setGlobal(key, value);
                    return;
                  } else if (!unsafe) {
                    delete O[key];
                  } else if (!noTargetGet && O[key]) {
                    simple = true;
                  }
                  if (simple)
                    O[key] = value;
                  else
                    createNonEnumerableProperty(O, key, value);
                })(Function.prototype, "toString", function toString() {
                  return typeof this == "function" && getInternalState(this).source || inspectSource(this);
                });
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var global = __w_pdfjs_require__2(6);
                var createNonEnumerableProperty = __w_pdfjs_require__2(21);
                module2.exports = function(key, value) {
                  try {
                    createNonEnumerableProperty(global, key, value);
                  } catch (error) {
                    global[key] = value;
                  }
                  return value;
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var store = __w_pdfjs_require__2(27);
                var functionToString = Function.toString;
                if (typeof store.inspectSource != "function") {
                  store.inspectSource = function(it) {
                    return functionToString.call(it);
                  };
                }
                module2.exports = store.inspectSource;
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var global = __w_pdfjs_require__2(6);
                var setGlobal = __w_pdfjs_require__2(25);
                var SHARED = "__core-js_shared__";
                var store = global[SHARED] || setGlobal(SHARED, {});
                module2.exports = store;
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var NATIVE_WEAK_MAP = __w_pdfjs_require__2(29);
                var global = __w_pdfjs_require__2(6);
                var isObject = __w_pdfjs_require__2(17);
                var createNonEnumerableProperty = __w_pdfjs_require__2(21);
                var objectHas = __w_pdfjs_require__2(18);
                var sharedKey = __w_pdfjs_require__2(30);
                var hiddenKeys = __w_pdfjs_require__2(34);
                var WeakMap2 = global.WeakMap;
                var set, get, has;
                var enforce = function(it) {
                  return has(it) ? get(it) : set(it, {});
                };
                var getterFor = function(TYPE) {
                  return function(it) {
                    var state;
                    if (!isObject(it) || (state = get(it)).type !== TYPE) {
                      throw TypeError("Incompatible receiver, " + TYPE + " required");
                    }
                    return state;
                  };
                };
                if (NATIVE_WEAK_MAP) {
                  var store = new WeakMap2();
                  var wmget = store.get;
                  var wmhas = store.has;
                  var wmset = store.set;
                  set = function(it, metadata) {
                    wmset.call(store, it, metadata);
                    return metadata;
                  };
                  get = function(it) {
                    return wmget.call(store, it) || {};
                  };
                  has = function(it) {
                    return wmhas.call(store, it);
                  };
                } else {
                  var STATE = sharedKey("state");
                  hiddenKeys[STATE] = true;
                  set = function(it, metadata) {
                    createNonEnumerableProperty(it, STATE, metadata);
                    return metadata;
                  };
                  get = function(it) {
                    return objectHas(it, STATE) ? it[STATE] : {};
                  };
                  has = function(it) {
                    return objectHas(it, STATE);
                  };
                }
                module2.exports = { set, get, has, enforce, getterFor };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var global = __w_pdfjs_require__2(6);
                var inspectSource = __w_pdfjs_require__2(26);
                var WeakMap2 = global.WeakMap;
                module2.exports = typeof WeakMap2 === "function" && /native code/.test(inspectSource(WeakMap2));
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var shared = __w_pdfjs_require__2(31);
                var uid = __w_pdfjs_require__2(33);
                var keys = shared("keys");
                module2.exports = function(key) {
                  return keys[key] || (keys[key] = uid(key));
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var IS_PURE = __w_pdfjs_require__2(32);
                var store = __w_pdfjs_require__2(27);
                (module2.exports = function(key, value) {
                  return store[key] || (store[key] = value !== void 0 ? value : {});
                })("versions", []).push({ version: "3.6.4", mode: IS_PURE ? "pure" : "global", copyright: "\xA9 2020 Denis Pushkarev (zloirock.ru)" });
              }, function(module2, exports2) {
                module2.exports = false;
              }, function(module2, exports2) {
                var id = 0;
                var postfix = Math.random();
                module2.exports = function(key) {
                  return "Symbol(" + String(key === void 0 ? "" : key) + ")_" + (++id + postfix).toString(36);
                };
              }, function(module2, exports2) {
                module2.exports = {};
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var has = __w_pdfjs_require__2(18);
                var ownKeys = __w_pdfjs_require__2(36);
                var getOwnPropertyDescriptorModule = __w_pdfjs_require__2(7);
                var definePropertyModule = __w_pdfjs_require__2(22);
                module2.exports = function(target, source) {
                  var keys = ownKeys(source);
                  var defineProperty = definePropertyModule.f;
                  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
                  for (var i = 0; i < keys.length; i++) {
                    var key = keys[i];
                    if (!has(target, key))
                      defineProperty(target, key, getOwnPropertyDescriptor(source, key));
                  }
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var getBuiltIn = __w_pdfjs_require__2(37);
                var getOwnPropertyNamesModule = __w_pdfjs_require__2(39);
                var getOwnPropertySymbolsModule = __w_pdfjs_require__2(46);
                var anObject = __w_pdfjs_require__2(23);
                module2.exports = getBuiltIn("Reflect", "ownKeys") || function ownKeys(it) {
                  var keys = getOwnPropertyNamesModule.f(anObject(it));
                  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
                  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var path = __w_pdfjs_require__2(38);
                var global = __w_pdfjs_require__2(6);
                var aFunction = function(variable) {
                  return typeof variable == "function" ? variable : void 0;
                };
                module2.exports = function(namespace, method) {
                  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global[namespace]) : path[namespace] && path[namespace][method] || global[namespace] && global[namespace][method];
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var global = __w_pdfjs_require__2(6);
                module2.exports = global;
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var internalObjectKeys = __w_pdfjs_require__2(40);
                var enumBugKeys = __w_pdfjs_require__2(45);
                var hiddenKeys = enumBugKeys.concat("length", "prototype");
                exports2.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
                  return internalObjectKeys(O, hiddenKeys);
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var has = __w_pdfjs_require__2(18);
                var toIndexedObject = __w_pdfjs_require__2(12);
                var indexOf = __w_pdfjs_require__2(41).indexOf;
                var hiddenKeys = __w_pdfjs_require__2(34);
                module2.exports = function(object, names) {
                  var O = toIndexedObject(object);
                  var i = 0;
                  var result = [];
                  var key;
                  for (key in O)
                    !has(hiddenKeys, key) && has(O, key) && result.push(key);
                  while (names.length > i)
                    if (has(O, key = names[i++])) {
                      ~indexOf(result, key) || result.push(key);
                    }
                  return result;
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var toIndexedObject = __w_pdfjs_require__2(12);
                var toLength = __w_pdfjs_require__2(42);
                var toAbsoluteIndex = __w_pdfjs_require__2(44);
                var createMethod = function(IS_INCLUDES) {
                  return function($this, el, fromIndex) {
                    var O = toIndexedObject($this);
                    var length = toLength(O.length);
                    var index = toAbsoluteIndex(fromIndex, length);
                    var value;
                    if (IS_INCLUDES && el != el)
                      while (length > index) {
                        value = O[index++];
                        if (value != value)
                          return true;
                      }
                    else
                      for (; length > index; index++) {
                        if ((IS_INCLUDES || index in O) && O[index] === el)
                          return IS_INCLUDES || index || 0;
                      }
                    return !IS_INCLUDES && -1;
                  };
                };
                module2.exports = { includes: createMethod(true), indexOf: createMethod(false) };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var toInteger = __w_pdfjs_require__2(43);
                var min = Math.min;
                module2.exports = function(argument) {
                  return argument > 0 ? min(toInteger(argument), 9007199254740991) : 0;
                };
              }, function(module2, exports2) {
                var ceil = Math.ceil;
                var floor = Math.floor;
                module2.exports = function(argument) {
                  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var toInteger = __w_pdfjs_require__2(43);
                var max = Math.max;
                var min = Math.min;
                module2.exports = function(index, length) {
                  var integer = toInteger(index);
                  return integer < 0 ? max(integer + length, 0) : min(integer, length);
                };
              }, function(module2, exports2) {
                module2.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
              }, function(module2, exports2) {
                exports2.f = Object.getOwnPropertySymbols;
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var fails = __w_pdfjs_require__2(9);
                var replacement = /#|\.prototype\./;
                var isForced = function(feature, detection) {
                  var value = data[normalize(feature)];
                  return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == "function" ? fails(detection) : !!detection;
                };
                var normalize = isForced.normalize = function(string) {
                  return String(string).replace(replacement, ".").toLowerCase();
                };
                var data = isForced.data = {};
                var NATIVE = isForced.NATIVE = "N";
                var POLYFILL = isForced.POLYFILL = "P";
                module2.exports = isForced;
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.isNodeJS = void 0;
                function _typeof2(obj) {
                  "@babel/helpers - typeof";
                  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                    _typeof2 = function _typeof3(obj2) {
                      return typeof obj2;
                    };
                  } else {
                    _typeof2 = function _typeof3(obj2) {
                      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                    };
                  }
                  return _typeof2(obj);
                }
                var isNodeJS = (typeof process === "undefined" ? "undefined" : _typeof2(process)) === "object" && process + "" === "[object process]" && !process.versions["nw"] && !process.versions["electron"];
                exports2.isNodeJS = isNodeJS;
              }, function(module2, exports2, __w_pdfjs_require__2) {
                __w_pdfjs_require__2(50);
                var entryUnbind = __w_pdfjs_require__2(57);
                module2.exports = entryUnbind("String", "startsWith");
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                var $ = __w_pdfjs_require__2(5);
                var getOwnPropertyDescriptor = __w_pdfjs_require__2(7).f;
                var toLength = __w_pdfjs_require__2(42);
                var notARegExp = __w_pdfjs_require__2(51);
                var requireObjectCoercible = __w_pdfjs_require__2(15);
                var correctIsRegExpLogic = __w_pdfjs_require__2(56);
                var IS_PURE = __w_pdfjs_require__2(32);
                var nativeStartsWith = "".startsWith;
                var min = Math.min;
                var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic("startsWith");
                var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function() {
                  var descriptor = getOwnPropertyDescriptor(String.prototype, "startsWith");
                  return descriptor && !descriptor.writable;
                }();
                $({ target: "String", proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, { startsWith: function startsWith(searchString) {
                  var that = String(requireObjectCoercible(this));
                  notARegExp(searchString);
                  var index = toLength(min(arguments.length > 1 ? arguments[1] : void 0, that.length));
                  var search = String(searchString);
                  return nativeStartsWith ? nativeStartsWith.call(that, search, index) : that.slice(index, index + search.length) === search;
                } });
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var isRegExp = __w_pdfjs_require__2(52);
                module2.exports = function(it) {
                  if (isRegExp(it)) {
                    throw TypeError("The method doesn't accept regular expressions");
                  }
                  return it;
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var isObject = __w_pdfjs_require__2(17);
                var classof = __w_pdfjs_require__2(14);
                var wellKnownSymbol = __w_pdfjs_require__2(53);
                var MATCH = wellKnownSymbol("match");
                module2.exports = function(it) {
                  var isRegExp;
                  return isObject(it) && ((isRegExp = it[MATCH]) !== void 0 ? !!isRegExp : classof(it) == "RegExp");
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var global = __w_pdfjs_require__2(6);
                var shared = __w_pdfjs_require__2(31);
                var has = __w_pdfjs_require__2(18);
                var uid = __w_pdfjs_require__2(33);
                var NATIVE_SYMBOL = __w_pdfjs_require__2(54);
                var USE_SYMBOL_AS_UID = __w_pdfjs_require__2(55);
                var WellKnownSymbolsStore = shared("wks");
                var Symbol2 = global.Symbol;
                var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2 : Symbol2 && Symbol2.withoutSetter || uid;
                module2.exports = function(name) {
                  if (!has(WellKnownSymbolsStore, name)) {
                    if (NATIVE_SYMBOL && has(Symbol2, name))
                      WellKnownSymbolsStore[name] = Symbol2[name];
                    else
                      WellKnownSymbolsStore[name] = createWellKnownSymbol("Symbol." + name);
                  }
                  return WellKnownSymbolsStore[name];
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var fails = __w_pdfjs_require__2(9);
                module2.exports = !!Object.getOwnPropertySymbols && !fails(function() {
                  return !String(Symbol());
                });
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var NATIVE_SYMBOL = __w_pdfjs_require__2(54);
                module2.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var wellKnownSymbol = __w_pdfjs_require__2(53);
                var MATCH = wellKnownSymbol("match");
                module2.exports = function(METHOD_NAME) {
                  var regexp = /./;
                  try {
                    "/./"[METHOD_NAME](regexp);
                  } catch (e) {
                    try {
                      regexp[MATCH] = false;
                      return "/./"[METHOD_NAME](regexp);
                    } catch (f) {
                    }
                  }
                  return false;
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var global = __w_pdfjs_require__2(6);
                var bind = __w_pdfjs_require__2(58);
                var call = Function.call;
                module2.exports = function(CONSTRUCTOR, METHOD, length) {
                  return bind(call, global[CONSTRUCTOR].prototype[METHOD], length);
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var aFunction = __w_pdfjs_require__2(59);
                module2.exports = function(fn, that, length) {
                  aFunction(fn);
                  if (that === void 0)
                    return fn;
                  switch (length) {
                    case 0:
                      return function() {
                        return fn.call(that);
                      };
                    case 1:
                      return function(a) {
                        return fn.call(that, a);
                      };
                    case 2:
                      return function(a, b) {
                        return fn.call(that, a, b);
                      };
                    case 3:
                      return function(a, b, c) {
                        return fn.call(that, a, b, c);
                      };
                  }
                  return function() {
                    return fn.apply(that, arguments);
                  };
                };
              }, function(module2, exports2) {
                module2.exports = function(it) {
                  if (typeof it != "function") {
                    throw TypeError(String(it) + " is not a function");
                  }
                  return it;
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                __w_pdfjs_require__2(61);
                var entryUnbind = __w_pdfjs_require__2(57);
                module2.exports = entryUnbind("String", "endsWith");
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                var $ = __w_pdfjs_require__2(5);
                var getOwnPropertyDescriptor = __w_pdfjs_require__2(7).f;
                var toLength = __w_pdfjs_require__2(42);
                var notARegExp = __w_pdfjs_require__2(51);
                var requireObjectCoercible = __w_pdfjs_require__2(15);
                var correctIsRegExpLogic = __w_pdfjs_require__2(56);
                var IS_PURE = __w_pdfjs_require__2(32);
                var nativeEndsWith = "".endsWith;
                var min = Math.min;
                var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic("endsWith");
                var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function() {
                  var descriptor = getOwnPropertyDescriptor(String.prototype, "endsWith");
                  return descriptor && !descriptor.writable;
                }();
                $({ target: "String", proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, { endsWith: function endsWith(searchString) {
                  var that = String(requireObjectCoercible(this));
                  notARegExp(searchString);
                  var endPosition = arguments.length > 1 ? arguments[1] : void 0;
                  var len = toLength(that.length);
                  var end = endPosition === void 0 ? len : min(toLength(endPosition), len);
                  var search = String(searchString);
                  return nativeEndsWith ? nativeEndsWith.call(that, search, end) : that.slice(end - search.length, end) === search;
                } });
              }, function(module2, exports2, __w_pdfjs_require__2) {
                __w_pdfjs_require__2(63);
                var entryUnbind = __w_pdfjs_require__2(57);
                module2.exports = entryUnbind("String", "includes");
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                var $ = __w_pdfjs_require__2(5);
                var notARegExp = __w_pdfjs_require__2(51);
                var requireObjectCoercible = __w_pdfjs_require__2(15);
                var correctIsRegExpLogic = __w_pdfjs_require__2(56);
                $({ target: "String", proto: true, forced: !correctIsRegExpLogic("includes") }, { includes: function includes(searchString) {
                  return !!~String(requireObjectCoercible(this)).indexOf(notARegExp(searchString), arguments.length > 1 ? arguments[1] : void 0);
                } });
              }, function(module2, exports2, __w_pdfjs_require__2) {
                __w_pdfjs_require__2(65);
                var entryUnbind = __w_pdfjs_require__2(57);
                module2.exports = entryUnbind("Array", "includes");
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                var $ = __w_pdfjs_require__2(5);
                var $includes = __w_pdfjs_require__2(41).includes;
                var addToUnscopables = __w_pdfjs_require__2(66);
                var arrayMethodUsesToLength = __w_pdfjs_require__2(71);
                var USES_TO_LENGTH = arrayMethodUsesToLength("indexOf", { ACCESSORS: true, 1: 0 });
                $({ target: "Array", proto: true, forced: !USES_TO_LENGTH }, { includes: function includes(el) {
                  return $includes(this, el, arguments.length > 1 ? arguments[1] : void 0);
                } });
                addToUnscopables("includes");
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var wellKnownSymbol = __w_pdfjs_require__2(53);
                var create = __w_pdfjs_require__2(67);
                var definePropertyModule = __w_pdfjs_require__2(22);
                var UNSCOPABLES = wellKnownSymbol("unscopables");
                var ArrayPrototype = Array.prototype;
                if (ArrayPrototype[UNSCOPABLES] == void 0) {
                  definePropertyModule.f(ArrayPrototype, UNSCOPABLES, { configurable: true, value: create(null) });
                }
                module2.exports = function(key) {
                  ArrayPrototype[UNSCOPABLES][key] = true;
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var anObject = __w_pdfjs_require__2(23);
                var defineProperties = __w_pdfjs_require__2(68);
                var enumBugKeys = __w_pdfjs_require__2(45);
                var hiddenKeys = __w_pdfjs_require__2(34);
                var html = __w_pdfjs_require__2(70);
                var documentCreateElement = __w_pdfjs_require__2(20);
                var sharedKey = __w_pdfjs_require__2(30);
                var GT = ">";
                var LT = "<";
                var PROTOTYPE = "prototype";
                var SCRIPT = "script";
                var IE_PROTO = sharedKey("IE_PROTO");
                var EmptyConstructor = function() {
                };
                var scriptTag = function(content) {
                  return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
                };
                var NullProtoObjectViaActiveX = function(activeXDocument2) {
                  activeXDocument2.write(scriptTag(""));
                  activeXDocument2.close();
                  var temp = activeXDocument2.parentWindow.Object;
                  activeXDocument2 = null;
                  return temp;
                };
                var NullProtoObjectViaIFrame = function() {
                  var iframe = documentCreateElement("iframe");
                  var JS = "java" + SCRIPT + ":";
                  var iframeDocument;
                  iframe.style.display = "none";
                  html.appendChild(iframe);
                  iframe.src = String(JS);
                  iframeDocument = iframe.contentWindow.document;
                  iframeDocument.open();
                  iframeDocument.write(scriptTag("document.F=Object"));
                  iframeDocument.close();
                  return iframeDocument.F;
                };
                var activeXDocument;
                var NullProtoObject = function() {
                  try {
                    activeXDocument = document.domain && new ActiveXObject("htmlfile");
                  } catch (error) {
                  }
                  NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
                  var length = enumBugKeys.length;
                  while (length--)
                    delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
                  return NullProtoObject();
                };
                hiddenKeys[IE_PROTO] = true;
                module2.exports = Object.create || function create(O, Properties) {
                  var result;
                  if (O !== null) {
                    EmptyConstructor[PROTOTYPE] = anObject(O);
                    result = new EmptyConstructor();
                    EmptyConstructor[PROTOTYPE] = null;
                    result[IE_PROTO] = O;
                  } else
                    result = NullProtoObject();
                  return Properties === void 0 ? result : defineProperties(result, Properties);
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var DESCRIPTORS = __w_pdfjs_require__2(8);
                var definePropertyModule = __w_pdfjs_require__2(22);
                var anObject = __w_pdfjs_require__2(23);
                var objectKeys = __w_pdfjs_require__2(69);
                module2.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {
                  anObject(O);
                  var keys = objectKeys(Properties);
                  var length = keys.length;
                  var index = 0;
                  var key;
                  while (length > index)
                    definePropertyModule.f(O, key = keys[index++], Properties[key]);
                  return O;
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var internalObjectKeys = __w_pdfjs_require__2(40);
                var enumBugKeys = __w_pdfjs_require__2(45);
                module2.exports = Object.keys || function keys(O) {
                  return internalObjectKeys(O, enumBugKeys);
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var getBuiltIn = __w_pdfjs_require__2(37);
                module2.exports = getBuiltIn("document", "documentElement");
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var DESCRIPTORS = __w_pdfjs_require__2(8);
                var fails = __w_pdfjs_require__2(9);
                var has = __w_pdfjs_require__2(18);
                var defineProperty = Object.defineProperty;
                var cache = {};
                var thrower = function(it) {
                  throw it;
                };
                module2.exports = function(METHOD_NAME, options) {
                  if (has(cache, METHOD_NAME))
                    return cache[METHOD_NAME];
                  if (!options)
                    options = {};
                  var method = [][METHOD_NAME];
                  var ACCESSORS = has(options, "ACCESSORS") ? options.ACCESSORS : false;
                  var argument0 = has(options, 0) ? options[0] : thrower;
                  var argument1 = has(options, 1) ? options[1] : void 0;
                  return cache[METHOD_NAME] = !!method && !fails(function() {
                    if (ACCESSORS && !DESCRIPTORS)
                      return true;
                    var O = { length: -1 };
                    if (ACCESSORS)
                      defineProperty(O, 1, { enumerable: true, get: thrower });
                    else
                      O[1] = 1;
                    method.call(O, argument0, argument1);
                  });
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                __w_pdfjs_require__2(73);
                __w_pdfjs_require__2(85);
                var path = __w_pdfjs_require__2(38);
                module2.exports = path.Array.from;
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                var charAt = __w_pdfjs_require__2(74).charAt;
                var InternalStateModule = __w_pdfjs_require__2(28);
                var defineIterator = __w_pdfjs_require__2(75);
                var STRING_ITERATOR = "String Iterator";
                var setInternalState = InternalStateModule.set;
                var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);
                defineIterator(String, "String", function(iterated) {
                  setInternalState(this, { type: STRING_ITERATOR, string: String(iterated), index: 0 });
                }, function next() {
                  var state = getInternalState(this);
                  var string = state.string;
                  var index = state.index;
                  var point;
                  if (index >= string.length)
                    return { value: void 0, done: true };
                  point = charAt(string, index);
                  state.index += point.length;
                  return { value: point, done: false };
                });
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var toInteger = __w_pdfjs_require__2(43);
                var requireObjectCoercible = __w_pdfjs_require__2(15);
                var createMethod = function(CONVERT_TO_STRING) {
                  return function($this, pos) {
                    var S = String(requireObjectCoercible($this));
                    var position = toInteger(pos);
                    var size = S.length;
                    var first, second;
                    if (position < 0 || position >= size)
                      return CONVERT_TO_STRING ? "" : void 0;
                    first = S.charCodeAt(position);
                    return first < 55296 || first > 56319 || position + 1 === size || (second = S.charCodeAt(position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? S.charAt(position) : first : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 55296 << 10) + (second - 56320) + 65536;
                  };
                };
                module2.exports = { codeAt: createMethod(false), charAt: createMethod(true) };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                var $ = __w_pdfjs_require__2(5);
                var createIteratorConstructor = __w_pdfjs_require__2(76);
                var getPrototypeOf = __w_pdfjs_require__2(78);
                var setPrototypeOf = __w_pdfjs_require__2(83);
                var setToStringTag = __w_pdfjs_require__2(81);
                var createNonEnumerableProperty = __w_pdfjs_require__2(21);
                var redefine = __w_pdfjs_require__2(24);
                var wellKnownSymbol = __w_pdfjs_require__2(53);
                var IS_PURE = __w_pdfjs_require__2(32);
                var Iterators = __w_pdfjs_require__2(82);
                var IteratorsCore = __w_pdfjs_require__2(77);
                var IteratorPrototype = IteratorsCore.IteratorPrototype;
                var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
                var ITERATOR = wellKnownSymbol("iterator");
                var KEYS = "keys";
                var VALUES = "values";
                var ENTRIES = "entries";
                var returnThis = function() {
                  return this;
                };
                module2.exports = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
                  createIteratorConstructor(IteratorConstructor, NAME, next);
                  var getIterationMethod = function(KIND) {
                    if (KIND === DEFAULT && defaultIterator)
                      return defaultIterator;
                    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype)
                      return IterablePrototype[KIND];
                    switch (KIND) {
                      case KEYS:
                        return function keys() {
                          return new IteratorConstructor(this, KIND);
                        };
                      case VALUES:
                        return function values() {
                          return new IteratorConstructor(this, KIND);
                        };
                      case ENTRIES:
                        return function entries() {
                          return new IteratorConstructor(this, KIND);
                        };
                    }
                    return function() {
                      return new IteratorConstructor(this);
                    };
                  };
                  var TO_STRING_TAG = NAME + " Iterator";
                  var INCORRECT_VALUES_NAME = false;
                  var IterablePrototype = Iterable.prototype;
                  var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
                  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
                  var anyNativeIterator = NAME == "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
                  var CurrentIteratorPrototype, methods, KEY;
                  if (anyNativeIterator) {
                    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
                    if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
                      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
                        if (setPrototypeOf) {
                          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
                        } else if (typeof CurrentIteratorPrototype[ITERATOR] != "function") {
                          createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR, returnThis);
                        }
                      }
                      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
                      if (IS_PURE)
                        Iterators[TO_STRING_TAG] = returnThis;
                    }
                  }
                  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
                    INCORRECT_VALUES_NAME = true;
                    defaultIterator = function values() {
                      return nativeIterator.call(this);
                    };
                  }
                  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
                    createNonEnumerableProperty(IterablePrototype, ITERATOR, defaultIterator);
                  }
                  Iterators[NAME] = defaultIterator;
                  if (DEFAULT) {
                    methods = { values: getIterationMethod(VALUES), keys: IS_SET ? defaultIterator : getIterationMethod(KEYS), entries: getIterationMethod(ENTRIES) };
                    if (FORCED)
                      for (KEY in methods) {
                        if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
                          redefine(IterablePrototype, KEY, methods[KEY]);
                        }
                      }
                    else
                      $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
                  }
                  return methods;
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                var IteratorPrototype = __w_pdfjs_require__2(77).IteratorPrototype;
                var create = __w_pdfjs_require__2(67);
                var createPropertyDescriptor = __w_pdfjs_require__2(11);
                var setToStringTag = __w_pdfjs_require__2(81);
                var Iterators = __w_pdfjs_require__2(82);
                var returnThis = function() {
                  return this;
                };
                module2.exports = function(IteratorConstructor, NAME, next) {
                  var TO_STRING_TAG = NAME + " Iterator";
                  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(1, next) });
                  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
                  Iterators[TO_STRING_TAG] = returnThis;
                  return IteratorConstructor;
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                var getPrototypeOf = __w_pdfjs_require__2(78);
                var createNonEnumerableProperty = __w_pdfjs_require__2(21);
                var has = __w_pdfjs_require__2(18);
                var wellKnownSymbol = __w_pdfjs_require__2(53);
                var IS_PURE = __w_pdfjs_require__2(32);
                var ITERATOR = wellKnownSymbol("iterator");
                var BUGGY_SAFARI_ITERATORS = false;
                var returnThis = function() {
                  return this;
                };
                var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;
                if ([].keys) {
                  arrayIterator = [].keys();
                  if (!("next" in arrayIterator))
                    BUGGY_SAFARI_ITERATORS = true;
                  else {
                    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
                    if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
                      IteratorPrototype = PrototypeOfArrayIteratorPrototype;
                  }
                }
                if (IteratorPrototype == void 0)
                  IteratorPrototype = {};
                if (!IS_PURE && !has(IteratorPrototype, ITERATOR)) {
                  createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);
                }
                module2.exports = { IteratorPrototype, BUGGY_SAFARI_ITERATORS };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var has = __w_pdfjs_require__2(18);
                var toObject = __w_pdfjs_require__2(79);
                var sharedKey = __w_pdfjs_require__2(30);
                var CORRECT_PROTOTYPE_GETTER = __w_pdfjs_require__2(80);
                var IE_PROTO = sharedKey("IE_PROTO");
                var ObjectPrototype = Object.prototype;
                module2.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function(O) {
                  O = toObject(O);
                  if (has(O, IE_PROTO))
                    return O[IE_PROTO];
                  if (typeof O.constructor == "function" && O instanceof O.constructor) {
                    return O.constructor.prototype;
                  }
                  return O instanceof Object ? ObjectPrototype : null;
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var requireObjectCoercible = __w_pdfjs_require__2(15);
                module2.exports = function(argument) {
                  return Object(requireObjectCoercible(argument));
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var fails = __w_pdfjs_require__2(9);
                module2.exports = !fails(function() {
                  function F() {
                  }
                  F.prototype.constructor = null;
                  return Object.getPrototypeOf(new F()) !== F.prototype;
                });
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var defineProperty = __w_pdfjs_require__2(22).f;
                var has = __w_pdfjs_require__2(18);
                var wellKnownSymbol = __w_pdfjs_require__2(53);
                var TO_STRING_TAG = wellKnownSymbol("toStringTag");
                module2.exports = function(it, TAG, STATIC) {
                  if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
                    defineProperty(it, TO_STRING_TAG, { configurable: true, value: TAG });
                  }
                };
              }, function(module2, exports2) {
                module2.exports = {};
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var anObject = __w_pdfjs_require__2(23);
                var aPossiblePrototype = __w_pdfjs_require__2(84);
                module2.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
                  var CORRECT_SETTER = false;
                  var test = {};
                  var setter;
                  try {
                    setter = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set;
                    setter.call(test, []);
                    CORRECT_SETTER = test instanceof Array;
                  } catch (error) {
                  }
                  return function setPrototypeOf(O, proto) {
                    anObject(O);
                    aPossiblePrototype(proto);
                    if (CORRECT_SETTER)
                      setter.call(O, proto);
                    else
                      O.__proto__ = proto;
                    return O;
                  };
                }() : void 0);
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var isObject = __w_pdfjs_require__2(17);
                module2.exports = function(it) {
                  if (!isObject(it) && it !== null) {
                    throw TypeError("Can't set " + String(it) + " as a prototype");
                  }
                  return it;
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var $ = __w_pdfjs_require__2(5);
                var from = __w_pdfjs_require__2(86);
                var checkCorrectnessOfIteration = __w_pdfjs_require__2(93);
                var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function(iterable) {
                  Array.from(iterable);
                });
                $({ target: "Array", stat: true, forced: INCORRECT_ITERATION }, { from });
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                var bind = __w_pdfjs_require__2(58);
                var toObject = __w_pdfjs_require__2(79);
                var callWithSafeIterationClosing = __w_pdfjs_require__2(87);
                var isArrayIteratorMethod = __w_pdfjs_require__2(88);
                var toLength = __w_pdfjs_require__2(42);
                var createProperty = __w_pdfjs_require__2(89);
                var getIteratorMethod = __w_pdfjs_require__2(90);
                module2.exports = function from(arrayLike) {
                  var O = toObject(arrayLike);
                  var C = typeof this == "function" ? this : Array;
                  var argumentsLength = arguments.length;
                  var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
                  var mapping = mapfn !== void 0;
                  var iteratorMethod = getIteratorMethod(O);
                  var index = 0;
                  var length, result, step, iterator, next, value;
                  if (mapping)
                    mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : void 0, 2);
                  if (iteratorMethod != void 0 && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {
                    iterator = iteratorMethod.call(O);
                    next = iterator.next;
                    result = new C();
                    for (; !(step = next.call(iterator)).done; index++) {
                      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
                      createProperty(result, index, value);
                    }
                  } else {
                    length = toLength(O.length);
                    result = new C(length);
                    for (; length > index; index++) {
                      value = mapping ? mapfn(O[index], index) : O[index];
                      createProperty(result, index, value);
                    }
                  }
                  result.length = index;
                  return result;
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var anObject = __w_pdfjs_require__2(23);
                module2.exports = function(iterator, fn, value, ENTRIES) {
                  try {
                    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
                  } catch (error) {
                    var returnMethod = iterator["return"];
                    if (returnMethod !== void 0)
                      anObject(returnMethod.call(iterator));
                    throw error;
                  }
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var wellKnownSymbol = __w_pdfjs_require__2(53);
                var Iterators = __w_pdfjs_require__2(82);
                var ITERATOR = wellKnownSymbol("iterator");
                var ArrayPrototype = Array.prototype;
                module2.exports = function(it) {
                  return it !== void 0 && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                var toPrimitive = __w_pdfjs_require__2(16);
                var definePropertyModule = __w_pdfjs_require__2(22);
                var createPropertyDescriptor = __w_pdfjs_require__2(11);
                module2.exports = function(object, key, value) {
                  var propertyKey = toPrimitive(key);
                  if (propertyKey in object)
                    definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
                  else
                    object[propertyKey] = value;
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var classof = __w_pdfjs_require__2(91);
                var Iterators = __w_pdfjs_require__2(82);
                var wellKnownSymbol = __w_pdfjs_require__2(53);
                var ITERATOR = wellKnownSymbol("iterator");
                module2.exports = function(it) {
                  if (it != void 0)
                    return it[ITERATOR] || it["@@iterator"] || Iterators[classof(it)];
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var TO_STRING_TAG_SUPPORT = __w_pdfjs_require__2(92);
                var classofRaw = __w_pdfjs_require__2(14);
                var wellKnownSymbol = __w_pdfjs_require__2(53);
                var TO_STRING_TAG = wellKnownSymbol("toStringTag");
                var CORRECT_ARGUMENTS = classofRaw(function() {
                  return arguments;
                }()) == "Arguments";
                var tryGet = function(it, key) {
                  try {
                    return it[key];
                  } catch (error) {
                  }
                };
                module2.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {
                  var O, tag, result;
                  return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == "Object" && typeof O.callee == "function" ? "Arguments" : result;
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var wellKnownSymbol = __w_pdfjs_require__2(53);
                var TO_STRING_TAG = wellKnownSymbol("toStringTag");
                var test = {};
                test[TO_STRING_TAG] = "z";
                module2.exports = String(test) === "[object z]";
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var wellKnownSymbol = __w_pdfjs_require__2(53);
                var ITERATOR = wellKnownSymbol("iterator");
                var SAFE_CLOSING = false;
                try {
                  var called = 0;
                  var iteratorWithReturn = { next: function() {
                    return { done: !!called++ };
                  }, "return": function() {
                    SAFE_CLOSING = true;
                  } };
                  iteratorWithReturn[ITERATOR] = function() {
                    return this;
                  };
                  Array.from(iteratorWithReturn, function() {
                    throw 2;
                  });
                } catch (error) {
                }
                module2.exports = function(exec, SKIP_CLOSING) {
                  if (!SKIP_CLOSING && !SAFE_CLOSING)
                    return false;
                  var ITERATION_SUPPORT = false;
                  try {
                    var object = {};
                    object[ITERATOR] = function() {
                      return { next: function() {
                        return { done: ITERATION_SUPPORT = true };
                      } };
                    };
                    exec(object);
                  } catch (error) {
                  }
                  return ITERATION_SUPPORT;
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                __w_pdfjs_require__2(95);
                var path = __w_pdfjs_require__2(38);
                module2.exports = path.Object.assign;
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var $ = __w_pdfjs_require__2(5);
                var assign = __w_pdfjs_require__2(96);
                $({ target: "Object", stat: true, forced: Object.assign !== assign }, { assign });
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                var DESCRIPTORS = __w_pdfjs_require__2(8);
                var fails = __w_pdfjs_require__2(9);
                var objectKeys = __w_pdfjs_require__2(69);
                var getOwnPropertySymbolsModule = __w_pdfjs_require__2(46);
                var propertyIsEnumerableModule = __w_pdfjs_require__2(10);
                var toObject = __w_pdfjs_require__2(79);
                var IndexedObject = __w_pdfjs_require__2(13);
                var nativeAssign = Object.assign;
                var defineProperty = Object.defineProperty;
                module2.exports = !nativeAssign || fails(function() {
                  if (DESCRIPTORS && nativeAssign({ b: 1 }, nativeAssign(defineProperty({}, "a", { enumerable: true, get: function() {
                    defineProperty(this, "b", { value: 3, enumerable: false });
                  } }), { b: 2 })).b !== 1)
                    return true;
                  var A = {};
                  var B = {};
                  var symbol = Symbol();
                  var alphabet = "abcdefghijklmnopqrst";
                  A[symbol] = 7;
                  alphabet.split("").forEach(function(chr) {
                    B[chr] = chr;
                  });
                  return nativeAssign({}, A)[symbol] != 7 || objectKeys(nativeAssign({}, B)).join("") != alphabet;
                }) ? function assign(target, source) {
                  var T = toObject(target);
                  var argumentsLength = arguments.length;
                  var index = 1;
                  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
                  var propertyIsEnumerable = propertyIsEnumerableModule.f;
                  while (argumentsLength > index) {
                    var S = IndexedObject(arguments[index++]);
                    var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);
                    var length = keys.length;
                    var j = 0;
                    var key;
                    while (length > j) {
                      key = keys[j++];
                      if (!DESCRIPTORS || propertyIsEnumerable.call(S, key))
                        T[key] = S[key];
                    }
                  }
                  return T;
                } : nativeAssign;
              }, function(module2, exports2, __w_pdfjs_require__2) {
                __w_pdfjs_require__2(98);
                var path = __w_pdfjs_require__2(38);
                module2.exports = path.Math.log2;
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var $ = __w_pdfjs_require__2(5);
                var log = Math.log;
                var LN2 = Math.LN2;
                $({ target: "Math", stat: true }, { log2: function log2(x) {
                  return log(x) / LN2;
                } });
              }, function(module2, exports2, __w_pdfjs_require__2) {
                __w_pdfjs_require__2(100);
                var path = __w_pdfjs_require__2(38);
                module2.exports = path.Number.isNaN;
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var $ = __w_pdfjs_require__2(5);
                $({ target: "Number", stat: true }, { isNaN: function isNaN2(number) {
                  return number != number;
                } });
              }, function(module2, exports2, __w_pdfjs_require__2) {
                __w_pdfjs_require__2(102);
                var path = __w_pdfjs_require__2(38);
                module2.exports = path.Number.isInteger;
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var $ = __w_pdfjs_require__2(5);
                var isInteger = __w_pdfjs_require__2(103);
                $({ target: "Number", stat: true }, { isInteger });
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var isObject = __w_pdfjs_require__2(17);
                var floor = Math.floor;
                module2.exports = function isInteger(it) {
                  return !isObject(it) && isFinite(it) && floor(it) === it;
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                __w_pdfjs_require__2(105);
                __w_pdfjs_require__2(73);
                __w_pdfjs_require__2(107);
                __w_pdfjs_require__2(110);
                __w_pdfjs_require__2(126);
                __w_pdfjs_require__2(127);
                var path = __w_pdfjs_require__2(38);
                module2.exports = path.Promise;
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var TO_STRING_TAG_SUPPORT = __w_pdfjs_require__2(92);
                var redefine = __w_pdfjs_require__2(24);
                var toString = __w_pdfjs_require__2(106);
                if (!TO_STRING_TAG_SUPPORT) {
                  redefine(Object.prototype, "toString", toString, { unsafe: true });
                }
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                var TO_STRING_TAG_SUPPORT = __w_pdfjs_require__2(92);
                var classof = __w_pdfjs_require__2(91);
                module2.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
                  return "[object " + classof(this) + "]";
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var global = __w_pdfjs_require__2(6);
                var DOMIterables = __w_pdfjs_require__2(108);
                var ArrayIteratorMethods = __w_pdfjs_require__2(109);
                var createNonEnumerableProperty = __w_pdfjs_require__2(21);
                var wellKnownSymbol = __w_pdfjs_require__2(53);
                var ITERATOR = wellKnownSymbol("iterator");
                var TO_STRING_TAG = wellKnownSymbol("toStringTag");
                var ArrayValues = ArrayIteratorMethods.values;
                for (var COLLECTION_NAME in DOMIterables) {
                  var Collection = global[COLLECTION_NAME];
                  var CollectionPrototype = Collection && Collection.prototype;
                  if (CollectionPrototype) {
                    if (CollectionPrototype[ITERATOR] !== ArrayValues)
                      try {
                        createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
                      } catch (error) {
                        CollectionPrototype[ITERATOR] = ArrayValues;
                      }
                    if (!CollectionPrototype[TO_STRING_TAG]) {
                      createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
                    }
                    if (DOMIterables[COLLECTION_NAME])
                      for (var METHOD_NAME in ArrayIteratorMethods) {
                        if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME])
                          try {
                            createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
                          } catch (error) {
                            CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
                          }
                      }
                  }
                }
              }, function(module2, exports2) {
                module2.exports = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                var toIndexedObject = __w_pdfjs_require__2(12);
                var addToUnscopables = __w_pdfjs_require__2(66);
                var Iterators = __w_pdfjs_require__2(82);
                var InternalStateModule = __w_pdfjs_require__2(28);
                var defineIterator = __w_pdfjs_require__2(75);
                var ARRAY_ITERATOR = "Array Iterator";
                var setInternalState = InternalStateModule.set;
                var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
                module2.exports = defineIterator(Array, "Array", function(iterated, kind) {
                  setInternalState(this, { type: ARRAY_ITERATOR, target: toIndexedObject(iterated), index: 0, kind });
                }, function() {
                  var state = getInternalState(this);
                  var target = state.target;
                  var kind = state.kind;
                  var index = state.index++;
                  if (!target || index >= target.length) {
                    state.target = void 0;
                    return { value: void 0, done: true };
                  }
                  if (kind == "keys")
                    return { value: index, done: false };
                  if (kind == "values")
                    return { value: target[index], done: false };
                  return { value: [index, target[index]], done: false };
                }, "values");
                Iterators.Arguments = Iterators.Array;
                addToUnscopables("keys");
                addToUnscopables("values");
                addToUnscopables("entries");
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                var $ = __w_pdfjs_require__2(5);
                var IS_PURE = __w_pdfjs_require__2(32);
                var global = __w_pdfjs_require__2(6);
                var getBuiltIn = __w_pdfjs_require__2(37);
                var NativePromise = __w_pdfjs_require__2(111);
                var redefine = __w_pdfjs_require__2(24);
                var redefineAll = __w_pdfjs_require__2(112);
                var setToStringTag = __w_pdfjs_require__2(81);
                var setSpecies = __w_pdfjs_require__2(113);
                var isObject = __w_pdfjs_require__2(17);
                var aFunction = __w_pdfjs_require__2(59);
                var anInstance = __w_pdfjs_require__2(114);
                var classof = __w_pdfjs_require__2(14);
                var inspectSource = __w_pdfjs_require__2(26);
                var iterate = __w_pdfjs_require__2(115);
                var checkCorrectnessOfIteration = __w_pdfjs_require__2(93);
                var speciesConstructor = __w_pdfjs_require__2(116);
                var task = __w_pdfjs_require__2(117).set;
                var microtask = __w_pdfjs_require__2(120);
                var promiseResolve = __w_pdfjs_require__2(121);
                var hostReportErrors = __w_pdfjs_require__2(123);
                var newPromiseCapabilityModule = __w_pdfjs_require__2(122);
                var perform = __w_pdfjs_require__2(124);
                var InternalStateModule = __w_pdfjs_require__2(28);
                var isForced = __w_pdfjs_require__2(47);
                var wellKnownSymbol = __w_pdfjs_require__2(53);
                var V8_VERSION = __w_pdfjs_require__2(125);
                var SPECIES = wellKnownSymbol("species");
                var PROMISE = "Promise";
                var getInternalState = InternalStateModule.get;
                var setInternalState = InternalStateModule.set;
                var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
                var PromiseConstructor = NativePromise;
                var TypeError2 = global.TypeError;
                var document2 = global.document;
                var process2 = global.process;
                var $fetch = getBuiltIn("fetch");
                var newPromiseCapability = newPromiseCapabilityModule.f;
                var newGenericPromiseCapability = newPromiseCapability;
                var IS_NODE = classof(process2) == "process";
                var DISPATCH_EVENT = !!(document2 && document2.createEvent && global.dispatchEvent);
                var UNHANDLED_REJECTION = "unhandledrejection";
                var REJECTION_HANDLED = "rejectionhandled";
                var PENDING = 0;
                var FULFILLED = 1;
                var REJECTED = 2;
                var HANDLED = 1;
                var UNHANDLED = 2;
                var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;
                var FORCED = isForced(PROMISE, function() {
                  var GLOBAL_CORE_JS_PROMISE = inspectSource(PromiseConstructor) !== String(PromiseConstructor);
                  if (!GLOBAL_CORE_JS_PROMISE) {
                    if (V8_VERSION === 66)
                      return true;
                    if (!IS_NODE && typeof PromiseRejectionEvent != "function")
                      return true;
                  }
                  if (IS_PURE && !PromiseConstructor.prototype["finally"])
                    return true;
                  if (V8_VERSION >= 51 && /native code/.test(PromiseConstructor))
                    return false;
                  var promise = PromiseConstructor.resolve(1);
                  var FakePromise = function(exec) {
                    exec(function() {
                    }, function() {
                    });
                  };
                  var constructor = promise.constructor = {};
                  constructor[SPECIES] = FakePromise;
                  return !(promise.then(function() {
                  }) instanceof FakePromise);
                });
                var INCORRECT_ITERATION = FORCED || !checkCorrectnessOfIteration(function(iterable) {
                  PromiseConstructor.all(iterable)["catch"](function() {
                  });
                });
                var isThenable = function(it) {
                  var then;
                  return isObject(it) && typeof (then = it.then) == "function" ? then : false;
                };
                var notify = function(promise, state, isReject) {
                  if (state.notified)
                    return;
                  state.notified = true;
                  var chain = state.reactions;
                  microtask(function() {
                    var value = state.value;
                    var ok = state.state == FULFILLED;
                    var index = 0;
                    while (chain.length > index) {
                      var reaction = chain[index++];
                      var handler = ok ? reaction.ok : reaction.fail;
                      var resolve = reaction.resolve;
                      var reject = reaction.reject;
                      var domain = reaction.domain;
                      var result, then, exited;
                      try {
                        if (handler) {
                          if (!ok) {
                            if (state.rejection === UNHANDLED)
                              onHandleUnhandled(promise, state);
                            state.rejection = HANDLED;
                          }
                          if (handler === true)
                            result = value;
                          else {
                            if (domain)
                              domain.enter();
                            result = handler(value);
                            if (domain) {
                              domain.exit();
                              exited = true;
                            }
                          }
                          if (result === reaction.promise) {
                            reject(TypeError2("Promise-chain cycle"));
                          } else if (then = isThenable(result)) {
                            then.call(result, resolve, reject);
                          } else
                            resolve(result);
                        } else
                          reject(value);
                      } catch (error) {
                        if (domain && !exited)
                          domain.exit();
                        reject(error);
                      }
                    }
                    state.reactions = [];
                    state.notified = false;
                    if (isReject && !state.rejection)
                      onUnhandled(promise, state);
                  });
                };
                var dispatchEvent = function(name, promise, reason) {
                  var event, handler;
                  if (DISPATCH_EVENT) {
                    event = document2.createEvent("Event");
                    event.promise = promise;
                    event.reason = reason;
                    event.initEvent(name, false, true);
                    global.dispatchEvent(event);
                  } else
                    event = { promise, reason };
                  if (handler = global["on" + name])
                    handler(event);
                  else if (name === UNHANDLED_REJECTION)
                    hostReportErrors("Unhandled promise rejection", reason);
                };
                var onUnhandled = function(promise, state) {
                  task.call(global, function() {
                    var value = state.value;
                    var IS_UNHANDLED = isUnhandled(state);
                    var result;
                    if (IS_UNHANDLED) {
                      result = perform(function() {
                        if (IS_NODE) {
                          process2.emit("unhandledRejection", value, promise);
                        } else
                          dispatchEvent(UNHANDLED_REJECTION, promise, value);
                      });
                      state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
                      if (result.error)
                        throw result.value;
                    }
                  });
                };
                var isUnhandled = function(state) {
                  return state.rejection !== HANDLED && !state.parent;
                };
                var onHandleUnhandled = function(promise, state) {
                  task.call(global, function() {
                    if (IS_NODE) {
                      process2.emit("rejectionHandled", promise);
                    } else
                      dispatchEvent(REJECTION_HANDLED, promise, state.value);
                  });
                };
                var bind = function(fn, promise, state, unwrap) {
                  return function(value) {
                    fn(promise, state, value, unwrap);
                  };
                };
                var internalReject = function(promise, state, value, unwrap) {
                  if (state.done)
                    return;
                  state.done = true;
                  if (unwrap)
                    state = unwrap;
                  state.value = value;
                  state.state = REJECTED;
                  notify(promise, state, true);
                };
                var internalResolve = function(promise, state, value, unwrap) {
                  if (state.done)
                    return;
                  state.done = true;
                  if (unwrap)
                    state = unwrap;
                  try {
                    if (promise === value)
                      throw TypeError2("Promise can't be resolved itself");
                    var then = isThenable(value);
                    if (then) {
                      microtask(function() {
                        var wrapper = { done: false };
                        try {
                          then.call(value, bind(internalResolve, promise, wrapper, state), bind(internalReject, promise, wrapper, state));
                        } catch (error) {
                          internalReject(promise, wrapper, error, state);
                        }
                      });
                    } else {
                      state.value = value;
                      state.state = FULFILLED;
                      notify(promise, state, false);
                    }
                  } catch (error) {
                    internalReject(promise, { done: false }, error, state);
                  }
                };
                if (FORCED) {
                  PromiseConstructor = function Promise2(executor) {
                    anInstance(this, PromiseConstructor, PROMISE);
                    aFunction(executor);
                    Internal.call(this);
                    var state = getInternalState(this);
                    try {
                      executor(bind(internalResolve, this, state), bind(internalReject, this, state));
                    } catch (error) {
                      internalReject(this, state, error);
                    }
                  };
                  Internal = function Promise2(executor) {
                    setInternalState(this, { type: PROMISE, done: false, notified: false, parent: false, reactions: [], rejection: false, state: PENDING, value: void 0 });
                  };
                  Internal.prototype = redefineAll(PromiseConstructor.prototype, { then: function then(onFulfilled, onRejected) {
                    var state = getInternalPromiseState(this);
                    var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
                    reaction.ok = typeof onFulfilled == "function" ? onFulfilled : true;
                    reaction.fail = typeof onRejected == "function" && onRejected;
                    reaction.domain = IS_NODE ? process2.domain : void 0;
                    state.parent = true;
                    state.reactions.push(reaction);
                    if (state.state != PENDING)
                      notify(this, state, false);
                    return reaction.promise;
                  }, "catch": function(onRejected) {
                    return this.then(void 0, onRejected);
                  } });
                  OwnPromiseCapability = function() {
                    var promise = new Internal();
                    var state = getInternalState(promise);
                    this.promise = promise;
                    this.resolve = bind(internalResolve, promise, state);
                    this.reject = bind(internalReject, promise, state);
                  };
                  newPromiseCapabilityModule.f = newPromiseCapability = function(C) {
                    return C === PromiseConstructor || C === PromiseWrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
                  };
                  if (!IS_PURE && typeof NativePromise == "function") {
                    nativeThen = NativePromise.prototype.then;
                    redefine(NativePromise.prototype, "then", function then(onFulfilled, onRejected) {
                      var that = this;
                      return new PromiseConstructor(function(resolve, reject) {
                        nativeThen.call(that, resolve, reject);
                      }).then(onFulfilled, onRejected);
                    }, { unsafe: true });
                    if (typeof $fetch == "function")
                      $({ global: true, enumerable: true, forced: true }, { fetch: function fetch2(input) {
                        return promiseResolve(PromiseConstructor, $fetch.apply(global, arguments));
                      } });
                  }
                }
                $({ global: true, wrap: true, forced: FORCED }, { Promise: PromiseConstructor });
                setToStringTag(PromiseConstructor, PROMISE, false, true);
                setSpecies(PROMISE);
                PromiseWrapper = getBuiltIn(PROMISE);
                $({ target: PROMISE, stat: true, forced: FORCED }, { reject: function reject(r) {
                  var capability = newPromiseCapability(this);
                  capability.reject.call(void 0, r);
                  return capability.promise;
                } });
                $({ target: PROMISE, stat: true, forced: IS_PURE || FORCED }, { resolve: function resolve(x) {
                  return promiseResolve(IS_PURE && this === PromiseWrapper ? PromiseConstructor : this, x);
                } });
                $({ target: PROMISE, stat: true, forced: INCORRECT_ITERATION }, { all: function all(iterable) {
                  var C = this;
                  var capability = newPromiseCapability(C);
                  var resolve = capability.resolve;
                  var reject = capability.reject;
                  var result = perform(function() {
                    var $promiseResolve = aFunction(C.resolve);
                    var values = [];
                    var counter = 0;
                    var remaining = 1;
                    iterate(iterable, function(promise) {
                      var index = counter++;
                      var alreadyCalled = false;
                      values.push(void 0);
                      remaining++;
                      $promiseResolve.call(C, promise).then(function(value) {
                        if (alreadyCalled)
                          return;
                        alreadyCalled = true;
                        values[index] = value;
                        --remaining || resolve(values);
                      }, reject);
                    });
                    --remaining || resolve(values);
                  });
                  if (result.error)
                    reject(result.value);
                  return capability.promise;
                }, race: function race(iterable) {
                  var C = this;
                  var capability = newPromiseCapability(C);
                  var reject = capability.reject;
                  var result = perform(function() {
                    var $promiseResolve = aFunction(C.resolve);
                    iterate(iterable, function(promise) {
                      $promiseResolve.call(C, promise).then(capability.resolve, reject);
                    });
                  });
                  if (result.error)
                    reject(result.value);
                  return capability.promise;
                } });
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var global = __w_pdfjs_require__2(6);
                module2.exports = global.Promise;
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var redefine = __w_pdfjs_require__2(24);
                module2.exports = function(target, src, options) {
                  for (var key in src)
                    redefine(target, key, src[key], options);
                  return target;
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                var getBuiltIn = __w_pdfjs_require__2(37);
                var definePropertyModule = __w_pdfjs_require__2(22);
                var wellKnownSymbol = __w_pdfjs_require__2(53);
                var DESCRIPTORS = __w_pdfjs_require__2(8);
                var SPECIES = wellKnownSymbol("species");
                module2.exports = function(CONSTRUCTOR_NAME) {
                  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
                  var defineProperty = definePropertyModule.f;
                  if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
                    defineProperty(Constructor, SPECIES, { configurable: true, get: function() {
                      return this;
                    } });
                  }
                };
              }, function(module2, exports2) {
                module2.exports = function(it, Constructor, name) {
                  if (!(it instanceof Constructor)) {
                    throw TypeError("Incorrect " + (name ? name + " " : "") + "invocation");
                  }
                  return it;
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var anObject = __w_pdfjs_require__2(23);
                var isArrayIteratorMethod = __w_pdfjs_require__2(88);
                var toLength = __w_pdfjs_require__2(42);
                var bind = __w_pdfjs_require__2(58);
                var getIteratorMethod = __w_pdfjs_require__2(90);
                var callWithSafeIterationClosing = __w_pdfjs_require__2(87);
                var Result = function(stopped, result) {
                  this.stopped = stopped;
                  this.result = result;
                };
                var iterate = module2.exports = function(iterable, fn, that, AS_ENTRIES, IS_ITERATOR) {
                  var boundFunction = bind(fn, that, AS_ENTRIES ? 2 : 1);
                  var iterator, iterFn, index, length, result, next, step;
                  if (IS_ITERATOR) {
                    iterator = iterable;
                  } else {
                    iterFn = getIteratorMethod(iterable);
                    if (typeof iterFn != "function")
                      throw TypeError("Target is not iterable");
                    if (isArrayIteratorMethod(iterFn)) {
                      for (index = 0, length = toLength(iterable.length); length > index; index++) {
                        result = AS_ENTRIES ? boundFunction(anObject(step = iterable[index])[0], step[1]) : boundFunction(iterable[index]);
                        if (result && result instanceof Result)
                          return result;
                      }
                      return new Result(false);
                    }
                    iterator = iterFn.call(iterable);
                  }
                  next = iterator.next;
                  while (!(step = next.call(iterator)).done) {
                    result = callWithSafeIterationClosing(iterator, boundFunction, step.value, AS_ENTRIES);
                    if (typeof result == "object" && result && result instanceof Result)
                      return result;
                  }
                  return new Result(false);
                };
                iterate.stop = function(result) {
                  return new Result(true, result);
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var anObject = __w_pdfjs_require__2(23);
                var aFunction = __w_pdfjs_require__2(59);
                var wellKnownSymbol = __w_pdfjs_require__2(53);
                var SPECIES = wellKnownSymbol("species");
                module2.exports = function(O, defaultConstructor) {
                  var C = anObject(O).constructor;
                  var S;
                  return C === void 0 || (S = anObject(C)[SPECIES]) == void 0 ? defaultConstructor : aFunction(S);
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var global = __w_pdfjs_require__2(6);
                var fails = __w_pdfjs_require__2(9);
                var classof = __w_pdfjs_require__2(14);
                var bind = __w_pdfjs_require__2(58);
                var html = __w_pdfjs_require__2(70);
                var createElement = __w_pdfjs_require__2(20);
                var IS_IOS = __w_pdfjs_require__2(118);
                var location = global.location;
                var set = global.setImmediate;
                var clear = global.clearImmediate;
                var process2 = global.process;
                var MessageChannel = global.MessageChannel;
                var Dispatch = global.Dispatch;
                var counter = 0;
                var queue = {};
                var ONREADYSTATECHANGE = "onreadystatechange";
                var defer, channel, port;
                var run = function(id) {
                  if (queue.hasOwnProperty(id)) {
                    var fn = queue[id];
                    delete queue[id];
                    fn();
                  }
                };
                var runner = function(id) {
                  return function() {
                    run(id);
                  };
                };
                var listener = function(event) {
                  run(event.data);
                };
                var post = function(id) {
                  global.postMessage(id + "", location.protocol + "//" + location.host);
                };
                if (!set || !clear) {
                  set = function setImmediate(fn) {
                    var args = [];
                    var i = 1;
                    while (arguments.length > i)
                      args.push(arguments[i++]);
                    queue[++counter] = function() {
                      (typeof fn == "function" ? fn : Function(fn)).apply(void 0, args);
                    };
                    defer(counter);
                    return counter;
                  };
                  clear = function clearImmediate(id) {
                    delete queue[id];
                  };
                  if (classof(process2) == "process") {
                    defer = function(id) {
                      process2.nextTick(runner(id));
                    };
                  } else if (Dispatch && Dispatch.now) {
                    defer = function(id) {
                      Dispatch.now(runner(id));
                    };
                  } else if (MessageChannel && !IS_IOS) {
                    channel = new MessageChannel();
                    port = channel.port2;
                    channel.port1.onmessage = listener;
                    defer = bind(port.postMessage, port, 1);
                  } else if (global.addEventListener && typeof postMessage == "function" && !global.importScripts && !fails(post)) {
                    defer = post;
                    global.addEventListener("message", listener, false);
                  } else if (ONREADYSTATECHANGE in createElement("script")) {
                    defer = function(id) {
                      html.appendChild(createElement("script"))[ONREADYSTATECHANGE] = function() {
                        html.removeChild(this);
                        run(id);
                      };
                    };
                  } else {
                    defer = function(id) {
                      setTimeout(runner(id), 0);
                    };
                  }
                }
                module2.exports = { set, clear };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var userAgent = __w_pdfjs_require__2(119);
                module2.exports = /(iphone|ipod|ipad).*applewebkit/i.test(userAgent);
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var getBuiltIn = __w_pdfjs_require__2(37);
                module2.exports = getBuiltIn("navigator", "userAgent") || "";
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var global = __w_pdfjs_require__2(6);
                var getOwnPropertyDescriptor = __w_pdfjs_require__2(7).f;
                var classof = __w_pdfjs_require__2(14);
                var macrotask = __w_pdfjs_require__2(117).set;
                var IS_IOS = __w_pdfjs_require__2(118);
                var MutationObserver = global.MutationObserver || global.WebKitMutationObserver;
                var process2 = global.process;
                var Promise2 = global.Promise;
                var IS_NODE = classof(process2) == "process";
                var queueMicrotaskDescriptor = getOwnPropertyDescriptor(global, "queueMicrotask");
                var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;
                var flush, head, last, notify, toggle, node, promise, then;
                if (!queueMicrotask) {
                  flush = function() {
                    var parent, fn;
                    if (IS_NODE && (parent = process2.domain))
                      parent.exit();
                    while (head) {
                      fn = head.fn;
                      head = head.next;
                      try {
                        fn();
                      } catch (error) {
                        if (head)
                          notify();
                        else
                          last = void 0;
                        throw error;
                      }
                    }
                    last = void 0;
                    if (parent)
                      parent.enter();
                  };
                  if (IS_NODE) {
                    notify = function() {
                      process2.nextTick(flush);
                    };
                  } else if (MutationObserver && !IS_IOS) {
                    toggle = true;
                    node = document.createTextNode("");
                    new MutationObserver(flush).observe(node, { characterData: true });
                    notify = function() {
                      node.data = toggle = !toggle;
                    };
                  } else if (Promise2 && Promise2.resolve) {
                    promise = Promise2.resolve(void 0);
                    then = promise.then;
                    notify = function() {
                      then.call(promise, flush);
                    };
                  } else {
                    notify = function() {
                      macrotask.call(global, flush);
                    };
                  }
                }
                module2.exports = queueMicrotask || function(fn) {
                  var task = { fn, next: void 0 };
                  if (last)
                    last.next = task;
                  if (!head) {
                    head = task;
                    notify();
                  }
                  last = task;
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var anObject = __w_pdfjs_require__2(23);
                var isObject = __w_pdfjs_require__2(17);
                var newPromiseCapability = __w_pdfjs_require__2(122);
                module2.exports = function(C, x) {
                  anObject(C);
                  if (isObject(x) && x.constructor === C)
                    return x;
                  var promiseCapability = newPromiseCapability.f(C);
                  var resolve = promiseCapability.resolve;
                  resolve(x);
                  return promiseCapability.promise;
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                var aFunction = __w_pdfjs_require__2(59);
                var PromiseCapability = function(C) {
                  var resolve, reject;
                  this.promise = new C(function($$resolve, $$reject) {
                    if (resolve !== void 0 || reject !== void 0)
                      throw TypeError("Bad Promise constructor");
                    resolve = $$resolve;
                    reject = $$reject;
                  });
                  this.resolve = aFunction(resolve);
                  this.reject = aFunction(reject);
                };
                module2.exports.f = function(C) {
                  return new PromiseCapability(C);
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var global = __w_pdfjs_require__2(6);
                module2.exports = function(a, b) {
                  var console2 = global.console;
                  if (console2 && console2.error) {
                    arguments.length === 1 ? console2.error(a) : console2.error(a, b);
                  }
                };
              }, function(module2, exports2) {
                module2.exports = function(exec) {
                  try {
                    return { error: false, value: exec() };
                  } catch (error) {
                    return { error: true, value: error };
                  }
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var global = __w_pdfjs_require__2(6);
                var userAgent = __w_pdfjs_require__2(119);
                var process2 = global.process;
                var versions = process2 && process2.versions;
                var v8 = versions && versions.v8;
                var match, version2;
                if (v8) {
                  match = v8.split(".");
                  version2 = match[0] + match[1];
                } else if (userAgent) {
                  match = userAgent.match(/Edge\/(\d+)/);
                  if (!match || match[1] >= 74) {
                    match = userAgent.match(/Chrome\/(\d+)/);
                    if (match)
                      version2 = match[1];
                  }
                }
                module2.exports = version2 && +version2;
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                var $ = __w_pdfjs_require__2(5);
                var aFunction = __w_pdfjs_require__2(59);
                var newPromiseCapabilityModule = __w_pdfjs_require__2(122);
                var perform = __w_pdfjs_require__2(124);
                var iterate = __w_pdfjs_require__2(115);
                $({ target: "Promise", stat: true }, { allSettled: function allSettled(iterable) {
                  var C = this;
                  var capability = newPromiseCapabilityModule.f(C);
                  var resolve = capability.resolve;
                  var reject = capability.reject;
                  var result = perform(function() {
                    var promiseResolve = aFunction(C.resolve);
                    var values = [];
                    var counter = 0;
                    var remaining = 1;
                    iterate(iterable, function(promise) {
                      var index = counter++;
                      var alreadyCalled = false;
                      values.push(void 0);
                      remaining++;
                      promiseResolve.call(C, promise).then(function(value) {
                        if (alreadyCalled)
                          return;
                        alreadyCalled = true;
                        values[index] = { status: "fulfilled", value };
                        --remaining || resolve(values);
                      }, function(e) {
                        if (alreadyCalled)
                          return;
                        alreadyCalled = true;
                        values[index] = { status: "rejected", reason: e };
                        --remaining || resolve(values);
                      });
                    });
                    --remaining || resolve(values);
                  });
                  if (result.error)
                    reject(result.value);
                  return capability.promise;
                } });
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                var $ = __w_pdfjs_require__2(5);
                var IS_PURE = __w_pdfjs_require__2(32);
                var NativePromise = __w_pdfjs_require__2(111);
                var fails = __w_pdfjs_require__2(9);
                var getBuiltIn = __w_pdfjs_require__2(37);
                var speciesConstructor = __w_pdfjs_require__2(116);
                var promiseResolve = __w_pdfjs_require__2(121);
                var redefine = __w_pdfjs_require__2(24);
                var NON_GENERIC = !!NativePromise && fails(function() {
                  NativePromise.prototype["finally"].call({ then: function() {
                  } }, function() {
                  });
                });
                $({ target: "Promise", proto: true, real: true, forced: NON_GENERIC }, { "finally": function(onFinally) {
                  var C = speciesConstructor(this, getBuiltIn("Promise"));
                  var isFunction = typeof onFinally == "function";
                  return this.then(isFunction ? function(x) {
                    return promiseResolve(C, onFinally()).then(function() {
                      return x;
                    });
                  } : onFinally, isFunction ? function(e) {
                    return promiseResolve(C, onFinally()).then(function() {
                      throw e;
                    });
                  } : onFinally);
                } });
                if (!IS_PURE && typeof NativePromise == "function" && !NativePromise.prototype["finally"]) {
                  redefine(NativePromise.prototype, "finally", getBuiltIn("Promise").prototype["finally"]);
                }
              }, function(module2, exports2, __w_pdfjs_require__2) {
                __w_pdfjs_require__2(129);
                __w_pdfjs_require__2(134);
                __w_pdfjs_require__2(132);
                var path = __w_pdfjs_require__2(38);
                module2.exports = path.URL;
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                __w_pdfjs_require__2(73);
                var $ = __w_pdfjs_require__2(5);
                var DESCRIPTORS = __w_pdfjs_require__2(8);
                var USE_NATIVE_URL = __w_pdfjs_require__2(130);
                var global = __w_pdfjs_require__2(6);
                var defineProperties = __w_pdfjs_require__2(68);
                var redefine = __w_pdfjs_require__2(24);
                var anInstance = __w_pdfjs_require__2(114);
                var has = __w_pdfjs_require__2(18);
                var assign = __w_pdfjs_require__2(96);
                var arrayFrom = __w_pdfjs_require__2(86);
                var codeAt = __w_pdfjs_require__2(74).codeAt;
                var toASCII = __w_pdfjs_require__2(131);
                var setToStringTag = __w_pdfjs_require__2(81);
                var URLSearchParamsModule = __w_pdfjs_require__2(132);
                var InternalStateModule = __w_pdfjs_require__2(28);
                var NativeURL = global.URL;
                var URLSearchParams2 = URLSearchParamsModule.URLSearchParams;
                var getInternalSearchParamsState = URLSearchParamsModule.getState;
                var setInternalState = InternalStateModule.set;
                var getInternalURLState = InternalStateModule.getterFor("URL");
                var floor = Math.floor;
                var pow = Math.pow;
                var INVALID_AUTHORITY = "Invalid authority";
                var INVALID_SCHEME = "Invalid scheme";
                var INVALID_HOST = "Invalid host";
                var INVALID_PORT = "Invalid port";
                var ALPHA = /[A-Za-z]/;
                var ALPHANUMERIC = /[\d+\-.A-Za-z]/;
                var DIGIT = /\d/;
                var HEX_START = /^(0x|0X)/;
                var OCT = /^[0-7]+$/;
                var DEC = /^\d+$/;
                var HEX = /^[\dA-Fa-f]+$/;
                var FORBIDDEN_HOST_CODE_POINT = /[\u0000\u0009\u000A\u000D #%/:?@[\\]]/;
                var FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT = /[\u0000\u0009\u000A\u000D #/:?@[\\]]/;
                var LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE = /^[\u0000-\u001F ]+|[\u0000-\u001F ]+$/g;
                var TAB_AND_NEW_LINE = /[\u0009\u000A\u000D]/g;
                var EOF;
                var parseHost = function(url, input) {
                  var result, codePoints, index;
                  if (input.charAt(0) == "[") {
                    if (input.charAt(input.length - 1) != "]")
                      return INVALID_HOST;
                    result = parseIPv6(input.slice(1, -1));
                    if (!result)
                      return INVALID_HOST;
                    url.host = result;
                  } else if (!isSpecial(url)) {
                    if (FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT.test(input))
                      return INVALID_HOST;
                    result = "";
                    codePoints = arrayFrom(input);
                    for (index = 0; index < codePoints.length; index++) {
                      result += percentEncode(codePoints[index], C0ControlPercentEncodeSet);
                    }
                    url.host = result;
                  } else {
                    input = toASCII(input);
                    if (FORBIDDEN_HOST_CODE_POINT.test(input))
                      return INVALID_HOST;
                    result = parseIPv4(input);
                    if (result === null)
                      return INVALID_HOST;
                    url.host = result;
                  }
                };
                var parseIPv4 = function(input) {
                  var parts = input.split(".");
                  var partsLength, numbers, index, part, radix, number, ipv4;
                  if (parts.length && parts[parts.length - 1] == "") {
                    parts.pop();
                  }
                  partsLength = parts.length;
                  if (partsLength > 4)
                    return input;
                  numbers = [];
                  for (index = 0; index < partsLength; index++) {
                    part = parts[index];
                    if (part == "")
                      return input;
                    radix = 10;
                    if (part.length > 1 && part.charAt(0) == "0") {
                      radix = HEX_START.test(part) ? 16 : 8;
                      part = part.slice(radix == 8 ? 1 : 2);
                    }
                    if (part === "") {
                      number = 0;
                    } else {
                      if (!(radix == 10 ? DEC : radix == 8 ? OCT : HEX).test(part))
                        return input;
                      number = parseInt(part, radix);
                    }
                    numbers.push(number);
                  }
                  for (index = 0; index < partsLength; index++) {
                    number = numbers[index];
                    if (index == partsLength - 1) {
                      if (number >= pow(256, 5 - partsLength))
                        return null;
                    } else if (number > 255)
                      return null;
                  }
                  ipv4 = numbers.pop();
                  for (index = 0; index < numbers.length; index++) {
                    ipv4 += numbers[index] * pow(256, 3 - index);
                  }
                  return ipv4;
                };
                var parseIPv6 = function(input) {
                  var address = [0, 0, 0, 0, 0, 0, 0, 0];
                  var pieceIndex = 0;
                  var compress = null;
                  var pointer = 0;
                  var value, length, numbersSeen, ipv4Piece, number, swaps, swap;
                  var char = function() {
                    return input.charAt(pointer);
                  };
                  if (char() == ":") {
                    if (input.charAt(1) != ":")
                      return;
                    pointer += 2;
                    pieceIndex++;
                    compress = pieceIndex;
                  }
                  while (char()) {
                    if (pieceIndex == 8)
                      return;
                    if (char() == ":") {
                      if (compress !== null)
                        return;
                      pointer++;
                      pieceIndex++;
                      compress = pieceIndex;
                      continue;
                    }
                    value = length = 0;
                    while (length < 4 && HEX.test(char())) {
                      value = value * 16 + parseInt(char(), 16);
                      pointer++;
                      length++;
                    }
                    if (char() == ".") {
                      if (length == 0)
                        return;
                      pointer -= length;
                      if (pieceIndex > 6)
                        return;
                      numbersSeen = 0;
                      while (char()) {
                        ipv4Piece = null;
                        if (numbersSeen > 0) {
                          if (char() == "." && numbersSeen < 4)
                            pointer++;
                          else
                            return;
                        }
                        if (!DIGIT.test(char()))
                          return;
                        while (DIGIT.test(char())) {
                          number = parseInt(char(), 10);
                          if (ipv4Piece === null)
                            ipv4Piece = number;
                          else if (ipv4Piece == 0)
                            return;
                          else
                            ipv4Piece = ipv4Piece * 10 + number;
                          if (ipv4Piece > 255)
                            return;
                          pointer++;
                        }
                        address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
                        numbersSeen++;
                        if (numbersSeen == 2 || numbersSeen == 4)
                          pieceIndex++;
                      }
                      if (numbersSeen != 4)
                        return;
                      break;
                    } else if (char() == ":") {
                      pointer++;
                      if (!char())
                        return;
                    } else if (char())
                      return;
                    address[pieceIndex++] = value;
                  }
                  if (compress !== null) {
                    swaps = pieceIndex - compress;
                    pieceIndex = 7;
                    while (pieceIndex != 0 && swaps > 0) {
                      swap = address[pieceIndex];
                      address[pieceIndex--] = address[compress + swaps - 1];
                      address[compress + --swaps] = swap;
                    }
                  } else if (pieceIndex != 8)
                    return;
                  return address;
                };
                var findLongestZeroSequence = function(ipv6) {
                  var maxIndex = null;
                  var maxLength = 1;
                  var currStart = null;
                  var currLength = 0;
                  var index = 0;
                  for (; index < 8; index++) {
                    if (ipv6[index] !== 0) {
                      if (currLength > maxLength) {
                        maxIndex = currStart;
                        maxLength = currLength;
                      }
                      currStart = null;
                      currLength = 0;
                    } else {
                      if (currStart === null)
                        currStart = index;
                      ++currLength;
                    }
                  }
                  if (currLength > maxLength) {
                    maxIndex = currStart;
                    maxLength = currLength;
                  }
                  return maxIndex;
                };
                var serializeHost = function(host) {
                  var result, index, compress, ignore0;
                  if (typeof host == "number") {
                    result = [];
                    for (index = 0; index < 4; index++) {
                      result.unshift(host % 256);
                      host = floor(host / 256);
                    }
                    return result.join(".");
                  } else if (typeof host == "object") {
                    result = "";
                    compress = findLongestZeroSequence(host);
                    for (index = 0; index < 8; index++) {
                      if (ignore0 && host[index] === 0)
                        continue;
                      if (ignore0)
                        ignore0 = false;
                      if (compress === index) {
                        result += index ? ":" : "::";
                        ignore0 = true;
                      } else {
                        result += host[index].toString(16);
                        if (index < 7)
                          result += ":";
                      }
                    }
                    return "[" + result + "]";
                  }
                  return host;
                };
                var C0ControlPercentEncodeSet = {};
                var fragmentPercentEncodeSet = assign({}, C0ControlPercentEncodeSet, { " ": 1, '"': 1, "<": 1, ">": 1, "`": 1 });
                var pathPercentEncodeSet = assign({}, fragmentPercentEncodeSet, { "#": 1, "?": 1, "{": 1, "}": 1 });
                var userinfoPercentEncodeSet = assign({}, pathPercentEncodeSet, { "/": 1, ":": 1, ";": 1, "=": 1, "@": 1, "[": 1, "\\": 1, "]": 1, "^": 1, "|": 1 });
                var percentEncode = function(char, set) {
                  var code = codeAt(char, 0);
                  return code > 32 && code < 127 && !has(set, char) ? char : encodeURIComponent(char);
                };
                var specialSchemes = { ftp: 21, file: null, http: 80, https: 443, ws: 80, wss: 443 };
                var isSpecial = function(url) {
                  return has(specialSchemes, url.scheme);
                };
                var includesCredentials = function(url) {
                  return url.username != "" || url.password != "";
                };
                var cannotHaveUsernamePasswordPort = function(url) {
                  return !url.host || url.cannotBeABaseURL || url.scheme == "file";
                };
                var isWindowsDriveLetter = function(string, normalized) {
                  var second;
                  return string.length == 2 && ALPHA.test(string.charAt(0)) && ((second = string.charAt(1)) == ":" || !normalized && second == "|");
                };
                var startsWithWindowsDriveLetter = function(string) {
                  var third;
                  return string.length > 1 && isWindowsDriveLetter(string.slice(0, 2)) && (string.length == 2 || (third = string.charAt(2)) === "/" || third === "\\" || third === "?" || third === "#");
                };
                var shortenURLsPath = function(url) {
                  var path = url.path;
                  var pathSize = path.length;
                  if (pathSize && (url.scheme != "file" || pathSize != 1 || !isWindowsDriveLetter(path[0], true))) {
                    path.pop();
                  }
                };
                var isSingleDot = function(segment) {
                  return segment === "." || segment.toLowerCase() === "%2e";
                };
                var isDoubleDot = function(segment) {
                  segment = segment.toLowerCase();
                  return segment === ".." || segment === "%2e." || segment === ".%2e" || segment === "%2e%2e";
                };
                var SCHEME_START = {};
                var SCHEME = {};
                var NO_SCHEME = {};
                var SPECIAL_RELATIVE_OR_AUTHORITY = {};
                var PATH_OR_AUTHORITY = {};
                var RELATIVE = {};
                var RELATIVE_SLASH = {};
                var SPECIAL_AUTHORITY_SLASHES = {};
                var SPECIAL_AUTHORITY_IGNORE_SLASHES = {};
                var AUTHORITY = {};
                var HOST = {};
                var HOSTNAME = {};
                var PORT = {};
                var FILE = {};
                var FILE_SLASH = {};
                var FILE_HOST = {};
                var PATH_START = {};
                var PATH = {};
                var CANNOT_BE_A_BASE_URL_PATH = {};
                var QUERY = {};
                var FRAGMENT = {};
                var parseURL = function(url, input, stateOverride, base) {
                  var state = stateOverride || SCHEME_START;
                  var pointer = 0;
                  var buffer = "";
                  var seenAt = false;
                  var seenBracket = false;
                  var seenPasswordToken = false;
                  var codePoints, char, bufferCodePoints, failure;
                  if (!stateOverride) {
                    url.scheme = "";
                    url.username = "";
                    url.password = "";
                    url.host = null;
                    url.port = null;
                    url.path = [];
                    url.query = null;
                    url.fragment = null;
                    url.cannotBeABaseURL = false;
                    input = input.replace(LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE, "");
                  }
                  input = input.replace(TAB_AND_NEW_LINE, "");
                  codePoints = arrayFrom(input);
                  while (pointer <= codePoints.length) {
                    char = codePoints[pointer];
                    switch (state) {
                      case SCHEME_START:
                        if (char && ALPHA.test(char)) {
                          buffer += char.toLowerCase();
                          state = SCHEME;
                        } else if (!stateOverride) {
                          state = NO_SCHEME;
                          continue;
                        } else
                          return INVALID_SCHEME;
                        break;
                      case SCHEME:
                        if (char && (ALPHANUMERIC.test(char) || char == "+" || char == "-" || char == ".")) {
                          buffer += char.toLowerCase();
                        } else if (char == ":") {
                          if (stateOverride && (isSpecial(url) != has(specialSchemes, buffer) || buffer == "file" && (includesCredentials(url) || url.port !== null) || url.scheme == "file" && !url.host))
                            return;
                          url.scheme = buffer;
                          if (stateOverride) {
                            if (isSpecial(url) && specialSchemes[url.scheme] == url.port)
                              url.port = null;
                            return;
                          }
                          buffer = "";
                          if (url.scheme == "file") {
                            state = FILE;
                          } else if (isSpecial(url) && base && base.scheme == url.scheme) {
                            state = SPECIAL_RELATIVE_OR_AUTHORITY;
                          } else if (isSpecial(url)) {
                            state = SPECIAL_AUTHORITY_SLASHES;
                          } else if (codePoints[pointer + 1] == "/") {
                            state = PATH_OR_AUTHORITY;
                            pointer++;
                          } else {
                            url.cannotBeABaseURL = true;
                            url.path.push("");
                            state = CANNOT_BE_A_BASE_URL_PATH;
                          }
                        } else if (!stateOverride) {
                          buffer = "";
                          state = NO_SCHEME;
                          pointer = 0;
                          continue;
                        } else
                          return INVALID_SCHEME;
                        break;
                      case NO_SCHEME:
                        if (!base || base.cannotBeABaseURL && char != "#")
                          return INVALID_SCHEME;
                        if (base.cannotBeABaseURL && char == "#") {
                          url.scheme = base.scheme;
                          url.path = base.path.slice();
                          url.query = base.query;
                          url.fragment = "";
                          url.cannotBeABaseURL = true;
                          state = FRAGMENT;
                          break;
                        }
                        state = base.scheme == "file" ? FILE : RELATIVE;
                        continue;
                      case SPECIAL_RELATIVE_OR_AUTHORITY:
                        if (char == "/" && codePoints[pointer + 1] == "/") {
                          state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
                          pointer++;
                        } else {
                          state = RELATIVE;
                          continue;
                        }
                        break;
                      case PATH_OR_AUTHORITY:
                        if (char == "/") {
                          state = AUTHORITY;
                          break;
                        } else {
                          state = PATH;
                          continue;
                        }
                      case RELATIVE:
                        url.scheme = base.scheme;
                        if (char == EOF) {
                          url.username = base.username;
                          url.password = base.password;
                          url.host = base.host;
                          url.port = base.port;
                          url.path = base.path.slice();
                          url.query = base.query;
                        } else if (char == "/" || char == "\\" && isSpecial(url)) {
                          state = RELATIVE_SLASH;
                        } else if (char == "?") {
                          url.username = base.username;
                          url.password = base.password;
                          url.host = base.host;
                          url.port = base.port;
                          url.path = base.path.slice();
                          url.query = "";
                          state = QUERY;
                        } else if (char == "#") {
                          url.username = base.username;
                          url.password = base.password;
                          url.host = base.host;
                          url.port = base.port;
                          url.path = base.path.slice();
                          url.query = base.query;
                          url.fragment = "";
                          state = FRAGMENT;
                        } else {
                          url.username = base.username;
                          url.password = base.password;
                          url.host = base.host;
                          url.port = base.port;
                          url.path = base.path.slice();
                          url.path.pop();
                          state = PATH;
                          continue;
                        }
                        break;
                      case RELATIVE_SLASH:
                        if (isSpecial(url) && (char == "/" || char == "\\")) {
                          state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
                        } else if (char == "/") {
                          state = AUTHORITY;
                        } else {
                          url.username = base.username;
                          url.password = base.password;
                          url.host = base.host;
                          url.port = base.port;
                          state = PATH;
                          continue;
                        }
                        break;
                      case SPECIAL_AUTHORITY_SLASHES:
                        state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
                        if (char != "/" || buffer.charAt(pointer + 1) != "/")
                          continue;
                        pointer++;
                        break;
                      case SPECIAL_AUTHORITY_IGNORE_SLASHES:
                        if (char != "/" && char != "\\") {
                          state = AUTHORITY;
                          continue;
                        }
                        break;
                      case AUTHORITY:
                        if (char == "@") {
                          if (seenAt)
                            buffer = "%40" + buffer;
                          seenAt = true;
                          bufferCodePoints = arrayFrom(buffer);
                          for (var i = 0; i < bufferCodePoints.length; i++) {
                            var codePoint = bufferCodePoints[i];
                            if (codePoint == ":" && !seenPasswordToken) {
                              seenPasswordToken = true;
                              continue;
                            }
                            var encodedCodePoints = percentEncode(codePoint, userinfoPercentEncodeSet);
                            if (seenPasswordToken)
                              url.password += encodedCodePoints;
                            else
                              url.username += encodedCodePoints;
                          }
                          buffer = "";
                        } else if (char == EOF || char == "/" || char == "?" || char == "#" || char == "\\" && isSpecial(url)) {
                          if (seenAt && buffer == "")
                            return INVALID_AUTHORITY;
                          pointer -= arrayFrom(buffer).length + 1;
                          buffer = "";
                          state = HOST;
                        } else
                          buffer += char;
                        break;
                      case HOST:
                      case HOSTNAME:
                        if (stateOverride && url.scheme == "file") {
                          state = FILE_HOST;
                          continue;
                        } else if (char == ":" && !seenBracket) {
                          if (buffer == "")
                            return INVALID_HOST;
                          failure = parseHost(url, buffer);
                          if (failure)
                            return failure;
                          buffer = "";
                          state = PORT;
                          if (stateOverride == HOSTNAME)
                            return;
                        } else if (char == EOF || char == "/" || char == "?" || char == "#" || char == "\\" && isSpecial(url)) {
                          if (isSpecial(url) && buffer == "")
                            return INVALID_HOST;
                          if (stateOverride && buffer == "" && (includesCredentials(url) || url.port !== null))
                            return;
                          failure = parseHost(url, buffer);
                          if (failure)
                            return failure;
                          buffer = "";
                          state = PATH_START;
                          if (stateOverride)
                            return;
                          continue;
                        } else {
                          if (char == "[")
                            seenBracket = true;
                          else if (char == "]")
                            seenBracket = false;
                          buffer += char;
                        }
                        break;
                      case PORT:
                        if (DIGIT.test(char)) {
                          buffer += char;
                        } else if (char == EOF || char == "/" || char == "?" || char == "#" || char == "\\" && isSpecial(url) || stateOverride) {
                          if (buffer != "") {
                            var port = parseInt(buffer, 10);
                            if (port > 65535)
                              return INVALID_PORT;
                            url.port = isSpecial(url) && port === specialSchemes[url.scheme] ? null : port;
                            buffer = "";
                          }
                          if (stateOverride)
                            return;
                          state = PATH_START;
                          continue;
                        } else
                          return INVALID_PORT;
                        break;
                      case FILE:
                        url.scheme = "file";
                        if (char == "/" || char == "\\")
                          state = FILE_SLASH;
                        else if (base && base.scheme == "file") {
                          if (char == EOF) {
                            url.host = base.host;
                            url.path = base.path.slice();
                            url.query = base.query;
                          } else if (char == "?") {
                            url.host = base.host;
                            url.path = base.path.slice();
                            url.query = "";
                            state = QUERY;
                          } else if (char == "#") {
                            url.host = base.host;
                            url.path = base.path.slice();
                            url.query = base.query;
                            url.fragment = "";
                            state = FRAGMENT;
                          } else {
                            if (!startsWithWindowsDriveLetter(codePoints.slice(pointer).join(""))) {
                              url.host = base.host;
                              url.path = base.path.slice();
                              shortenURLsPath(url);
                            }
                            state = PATH;
                            continue;
                          }
                        } else {
                          state = PATH;
                          continue;
                        }
                        break;
                      case FILE_SLASH:
                        if (char == "/" || char == "\\") {
                          state = FILE_HOST;
                          break;
                        }
                        if (base && base.scheme == "file" && !startsWithWindowsDriveLetter(codePoints.slice(pointer).join(""))) {
                          if (isWindowsDriveLetter(base.path[0], true))
                            url.path.push(base.path[0]);
                          else
                            url.host = base.host;
                        }
                        state = PATH;
                        continue;
                      case FILE_HOST:
                        if (char == EOF || char == "/" || char == "\\" || char == "?" || char == "#") {
                          if (!stateOverride && isWindowsDriveLetter(buffer)) {
                            state = PATH;
                          } else if (buffer == "") {
                            url.host = "";
                            if (stateOverride)
                              return;
                            state = PATH_START;
                          } else {
                            failure = parseHost(url, buffer);
                            if (failure)
                              return failure;
                            if (url.host == "localhost")
                              url.host = "";
                            if (stateOverride)
                              return;
                            buffer = "";
                            state = PATH_START;
                          }
                          continue;
                        } else
                          buffer += char;
                        break;
                      case PATH_START:
                        if (isSpecial(url)) {
                          state = PATH;
                          if (char != "/" && char != "\\")
                            continue;
                        } else if (!stateOverride && char == "?") {
                          url.query = "";
                          state = QUERY;
                        } else if (!stateOverride && char == "#") {
                          url.fragment = "";
                          state = FRAGMENT;
                        } else if (char != EOF) {
                          state = PATH;
                          if (char != "/")
                            continue;
                        }
                        break;
                      case PATH:
                        if (char == EOF || char == "/" || char == "\\" && isSpecial(url) || !stateOverride && (char == "?" || char == "#")) {
                          if (isDoubleDot(buffer)) {
                            shortenURLsPath(url);
                            if (char != "/" && !(char == "\\" && isSpecial(url))) {
                              url.path.push("");
                            }
                          } else if (isSingleDot(buffer)) {
                            if (char != "/" && !(char == "\\" && isSpecial(url))) {
                              url.path.push("");
                            }
                          } else {
                            if (url.scheme == "file" && !url.path.length && isWindowsDriveLetter(buffer)) {
                              if (url.host)
                                url.host = "";
                              buffer = buffer.charAt(0) + ":";
                            }
                            url.path.push(buffer);
                          }
                          buffer = "";
                          if (url.scheme == "file" && (char == EOF || char == "?" || char == "#")) {
                            while (url.path.length > 1 && url.path[0] === "") {
                              url.path.shift();
                            }
                          }
                          if (char == "?") {
                            url.query = "";
                            state = QUERY;
                          } else if (char == "#") {
                            url.fragment = "";
                            state = FRAGMENT;
                          }
                        } else {
                          buffer += percentEncode(char, pathPercentEncodeSet);
                        }
                        break;
                      case CANNOT_BE_A_BASE_URL_PATH:
                        if (char == "?") {
                          url.query = "";
                          state = QUERY;
                        } else if (char == "#") {
                          url.fragment = "";
                          state = FRAGMENT;
                        } else if (char != EOF) {
                          url.path[0] += percentEncode(char, C0ControlPercentEncodeSet);
                        }
                        break;
                      case QUERY:
                        if (!stateOverride && char == "#") {
                          url.fragment = "";
                          state = FRAGMENT;
                        } else if (char != EOF) {
                          if (char == "'" && isSpecial(url))
                            url.query += "%27";
                          else if (char == "#")
                            url.query += "%23";
                          else
                            url.query += percentEncode(char, C0ControlPercentEncodeSet);
                        }
                        break;
                      case FRAGMENT:
                        if (char != EOF)
                          url.fragment += percentEncode(char, fragmentPercentEncodeSet);
                        break;
                    }
                    pointer++;
                  }
                };
                var URLConstructor = function URL2(url) {
                  var that = anInstance(this, URLConstructor, "URL");
                  var base = arguments.length > 1 ? arguments[1] : void 0;
                  var urlString = String(url);
                  var state = setInternalState(that, { type: "URL" });
                  var baseState, failure;
                  if (base !== void 0) {
                    if (base instanceof URLConstructor)
                      baseState = getInternalURLState(base);
                    else {
                      failure = parseURL(baseState = {}, String(base));
                      if (failure)
                        throw TypeError(failure);
                    }
                  }
                  failure = parseURL(state, urlString, null, baseState);
                  if (failure)
                    throw TypeError(failure);
                  var searchParams = state.searchParams = new URLSearchParams2();
                  var searchParamsState = getInternalSearchParamsState(searchParams);
                  searchParamsState.updateSearchParams(state.query);
                  searchParamsState.updateURL = function() {
                    state.query = String(searchParams) || null;
                  };
                  if (!DESCRIPTORS) {
                    that.href = serializeURL.call(that);
                    that.origin = getOrigin.call(that);
                    that.protocol = getProtocol.call(that);
                    that.username = getUsername.call(that);
                    that.password = getPassword.call(that);
                    that.host = getHost.call(that);
                    that.hostname = getHostname.call(that);
                    that.port = getPort.call(that);
                    that.pathname = getPathname.call(that);
                    that.search = getSearch.call(that);
                    that.searchParams = getSearchParams.call(that);
                    that.hash = getHash.call(that);
                  }
                };
                var URLPrototype = URLConstructor.prototype;
                var serializeURL = function() {
                  var url = getInternalURLState(this);
                  var scheme = url.scheme;
                  var username = url.username;
                  var password = url.password;
                  var host = url.host;
                  var port = url.port;
                  var path = url.path;
                  var query = url.query;
                  var fragment = url.fragment;
                  var output = scheme + ":";
                  if (host !== null) {
                    output += "//";
                    if (includesCredentials(url)) {
                      output += username + (password ? ":" + password : "") + "@";
                    }
                    output += serializeHost(host);
                    if (port !== null)
                      output += ":" + port;
                  } else if (scheme == "file")
                    output += "//";
                  output += url.cannotBeABaseURL ? path[0] : path.length ? "/" + path.join("/") : "";
                  if (query !== null)
                    output += "?" + query;
                  if (fragment !== null)
                    output += "#" + fragment;
                  return output;
                };
                var getOrigin = function() {
                  var url = getInternalURLState(this);
                  var scheme = url.scheme;
                  var port = url.port;
                  if (scheme == "blob")
                    try {
                      return new URL(scheme.path[0]).origin;
                    } catch (error) {
                      return "null";
                    }
                  if (scheme == "file" || !isSpecial(url))
                    return "null";
                  return scheme + "://" + serializeHost(url.host) + (port !== null ? ":" + port : "");
                };
                var getProtocol = function() {
                  return getInternalURLState(this).scheme + ":";
                };
                var getUsername = function() {
                  return getInternalURLState(this).username;
                };
                var getPassword = function() {
                  return getInternalURLState(this).password;
                };
                var getHost = function() {
                  var url = getInternalURLState(this);
                  var host = url.host;
                  var port = url.port;
                  return host === null ? "" : port === null ? serializeHost(host) : serializeHost(host) + ":" + port;
                };
                var getHostname = function() {
                  var host = getInternalURLState(this).host;
                  return host === null ? "" : serializeHost(host);
                };
                var getPort = function() {
                  var port = getInternalURLState(this).port;
                  return port === null ? "" : String(port);
                };
                var getPathname = function() {
                  var url = getInternalURLState(this);
                  var path = url.path;
                  return url.cannotBeABaseURL ? path[0] : path.length ? "/" + path.join("/") : "";
                };
                var getSearch = function() {
                  var query = getInternalURLState(this).query;
                  return query ? "?" + query : "";
                };
                var getSearchParams = function() {
                  return getInternalURLState(this).searchParams;
                };
                var getHash = function() {
                  var fragment = getInternalURLState(this).fragment;
                  return fragment ? "#" + fragment : "";
                };
                var accessorDescriptor = function(getter, setter) {
                  return { get: getter, set: setter, configurable: true, enumerable: true };
                };
                if (DESCRIPTORS) {
                  defineProperties(URLPrototype, { href: accessorDescriptor(serializeURL, function(href) {
                    var url = getInternalURLState(this);
                    var urlString = String(href);
                    var failure = parseURL(url, urlString);
                    if (failure)
                      throw TypeError(failure);
                    getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);
                  }), origin: accessorDescriptor(getOrigin), protocol: accessorDescriptor(getProtocol, function(protocol) {
                    var url = getInternalURLState(this);
                    parseURL(url, String(protocol) + ":", SCHEME_START);
                  }), username: accessorDescriptor(getUsername, function(username) {
                    var url = getInternalURLState(this);
                    var codePoints = arrayFrom(String(username));
                    if (cannotHaveUsernamePasswordPort(url))
                      return;
                    url.username = "";
                    for (var i = 0; i < codePoints.length; i++) {
                      url.username += percentEncode(codePoints[i], userinfoPercentEncodeSet);
                    }
                  }), password: accessorDescriptor(getPassword, function(password) {
                    var url = getInternalURLState(this);
                    var codePoints = arrayFrom(String(password));
                    if (cannotHaveUsernamePasswordPort(url))
                      return;
                    url.password = "";
                    for (var i = 0; i < codePoints.length; i++) {
                      url.password += percentEncode(codePoints[i], userinfoPercentEncodeSet);
                    }
                  }), host: accessorDescriptor(getHost, function(host) {
                    var url = getInternalURLState(this);
                    if (url.cannotBeABaseURL)
                      return;
                    parseURL(url, String(host), HOST);
                  }), hostname: accessorDescriptor(getHostname, function(hostname) {
                    var url = getInternalURLState(this);
                    if (url.cannotBeABaseURL)
                      return;
                    parseURL(url, String(hostname), HOSTNAME);
                  }), port: accessorDescriptor(getPort, function(port) {
                    var url = getInternalURLState(this);
                    if (cannotHaveUsernamePasswordPort(url))
                      return;
                    port = String(port);
                    if (port == "")
                      url.port = null;
                    else
                      parseURL(url, port, PORT);
                  }), pathname: accessorDescriptor(getPathname, function(pathname) {
                    var url = getInternalURLState(this);
                    if (url.cannotBeABaseURL)
                      return;
                    url.path = [];
                    parseURL(url, pathname + "", PATH_START);
                  }), search: accessorDescriptor(getSearch, function(search) {
                    var url = getInternalURLState(this);
                    search = String(search);
                    if (search == "") {
                      url.query = null;
                    } else {
                      if ("?" == search.charAt(0))
                        search = search.slice(1);
                      url.query = "";
                      parseURL(url, search, QUERY);
                    }
                    getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);
                  }), searchParams: accessorDescriptor(getSearchParams), hash: accessorDescriptor(getHash, function(hash) {
                    var url = getInternalURLState(this);
                    hash = String(hash);
                    if (hash == "") {
                      url.fragment = null;
                      return;
                    }
                    if ("#" == hash.charAt(0))
                      hash = hash.slice(1);
                    url.fragment = "";
                    parseURL(url, hash, FRAGMENT);
                  }) });
                }
                redefine(URLPrototype, "toJSON", function toJSON() {
                  return serializeURL.call(this);
                }, { enumerable: true });
                redefine(URLPrototype, "toString", function toString() {
                  return serializeURL.call(this);
                }, { enumerable: true });
                if (NativeURL) {
                  var nativeCreateObjectURL = NativeURL.createObjectURL;
                  var nativeRevokeObjectURL = NativeURL.revokeObjectURL;
                  if (nativeCreateObjectURL)
                    redefine(URLConstructor, "createObjectURL", function createObjectURL(blob) {
                      return nativeCreateObjectURL.apply(NativeURL, arguments);
                    });
                  if (nativeRevokeObjectURL)
                    redefine(URLConstructor, "revokeObjectURL", function revokeObjectURL(url) {
                      return nativeRevokeObjectURL.apply(NativeURL, arguments);
                    });
                }
                setToStringTag(URLConstructor, "URL");
                $({ global: true, forced: !USE_NATIVE_URL, sham: !DESCRIPTORS }, { URL: URLConstructor });
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var fails = __w_pdfjs_require__2(9);
                var wellKnownSymbol = __w_pdfjs_require__2(53);
                var IS_PURE = __w_pdfjs_require__2(32);
                var ITERATOR = wellKnownSymbol("iterator");
                module2.exports = !fails(function() {
                  var url = new URL("b?a=1&b=2&c=3", "http://a");
                  var searchParams = url.searchParams;
                  var result = "";
                  url.pathname = "c%20d";
                  searchParams.forEach(function(value, key) {
                    searchParams["delete"]("b");
                    result += key + value;
                  });
                  return IS_PURE && !url.toJSON || !searchParams.sort || url.href !== "http://a/c%20d?a=1&c=3" || searchParams.get("c") !== "3" || String(new URLSearchParams("?a=1")) !== "a=1" || !searchParams[ITERATOR] || new URL("https://a@b").username !== "a" || new URLSearchParams(new URLSearchParams("a=b")).get("a") !== "b" || new URL("http://\u0442\u0435\u0441\u0442").host !== "xn--e1aybc" || new URL("http://a#\u0431").hash !== "#%D0%B1" || result !== "a1c3" || new URL("http://x", void 0).host !== "x";
                });
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                var maxInt = 2147483647;
                var base = 36;
                var tMin = 1;
                var tMax = 26;
                var skew = 38;
                var damp = 700;
                var initialBias = 72;
                var initialN = 128;
                var delimiter = "-";
                var regexNonASCII = /[^\0-\u007E]/;
                var regexSeparators = /[.\u3002\uFF0E\uFF61]/g;
                var OVERFLOW_ERROR = "Overflow: input needs wider integers to process";
                var baseMinusTMin = base - tMin;
                var floor = Math.floor;
                var stringFromCharCode = String.fromCharCode;
                var ucs2decode = function(string) {
                  var output = [];
                  var counter = 0;
                  var length = string.length;
                  while (counter < length) {
                    var value = string.charCodeAt(counter++);
                    if (value >= 55296 && value <= 56319 && counter < length) {
                      var extra = string.charCodeAt(counter++);
                      if ((extra & 64512) == 56320) {
                        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
                      } else {
                        output.push(value);
                        counter--;
                      }
                    } else {
                      output.push(value);
                    }
                  }
                  return output;
                };
                var digitToBasic = function(digit) {
                  return digit + 22 + 75 * (digit < 26);
                };
                var adapt = function(delta, numPoints, firstTime) {
                  var k = 0;
                  delta = firstTime ? floor(delta / damp) : delta >> 1;
                  delta += floor(delta / numPoints);
                  for (; delta > baseMinusTMin * tMax >> 1; k += base) {
                    delta = floor(delta / baseMinusTMin);
                  }
                  return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
                };
                var encode = function(input) {
                  var output = [];
                  input = ucs2decode(input);
                  var inputLength = input.length;
                  var n = initialN;
                  var delta = 0;
                  var bias = initialBias;
                  var i, currentValue;
                  for (i = 0; i < input.length; i++) {
                    currentValue = input[i];
                    if (currentValue < 128) {
                      output.push(stringFromCharCode(currentValue));
                    }
                  }
                  var basicLength = output.length;
                  var handledCPCount = basicLength;
                  if (basicLength) {
                    output.push(delimiter);
                  }
                  while (handledCPCount < inputLength) {
                    var m = maxInt;
                    for (i = 0; i < input.length; i++) {
                      currentValue = input[i];
                      if (currentValue >= n && currentValue < m) {
                        m = currentValue;
                      }
                    }
                    var handledCPCountPlusOne = handledCPCount + 1;
                    if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                      throw RangeError(OVERFLOW_ERROR);
                    }
                    delta += (m - n) * handledCPCountPlusOne;
                    n = m;
                    for (i = 0; i < input.length; i++) {
                      currentValue = input[i];
                      if (currentValue < n && ++delta > maxInt) {
                        throw RangeError(OVERFLOW_ERROR);
                      }
                      if (currentValue == n) {
                        var q = delta;
                        for (var k = base; ; k += base) {
                          var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                          if (q < t)
                            break;
                          var qMinusT = q - t;
                          var baseMinusT = base - t;
                          output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT)));
                          q = floor(qMinusT / baseMinusT);
                        }
                        output.push(stringFromCharCode(digitToBasic(q)));
                        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                        delta = 0;
                        ++handledCPCount;
                      }
                    }
                    ++delta;
                    ++n;
                  }
                  return output.join("");
                };
                module2.exports = function(input) {
                  var encoded = [];
                  var labels = input.toLowerCase().replace(regexSeparators, ".").split(".");
                  var i, label;
                  for (i = 0; i < labels.length; i++) {
                    label = labels[i];
                    encoded.push(regexNonASCII.test(label) ? "xn--" + encode(label) : label);
                  }
                  return encoded.join(".");
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                __w_pdfjs_require__2(109);
                var $ = __w_pdfjs_require__2(5);
                var getBuiltIn = __w_pdfjs_require__2(37);
                var USE_NATIVE_URL = __w_pdfjs_require__2(130);
                var redefine = __w_pdfjs_require__2(24);
                var redefineAll = __w_pdfjs_require__2(112);
                var setToStringTag = __w_pdfjs_require__2(81);
                var createIteratorConstructor = __w_pdfjs_require__2(76);
                var InternalStateModule = __w_pdfjs_require__2(28);
                var anInstance = __w_pdfjs_require__2(114);
                var hasOwn = __w_pdfjs_require__2(18);
                var bind = __w_pdfjs_require__2(58);
                var classof = __w_pdfjs_require__2(91);
                var anObject = __w_pdfjs_require__2(23);
                var isObject = __w_pdfjs_require__2(17);
                var create = __w_pdfjs_require__2(67);
                var createPropertyDescriptor = __w_pdfjs_require__2(11);
                var getIterator = __w_pdfjs_require__2(133);
                var getIteratorMethod = __w_pdfjs_require__2(90);
                var wellKnownSymbol = __w_pdfjs_require__2(53);
                var $fetch = getBuiltIn("fetch");
                var Headers2 = getBuiltIn("Headers");
                var ITERATOR = wellKnownSymbol("iterator");
                var URL_SEARCH_PARAMS = "URLSearchParams";
                var URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + "Iterator";
                var setInternalState = InternalStateModule.set;
                var getInternalParamsState = InternalStateModule.getterFor(URL_SEARCH_PARAMS);
                var getInternalIteratorState = InternalStateModule.getterFor(URL_SEARCH_PARAMS_ITERATOR);
                var plus = /\+/g;
                var sequences = Array(4);
                var percentSequence = function(bytes) {
                  return sequences[bytes - 1] || (sequences[bytes - 1] = RegExp("((?:%[\\da-f]{2}){" + bytes + "})", "gi"));
                };
                var percentDecode = function(sequence) {
                  try {
                    return decodeURIComponent(sequence);
                  } catch (error) {
                    return sequence;
                  }
                };
                var deserialize = function(it) {
                  var result = it.replace(plus, " ");
                  var bytes = 4;
                  try {
                    return decodeURIComponent(result);
                  } catch (error) {
                    while (bytes) {
                      result = result.replace(percentSequence(bytes--), percentDecode);
                    }
                    return result;
                  }
                };
                var find = /[!'()~]|%20/g;
                var replace = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+" };
                var replacer = function(match) {
                  return replace[match];
                };
                var serialize = function(it) {
                  return encodeURIComponent(it).replace(find, replacer);
                };
                var parseSearchParams = function(result, query) {
                  if (query) {
                    var attributes = query.split("&");
                    var index = 0;
                    var attribute, entry;
                    while (index < attributes.length) {
                      attribute = attributes[index++];
                      if (attribute.length) {
                        entry = attribute.split("=");
                        result.push({ key: deserialize(entry.shift()), value: deserialize(entry.join("=")) });
                      }
                    }
                  }
                };
                var updateSearchParams = function(query) {
                  this.entries.length = 0;
                  parseSearchParams(this.entries, query);
                };
                var validateArgumentsLength = function(passed, required) {
                  if (passed < required)
                    throw TypeError("Not enough arguments");
                };
                var URLSearchParamsIterator = createIteratorConstructor(function Iterator(params, kind) {
                  setInternalState(this, { type: URL_SEARCH_PARAMS_ITERATOR, iterator: getIterator(getInternalParamsState(params).entries), kind });
                }, "Iterator", function next() {
                  var state = getInternalIteratorState(this);
                  var kind = state.kind;
                  var step = state.iterator.next();
                  var entry = step.value;
                  if (!step.done) {
                    step.value = kind === "keys" ? entry.key : kind === "values" ? entry.value : [entry.key, entry.value];
                  }
                  return step;
                });
                var URLSearchParamsConstructor = function URLSearchParams2() {
                  anInstance(this, URLSearchParamsConstructor, URL_SEARCH_PARAMS);
                  var init = arguments.length > 0 ? arguments[0] : void 0;
                  var that = this;
                  var entries = [];
                  var iteratorMethod, iterator, next, step, entryIterator, entryNext, first, second, key;
                  setInternalState(that, { type: URL_SEARCH_PARAMS, entries, updateURL: function() {
                  }, updateSearchParams });
                  if (init !== void 0) {
                    if (isObject(init)) {
                      iteratorMethod = getIteratorMethod(init);
                      if (typeof iteratorMethod === "function") {
                        iterator = iteratorMethod.call(init);
                        next = iterator.next;
                        while (!(step = next.call(iterator)).done) {
                          entryIterator = getIterator(anObject(step.value));
                          entryNext = entryIterator.next;
                          if ((first = entryNext.call(entryIterator)).done || (second = entryNext.call(entryIterator)).done || !entryNext.call(entryIterator).done)
                            throw TypeError("Expected sequence with length 2");
                          entries.push({ key: first.value + "", value: second.value + "" });
                        }
                      } else
                        for (key in init)
                          if (hasOwn(init, key))
                            entries.push({ key, value: init[key] + "" });
                    } else {
                      parseSearchParams(entries, typeof init === "string" ? init.charAt(0) === "?" ? init.slice(1) : init : init + "");
                    }
                  }
                };
                var URLSearchParamsPrototype = URLSearchParamsConstructor.prototype;
                redefineAll(URLSearchParamsPrototype, { append: function append(name, value) {
                  validateArgumentsLength(arguments.length, 2);
                  var state = getInternalParamsState(this);
                  state.entries.push({ key: name + "", value: value + "" });
                  state.updateURL();
                }, "delete": function(name) {
                  validateArgumentsLength(arguments.length, 1);
                  var state = getInternalParamsState(this);
                  var entries = state.entries;
                  var key = name + "";
                  var index = 0;
                  while (index < entries.length) {
                    if (entries[index].key === key)
                      entries.splice(index, 1);
                    else
                      index++;
                  }
                  state.updateURL();
                }, get: function get(name) {
                  validateArgumentsLength(arguments.length, 1);
                  var entries = getInternalParamsState(this).entries;
                  var key = name + "";
                  var index = 0;
                  for (; index < entries.length; index++) {
                    if (entries[index].key === key)
                      return entries[index].value;
                  }
                  return null;
                }, getAll: function getAll(name) {
                  validateArgumentsLength(arguments.length, 1);
                  var entries = getInternalParamsState(this).entries;
                  var key = name + "";
                  var result = [];
                  var index = 0;
                  for (; index < entries.length; index++) {
                    if (entries[index].key === key)
                      result.push(entries[index].value);
                  }
                  return result;
                }, has: function has(name) {
                  validateArgumentsLength(arguments.length, 1);
                  var entries = getInternalParamsState(this).entries;
                  var key = name + "";
                  var index = 0;
                  while (index < entries.length) {
                    if (entries[index++].key === key)
                      return true;
                  }
                  return false;
                }, set: function set(name, value) {
                  validateArgumentsLength(arguments.length, 1);
                  var state = getInternalParamsState(this);
                  var entries = state.entries;
                  var found = false;
                  var key = name + "";
                  var val = value + "";
                  var index = 0;
                  var entry;
                  for (; index < entries.length; index++) {
                    entry = entries[index];
                    if (entry.key === key) {
                      if (found)
                        entries.splice(index--, 1);
                      else {
                        found = true;
                        entry.value = val;
                      }
                    }
                  }
                  if (!found)
                    entries.push({ key, value: val });
                  state.updateURL();
                }, sort: function sort() {
                  var state = getInternalParamsState(this);
                  var entries = state.entries;
                  var slice = entries.slice();
                  var entry, entriesIndex, sliceIndex;
                  entries.length = 0;
                  for (sliceIndex = 0; sliceIndex < slice.length; sliceIndex++) {
                    entry = slice[sliceIndex];
                    for (entriesIndex = 0; entriesIndex < sliceIndex; entriesIndex++) {
                      if (entries[entriesIndex].key > entry.key) {
                        entries.splice(entriesIndex, 0, entry);
                        break;
                      }
                    }
                    if (entriesIndex === sliceIndex)
                      entries.push(entry);
                  }
                  state.updateURL();
                }, forEach: function forEach(callback) {
                  var entries = getInternalParamsState(this).entries;
                  var boundFunction = bind(callback, arguments.length > 1 ? arguments[1] : void 0, 3);
                  var index = 0;
                  var entry;
                  while (index < entries.length) {
                    entry = entries[index++];
                    boundFunction(entry.value, entry.key, this);
                  }
                }, keys: function keys() {
                  return new URLSearchParamsIterator(this, "keys");
                }, values: function values() {
                  return new URLSearchParamsIterator(this, "values");
                }, entries: function entries() {
                  return new URLSearchParamsIterator(this, "entries");
                } }, { enumerable: true });
                redefine(URLSearchParamsPrototype, ITERATOR, URLSearchParamsPrototype.entries);
                redefine(URLSearchParamsPrototype, "toString", function toString() {
                  var entries = getInternalParamsState(this).entries;
                  var result = [];
                  var index = 0;
                  var entry;
                  while (index < entries.length) {
                    entry = entries[index++];
                    result.push(serialize(entry.key) + "=" + serialize(entry.value));
                  }
                  return result.join("&");
                }, { enumerable: true });
                setToStringTag(URLSearchParamsConstructor, URL_SEARCH_PARAMS);
                $({ global: true, forced: !USE_NATIVE_URL }, { URLSearchParams: URLSearchParamsConstructor });
                if (!USE_NATIVE_URL && typeof $fetch == "function" && typeof Headers2 == "function") {
                  $({ global: true, enumerable: true, forced: true }, { fetch: function fetch2(input) {
                    var args = [input];
                    var init, body, headers;
                    if (arguments.length > 1) {
                      init = arguments[1];
                      if (isObject(init)) {
                        body = init.body;
                        if (classof(body) === URL_SEARCH_PARAMS) {
                          headers = init.headers ? new Headers2(init.headers) : new Headers2();
                          if (!headers.has("content-type")) {
                            headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
                          }
                          init = create(init, { body: createPropertyDescriptor(0, String(body)), headers: createPropertyDescriptor(0, headers) });
                        }
                      }
                      args.push(init);
                    }
                    return $fetch.apply(this, args);
                  } });
                }
                module2.exports = { URLSearchParams: URLSearchParamsConstructor, getState: getInternalParamsState };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var anObject = __w_pdfjs_require__2(23);
                var getIteratorMethod = __w_pdfjs_require__2(90);
                module2.exports = function(it) {
                  var iteratorMethod = getIteratorMethod(it);
                  if (typeof iteratorMethod != "function") {
                    throw TypeError(String(it) + " is not iterable");
                  }
                  return anObject(iteratorMethod.call(it));
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                var $ = __w_pdfjs_require__2(5);
                $({ target: "URL", proto: true, enumerable: true }, { toJSON: function toJSON() {
                  return URL.prototype.toString.call(this);
                } });
              }, function(module2, exports2, __w_pdfjs_require__2) {
                (function(global, factory) {
                  true ? factory(exports2) : 0;
                })(this, function(exports3) {
                  "use strict";
                  var SymbolPolyfill = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol : function(description) {
                    return "Symbol(" + description + ")";
                  };
                  function noop() {
                  }
                  var NumberIsNaN = Number.isNaN || function(x) {
                    return x !== x;
                  };
                  var rethrowAssertionErrorRejection = noop;
                  function typeIsObject(x) {
                    return typeof x === "object" && x !== null || typeof x === "function";
                  }
                  function createArrayFromList(elements) {
                    return elements.slice();
                  }
                  function ArrayBufferCopy(dest, destOffset, src, srcOffset, n) {
                    new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);
                  }
                  function IsFiniteNonNegativeNumber(v) {
                    if (IsNonNegativeNumber(v) === false) {
                      return false;
                    }
                    if (v === Infinity) {
                      return false;
                    }
                    return true;
                  }
                  function IsNonNegativeNumber(v) {
                    if (typeof v !== "number") {
                      return false;
                    }
                    if (NumberIsNaN(v)) {
                      return false;
                    }
                    if (v < 0) {
                      return false;
                    }
                    return true;
                  }
                  function Call(F, V, args) {
                    if (typeof F !== "function") {
                      throw new TypeError("Argument is not a function");
                    }
                    return Function.prototype.apply.call(F, V, args);
                  }
                  function CreateAlgorithmFromUnderlyingMethod(underlyingObject, methodName, algoArgCount, extraArgs) {
                    var method = underlyingObject[methodName];
                    if (method !== void 0) {
                      if (typeof method !== "function") {
                        throw new TypeError(method + " is not a method");
                      }
                      switch (algoArgCount) {
                        case 0: {
                          return function() {
                            return PromiseCall(method, underlyingObject, extraArgs);
                          };
                        }
                        case 1: {
                          return function(arg) {
                            var fullArgs = [arg].concat(extraArgs);
                            return PromiseCall(method, underlyingObject, fullArgs);
                          };
                        }
                      }
                    }
                    return function() {
                      return promiseResolvedWith(void 0);
                    };
                  }
                  function InvokeOrNoop(O, P, args) {
                    var method = O[P];
                    if (method === void 0) {
                      return void 0;
                    }
                    return Call(method, O, args);
                  }
                  function PromiseCall(F, V, args) {
                    try {
                      return promiseResolvedWith(Call(F, V, args));
                    } catch (value) {
                      return promiseRejectedWith(value);
                    }
                  }
                  function TransferArrayBuffer(O) {
                    return O;
                  }
                  function IsDetachedBuffer(O) {
                    return false;
                  }
                  function ValidateAndNormalizeHighWaterMark(highWaterMark) {
                    highWaterMark = Number(highWaterMark);
                    if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {
                      throw new RangeError("highWaterMark property of a queuing strategy must be non-negative and non-NaN");
                    }
                    return highWaterMark;
                  }
                  function MakeSizeAlgorithmFromSizeFunction(size) {
                    if (size === void 0) {
                      return function() {
                        return 1;
                      };
                    }
                    if (typeof size !== "function") {
                      throw new TypeError("size property of a queuing strategy must be a function");
                    }
                    return function(chunk) {
                      return size(chunk);
                    };
                  }
                  var originalPromise = Promise;
                  var originalPromiseThen = Promise.prototype.then;
                  var originalPromiseResolve = Promise.resolve.bind(originalPromise);
                  var originalPromiseReject = Promise.reject.bind(originalPromise);
                  function newPromise(executor) {
                    return new originalPromise(executor);
                  }
                  function promiseResolvedWith(value) {
                    return originalPromiseResolve(value);
                  }
                  function promiseRejectedWith(reason) {
                    return originalPromiseReject(reason);
                  }
                  function PerformPromiseThen(promise, onFulfilled, onRejected) {
                    return originalPromiseThen.call(promise, onFulfilled, onRejected);
                  }
                  function uponPromise(promise, onFulfilled, onRejected) {
                    PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), void 0, rethrowAssertionErrorRejection);
                  }
                  function uponFulfillment(promise, onFulfilled) {
                    uponPromise(promise, onFulfilled);
                  }
                  function uponRejection(promise, onRejected) {
                    uponPromise(promise, void 0, onRejected);
                  }
                  function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
                    return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
                  }
                  function setPromiseIsHandledToTrue(promise) {
                    PerformPromiseThen(promise, void 0, rethrowAssertionErrorRejection);
                  }
                  var QUEUE_MAX_ARRAY_SIZE = 16384;
                  var SimpleQueue = function() {
                    function SimpleQueue2() {
                      this._cursor = 0;
                      this._size = 0;
                      this._front = { _elements: [], _next: void 0 };
                      this._back = this._front;
                      this._cursor = 0;
                      this._size = 0;
                    }
                    Object.defineProperty(SimpleQueue2.prototype, "length", { get: function() {
                      return this._size;
                    }, enumerable: true, configurable: true });
                    SimpleQueue2.prototype.push = function(element) {
                      var oldBack = this._back;
                      var newBack = oldBack;
                      if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {
                        newBack = { _elements: [], _next: void 0 };
                      }
                      oldBack._elements.push(element);
                      if (newBack !== oldBack) {
                        this._back = newBack;
                        oldBack._next = newBack;
                      }
                      ++this._size;
                    };
                    SimpleQueue2.prototype.shift = function() {
                      var oldFront = this._front;
                      var newFront = oldFront;
                      var oldCursor = this._cursor;
                      var newCursor = oldCursor + 1;
                      var elements = oldFront._elements;
                      var element = elements[oldCursor];
                      if (newCursor === QUEUE_MAX_ARRAY_SIZE) {
                        newFront = oldFront._next;
                        newCursor = 0;
                      }
                      --this._size;
                      this._cursor = newCursor;
                      if (oldFront !== newFront) {
                        this._front = newFront;
                      }
                      elements[oldCursor] = void 0;
                      return element;
                    };
                    SimpleQueue2.prototype.forEach = function(callback) {
                      var i = this._cursor;
                      var node = this._front;
                      var elements = node._elements;
                      while (i !== elements.length || node._next !== void 0) {
                        if (i === elements.length) {
                          node = node._next;
                          elements = node._elements;
                          i = 0;
                          if (elements.length === 0) {
                            break;
                          }
                        }
                        callback(elements[i]);
                        ++i;
                      }
                    };
                    SimpleQueue2.prototype.peek = function() {
                      var front = this._front;
                      var cursor = this._cursor;
                      return front._elements[cursor];
                    };
                    return SimpleQueue2;
                  }();
                  function ReadableStreamCreateReadResult(value, done, forAuthorCode) {
                    var prototype = null;
                    if (forAuthorCode === true) {
                      prototype = Object.prototype;
                    }
                    var obj = Object.create(prototype);
                    obj.value = value;
                    obj.done = done;
                    return obj;
                  }
                  function ReadableStreamReaderGenericInitialize(reader, stream) {
                    reader._forAuthorCode = true;
                    reader._ownerReadableStream = stream;
                    stream._reader = reader;
                    if (stream._state === "readable") {
                      defaultReaderClosedPromiseInitialize(reader);
                    } else if (stream._state === "closed") {
                      defaultReaderClosedPromiseInitializeAsResolved(reader);
                    } else {
                      defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
                    }
                  }
                  function ReadableStreamReaderGenericCancel(reader, reason) {
                    var stream = reader._ownerReadableStream;
                    return ReadableStreamCancel(stream, reason);
                  }
                  function ReadableStreamReaderGenericRelease(reader) {
                    if (reader._ownerReadableStream._state === "readable") {
                      defaultReaderClosedPromiseReject(reader, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness"));
                    } else {
                      defaultReaderClosedPromiseResetToRejected(reader, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness"));
                    }
                    reader._ownerReadableStream._reader = void 0;
                    reader._ownerReadableStream = void 0;
                  }
                  function readerLockException(name) {
                    return new TypeError("Cannot " + name + " a stream using a released reader");
                  }
                  function defaultReaderClosedPromiseInitialize(reader) {
                    reader._closedPromise = newPromise(function(resolve, reject) {
                      reader._closedPromise_resolve = resolve;
                      reader._closedPromise_reject = reject;
                    });
                  }
                  function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
                    defaultReaderClosedPromiseInitialize(reader);
                    defaultReaderClosedPromiseReject(reader, reason);
                  }
                  function defaultReaderClosedPromiseInitializeAsResolved(reader) {
                    defaultReaderClosedPromiseInitialize(reader);
                    defaultReaderClosedPromiseResolve(reader);
                  }
                  function defaultReaderClosedPromiseReject(reader, reason) {
                    setPromiseIsHandledToTrue(reader._closedPromise);
                    reader._closedPromise_reject(reason);
                    reader._closedPromise_resolve = void 0;
                    reader._closedPromise_reject = void 0;
                  }
                  function defaultReaderClosedPromiseResetToRejected(reader, reason) {
                    defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
                  }
                  function defaultReaderClosedPromiseResolve(reader) {
                    reader._closedPromise_resolve(void 0);
                    reader._closedPromise_resolve = void 0;
                    reader._closedPromise_reject = void 0;
                  }
                  var CancelSteps = SymbolPolyfill("[[CancelSteps]]");
                  var PullSteps = SymbolPolyfill("[[PullSteps]]");
                  function AcquireReadableStreamDefaultReader(stream, forAuthorCode) {
                    if (forAuthorCode === void 0) {
                      forAuthorCode = false;
                    }
                    var reader = new ReadableStreamDefaultReader(stream);
                    reader._forAuthorCode = forAuthorCode;
                    return reader;
                  }
                  function ReadableStreamAddReadRequest(stream) {
                    var promise = newPromise(function(resolve, reject) {
                      var readRequest = { _resolve: resolve, _reject: reject };
                      stream._reader._readRequests.push(readRequest);
                    });
                    return promise;
                  }
                  function ReadableStreamFulfillReadRequest(stream, chunk, done) {
                    var reader = stream._reader;
                    var readRequest = reader._readRequests.shift();
                    readRequest._resolve(ReadableStreamCreateReadResult(chunk, done, reader._forAuthorCode));
                  }
                  function ReadableStreamGetNumReadRequests(stream) {
                    return stream._reader._readRequests.length;
                  }
                  function ReadableStreamHasDefaultReader(stream) {
                    var reader = stream._reader;
                    if (reader === void 0) {
                      return false;
                    }
                    if (!IsReadableStreamDefaultReader(reader)) {
                      return false;
                    }
                    return true;
                  }
                  var ReadableStreamDefaultReader = function() {
                    function ReadableStreamDefaultReader2(stream) {
                      if (IsReadableStream(stream) === false) {
                        throw new TypeError("ReadableStreamDefaultReader can only be constructed with a ReadableStream instance");
                      }
                      if (IsReadableStreamLocked(stream) === true) {
                        throw new TypeError("This stream has already been locked for exclusive reading by another reader");
                      }
                      ReadableStreamReaderGenericInitialize(this, stream);
                      this._readRequests = new SimpleQueue();
                    }
                    Object.defineProperty(ReadableStreamDefaultReader2.prototype, "closed", { get: function() {
                      if (!IsReadableStreamDefaultReader(this)) {
                        return promiseRejectedWith(defaultReaderBrandCheckException("closed"));
                      }
                      return this._closedPromise;
                    }, enumerable: true, configurable: true });
                    ReadableStreamDefaultReader2.prototype.cancel = function(reason) {
                      if (!IsReadableStreamDefaultReader(this)) {
                        return promiseRejectedWith(defaultReaderBrandCheckException("cancel"));
                      }
                      if (this._ownerReadableStream === void 0) {
                        return promiseRejectedWith(readerLockException("cancel"));
                      }
                      return ReadableStreamReaderGenericCancel(this, reason);
                    };
                    ReadableStreamDefaultReader2.prototype.read = function() {
                      if (!IsReadableStreamDefaultReader(this)) {
                        return promiseRejectedWith(defaultReaderBrandCheckException("read"));
                      }
                      if (this._ownerReadableStream === void 0) {
                        return promiseRejectedWith(readerLockException("read from"));
                      }
                      return ReadableStreamDefaultReaderRead(this);
                    };
                    ReadableStreamDefaultReader2.prototype.releaseLock = function() {
                      if (!IsReadableStreamDefaultReader(this)) {
                        throw defaultReaderBrandCheckException("releaseLock");
                      }
                      if (this._ownerReadableStream === void 0) {
                        return;
                      }
                      if (this._readRequests.length > 0) {
                        throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
                      }
                      ReadableStreamReaderGenericRelease(this);
                    };
                    return ReadableStreamDefaultReader2;
                  }();
                  function IsReadableStreamDefaultReader(x) {
                    if (!typeIsObject(x)) {
                      return false;
                    }
                    if (!Object.prototype.hasOwnProperty.call(x, "_readRequests")) {
                      return false;
                    }
                    return true;
                  }
                  function ReadableStreamDefaultReaderRead(reader) {
                    var stream = reader._ownerReadableStream;
                    stream._disturbed = true;
                    if (stream._state === "closed") {
                      return promiseResolvedWith(ReadableStreamCreateReadResult(void 0, true, reader._forAuthorCode));
                    }
                    if (stream._state === "errored") {
                      return promiseRejectedWith(stream._storedError);
                    }
                    return stream._readableStreamController[PullSteps]();
                  }
                  function defaultReaderBrandCheckException(name) {
                    return new TypeError("ReadableStreamDefaultReader.prototype." + name + " can only be used on a ReadableStreamDefaultReader");
                  }
                  var _a;
                  var AsyncIteratorPrototype;
                  if (typeof SymbolPolyfill.asyncIterator === "symbol") {
                    AsyncIteratorPrototype = (_a = {}, _a[SymbolPolyfill.asyncIterator] = function() {
                      return this;
                    }, _a);
                    Object.defineProperty(AsyncIteratorPrototype, SymbolPolyfill.asyncIterator, { enumerable: false });
                  }
                  var ReadableStreamAsyncIteratorPrototype = { next: function() {
                    if (IsReadableStreamAsyncIterator(this) === false) {
                      return promiseRejectedWith(streamAsyncIteratorBrandCheckException("next"));
                    }
                    var reader = this._asyncIteratorReader;
                    if (reader._ownerReadableStream === void 0) {
                      return promiseRejectedWith(readerLockException("iterate"));
                    }
                    return transformPromiseWith(ReadableStreamDefaultReaderRead(reader), function(result) {
                      var done = result.done;
                      if (done) {
                        ReadableStreamReaderGenericRelease(reader);
                      }
                      var value = result.value;
                      return ReadableStreamCreateReadResult(value, done, true);
                    });
                  }, return: function(value) {
                    if (IsReadableStreamAsyncIterator(this) === false) {
                      return promiseRejectedWith(streamAsyncIteratorBrandCheckException("next"));
                    }
                    var reader = this._asyncIteratorReader;
                    if (reader._ownerReadableStream === void 0) {
                      return promiseRejectedWith(readerLockException("finish iterating"));
                    }
                    if (reader._readRequests.length > 0) {
                      return promiseRejectedWith(new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled"));
                    }
                    if (this._preventCancel === false) {
                      var result = ReadableStreamReaderGenericCancel(reader, value);
                      ReadableStreamReaderGenericRelease(reader);
                      return transformPromiseWith(result, function() {
                        return ReadableStreamCreateReadResult(value, true, true);
                      });
                    }
                    ReadableStreamReaderGenericRelease(reader);
                    return promiseResolvedWith(ReadableStreamCreateReadResult(value, true, true));
                  } };
                  if (AsyncIteratorPrototype !== void 0) {
                    Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
                  }
                  Object.defineProperty(ReadableStreamAsyncIteratorPrototype, "next", { enumerable: false });
                  Object.defineProperty(ReadableStreamAsyncIteratorPrototype, "return", { enumerable: false });
                  function AcquireReadableStreamAsyncIterator(stream, preventCancel) {
                    if (preventCancel === void 0) {
                      preventCancel = false;
                    }
                    var reader = AcquireReadableStreamDefaultReader(stream);
                    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
                    iterator._asyncIteratorReader = reader;
                    iterator._preventCancel = Boolean(preventCancel);
                    return iterator;
                  }
                  function IsReadableStreamAsyncIterator(x) {
                    if (!typeIsObject(x)) {
                      return false;
                    }
                    if (!Object.prototype.hasOwnProperty.call(x, "_asyncIteratorReader")) {
                      return false;
                    }
                    return true;
                  }
                  function streamAsyncIteratorBrandCheckException(name) {
                    return new TypeError("ReadableStreamAsyncIterator." + name + " can only be used on a ReadableSteamAsyncIterator");
                  }
                  function DequeueValue(container) {
                    var pair = container._queue.shift();
                    container._queueTotalSize -= pair.size;
                    if (container._queueTotalSize < 0) {
                      container._queueTotalSize = 0;
                    }
                    return pair.value;
                  }
                  function EnqueueValueWithSize(container, value, size) {
                    size = Number(size);
                    if (!IsFiniteNonNegativeNumber(size)) {
                      throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
                    }
                    container._queue.push({ value, size });
                    container._queueTotalSize += size;
                  }
                  function PeekQueueValue(container) {
                    var pair = container._queue.peek();
                    return pair.value;
                  }
                  function ResetQueue(container) {
                    container._queue = new SimpleQueue();
                    container._queueTotalSize = 0;
                  }
                  var AbortSteps = SymbolPolyfill("[[AbortSteps]]");
                  var ErrorSteps = SymbolPolyfill("[[ErrorSteps]]");
                  var WritableStream = function() {
                    function WritableStream2(underlyingSink, strategy) {
                      if (underlyingSink === void 0) {
                        underlyingSink = {};
                      }
                      if (strategy === void 0) {
                        strategy = {};
                      }
                      InitializeWritableStream(this);
                      var size = strategy.size;
                      var highWaterMark = strategy.highWaterMark;
                      var type = underlyingSink.type;
                      if (type !== void 0) {
                        throw new RangeError("Invalid type is specified");
                      }
                      var sizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(size);
                      if (highWaterMark === void 0) {
                        highWaterMark = 1;
                      }
                      highWaterMark = ValidateAndNormalizeHighWaterMark(highWaterMark);
                      SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
                    }
                    Object.defineProperty(WritableStream2.prototype, "locked", { get: function() {
                      if (IsWritableStream(this) === false) {
                        throw streamBrandCheckException("locked");
                      }
                      return IsWritableStreamLocked(this);
                    }, enumerable: true, configurable: true });
                    WritableStream2.prototype.abort = function(reason) {
                      if (IsWritableStream(this) === false) {
                        return promiseRejectedWith(streamBrandCheckException("abort"));
                      }
                      if (IsWritableStreamLocked(this) === true) {
                        return promiseRejectedWith(new TypeError("Cannot abort a stream that already has a writer"));
                      }
                      return WritableStreamAbort(this, reason);
                    };
                    WritableStream2.prototype.close = function() {
                      if (IsWritableStream(this) === false) {
                        return promiseRejectedWith(streamBrandCheckException("close"));
                      }
                      if (IsWritableStreamLocked(this) === true) {
                        return promiseRejectedWith(new TypeError("Cannot close a stream that already has a writer"));
                      }
                      if (WritableStreamCloseQueuedOrInFlight(this) === true) {
                        return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
                      }
                      return WritableStreamClose(this);
                    };
                    WritableStream2.prototype.getWriter = function() {
                      if (IsWritableStream(this) === false) {
                        throw streamBrandCheckException("getWriter");
                      }
                      return AcquireWritableStreamDefaultWriter(this);
                    };
                    return WritableStream2;
                  }();
                  function AcquireWritableStreamDefaultWriter(stream) {
                    return new WritableStreamDefaultWriter(stream);
                  }
                  function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
                    if (highWaterMark === void 0) {
                      highWaterMark = 1;
                    }
                    if (sizeAlgorithm === void 0) {
                      sizeAlgorithm = function() {
                        return 1;
                      };
                    }
                    var stream = Object.create(WritableStream.prototype);
                    InitializeWritableStream(stream);
                    var controller = Object.create(WritableStreamDefaultController.prototype);
                    SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
                    return stream;
                  }
                  function InitializeWritableStream(stream) {
                    stream._state = "writable";
                    stream._storedError = void 0;
                    stream._writer = void 0;
                    stream._writableStreamController = void 0;
                    stream._writeRequests = new SimpleQueue();
                    stream._inFlightWriteRequest = void 0;
                    stream._closeRequest = void 0;
                    stream._inFlightCloseRequest = void 0;
                    stream._pendingAbortRequest = void 0;
                    stream._backpressure = false;
                  }
                  function IsWritableStream(x) {
                    if (!typeIsObject(x)) {
                      return false;
                    }
                    if (!Object.prototype.hasOwnProperty.call(x, "_writableStreamController")) {
                      return false;
                    }
                    return true;
                  }
                  function IsWritableStreamLocked(stream) {
                    if (stream._writer === void 0) {
                      return false;
                    }
                    return true;
                  }
                  function WritableStreamAbort(stream, reason) {
                    var state = stream._state;
                    if (state === "closed" || state === "errored") {
                      return promiseResolvedWith(void 0);
                    }
                    if (stream._pendingAbortRequest !== void 0) {
                      return stream._pendingAbortRequest._promise;
                    }
                    var wasAlreadyErroring = false;
                    if (state === "erroring") {
                      wasAlreadyErroring = true;
                      reason = void 0;
                    }
                    var promise = newPromise(function(resolve, reject) {
                      stream._pendingAbortRequest = { _promise: void 0, _resolve: resolve, _reject: reject, _reason: reason, _wasAlreadyErroring: wasAlreadyErroring };
                    });
                    stream._pendingAbortRequest._promise = promise;
                    if (wasAlreadyErroring === false) {
                      WritableStreamStartErroring(stream, reason);
                    }
                    return promise;
                  }
                  function WritableStreamClose(stream) {
                    var state = stream._state;
                    if (state === "closed" || state === "errored") {
                      return promiseRejectedWith(new TypeError("The stream (in " + state + " state) is not in the writable state and cannot be closed"));
                    }
                    var promise = newPromise(function(resolve, reject) {
                      var closeRequest = { _resolve: resolve, _reject: reject };
                      stream._closeRequest = closeRequest;
                    });
                    var writer = stream._writer;
                    if (writer !== void 0 && stream._backpressure === true && state === "writable") {
                      defaultWriterReadyPromiseResolve(writer);
                    }
                    WritableStreamDefaultControllerClose(stream._writableStreamController);
                    return promise;
                  }
                  function WritableStreamAddWriteRequest(stream) {
                    var promise = newPromise(function(resolve, reject) {
                      var writeRequest = { _resolve: resolve, _reject: reject };
                      stream._writeRequests.push(writeRequest);
                    });
                    return promise;
                  }
                  function WritableStreamDealWithRejection(stream, error) {
                    var state = stream._state;
                    if (state === "writable") {
                      WritableStreamStartErroring(stream, error);
                      return;
                    }
                    WritableStreamFinishErroring(stream);
                  }
                  function WritableStreamStartErroring(stream, reason) {
                    var controller = stream._writableStreamController;
                    stream._state = "erroring";
                    stream._storedError = reason;
                    var writer = stream._writer;
                    if (writer !== void 0) {
                      WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
                    }
                    if (WritableStreamHasOperationMarkedInFlight(stream) === false && controller._started === true) {
                      WritableStreamFinishErroring(stream);
                    }
                  }
                  function WritableStreamFinishErroring(stream) {
                    stream._state = "errored";
                    stream._writableStreamController[ErrorSteps]();
                    var storedError = stream._storedError;
                    stream._writeRequests.forEach(function(writeRequest) {
                      writeRequest._reject(storedError);
                    });
                    stream._writeRequests = new SimpleQueue();
                    if (stream._pendingAbortRequest === void 0) {
                      WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
                      return;
                    }
                    var abortRequest = stream._pendingAbortRequest;
                    stream._pendingAbortRequest = void 0;
                    if (abortRequest._wasAlreadyErroring === true) {
                      abortRequest._reject(storedError);
                      WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
                      return;
                    }
                    var promise = stream._writableStreamController[AbortSteps](abortRequest._reason);
                    uponPromise(promise, function() {
                      abortRequest._resolve();
                      WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
                    }, function(reason) {
                      abortRequest._reject(reason);
                      WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
                    });
                  }
                  function WritableStreamFinishInFlightWrite(stream) {
                    stream._inFlightWriteRequest._resolve(void 0);
                    stream._inFlightWriteRequest = void 0;
                  }
                  function WritableStreamFinishInFlightWriteWithError(stream, error) {
                    stream._inFlightWriteRequest._reject(error);
                    stream._inFlightWriteRequest = void 0;
                    WritableStreamDealWithRejection(stream, error);
                  }
                  function WritableStreamFinishInFlightClose(stream) {
                    stream._inFlightCloseRequest._resolve(void 0);
                    stream._inFlightCloseRequest = void 0;
                    var state = stream._state;
                    if (state === "erroring") {
                      stream._storedError = void 0;
                      if (stream._pendingAbortRequest !== void 0) {
                        stream._pendingAbortRequest._resolve();
                        stream._pendingAbortRequest = void 0;
                      }
                    }
                    stream._state = "closed";
                    var writer = stream._writer;
                    if (writer !== void 0) {
                      defaultWriterClosedPromiseResolve(writer);
                    }
                  }
                  function WritableStreamFinishInFlightCloseWithError(stream, error) {
                    stream._inFlightCloseRequest._reject(error);
                    stream._inFlightCloseRequest = void 0;
                    if (stream._pendingAbortRequest !== void 0) {
                      stream._pendingAbortRequest._reject(error);
                      stream._pendingAbortRequest = void 0;
                    }
                    WritableStreamDealWithRejection(stream, error);
                  }
                  function WritableStreamCloseQueuedOrInFlight(stream) {
                    if (stream._closeRequest === void 0 && stream._inFlightCloseRequest === void 0) {
                      return false;
                    }
                    return true;
                  }
                  function WritableStreamHasOperationMarkedInFlight(stream) {
                    if (stream._inFlightWriteRequest === void 0 && stream._inFlightCloseRequest === void 0) {
                      return false;
                    }
                    return true;
                  }
                  function WritableStreamMarkCloseRequestInFlight(stream) {
                    stream._inFlightCloseRequest = stream._closeRequest;
                    stream._closeRequest = void 0;
                  }
                  function WritableStreamMarkFirstWriteRequestInFlight(stream) {
                    stream._inFlightWriteRequest = stream._writeRequests.shift();
                  }
                  function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
                    if (stream._closeRequest !== void 0) {
                      stream._closeRequest._reject(stream._storedError);
                      stream._closeRequest = void 0;
                    }
                    var writer = stream._writer;
                    if (writer !== void 0) {
                      defaultWriterClosedPromiseReject(writer, stream._storedError);
                    }
                  }
                  function WritableStreamUpdateBackpressure(stream, backpressure) {
                    var writer = stream._writer;
                    if (writer !== void 0 && backpressure !== stream._backpressure) {
                      if (backpressure === true) {
                        defaultWriterReadyPromiseReset(writer);
                      } else {
                        defaultWriterReadyPromiseResolve(writer);
                      }
                    }
                    stream._backpressure = backpressure;
                  }
                  var WritableStreamDefaultWriter = function() {
                    function WritableStreamDefaultWriter2(stream) {
                      if (IsWritableStream(stream) === false) {
                        throw new TypeError("WritableStreamDefaultWriter can only be constructed with a WritableStream instance");
                      }
                      if (IsWritableStreamLocked(stream) === true) {
                        throw new TypeError("This stream has already been locked for exclusive writing by another writer");
                      }
                      this._ownerWritableStream = stream;
                      stream._writer = this;
                      var state = stream._state;
                      if (state === "writable") {
                        if (WritableStreamCloseQueuedOrInFlight(stream) === false && stream._backpressure === true) {
                          defaultWriterReadyPromiseInitialize(this);
                        } else {
                          defaultWriterReadyPromiseInitializeAsResolved(this);
                        }
                        defaultWriterClosedPromiseInitialize(this);
                      } else if (state === "erroring") {
                        defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);
                        defaultWriterClosedPromiseInitialize(this);
                      } else if (state === "closed") {
                        defaultWriterReadyPromiseInitializeAsResolved(this);
                        defaultWriterClosedPromiseInitializeAsResolved(this);
                      } else {
                        var storedError = stream._storedError;
                        defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
                        defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
                      }
                    }
                    Object.defineProperty(WritableStreamDefaultWriter2.prototype, "closed", { get: function() {
                      if (IsWritableStreamDefaultWriter(this) === false) {
                        return promiseRejectedWith(defaultWriterBrandCheckException("closed"));
                      }
                      return this._closedPromise;
                    }, enumerable: true, configurable: true });
                    Object.defineProperty(WritableStreamDefaultWriter2.prototype, "desiredSize", { get: function() {
                      if (IsWritableStreamDefaultWriter(this) === false) {
                        throw defaultWriterBrandCheckException("desiredSize");
                      }
                      if (this._ownerWritableStream === void 0) {
                        throw defaultWriterLockException("desiredSize");
                      }
                      return WritableStreamDefaultWriterGetDesiredSize(this);
                    }, enumerable: true, configurable: true });
                    Object.defineProperty(WritableStreamDefaultWriter2.prototype, "ready", { get: function() {
                      if (IsWritableStreamDefaultWriter(this) === false) {
                        return promiseRejectedWith(defaultWriterBrandCheckException("ready"));
                      }
                      return this._readyPromise;
                    }, enumerable: true, configurable: true });
                    WritableStreamDefaultWriter2.prototype.abort = function(reason) {
                      if (IsWritableStreamDefaultWriter(this) === false) {
                        return promiseRejectedWith(defaultWriterBrandCheckException("abort"));
                      }
                      if (this._ownerWritableStream === void 0) {
                        return promiseRejectedWith(defaultWriterLockException("abort"));
                      }
                      return WritableStreamDefaultWriterAbort(this, reason);
                    };
                    WritableStreamDefaultWriter2.prototype.close = function() {
                      if (IsWritableStreamDefaultWriter(this) === false) {
                        return promiseRejectedWith(defaultWriterBrandCheckException("close"));
                      }
                      var stream = this._ownerWritableStream;
                      if (stream === void 0) {
                        return promiseRejectedWith(defaultWriterLockException("close"));
                      }
                      if (WritableStreamCloseQueuedOrInFlight(stream) === true) {
                        return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
                      }
                      return WritableStreamDefaultWriterClose(this);
                    };
                    WritableStreamDefaultWriter2.prototype.releaseLock = function() {
                      if (IsWritableStreamDefaultWriter(this) === false) {
                        throw defaultWriterBrandCheckException("releaseLock");
                      }
                      var stream = this._ownerWritableStream;
                      if (stream === void 0) {
                        return;
                      }
                      WritableStreamDefaultWriterRelease(this);
                    };
                    WritableStreamDefaultWriter2.prototype.write = function(chunk) {
                      if (IsWritableStreamDefaultWriter(this) === false) {
                        return promiseRejectedWith(defaultWriterBrandCheckException("write"));
                      }
                      if (this._ownerWritableStream === void 0) {
                        return promiseRejectedWith(defaultWriterLockException("write to"));
                      }
                      return WritableStreamDefaultWriterWrite(this, chunk);
                    };
                    return WritableStreamDefaultWriter2;
                  }();
                  function IsWritableStreamDefaultWriter(x) {
                    if (!typeIsObject(x)) {
                      return false;
                    }
                    if (!Object.prototype.hasOwnProperty.call(x, "_ownerWritableStream")) {
                      return false;
                    }
                    return true;
                  }
                  function WritableStreamDefaultWriterAbort(writer, reason) {
                    var stream = writer._ownerWritableStream;
                    return WritableStreamAbort(stream, reason);
                  }
                  function WritableStreamDefaultWriterClose(writer) {
                    var stream = writer._ownerWritableStream;
                    return WritableStreamClose(stream);
                  }
                  function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
                    var stream = writer._ownerWritableStream;
                    var state = stream._state;
                    if (WritableStreamCloseQueuedOrInFlight(stream) === true || state === "closed") {
                      return promiseResolvedWith(void 0);
                    }
                    if (state === "errored") {
                      return promiseRejectedWith(stream._storedError);
                    }
                    return WritableStreamDefaultWriterClose(writer);
                  }
                  function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {
                    if (writer._closedPromiseState === "pending") {
                      defaultWriterClosedPromiseReject(writer, error);
                    } else {
                      defaultWriterClosedPromiseResetToRejected(writer, error);
                    }
                  }
                  function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {
                    if (writer._readyPromiseState === "pending") {
                      defaultWriterReadyPromiseReject(writer, error);
                    } else {
                      defaultWriterReadyPromiseResetToRejected(writer, error);
                    }
                  }
                  function WritableStreamDefaultWriterGetDesiredSize(writer) {
                    var stream = writer._ownerWritableStream;
                    var state = stream._state;
                    if (state === "errored" || state === "erroring") {
                      return null;
                    }
                    if (state === "closed") {
                      return 0;
                    }
                    return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
                  }
                  function WritableStreamDefaultWriterRelease(writer) {
                    var stream = writer._ownerWritableStream;
                    var releasedError = new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");
                    WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
                    WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
                    stream._writer = void 0;
                    writer._ownerWritableStream = void 0;
                  }
                  function WritableStreamDefaultWriterWrite(writer, chunk) {
                    var stream = writer._ownerWritableStream;
                    var controller = stream._writableStreamController;
                    var chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
                    if (stream !== writer._ownerWritableStream) {
                      return promiseRejectedWith(defaultWriterLockException("write to"));
                    }
                    var state = stream._state;
                    if (state === "errored") {
                      return promiseRejectedWith(stream._storedError);
                    }
                    if (WritableStreamCloseQueuedOrInFlight(stream) === true || state === "closed") {
                      return promiseRejectedWith(new TypeError("The stream is closing or closed and cannot be written to"));
                    }
                    if (state === "erroring") {
                      return promiseRejectedWith(stream._storedError);
                    }
                    var promise = WritableStreamAddWriteRequest(stream);
                    WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
                    return promise;
                  }
                  var WritableStreamDefaultController = function() {
                    function WritableStreamDefaultController2() {
                      throw new TypeError("WritableStreamDefaultController cannot be constructed explicitly");
                    }
                    WritableStreamDefaultController2.prototype.error = function(e) {
                      if (IsWritableStreamDefaultController(this) === false) {
                        throw new TypeError("WritableStreamDefaultController.prototype.error can only be used on a WritableStreamDefaultController");
                      }
                      var state = this._controlledWritableStream._state;
                      if (state !== "writable") {
                        return;
                      }
                      WritableStreamDefaultControllerError(this, e);
                    };
                    WritableStreamDefaultController2.prototype[AbortSteps] = function(reason) {
                      var result = this._abortAlgorithm(reason);
                      WritableStreamDefaultControllerClearAlgorithms(this);
                      return result;
                    };
                    WritableStreamDefaultController2.prototype[ErrorSteps] = function() {
                      ResetQueue(this);
                    };
                    return WritableStreamDefaultController2;
                  }();
                  function IsWritableStreamDefaultController(x) {
                    if (!typeIsObject(x)) {
                      return false;
                    }
                    if (!Object.prototype.hasOwnProperty.call(x, "_controlledWritableStream")) {
                      return false;
                    }
                    return true;
                  }
                  function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
                    controller._controlledWritableStream = stream;
                    stream._writableStreamController = controller;
                    controller._queue = void 0;
                    controller._queueTotalSize = void 0;
                    ResetQueue(controller);
                    controller._started = false;
                    controller._strategySizeAlgorithm = sizeAlgorithm;
                    controller._strategyHWM = highWaterMark;
                    controller._writeAlgorithm = writeAlgorithm;
                    controller._closeAlgorithm = closeAlgorithm;
                    controller._abortAlgorithm = abortAlgorithm;
                    var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
                    WritableStreamUpdateBackpressure(stream, backpressure);
                    var startResult = startAlgorithm();
                    var startPromise = promiseResolvedWith(startResult);
                    uponPromise(startPromise, function() {
                      controller._started = true;
                      WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
                    }, function(r) {
                      controller._started = true;
                      WritableStreamDealWithRejection(stream, r);
                    });
                  }
                  function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
                    var controller = Object.create(WritableStreamDefaultController.prototype);
                    function startAlgorithm() {
                      return InvokeOrNoop(underlyingSink, "start", [controller]);
                    }
                    var writeAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, "write", 1, [controller]);
                    var closeAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, "close", 0, []);
                    var abortAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, "abort", 1, []);
                    SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
                  }
                  function WritableStreamDefaultControllerClearAlgorithms(controller) {
                    controller._writeAlgorithm = void 0;
                    controller._closeAlgorithm = void 0;
                    controller._abortAlgorithm = void 0;
                    controller._strategySizeAlgorithm = void 0;
                  }
                  function WritableStreamDefaultControllerClose(controller) {
                    EnqueueValueWithSize(controller, "close", 0);
                    WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
                  }
                  function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
                    try {
                      return controller._strategySizeAlgorithm(chunk);
                    } catch (chunkSizeE) {
                      WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
                      return 1;
                    }
                  }
                  function WritableStreamDefaultControllerGetDesiredSize(controller) {
                    return controller._strategyHWM - controller._queueTotalSize;
                  }
                  function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
                    var writeRecord = { chunk };
                    try {
                      EnqueueValueWithSize(controller, writeRecord, chunkSize);
                    } catch (enqueueE) {
                      WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
                      return;
                    }
                    var stream = controller._controlledWritableStream;
                    if (WritableStreamCloseQueuedOrInFlight(stream) === false && stream._state === "writable") {
                      var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
                      WritableStreamUpdateBackpressure(stream, backpressure);
                    }
                    WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
                  }
                  function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
                    var stream = controller._controlledWritableStream;
                    if (controller._started === false) {
                      return;
                    }
                    if (stream._inFlightWriteRequest !== void 0) {
                      return;
                    }
                    var state = stream._state;
                    if (state === "erroring") {
                      WritableStreamFinishErroring(stream);
                      return;
                    }
                    if (controller._queue.length === 0) {
                      return;
                    }
                    var writeRecord = PeekQueueValue(controller);
                    if (writeRecord === "close") {
                      WritableStreamDefaultControllerProcessClose(controller);
                    } else {
                      WritableStreamDefaultControllerProcessWrite(controller, writeRecord.chunk);
                    }
                  }
                  function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {
                    if (controller._controlledWritableStream._state === "writable") {
                      WritableStreamDefaultControllerError(controller, error);
                    }
                  }
                  function WritableStreamDefaultControllerProcessClose(controller) {
                    var stream = controller._controlledWritableStream;
                    WritableStreamMarkCloseRequestInFlight(stream);
                    DequeueValue(controller);
                    var sinkClosePromise = controller._closeAlgorithm();
                    WritableStreamDefaultControllerClearAlgorithms(controller);
                    uponPromise(sinkClosePromise, function() {
                      WritableStreamFinishInFlightClose(stream);
                    }, function(reason) {
                      WritableStreamFinishInFlightCloseWithError(stream, reason);
                    });
                  }
                  function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
                    var stream = controller._controlledWritableStream;
                    WritableStreamMarkFirstWriteRequestInFlight(stream);
                    var sinkWritePromise = controller._writeAlgorithm(chunk);
                    uponPromise(sinkWritePromise, function() {
                      WritableStreamFinishInFlightWrite(stream);
                      var state = stream._state;
                      DequeueValue(controller);
                      if (WritableStreamCloseQueuedOrInFlight(stream) === false && state === "writable") {
                        var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
                        WritableStreamUpdateBackpressure(stream, backpressure);
                      }
                      WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
                    }, function(reason) {
                      if (stream._state === "writable") {
                        WritableStreamDefaultControllerClearAlgorithms(controller);
                      }
                      WritableStreamFinishInFlightWriteWithError(stream, reason);
                    });
                  }
                  function WritableStreamDefaultControllerGetBackpressure(controller) {
                    var desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
                    return desiredSize <= 0;
                  }
                  function WritableStreamDefaultControllerError(controller, error) {
                    var stream = controller._controlledWritableStream;
                    WritableStreamDefaultControllerClearAlgorithms(controller);
                    WritableStreamStartErroring(stream, error);
                  }
                  function streamBrandCheckException(name) {
                    return new TypeError("WritableStream.prototype." + name + " can only be used on a WritableStream");
                  }
                  function defaultWriterBrandCheckException(name) {
                    return new TypeError("WritableStreamDefaultWriter.prototype." + name + " can only be used on a WritableStreamDefaultWriter");
                  }
                  function defaultWriterLockException(name) {
                    return new TypeError("Cannot " + name + " a stream using a released writer");
                  }
                  function defaultWriterClosedPromiseInitialize(writer) {
                    writer._closedPromise = newPromise(function(resolve, reject) {
                      writer._closedPromise_resolve = resolve;
                      writer._closedPromise_reject = reject;
                      writer._closedPromiseState = "pending";
                    });
                  }
                  function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
                    defaultWriterClosedPromiseInitialize(writer);
                    defaultWriterClosedPromiseReject(writer, reason);
                  }
                  function defaultWriterClosedPromiseInitializeAsResolved(writer) {
                    defaultWriterClosedPromiseInitialize(writer);
                    defaultWriterClosedPromiseResolve(writer);
                  }
                  function defaultWriterClosedPromiseReject(writer, reason) {
                    setPromiseIsHandledToTrue(writer._closedPromise);
                    writer._closedPromise_reject(reason);
                    writer._closedPromise_resolve = void 0;
                    writer._closedPromise_reject = void 0;
                    writer._closedPromiseState = "rejected";
                  }
                  function defaultWriterClosedPromiseResetToRejected(writer, reason) {
                    defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
                  }
                  function defaultWriterClosedPromiseResolve(writer) {
                    writer._closedPromise_resolve(void 0);
                    writer._closedPromise_resolve = void 0;
                    writer._closedPromise_reject = void 0;
                    writer._closedPromiseState = "resolved";
                  }
                  function defaultWriterReadyPromiseInitialize(writer) {
                    writer._readyPromise = newPromise(function(resolve, reject) {
                      writer._readyPromise_resolve = resolve;
                      writer._readyPromise_reject = reject;
                    });
                    writer._readyPromiseState = "pending";
                  }
                  function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
                    defaultWriterReadyPromiseInitialize(writer);
                    defaultWriterReadyPromiseReject(writer, reason);
                  }
                  function defaultWriterReadyPromiseInitializeAsResolved(writer) {
                    defaultWriterReadyPromiseInitialize(writer);
                    defaultWriterReadyPromiseResolve(writer);
                  }
                  function defaultWriterReadyPromiseReject(writer, reason) {
                    setPromiseIsHandledToTrue(writer._readyPromise);
                    writer._readyPromise_reject(reason);
                    writer._readyPromise_resolve = void 0;
                    writer._readyPromise_reject = void 0;
                    writer._readyPromiseState = "rejected";
                  }
                  function defaultWriterReadyPromiseReset(writer) {
                    defaultWriterReadyPromiseInitialize(writer);
                  }
                  function defaultWriterReadyPromiseResetToRejected(writer, reason) {
                    defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
                  }
                  function defaultWriterReadyPromiseResolve(writer) {
                    writer._readyPromise_resolve(void 0);
                    writer._readyPromise_resolve = void 0;
                    writer._readyPromise_reject = void 0;
                    writer._readyPromiseState = "fulfilled";
                  }
                  function isAbortSignal(value) {
                    if (typeof value !== "object" || value === null) {
                      return false;
                    }
                    try {
                      return typeof value.aborted === "boolean";
                    } catch (_a2) {
                      return false;
                    }
                  }
                  var NativeDOMException = typeof DOMException !== "undefined" ? DOMException : void 0;
                  function isDOMExceptionConstructor(ctor) {
                    if (!(typeof ctor === "function" || typeof ctor === "object")) {
                      return false;
                    }
                    try {
                      new ctor();
                      return true;
                    } catch (_a2) {
                      return false;
                    }
                  }
                  function createDOMExceptionPolyfill() {
                    var ctor = function DOMException2(message, name) {
                      this.message = message || "";
                      this.name = name || "Error";
                      if (Error.captureStackTrace) {
                        Error.captureStackTrace(this, this.constructor);
                      }
                    };
                    ctor.prototype = Object.create(Error.prototype);
                    Object.defineProperty(ctor.prototype, "constructor", { value: ctor, writable: true, configurable: true });
                    return ctor;
                  }
                  var DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();
                  function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
                    var reader = AcquireReadableStreamDefaultReader(source);
                    var writer = AcquireWritableStreamDefaultWriter(dest);
                    source._disturbed = true;
                    var shuttingDown = false;
                    var currentWrite = promiseResolvedWith(void 0);
                    return newPromise(function(resolve, reject) {
                      var abortAlgorithm;
                      if (signal !== void 0) {
                        abortAlgorithm = function() {
                          var error = new DOMException$1("Aborted", "AbortError");
                          var actions = [];
                          if (preventAbort === false) {
                            actions.push(function() {
                              if (dest._state === "writable") {
                                return WritableStreamAbort(dest, error);
                              }
                              return promiseResolvedWith(void 0);
                            });
                          }
                          if (preventCancel === false) {
                            actions.push(function() {
                              if (source._state === "readable") {
                                return ReadableStreamCancel(source, error);
                              }
                              return promiseResolvedWith(void 0);
                            });
                          }
                          shutdownWithAction(function() {
                            return Promise.all(actions.map(function(action) {
                              return action();
                            }));
                          }, true, error);
                        };
                        if (signal.aborted === true) {
                          abortAlgorithm();
                          return;
                        }
                        signal.addEventListener("abort", abortAlgorithm);
                      }
                      function pipeLoop() {
                        return newPromise(function(resolveLoop, rejectLoop) {
                          function next(done) {
                            if (done) {
                              resolveLoop();
                            } else {
                              PerformPromiseThen(pipeStep(), next, rejectLoop);
                            }
                          }
                          next(false);
                        });
                      }
                      function pipeStep() {
                        if (shuttingDown === true) {
                          return promiseResolvedWith(true);
                        }
                        return PerformPromiseThen(writer._readyPromise, function() {
                          return PerformPromiseThen(ReadableStreamDefaultReaderRead(reader), function(_a2) {
                            var value = _a2.value, done = _a2.done;
                            if (done === true) {
                              return true;
                            }
                            currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, value), void 0, noop);
                            return false;
                          });
                        });
                      }
                      isOrBecomesErrored(source, reader._closedPromise, function(storedError) {
                        if (preventAbort === false) {
                          shutdownWithAction(function() {
                            return WritableStreamAbort(dest, storedError);
                          }, true, storedError);
                        } else {
                          shutdown(true, storedError);
                        }
                      });
                      isOrBecomesErrored(dest, writer._closedPromise, function(storedError) {
                        if (preventCancel === false) {
                          shutdownWithAction(function() {
                            return ReadableStreamCancel(source, storedError);
                          }, true, storedError);
                        } else {
                          shutdown(true, storedError);
                        }
                      });
                      isOrBecomesClosed(source, reader._closedPromise, function() {
                        if (preventClose === false) {
                          shutdownWithAction(function() {
                            return WritableStreamDefaultWriterCloseWithErrorPropagation(writer);
                          });
                        } else {
                          shutdown();
                        }
                      });
                      if (WritableStreamCloseQueuedOrInFlight(dest) === true || dest._state === "closed") {
                        var destClosed_1 = new TypeError("the destination writable stream closed before all data could be piped to it");
                        if (preventCancel === false) {
                          shutdownWithAction(function() {
                            return ReadableStreamCancel(source, destClosed_1);
                          }, true, destClosed_1);
                        } else {
                          shutdown(true, destClosed_1);
                        }
                      }
                      setPromiseIsHandledToTrue(pipeLoop());
                      function waitForWritesToFinish() {
                        var oldCurrentWrite = currentWrite;
                        return PerformPromiseThen(currentWrite, function() {
                          return oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : void 0;
                        });
                      }
                      function isOrBecomesErrored(stream, promise, action) {
                        if (stream._state === "errored") {
                          action(stream._storedError);
                        } else {
                          uponRejection(promise, action);
                        }
                      }
                      function isOrBecomesClosed(stream, promise, action) {
                        if (stream._state === "closed") {
                          action();
                        } else {
                          uponFulfillment(promise, action);
                        }
                      }
                      function shutdownWithAction(action, originalIsError, originalError) {
                        if (shuttingDown === true) {
                          return;
                        }
                        shuttingDown = true;
                        if (dest._state === "writable" && WritableStreamCloseQueuedOrInFlight(dest) === false) {
                          uponFulfillment(waitForWritesToFinish(), doTheRest);
                        } else {
                          doTheRest();
                        }
                        function doTheRest() {
                          uponPromise(action(), function() {
                            return finalize(originalIsError, originalError);
                          }, function(newError) {
                            return finalize(true, newError);
                          });
                        }
                      }
                      function shutdown(isError, error) {
                        if (shuttingDown === true) {
                          return;
                        }
                        shuttingDown = true;
                        if (dest._state === "writable" && WritableStreamCloseQueuedOrInFlight(dest) === false) {
                          uponFulfillment(waitForWritesToFinish(), function() {
                            return finalize(isError, error);
                          });
                        } else {
                          finalize(isError, error);
                        }
                      }
                      function finalize(isError, error) {
                        WritableStreamDefaultWriterRelease(writer);
                        ReadableStreamReaderGenericRelease(reader);
                        if (signal !== void 0) {
                          signal.removeEventListener("abort", abortAlgorithm);
                        }
                        if (isError) {
                          reject(error);
                        } else {
                          resolve(void 0);
                        }
                      }
                    });
                  }
                  var ReadableStreamDefaultController = function() {
                    function ReadableStreamDefaultController2() {
                      throw new TypeError();
                    }
                    Object.defineProperty(ReadableStreamDefaultController2.prototype, "desiredSize", { get: function() {
                      if (IsReadableStreamDefaultController(this) === false) {
                        throw defaultControllerBrandCheckException("desiredSize");
                      }
                      return ReadableStreamDefaultControllerGetDesiredSize(this);
                    }, enumerable: true, configurable: true });
                    ReadableStreamDefaultController2.prototype.close = function() {
                      if (IsReadableStreamDefaultController(this) === false) {
                        throw defaultControllerBrandCheckException("close");
                      }
                      if (ReadableStreamDefaultControllerCanCloseOrEnqueue(this) === false) {
                        throw new TypeError("The stream is not in a state that permits close");
                      }
                      ReadableStreamDefaultControllerClose(this);
                    };
                    ReadableStreamDefaultController2.prototype.enqueue = function(chunk) {
                      if (IsReadableStreamDefaultController(this) === false) {
                        throw defaultControllerBrandCheckException("enqueue");
                      }
                      if (ReadableStreamDefaultControllerCanCloseOrEnqueue(this) === false) {
                        throw new TypeError("The stream is not in a state that permits enqueue");
                      }
                      return ReadableStreamDefaultControllerEnqueue(this, chunk);
                    };
                    ReadableStreamDefaultController2.prototype.error = function(e) {
                      if (IsReadableStreamDefaultController(this) === false) {
                        throw defaultControllerBrandCheckException("error");
                      }
                      ReadableStreamDefaultControllerError(this, e);
                    };
                    ReadableStreamDefaultController2.prototype[CancelSteps] = function(reason) {
                      ResetQueue(this);
                      var result = this._cancelAlgorithm(reason);
                      ReadableStreamDefaultControllerClearAlgorithms(this);
                      return result;
                    };
                    ReadableStreamDefaultController2.prototype[PullSteps] = function() {
                      var stream = this._controlledReadableStream;
                      if (this._queue.length > 0) {
                        var chunk = DequeueValue(this);
                        if (this._closeRequested === true && this._queue.length === 0) {
                          ReadableStreamDefaultControllerClearAlgorithms(this);
                          ReadableStreamClose(stream);
                        } else {
                          ReadableStreamDefaultControllerCallPullIfNeeded(this);
                        }
                        return promiseResolvedWith(ReadableStreamCreateReadResult(chunk, false, stream._reader._forAuthorCode));
                      }
                      var pendingPromise = ReadableStreamAddReadRequest(stream);
                      ReadableStreamDefaultControllerCallPullIfNeeded(this);
                      return pendingPromise;
                    };
                    return ReadableStreamDefaultController2;
                  }();
                  function IsReadableStreamDefaultController(x) {
                    if (!typeIsObject(x)) {
                      return false;
                    }
                    if (!Object.prototype.hasOwnProperty.call(x, "_controlledReadableStream")) {
                      return false;
                    }
                    return true;
                  }
                  function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
                    var shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
                    if (shouldPull === false) {
                      return;
                    }
                    if (controller._pulling === true) {
                      controller._pullAgain = true;
                      return;
                    }
                    controller._pulling = true;
                    var pullPromise = controller._pullAlgorithm();
                    uponPromise(pullPromise, function() {
                      controller._pulling = false;
                      if (controller._pullAgain === true) {
                        controller._pullAgain = false;
                        ReadableStreamDefaultControllerCallPullIfNeeded(controller);
                      }
                    }, function(e) {
                      ReadableStreamDefaultControllerError(controller, e);
                    });
                  }
                  function ReadableStreamDefaultControllerShouldCallPull(controller) {
                    var stream = controller._controlledReadableStream;
                    if (ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) === false) {
                      return false;
                    }
                    if (controller._started === false) {
                      return false;
                    }
                    if (IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {
                      return true;
                    }
                    var desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
                    if (desiredSize > 0) {
                      return true;
                    }
                    return false;
                  }
                  function ReadableStreamDefaultControllerClearAlgorithms(controller) {
                    controller._pullAlgorithm = void 0;
                    controller._cancelAlgorithm = void 0;
                    controller._strategySizeAlgorithm = void 0;
                  }
                  function ReadableStreamDefaultControllerClose(controller) {
                    var stream = controller._controlledReadableStream;
                    controller._closeRequested = true;
                    if (controller._queue.length === 0) {
                      ReadableStreamDefaultControllerClearAlgorithms(controller);
                      ReadableStreamClose(stream);
                    }
                  }
                  function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
                    var stream = controller._controlledReadableStream;
                    if (IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {
                      ReadableStreamFulfillReadRequest(stream, chunk, false);
                    } else {
                      var chunkSize = void 0;
                      try {
                        chunkSize = controller._strategySizeAlgorithm(chunk);
                      } catch (chunkSizeE) {
                        ReadableStreamDefaultControllerError(controller, chunkSizeE);
                        throw chunkSizeE;
                      }
                      try {
                        EnqueueValueWithSize(controller, chunk, chunkSize);
                      } catch (enqueueE) {
                        ReadableStreamDefaultControllerError(controller, enqueueE);
                        throw enqueueE;
                      }
                    }
                    ReadableStreamDefaultControllerCallPullIfNeeded(controller);
                  }
                  function ReadableStreamDefaultControllerError(controller, e) {
                    var stream = controller._controlledReadableStream;
                    if (stream._state !== "readable") {
                      return;
                    }
                    ResetQueue(controller);
                    ReadableStreamDefaultControllerClearAlgorithms(controller);
                    ReadableStreamError(stream, e);
                  }
                  function ReadableStreamDefaultControllerGetDesiredSize(controller) {
                    var stream = controller._controlledReadableStream;
                    var state = stream._state;
                    if (state === "errored") {
                      return null;
                    }
                    if (state === "closed") {
                      return 0;
                    }
                    return controller._strategyHWM - controller._queueTotalSize;
                  }
                  function ReadableStreamDefaultControllerHasBackpressure(controller) {
                    if (ReadableStreamDefaultControllerShouldCallPull(controller) === true) {
                      return false;
                    }
                    return true;
                  }
                  function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
                    var state = controller._controlledReadableStream._state;
                    if (controller._closeRequested === false && state === "readable") {
                      return true;
                    }
                    return false;
                  }
                  function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
                    controller._controlledReadableStream = stream;
                    controller._queue = void 0;
                    controller._queueTotalSize = void 0;
                    ResetQueue(controller);
                    controller._started = false;
                    controller._closeRequested = false;
                    controller._pullAgain = false;
                    controller._pulling = false;
                    controller._strategySizeAlgorithm = sizeAlgorithm;
                    controller._strategyHWM = highWaterMark;
                    controller._pullAlgorithm = pullAlgorithm;
                    controller._cancelAlgorithm = cancelAlgorithm;
                    stream._readableStreamController = controller;
                    var startResult = startAlgorithm();
                    uponPromise(promiseResolvedWith(startResult), function() {
                      controller._started = true;
                      ReadableStreamDefaultControllerCallPullIfNeeded(controller);
                    }, function(r) {
                      ReadableStreamDefaultControllerError(controller, r);
                    });
                  }
                  function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
                    var controller = Object.create(ReadableStreamDefaultController.prototype);
                    function startAlgorithm() {
                      return InvokeOrNoop(underlyingSource, "start", [controller]);
                    }
                    var pullAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSource, "pull", 0, [controller]);
                    var cancelAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSource, "cancel", 1, []);
                    SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
                  }
                  function defaultControllerBrandCheckException(name) {
                    return new TypeError("ReadableStreamDefaultController.prototype." + name + " can only be used on a ReadableStreamDefaultController");
                  }
                  function ReadableStreamTee(stream, cloneForBranch2) {
                    var reader = AcquireReadableStreamDefaultReader(stream);
                    var reading = false;
                    var canceled1 = false;
                    var canceled2 = false;
                    var reason1;
                    var reason2;
                    var branch1;
                    var branch2;
                    var resolveCancelPromise;
                    var cancelPromise = newPromise(function(resolve) {
                      resolveCancelPromise = resolve;
                    });
                    function pullAlgorithm() {
                      if (reading === true) {
                        return promiseResolvedWith(void 0);
                      }
                      reading = true;
                      var readPromise = transformPromiseWith(ReadableStreamDefaultReaderRead(reader), function(result) {
                        reading = false;
                        var done = result.done;
                        if (done === true) {
                          if (canceled1 === false) {
                            ReadableStreamDefaultControllerClose(branch1._readableStreamController);
                          }
                          if (canceled2 === false) {
                            ReadableStreamDefaultControllerClose(branch2._readableStreamController);
                          }
                          return;
                        }
                        var value = result.value;
                        var value1 = value;
                        var value2 = value;
                        if (canceled1 === false) {
                          ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, value1);
                        }
                        if (canceled2 === false) {
                          ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, value2);
                        }
                      });
                      setPromiseIsHandledToTrue(readPromise);
                      return promiseResolvedWith(void 0);
                    }
                    function cancel1Algorithm(reason) {
                      canceled1 = true;
                      reason1 = reason;
                      if (canceled2 === true) {
                        var compositeReason = createArrayFromList([reason1, reason2]);
                        var cancelResult = ReadableStreamCancel(stream, compositeReason);
                        resolveCancelPromise(cancelResult);
                      }
                      return cancelPromise;
                    }
                    function cancel2Algorithm(reason) {
                      canceled2 = true;
                      reason2 = reason;
                      if (canceled1 === true) {
                        var compositeReason = createArrayFromList([reason1, reason2]);
                        var cancelResult = ReadableStreamCancel(stream, compositeReason);
                        resolveCancelPromise(cancelResult);
                      }
                      return cancelPromise;
                    }
                    function startAlgorithm() {
                    }
                    branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);
                    branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);
                    uponRejection(reader._closedPromise, function(r) {
                      ReadableStreamDefaultControllerError(branch1._readableStreamController, r);
                      ReadableStreamDefaultControllerError(branch2._readableStreamController, r);
                    });
                    return [branch1, branch2];
                  }
                  var NumberIsInteger = Number.isInteger || function(value) {
                    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
                  };
                  var ReadableStreamBYOBRequest = function() {
                    function ReadableStreamBYOBRequest2() {
                      throw new TypeError("ReadableStreamBYOBRequest cannot be used directly");
                    }
                    Object.defineProperty(ReadableStreamBYOBRequest2.prototype, "view", { get: function() {
                      if (IsReadableStreamBYOBRequest(this) === false) {
                        throw byobRequestBrandCheckException("view");
                      }
                      return this._view;
                    }, enumerable: true, configurable: true });
                    ReadableStreamBYOBRequest2.prototype.respond = function(bytesWritten) {
                      if (IsReadableStreamBYOBRequest(this) === false) {
                        throw byobRequestBrandCheckException("respond");
                      }
                      if (this._associatedReadableByteStreamController === void 0) {
                        throw new TypeError("This BYOB request has been invalidated");
                      }
                      if (IsDetachedBuffer(this._view.buffer) === true)
                        ;
                      ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
                    };
                    ReadableStreamBYOBRequest2.prototype.respondWithNewView = function(view) {
                      if (IsReadableStreamBYOBRequest(this) === false) {
                        throw byobRequestBrandCheckException("respond");
                      }
                      if (this._associatedReadableByteStreamController === void 0) {
                        throw new TypeError("This BYOB request has been invalidated");
                      }
                      if (!ArrayBuffer.isView(view)) {
                        throw new TypeError("You can only respond with array buffer views");
                      }
                      if (IsDetachedBuffer(view.buffer) === true)
                        ;
                      ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
                    };
                    return ReadableStreamBYOBRequest2;
                  }();
                  var ReadableByteStreamController = function() {
                    function ReadableByteStreamController2() {
                      throw new TypeError("ReadableByteStreamController constructor cannot be used directly");
                    }
                    Object.defineProperty(ReadableByteStreamController2.prototype, "byobRequest", { get: function() {
                      if (IsReadableByteStreamController(this) === false) {
                        throw byteStreamControllerBrandCheckException("byobRequest");
                      }
                      if (this._byobRequest === void 0 && this._pendingPullIntos.length > 0) {
                        var firstDescriptor = this._pendingPullIntos.peek();
                        var view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
                        var byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
                        SetUpReadableStreamBYOBRequest(byobRequest, this, view);
                        this._byobRequest = byobRequest;
                      }
                      return this._byobRequest;
                    }, enumerable: true, configurable: true });
                    Object.defineProperty(ReadableByteStreamController2.prototype, "desiredSize", { get: function() {
                      if (IsReadableByteStreamController(this) === false) {
                        throw byteStreamControllerBrandCheckException("desiredSize");
                      }
                      return ReadableByteStreamControllerGetDesiredSize(this);
                    }, enumerable: true, configurable: true });
                    ReadableByteStreamController2.prototype.close = function() {
                      if (IsReadableByteStreamController(this) === false) {
                        throw byteStreamControllerBrandCheckException("close");
                      }
                      if (this._closeRequested === true) {
                        throw new TypeError("The stream has already been closed; do not close it again!");
                      }
                      var state = this._controlledReadableByteStream._state;
                      if (state !== "readable") {
                        throw new TypeError("The stream (in " + state + " state) is not in the readable state and cannot be closed");
                      }
                      ReadableByteStreamControllerClose(this);
                    };
                    ReadableByteStreamController2.prototype.enqueue = function(chunk) {
                      if (IsReadableByteStreamController(this) === false) {
                        throw byteStreamControllerBrandCheckException("enqueue");
                      }
                      if (this._closeRequested === true) {
                        throw new TypeError("stream is closed or draining");
                      }
                      var state = this._controlledReadableByteStream._state;
                      if (state !== "readable") {
                        throw new TypeError("The stream (in " + state + " state) is not in the readable state and cannot be enqueued to");
                      }
                      if (!ArrayBuffer.isView(chunk)) {
                        throw new TypeError("You can only enqueue array buffer views when using a ReadableByteStreamController");
                      }
                      if (IsDetachedBuffer(chunk.buffer) === true)
                        ;
                      ReadableByteStreamControllerEnqueue(this, chunk);
                    };
                    ReadableByteStreamController2.prototype.error = function(e) {
                      if (IsReadableByteStreamController(this) === false) {
                        throw byteStreamControllerBrandCheckException("error");
                      }
                      ReadableByteStreamControllerError(this, e);
                    };
                    ReadableByteStreamController2.prototype[CancelSteps] = function(reason) {
                      if (this._pendingPullIntos.length > 0) {
                        var firstDescriptor = this._pendingPullIntos.peek();
                        firstDescriptor.bytesFilled = 0;
                      }
                      ResetQueue(this);
                      var result = this._cancelAlgorithm(reason);
                      ReadableByteStreamControllerClearAlgorithms(this);
                      return result;
                    };
                    ReadableByteStreamController2.prototype[PullSteps] = function() {
                      var stream = this._controlledReadableByteStream;
                      if (this._queueTotalSize > 0) {
                        var entry = this._queue.shift();
                        this._queueTotalSize -= entry.byteLength;
                        ReadableByteStreamControllerHandleQueueDrain(this);
                        var view = void 0;
                        try {
                          view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
                        } catch (viewE) {
                          return promiseRejectedWith(viewE);
                        }
                        return promiseResolvedWith(ReadableStreamCreateReadResult(view, false, stream._reader._forAuthorCode));
                      }
                      var autoAllocateChunkSize = this._autoAllocateChunkSize;
                      if (autoAllocateChunkSize !== void 0) {
                        var buffer = void 0;
                        try {
                          buffer = new ArrayBuffer(autoAllocateChunkSize);
                        } catch (bufferE) {
                          return promiseRejectedWith(bufferE);
                        }
                        var pullIntoDescriptor = { buffer, byteOffset: 0, byteLength: autoAllocateChunkSize, bytesFilled: 0, elementSize: 1, ctor: Uint8Array, readerType: "default" };
                        this._pendingPullIntos.push(pullIntoDescriptor);
                      }
                      var promise = ReadableStreamAddReadRequest(stream);
                      ReadableByteStreamControllerCallPullIfNeeded(this);
                      return promise;
                    };
                    return ReadableByteStreamController2;
                  }();
                  function IsReadableByteStreamController(x) {
                    if (!typeIsObject(x)) {
                      return false;
                    }
                    if (!Object.prototype.hasOwnProperty.call(x, "_controlledReadableByteStream")) {
                      return false;
                    }
                    return true;
                  }
                  function IsReadableStreamBYOBRequest(x) {
                    if (!typeIsObject(x)) {
                      return false;
                    }
                    if (!Object.prototype.hasOwnProperty.call(x, "_associatedReadableByteStreamController")) {
                      return false;
                    }
                    return true;
                  }
                  function ReadableByteStreamControllerCallPullIfNeeded(controller) {
                    var shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
                    if (shouldPull === false) {
                      return;
                    }
                    if (controller._pulling === true) {
                      controller._pullAgain = true;
                      return;
                    }
                    controller._pulling = true;
                    var pullPromise = controller._pullAlgorithm();
                    uponPromise(pullPromise, function() {
                      controller._pulling = false;
                      if (controller._pullAgain === true) {
                        controller._pullAgain = false;
                        ReadableByteStreamControllerCallPullIfNeeded(controller);
                      }
                    }, function(e) {
                      ReadableByteStreamControllerError(controller, e);
                    });
                  }
                  function ReadableByteStreamControllerClearPendingPullIntos(controller) {
                    ReadableByteStreamControllerInvalidateBYOBRequest(controller);
                    controller._pendingPullIntos = new SimpleQueue();
                  }
                  function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
                    var done = false;
                    if (stream._state === "closed") {
                      done = true;
                    }
                    var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
                    if (pullIntoDescriptor.readerType === "default") {
                      ReadableStreamFulfillReadRequest(stream, filledView, done);
                    } else {
                      ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
                    }
                  }
                  function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
                    var bytesFilled = pullIntoDescriptor.bytesFilled;
                    var elementSize = pullIntoDescriptor.elementSize;
                    return new pullIntoDescriptor.ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
                  }
                  function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
                    controller._queue.push({ buffer, byteOffset, byteLength });
                    controller._queueTotalSize += byteLength;
                  }
                  function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
                    var elementSize = pullIntoDescriptor.elementSize;
                    var currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;
                    var maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
                    var maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
                    var maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;
                    var totalBytesToCopyRemaining = maxBytesToCopy;
                    var ready = false;
                    if (maxAlignedBytes > currentAlignedBytes) {
                      totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
                      ready = true;
                    }
                    var queue = controller._queue;
                    while (totalBytesToCopyRemaining > 0) {
                      var headOfQueue = queue.peek();
                      var bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
                      var destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
                      ArrayBufferCopy(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);
                      if (headOfQueue.byteLength === bytesToCopy) {
                        queue.shift();
                      } else {
                        headOfQueue.byteOffset += bytesToCopy;
                        headOfQueue.byteLength -= bytesToCopy;
                      }
                      controller._queueTotalSize -= bytesToCopy;
                      ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
                      totalBytesToCopyRemaining -= bytesToCopy;
                    }
                    return ready;
                  }
                  function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
                    ReadableByteStreamControllerInvalidateBYOBRequest(controller);
                    pullIntoDescriptor.bytesFilled += size;
                  }
                  function ReadableByteStreamControllerHandleQueueDrain(controller) {
                    if (controller._queueTotalSize === 0 && controller._closeRequested === true) {
                      ReadableByteStreamControllerClearAlgorithms(controller);
                      ReadableStreamClose(controller._controlledReadableByteStream);
                    } else {
                      ReadableByteStreamControllerCallPullIfNeeded(controller);
                    }
                  }
                  function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
                    if (controller._byobRequest === void 0) {
                      return;
                    }
                    controller._byobRequest._associatedReadableByteStreamController = void 0;
                    controller._byobRequest._view = void 0;
                    controller._byobRequest = void 0;
                  }
                  function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
                    while (controller._pendingPullIntos.length > 0) {
                      if (controller._queueTotalSize === 0) {
                        return;
                      }
                      var pullIntoDescriptor = controller._pendingPullIntos.peek();
                      if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) {
                        ReadableByteStreamControllerShiftPendingPullInto(controller);
                        ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
                      }
                    }
                  }
                  function ReadableByteStreamControllerPullInto(controller, view) {
                    var stream = controller._controlledReadableByteStream;
                    var elementSize = 1;
                    if (view.constructor !== DataView) {
                      elementSize = view.constructor.BYTES_PER_ELEMENT;
                    }
                    var ctor = view.constructor;
                    var buffer = TransferArrayBuffer(view.buffer);
                    var pullIntoDescriptor = { buffer, byteOffset: view.byteOffset, byteLength: view.byteLength, bytesFilled: 0, elementSize, ctor, readerType: "byob" };
                    if (controller._pendingPullIntos.length > 0) {
                      controller._pendingPullIntos.push(pullIntoDescriptor);
                      return ReadableStreamAddReadIntoRequest(stream);
                    }
                    if (stream._state === "closed") {
                      var emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
                      return promiseResolvedWith(ReadableStreamCreateReadResult(emptyView, true, stream._reader._forAuthorCode));
                    }
                    if (controller._queueTotalSize > 0) {
                      if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) {
                        var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
                        ReadableByteStreamControllerHandleQueueDrain(controller);
                        return promiseResolvedWith(ReadableStreamCreateReadResult(filledView, false, stream._reader._forAuthorCode));
                      }
                      if (controller._closeRequested === true) {
                        var e = new TypeError("Insufficient bytes to fill elements in the given buffer");
                        ReadableByteStreamControllerError(controller, e);
                        return promiseRejectedWith(e);
                      }
                    }
                    controller._pendingPullIntos.push(pullIntoDescriptor);
                    var promise = ReadableStreamAddReadIntoRequest(stream);
                    ReadableByteStreamControllerCallPullIfNeeded(controller);
                    return promise;
                  }
                  function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
                    firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
                    var stream = controller._controlledReadableByteStream;
                    if (ReadableStreamHasBYOBReader(stream) === true) {
                      while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {
                        var pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
                        ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
                      }
                    }
                  }
                  function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
                    if (pullIntoDescriptor.bytesFilled + bytesWritten > pullIntoDescriptor.byteLength) {
                      throw new RangeError("bytesWritten out of range");
                    }
                    ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);
                    if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {
                      return;
                    }
                    ReadableByteStreamControllerShiftPendingPullInto(controller);
                    var remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
                    if (remainderSize > 0) {
                      var end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
                      var remainder = pullIntoDescriptor.buffer.slice(end - remainderSize, end);
                      ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);
                    }
                    pullIntoDescriptor.buffer = TransferArrayBuffer(pullIntoDescriptor.buffer);
                    pullIntoDescriptor.bytesFilled -= remainderSize;
                    ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
                    ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
                  }
                  function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
                    var firstDescriptor = controller._pendingPullIntos.peek();
                    var stream = controller._controlledReadableByteStream;
                    if (stream._state === "closed") {
                      if (bytesWritten !== 0) {
                        throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
                      }
                      ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);
                    } else {
                      ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
                    }
                    ReadableByteStreamControllerCallPullIfNeeded(controller);
                  }
                  function ReadableByteStreamControllerShiftPendingPullInto(controller) {
                    var descriptor = controller._pendingPullIntos.shift();
                    ReadableByteStreamControllerInvalidateBYOBRequest(controller);
                    return descriptor;
                  }
                  function ReadableByteStreamControllerShouldCallPull(controller) {
                    var stream = controller._controlledReadableByteStream;
                    if (stream._state !== "readable") {
                      return false;
                    }
                    if (controller._closeRequested === true) {
                      return false;
                    }
                    if (controller._started === false) {
                      return false;
                    }
                    if (ReadableStreamHasDefaultReader(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {
                      return true;
                    }
                    if (ReadableStreamHasBYOBReader(stream) === true && ReadableStreamGetNumReadIntoRequests(stream) > 0) {
                      return true;
                    }
                    var desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);
                    if (desiredSize > 0) {
                      return true;
                    }
                    return false;
                  }
                  function ReadableByteStreamControllerClearAlgorithms(controller) {
                    controller._pullAlgorithm = void 0;
                    controller._cancelAlgorithm = void 0;
                  }
                  function ReadableByteStreamControllerClose(controller) {
                    var stream = controller._controlledReadableByteStream;
                    if (controller._queueTotalSize > 0) {
                      controller._closeRequested = true;
                      return;
                    }
                    if (controller._pendingPullIntos.length > 0) {
                      var firstPendingPullInto = controller._pendingPullIntos.peek();
                      if (firstPendingPullInto.bytesFilled > 0) {
                        var e = new TypeError("Insufficient bytes to fill elements in the given buffer");
                        ReadableByteStreamControllerError(controller, e);
                        throw e;
                      }
                    }
                    ReadableByteStreamControllerClearAlgorithms(controller);
                    ReadableStreamClose(stream);
                  }
                  function ReadableByteStreamControllerEnqueue(controller, chunk) {
                    var stream = controller._controlledReadableByteStream;
                    var buffer = chunk.buffer;
                    var byteOffset = chunk.byteOffset;
                    var byteLength = chunk.byteLength;
                    var transferredBuffer = TransferArrayBuffer(buffer);
                    if (ReadableStreamHasDefaultReader(stream) === true) {
                      if (ReadableStreamGetNumReadRequests(stream) === 0) {
                        ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
                      } else {
                        var transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
                        ReadableStreamFulfillReadRequest(stream, transferredView, false);
                      }
                    } else if (ReadableStreamHasBYOBReader(stream) === true) {
                      ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
                      ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
                    } else {
                      ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
                    }
                    ReadableByteStreamControllerCallPullIfNeeded(controller);
                  }
                  function ReadableByteStreamControllerError(controller, e) {
                    var stream = controller._controlledReadableByteStream;
                    if (stream._state !== "readable") {
                      return;
                    }
                    ReadableByteStreamControllerClearPendingPullIntos(controller);
                    ResetQueue(controller);
                    ReadableByteStreamControllerClearAlgorithms(controller);
                    ReadableStreamError(stream, e);
                  }
                  function ReadableByteStreamControllerGetDesiredSize(controller) {
                    var stream = controller._controlledReadableByteStream;
                    var state = stream._state;
                    if (state === "errored") {
                      return null;
                    }
                    if (state === "closed") {
                      return 0;
                    }
                    return controller._strategyHWM - controller._queueTotalSize;
                  }
                  function ReadableByteStreamControllerRespond(controller, bytesWritten) {
                    bytesWritten = Number(bytesWritten);
                    if (IsFiniteNonNegativeNumber(bytesWritten) === false) {
                      throw new RangeError("bytesWritten must be a finite");
                    }
                    ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
                  }
                  function ReadableByteStreamControllerRespondWithNewView(controller, view) {
                    var firstDescriptor = controller._pendingPullIntos.peek();
                    if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
                      throw new RangeError("The region specified by view does not match byobRequest");
                    }
                    if (firstDescriptor.byteLength !== view.byteLength) {
                      throw new RangeError("The buffer of view has different capacity than byobRequest");
                    }
                    firstDescriptor.buffer = view.buffer;
                    ReadableByteStreamControllerRespondInternal(controller, view.byteLength);
                  }
                  function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
                    controller._controlledReadableByteStream = stream;
                    controller._pullAgain = false;
                    controller._pulling = false;
                    controller._byobRequest = void 0;
                    controller._queue = controller._queueTotalSize = void 0;
                    ResetQueue(controller);
                    controller._closeRequested = false;
                    controller._started = false;
                    controller._strategyHWM = ValidateAndNormalizeHighWaterMark(highWaterMark);
                    controller._pullAlgorithm = pullAlgorithm;
                    controller._cancelAlgorithm = cancelAlgorithm;
                    controller._autoAllocateChunkSize = autoAllocateChunkSize;
                    controller._pendingPullIntos = new SimpleQueue();
                    stream._readableStreamController = controller;
                    var startResult = startAlgorithm();
                    uponPromise(promiseResolvedWith(startResult), function() {
                      controller._started = true;
                      ReadableByteStreamControllerCallPullIfNeeded(controller);
                    }, function(r) {
                      ReadableByteStreamControllerError(controller, r);
                    });
                  }
                  function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {
                    var controller = Object.create(ReadableByteStreamController.prototype);
                    function startAlgorithm() {
                      return InvokeOrNoop(underlyingByteSource, "start", [controller]);
                    }
                    var pullAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingByteSource, "pull", 0, [controller]);
                    var cancelAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingByteSource, "cancel", 1, []);
                    var autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
                    if (autoAllocateChunkSize !== void 0) {
                      autoAllocateChunkSize = Number(autoAllocateChunkSize);
                      if (NumberIsInteger(autoAllocateChunkSize) === false || autoAllocateChunkSize <= 0) {
                        throw new RangeError("autoAllocateChunkSize must be a positive integer");
                      }
                    }
                    SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
                  }
                  function SetUpReadableStreamBYOBRequest(request, controller, view) {
                    request._associatedReadableByteStreamController = controller;
                    request._view = view;
                  }
                  function byobRequestBrandCheckException(name) {
                    return new TypeError("ReadableStreamBYOBRequest.prototype." + name + " can only be used on a ReadableStreamBYOBRequest");
                  }
                  function byteStreamControllerBrandCheckException(name) {
                    return new TypeError("ReadableByteStreamController.prototype." + name + " can only be used on a ReadableByteStreamController");
                  }
                  function AcquireReadableStreamBYOBReader(stream, forAuthorCode) {
                    if (forAuthorCode === void 0) {
                      forAuthorCode = false;
                    }
                    var reader = new ReadableStreamBYOBReader(stream);
                    reader._forAuthorCode = forAuthorCode;
                    return reader;
                  }
                  function ReadableStreamAddReadIntoRequest(stream) {
                    var promise = newPromise(function(resolve, reject) {
                      var readIntoRequest = { _resolve: resolve, _reject: reject };
                      stream._reader._readIntoRequests.push(readIntoRequest);
                    });
                    return promise;
                  }
                  function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
                    var reader = stream._reader;
                    var readIntoRequest = reader._readIntoRequests.shift();
                    readIntoRequest._resolve(ReadableStreamCreateReadResult(chunk, done, reader._forAuthorCode));
                  }
                  function ReadableStreamGetNumReadIntoRequests(stream) {
                    return stream._reader._readIntoRequests.length;
                  }
                  function ReadableStreamHasBYOBReader(stream) {
                    var reader = stream._reader;
                    if (reader === void 0) {
                      return false;
                    }
                    if (!IsReadableStreamBYOBReader(reader)) {
                      return false;
                    }
                    return true;
                  }
                  var ReadableStreamBYOBReader = function() {
                    function ReadableStreamBYOBReader2(stream) {
                      if (!IsReadableStream(stream)) {
                        throw new TypeError("ReadableStreamBYOBReader can only be constructed with a ReadableStream instance given a byte source");
                      }
                      if (IsReadableByteStreamController(stream._readableStreamController) === false) {
                        throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
                      }
                      if (IsReadableStreamLocked(stream)) {
                        throw new TypeError("This stream has already been locked for exclusive reading by another reader");
                      }
                      ReadableStreamReaderGenericInitialize(this, stream);
                      this._readIntoRequests = new SimpleQueue();
                    }
                    Object.defineProperty(ReadableStreamBYOBReader2.prototype, "closed", { get: function() {
                      if (!IsReadableStreamBYOBReader(this)) {
                        return promiseRejectedWith(byobReaderBrandCheckException("closed"));
                      }
                      return this._closedPromise;
                    }, enumerable: true, configurable: true });
                    ReadableStreamBYOBReader2.prototype.cancel = function(reason) {
                      if (!IsReadableStreamBYOBReader(this)) {
                        return promiseRejectedWith(byobReaderBrandCheckException("cancel"));
                      }
                      if (this._ownerReadableStream === void 0) {
                        return promiseRejectedWith(readerLockException("cancel"));
                      }
                      return ReadableStreamReaderGenericCancel(this, reason);
                    };
                    ReadableStreamBYOBReader2.prototype.read = function(view) {
                      if (!IsReadableStreamBYOBReader(this)) {
                        return promiseRejectedWith(byobReaderBrandCheckException("read"));
                      }
                      if (this._ownerReadableStream === void 0) {
                        return promiseRejectedWith(readerLockException("read from"));
                      }
                      if (!ArrayBuffer.isView(view)) {
                        return promiseRejectedWith(new TypeError("view must be an array buffer view"));
                      }
                      if (IsDetachedBuffer(view.buffer) === true)
                        ;
                      if (view.byteLength === 0) {
                        return promiseRejectedWith(new TypeError("view must have non-zero byteLength"));
                      }
                      return ReadableStreamBYOBReaderRead(this, view);
                    };
                    ReadableStreamBYOBReader2.prototype.releaseLock = function() {
                      if (!IsReadableStreamBYOBReader(this)) {
                        throw byobReaderBrandCheckException("releaseLock");
                      }
                      if (this._ownerReadableStream === void 0) {
                        return;
                      }
                      if (this._readIntoRequests.length > 0) {
                        throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
                      }
                      ReadableStreamReaderGenericRelease(this);
                    };
                    return ReadableStreamBYOBReader2;
                  }();
                  function IsReadableStreamBYOBReader(x) {
                    if (!typeIsObject(x)) {
                      return false;
                    }
                    if (!Object.prototype.hasOwnProperty.call(x, "_readIntoRequests")) {
                      return false;
                    }
                    return true;
                  }
                  function ReadableStreamBYOBReaderRead(reader, view) {
                    var stream = reader._ownerReadableStream;
                    stream._disturbed = true;
                    if (stream._state === "errored") {
                      return promiseRejectedWith(stream._storedError);
                    }
                    return ReadableByteStreamControllerPullInto(stream._readableStreamController, view);
                  }
                  function byobReaderBrandCheckException(name) {
                    return new TypeError("ReadableStreamBYOBReader.prototype." + name + " can only be used on a ReadableStreamBYOBReader");
                  }
                  var ReadableStream2 = function() {
                    function ReadableStream3(underlyingSource, strategy) {
                      if (underlyingSource === void 0) {
                        underlyingSource = {};
                      }
                      if (strategy === void 0) {
                        strategy = {};
                      }
                      InitializeReadableStream(this);
                      var size = strategy.size;
                      var highWaterMark = strategy.highWaterMark;
                      var type = underlyingSource.type;
                      var typeString = String(type);
                      if (typeString === "bytes") {
                        if (size !== void 0) {
                          throw new RangeError("The strategy for a byte stream cannot have a size function");
                        }
                        if (highWaterMark === void 0) {
                          highWaterMark = 0;
                        }
                        highWaterMark = ValidateAndNormalizeHighWaterMark(highWaterMark);
                        SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
                      } else if (type === void 0) {
                        var sizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(size);
                        if (highWaterMark === void 0) {
                          highWaterMark = 1;
                        }
                        highWaterMark = ValidateAndNormalizeHighWaterMark(highWaterMark);
                        SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
                      } else {
                        throw new RangeError("Invalid type is specified");
                      }
                    }
                    Object.defineProperty(ReadableStream3.prototype, "locked", { get: function() {
                      if (IsReadableStream(this) === false) {
                        throw streamBrandCheckException$1("locked");
                      }
                      return IsReadableStreamLocked(this);
                    }, enumerable: true, configurable: true });
                    ReadableStream3.prototype.cancel = function(reason) {
                      if (IsReadableStream(this) === false) {
                        return promiseRejectedWith(streamBrandCheckException$1("cancel"));
                      }
                      if (IsReadableStreamLocked(this) === true) {
                        return promiseRejectedWith(new TypeError("Cannot cancel a stream that already has a reader"));
                      }
                      return ReadableStreamCancel(this, reason);
                    };
                    ReadableStream3.prototype.getReader = function(_a2) {
                      var mode = (_a2 === void 0 ? {} : _a2).mode;
                      if (IsReadableStream(this) === false) {
                        throw streamBrandCheckException$1("getReader");
                      }
                      if (mode === void 0) {
                        return AcquireReadableStreamDefaultReader(this, true);
                      }
                      mode = String(mode);
                      if (mode === "byob") {
                        return AcquireReadableStreamBYOBReader(this, true);
                      }
                      throw new RangeError("Invalid mode is specified");
                    };
                    ReadableStream3.prototype.pipeThrough = function(_a2, _b) {
                      var writable = _a2.writable, readable = _a2.readable;
                      var _c = _b === void 0 ? {} : _b, preventClose = _c.preventClose, preventAbort = _c.preventAbort, preventCancel = _c.preventCancel, signal = _c.signal;
                      if (IsReadableStream(this) === false) {
                        throw streamBrandCheckException$1("pipeThrough");
                      }
                      if (IsWritableStream(writable) === false) {
                        throw new TypeError("writable argument to pipeThrough must be a WritableStream");
                      }
                      if (IsReadableStream(readable) === false) {
                        throw new TypeError("readable argument to pipeThrough must be a ReadableStream");
                      }
                      preventClose = Boolean(preventClose);
                      preventAbort = Boolean(preventAbort);
                      preventCancel = Boolean(preventCancel);
                      if (signal !== void 0 && !isAbortSignal(signal)) {
                        throw new TypeError("ReadableStream.prototype.pipeThrough's signal option must be an AbortSignal");
                      }
                      if (IsReadableStreamLocked(this) === true) {
                        throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
                      }
                      if (IsWritableStreamLocked(writable) === true) {
                        throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
                      }
                      var promise = ReadableStreamPipeTo(this, writable, preventClose, preventAbort, preventCancel, signal);
                      setPromiseIsHandledToTrue(promise);
                      return readable;
                    };
                    ReadableStream3.prototype.pipeTo = function(dest, _a2) {
                      var _b = _a2 === void 0 ? {} : _a2, preventClose = _b.preventClose, preventAbort = _b.preventAbort, preventCancel = _b.preventCancel, signal = _b.signal;
                      if (IsReadableStream(this) === false) {
                        return promiseRejectedWith(streamBrandCheckException$1("pipeTo"));
                      }
                      if (IsWritableStream(dest) === false) {
                        return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));
                      }
                      preventClose = Boolean(preventClose);
                      preventAbort = Boolean(preventAbort);
                      preventCancel = Boolean(preventCancel);
                      if (signal !== void 0 && !isAbortSignal(signal)) {
                        return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo's signal option must be an AbortSignal"));
                      }
                      if (IsReadableStreamLocked(this) === true) {
                        return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"));
                      }
                      if (IsWritableStreamLocked(dest) === true) {
                        return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"));
                      }
                      return ReadableStreamPipeTo(this, dest, preventClose, preventAbort, preventCancel, signal);
                    };
                    ReadableStream3.prototype.tee = function() {
                      if (IsReadableStream(this) === false) {
                        throw streamBrandCheckException$1("tee");
                      }
                      var branches = ReadableStreamTee(this);
                      return createArrayFromList(branches);
                    };
                    ReadableStream3.prototype.getIterator = function(_a2) {
                      var _b = (_a2 === void 0 ? {} : _a2).preventCancel, preventCancel = _b === void 0 ? false : _b;
                      if (IsReadableStream(this) === false) {
                        throw streamBrandCheckException$1("getIterator");
                      }
                      return AcquireReadableStreamAsyncIterator(this, preventCancel);
                    };
                    return ReadableStream3;
                  }();
                  if (typeof SymbolPolyfill.asyncIterator === "symbol") {
                    Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.asyncIterator, { value: ReadableStream2.prototype.getIterator, enumerable: false, writable: true, configurable: true });
                  }
                  function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
                    if (highWaterMark === void 0) {
                      highWaterMark = 1;
                    }
                    if (sizeAlgorithm === void 0) {
                      sizeAlgorithm = function() {
                        return 1;
                      };
                    }
                    var stream = Object.create(ReadableStream2.prototype);
                    InitializeReadableStream(stream);
                    var controller = Object.create(ReadableStreamDefaultController.prototype);
                    SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
                    return stream;
                  }
                  function InitializeReadableStream(stream) {
                    stream._state = "readable";
                    stream._reader = void 0;
                    stream._storedError = void 0;
                    stream._disturbed = false;
                  }
                  function IsReadableStream(x) {
                    if (!typeIsObject(x)) {
                      return false;
                    }
                    if (!Object.prototype.hasOwnProperty.call(x, "_readableStreamController")) {
                      return false;
                    }
                    return true;
                  }
                  function IsReadableStreamLocked(stream) {
                    if (stream._reader === void 0) {
                      return false;
                    }
                    return true;
                  }
                  function ReadableStreamCancel(stream, reason) {
                    stream._disturbed = true;
                    if (stream._state === "closed") {
                      return promiseResolvedWith(void 0);
                    }
                    if (stream._state === "errored") {
                      return promiseRejectedWith(stream._storedError);
                    }
                    ReadableStreamClose(stream);
                    var sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);
                    return transformPromiseWith(sourceCancelPromise, noop);
                  }
                  function ReadableStreamClose(stream) {
                    stream._state = "closed";
                    var reader = stream._reader;
                    if (reader === void 0) {
                      return;
                    }
                    if (IsReadableStreamDefaultReader(reader)) {
                      reader._readRequests.forEach(function(readRequest) {
                        readRequest._resolve(ReadableStreamCreateReadResult(void 0, true, reader._forAuthorCode));
                      });
                      reader._readRequests = new SimpleQueue();
                    }
                    defaultReaderClosedPromiseResolve(reader);
                  }
                  function ReadableStreamError(stream, e) {
                    stream._state = "errored";
                    stream._storedError = e;
                    var reader = stream._reader;
                    if (reader === void 0) {
                      return;
                    }
                    if (IsReadableStreamDefaultReader(reader)) {
                      reader._readRequests.forEach(function(readRequest) {
                        readRequest._reject(e);
                      });
                      reader._readRequests = new SimpleQueue();
                    } else {
                      reader._readIntoRequests.forEach(function(readIntoRequest) {
                        readIntoRequest._reject(e);
                      });
                      reader._readIntoRequests = new SimpleQueue();
                    }
                    defaultReaderClosedPromiseReject(reader, e);
                  }
                  function streamBrandCheckException$1(name) {
                    return new TypeError("ReadableStream.prototype." + name + " can only be used on a ReadableStream");
                  }
                  var ByteLengthQueuingStrategy = function() {
                    function ByteLengthQueuingStrategy2(_a2) {
                      var highWaterMark = _a2.highWaterMark;
                      this.highWaterMark = highWaterMark;
                    }
                    ByteLengthQueuingStrategy2.prototype.size = function(chunk) {
                      return chunk.byteLength;
                    };
                    return ByteLengthQueuingStrategy2;
                  }();
                  var CountQueuingStrategy = function() {
                    function CountQueuingStrategy2(_a2) {
                      var highWaterMark = _a2.highWaterMark;
                      this.highWaterMark = highWaterMark;
                    }
                    CountQueuingStrategy2.prototype.size = function() {
                      return 1;
                    };
                    return CountQueuingStrategy2;
                  }();
                  var TransformStream = function() {
                    function TransformStream2(transformer, writableStrategy, readableStrategy) {
                      if (transformer === void 0) {
                        transformer = {};
                      }
                      if (writableStrategy === void 0) {
                        writableStrategy = {};
                      }
                      if (readableStrategy === void 0) {
                        readableStrategy = {};
                      }
                      var writableSizeFunction = writableStrategy.size;
                      var writableHighWaterMark = writableStrategy.highWaterMark;
                      var readableSizeFunction = readableStrategy.size;
                      var readableHighWaterMark = readableStrategy.highWaterMark;
                      var writableType = transformer.writableType;
                      if (writableType !== void 0) {
                        throw new RangeError("Invalid writable type specified");
                      }
                      var writableSizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(writableSizeFunction);
                      if (writableHighWaterMark === void 0) {
                        writableHighWaterMark = 1;
                      }
                      writableHighWaterMark = ValidateAndNormalizeHighWaterMark(writableHighWaterMark);
                      var readableType = transformer.readableType;
                      if (readableType !== void 0) {
                        throw new RangeError("Invalid readable type specified");
                      }
                      var readableSizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(readableSizeFunction);
                      if (readableHighWaterMark === void 0) {
                        readableHighWaterMark = 0;
                      }
                      readableHighWaterMark = ValidateAndNormalizeHighWaterMark(readableHighWaterMark);
                      var startPromise_resolve;
                      var startPromise = newPromise(function(resolve) {
                        startPromise_resolve = resolve;
                      });
                      InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
                      SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);
                      var startResult = InvokeOrNoop(transformer, "start", [this._transformStreamController]);
                      startPromise_resolve(startResult);
                    }
                    Object.defineProperty(TransformStream2.prototype, "readable", { get: function() {
                      if (IsTransformStream(this) === false) {
                        throw streamBrandCheckException$2("readable");
                      }
                      return this._readable;
                    }, enumerable: true, configurable: true });
                    Object.defineProperty(TransformStream2.prototype, "writable", { get: function() {
                      if (IsTransformStream(this) === false) {
                        throw streamBrandCheckException$2("writable");
                      }
                      return this._writable;
                    }, enumerable: true, configurable: true });
                    return TransformStream2;
                  }();
                  function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
                    function startAlgorithm() {
                      return startPromise;
                    }
                    function writeAlgorithm(chunk) {
                      return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);
                    }
                    function abortAlgorithm(reason) {
                      return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);
                    }
                    function closeAlgorithm() {
                      return TransformStreamDefaultSinkCloseAlgorithm(stream);
                    }
                    stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
                    function pullAlgorithm() {
                      return TransformStreamDefaultSourcePullAlgorithm(stream);
                    }
                    function cancelAlgorithm(reason) {
                      TransformStreamErrorWritableAndUnblockWrite(stream, reason);
                      return promiseResolvedWith(void 0);
                    }
                    stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
                    stream._backpressure = void 0;
                    stream._backpressureChangePromise = void 0;
                    stream._backpressureChangePromise_resolve = void 0;
                    TransformStreamSetBackpressure(stream, true);
                    stream._transformStreamController = void 0;
                  }
                  function IsTransformStream(x) {
                    if (!typeIsObject(x)) {
                      return false;
                    }
                    if (!Object.prototype.hasOwnProperty.call(x, "_transformStreamController")) {
                      return false;
                    }
                    return true;
                  }
                  function TransformStreamError(stream, e) {
                    ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);
                    TransformStreamErrorWritableAndUnblockWrite(stream, e);
                  }
                  function TransformStreamErrorWritableAndUnblockWrite(stream, e) {
                    TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);
                    WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);
                    if (stream._backpressure === true) {
                      TransformStreamSetBackpressure(stream, false);
                    }
                  }
                  function TransformStreamSetBackpressure(stream, backpressure) {
                    if (stream._backpressureChangePromise !== void 0) {
                      stream._backpressureChangePromise_resolve();
                    }
                    stream._backpressureChangePromise = newPromise(function(resolve) {
                      stream._backpressureChangePromise_resolve = resolve;
                    });
                    stream._backpressure = backpressure;
                  }
                  var TransformStreamDefaultController = function() {
                    function TransformStreamDefaultController2() {
                      throw new TypeError("TransformStreamDefaultController instances cannot be created directly");
                    }
                    Object.defineProperty(TransformStreamDefaultController2.prototype, "desiredSize", { get: function() {
                      if (IsTransformStreamDefaultController(this) === false) {
                        throw defaultControllerBrandCheckException$1("desiredSize");
                      }
                      var readableController = this._controlledTransformStream._readable._readableStreamController;
                      return ReadableStreamDefaultControllerGetDesiredSize(readableController);
                    }, enumerable: true, configurable: true });
                    TransformStreamDefaultController2.prototype.enqueue = function(chunk) {
                      if (IsTransformStreamDefaultController(this) === false) {
                        throw defaultControllerBrandCheckException$1("enqueue");
                      }
                      TransformStreamDefaultControllerEnqueue(this, chunk);
                    };
                    TransformStreamDefaultController2.prototype.error = function(reason) {
                      if (IsTransformStreamDefaultController(this) === false) {
                        throw defaultControllerBrandCheckException$1("error");
                      }
                      TransformStreamDefaultControllerError(this, reason);
                    };
                    TransformStreamDefaultController2.prototype.terminate = function() {
                      if (IsTransformStreamDefaultController(this) === false) {
                        throw defaultControllerBrandCheckException$1("terminate");
                      }
                      TransformStreamDefaultControllerTerminate(this);
                    };
                    return TransformStreamDefaultController2;
                  }();
                  function IsTransformStreamDefaultController(x) {
                    if (!typeIsObject(x)) {
                      return false;
                    }
                    if (!Object.prototype.hasOwnProperty.call(x, "_controlledTransformStream")) {
                      return false;
                    }
                    return true;
                  }
                  function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {
                    controller._controlledTransformStream = stream;
                    stream._transformStreamController = controller;
                    controller._transformAlgorithm = transformAlgorithm;
                    controller._flushAlgorithm = flushAlgorithm;
                  }
                  function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {
                    var controller = Object.create(TransformStreamDefaultController.prototype);
                    var transformAlgorithm = function(chunk) {
                      try {
                        TransformStreamDefaultControllerEnqueue(controller, chunk);
                        return promiseResolvedWith(void 0);
                      } catch (transformResultE) {
                        return promiseRejectedWith(transformResultE);
                      }
                    };
                    var transformMethod = transformer.transform;
                    if (transformMethod !== void 0) {
                      if (typeof transformMethod !== "function") {
                        throw new TypeError("transform is not a method");
                      }
                      transformAlgorithm = function(chunk) {
                        return PromiseCall(transformMethod, transformer, [chunk, controller]);
                      };
                    }
                    var flushAlgorithm = CreateAlgorithmFromUnderlyingMethod(transformer, "flush", 0, [controller]);
                    SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);
                  }
                  function TransformStreamDefaultControllerClearAlgorithms(controller) {
                    controller._transformAlgorithm = void 0;
                    controller._flushAlgorithm = void 0;
                  }
                  function TransformStreamDefaultControllerEnqueue(controller, chunk) {
                    var stream = controller._controlledTransformStream;
                    var readableController = stream._readable._readableStreamController;
                    if (ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) === false) {
                      throw new TypeError("Readable side is not in a state that permits enqueue");
                    }
                    try {
                      ReadableStreamDefaultControllerEnqueue(readableController, chunk);
                    } catch (e) {
                      TransformStreamErrorWritableAndUnblockWrite(stream, e);
                      throw stream._readable._storedError;
                    }
                    var backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);
                    if (backpressure !== stream._backpressure) {
                      TransformStreamSetBackpressure(stream, true);
                    }
                  }
                  function TransformStreamDefaultControllerError(controller, e) {
                    TransformStreamError(controller._controlledTransformStream, e);
                  }
                  function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
                    var transformPromise = controller._transformAlgorithm(chunk);
                    return transformPromiseWith(transformPromise, void 0, function(r) {
                      TransformStreamError(controller._controlledTransformStream, r);
                      throw r;
                    });
                  }
                  function TransformStreamDefaultControllerTerminate(controller) {
                    var stream = controller._controlledTransformStream;
                    var readableController = stream._readable._readableStreamController;
                    if (ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) === true) {
                      ReadableStreamDefaultControllerClose(readableController);
                    }
                    var error = new TypeError("TransformStream terminated");
                    TransformStreamErrorWritableAndUnblockWrite(stream, error);
                  }
                  function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
                    var controller = stream._transformStreamController;
                    if (stream._backpressure === true) {
                      var backpressureChangePromise = stream._backpressureChangePromise;
                      return transformPromiseWith(backpressureChangePromise, function() {
                        var writable = stream._writable;
                        var state = writable._state;
                        if (state === "erroring") {
                          throw writable._storedError;
                        }
                        return TransformStreamDefaultControllerPerformTransform(controller, chunk);
                      });
                    }
                    return TransformStreamDefaultControllerPerformTransform(controller, chunk);
                  }
                  function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {
                    TransformStreamError(stream, reason);
                    return promiseResolvedWith(void 0);
                  }
                  function TransformStreamDefaultSinkCloseAlgorithm(stream) {
                    var readable = stream._readable;
                    var controller = stream._transformStreamController;
                    var flushPromise = controller._flushAlgorithm();
                    TransformStreamDefaultControllerClearAlgorithms(controller);
                    return transformPromiseWith(flushPromise, function() {
                      if (readable._state === "errored") {
                        throw readable._storedError;
                      }
                      var readableController = readable._readableStreamController;
                      if (ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) === true) {
                        ReadableStreamDefaultControllerClose(readableController);
                      }
                    }, function(r) {
                      TransformStreamError(stream, r);
                      throw readable._storedError;
                    });
                  }
                  function TransformStreamDefaultSourcePullAlgorithm(stream) {
                    TransformStreamSetBackpressure(stream, false);
                    return stream._backpressureChangePromise;
                  }
                  function defaultControllerBrandCheckException$1(name) {
                    return new TypeError("TransformStreamDefaultController.prototype." + name + " can only be used on a TransformStreamDefaultController");
                  }
                  function streamBrandCheckException$2(name) {
                    return new TypeError("TransformStream.prototype." + name + " can only be used on a TransformStream");
                  }
                  exports3.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;
                  exports3.CountQueuingStrategy = CountQueuingStrategy;
                  exports3.ReadableStream = ReadableStream2;
                  exports3.TransformStream = TransformStream;
                  exports3.WritableStream = WritableStream;
                  Object.defineProperty(exports3, "__esModule", { value: true });
                });
              }, function(module2, exports2, __w_pdfjs_require__2) {
                __w_pdfjs_require__2(137);
                __w_pdfjs_require__2(105);
                __w_pdfjs_require__2(73);
                __w_pdfjs_require__2(107);
                var path = __w_pdfjs_require__2(38);
                module2.exports = path.Map;
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                var collection = __w_pdfjs_require__2(138);
                var collectionStrong = __w_pdfjs_require__2(142);
                module2.exports = collection("Map", function(init) {
                  return function Map2() {
                    return init(this, arguments.length ? arguments[0] : void 0);
                  };
                }, collectionStrong);
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                var $ = __w_pdfjs_require__2(5);
                var global = __w_pdfjs_require__2(6);
                var isForced = __w_pdfjs_require__2(47);
                var redefine = __w_pdfjs_require__2(24);
                var InternalMetadataModule = __w_pdfjs_require__2(139);
                var iterate = __w_pdfjs_require__2(115);
                var anInstance = __w_pdfjs_require__2(114);
                var isObject = __w_pdfjs_require__2(17);
                var fails = __w_pdfjs_require__2(9);
                var checkCorrectnessOfIteration = __w_pdfjs_require__2(93);
                var setToStringTag = __w_pdfjs_require__2(81);
                var inheritIfRequired = __w_pdfjs_require__2(141);
                module2.exports = function(CONSTRUCTOR_NAME, wrapper, common) {
                  var IS_MAP = CONSTRUCTOR_NAME.indexOf("Map") !== -1;
                  var IS_WEAK = CONSTRUCTOR_NAME.indexOf("Weak") !== -1;
                  var ADDER = IS_MAP ? "set" : "add";
                  var NativeConstructor = global[CONSTRUCTOR_NAME];
                  var NativePrototype = NativeConstructor && NativeConstructor.prototype;
                  var Constructor = NativeConstructor;
                  var exported = {};
                  var fixMethod = function(KEY) {
                    var nativeMethod = NativePrototype[KEY];
                    redefine(NativePrototype, KEY, KEY == "add" ? function add(value) {
                      nativeMethod.call(this, value === 0 ? 0 : value);
                      return this;
                    } : KEY == "delete" ? function(key) {
                      return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
                    } : KEY == "get" ? function get(key) {
                      return IS_WEAK && !isObject(key) ? void 0 : nativeMethod.call(this, key === 0 ? 0 : key);
                    } : KEY == "has" ? function has(key) {
                      return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
                    } : function set(key, value) {
                      nativeMethod.call(this, key === 0 ? 0 : key, value);
                      return this;
                    });
                  };
                  if (isForced(CONSTRUCTOR_NAME, typeof NativeConstructor != "function" || !(IS_WEAK || NativePrototype.forEach && !fails(function() {
                    new NativeConstructor().entries().next();
                  })))) {
                    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
                    InternalMetadataModule.REQUIRED = true;
                  } else if (isForced(CONSTRUCTOR_NAME, true)) {
                    var instance = new Constructor();
                    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
                    var THROWS_ON_PRIMITIVES = fails(function() {
                      instance.has(1);
                    });
                    var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function(iterable) {
                      new NativeConstructor(iterable);
                    });
                    var BUGGY_ZERO = !IS_WEAK && fails(function() {
                      var $instance = new NativeConstructor();
                      var index = 5;
                      while (index--)
                        $instance[ADDER](index, index);
                      return !$instance.has(-0);
                    });
                    if (!ACCEPT_ITERABLES) {
                      Constructor = wrapper(function(dummy, iterable) {
                        anInstance(dummy, Constructor, CONSTRUCTOR_NAME);
                        var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
                        if (iterable != void 0)
                          iterate(iterable, that[ADDER], that, IS_MAP);
                        return that;
                      });
                      Constructor.prototype = NativePrototype;
                      NativePrototype.constructor = Constructor;
                    }
                    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
                      fixMethod("delete");
                      fixMethod("has");
                      IS_MAP && fixMethod("get");
                    }
                    if (BUGGY_ZERO || HASNT_CHAINING)
                      fixMethod(ADDER);
                    if (IS_WEAK && NativePrototype.clear)
                      delete NativePrototype.clear;
                  }
                  exported[CONSTRUCTOR_NAME] = Constructor;
                  $({ global: true, forced: Constructor != NativeConstructor }, exported);
                  setToStringTag(Constructor, CONSTRUCTOR_NAME);
                  if (!IS_WEAK)
                    common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);
                  return Constructor;
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var hiddenKeys = __w_pdfjs_require__2(34);
                var isObject = __w_pdfjs_require__2(17);
                var has = __w_pdfjs_require__2(18);
                var defineProperty = __w_pdfjs_require__2(22).f;
                var uid = __w_pdfjs_require__2(33);
                var FREEZING = __w_pdfjs_require__2(140);
                var METADATA = uid("meta");
                var id = 0;
                var isExtensible = Object.isExtensible || function() {
                  return true;
                };
                var setMetadata = function(it) {
                  defineProperty(it, METADATA, { value: { objectID: "O" + ++id, weakData: {} } });
                };
                var fastKey = function(it, create) {
                  if (!isObject(it))
                    return typeof it == "symbol" ? it : (typeof it == "string" ? "S" : "P") + it;
                  if (!has(it, METADATA)) {
                    if (!isExtensible(it))
                      return "F";
                    if (!create)
                      return "E";
                    setMetadata(it);
                  }
                  return it[METADATA].objectID;
                };
                var getWeakData = function(it, create) {
                  if (!has(it, METADATA)) {
                    if (!isExtensible(it))
                      return true;
                    if (!create)
                      return false;
                    setMetadata(it);
                  }
                  return it[METADATA].weakData;
                };
                var onFreeze = function(it) {
                  if (FREEZING && meta.REQUIRED && isExtensible(it) && !has(it, METADATA))
                    setMetadata(it);
                  return it;
                };
                var meta = module2.exports = { REQUIRED: false, fastKey, getWeakData, onFreeze };
                hiddenKeys[METADATA] = true;
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var fails = __w_pdfjs_require__2(9);
                module2.exports = !fails(function() {
                  return Object.isExtensible(Object.preventExtensions({}));
                });
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var isObject = __w_pdfjs_require__2(17);
                var setPrototypeOf = __w_pdfjs_require__2(83);
                module2.exports = function($this, dummy, Wrapper) {
                  var NewTarget, NewTargetPrototype;
                  if (setPrototypeOf && typeof (NewTarget = dummy.constructor) == "function" && NewTarget !== Wrapper && isObject(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype)
                    setPrototypeOf($this, NewTargetPrototype);
                  return $this;
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                var defineProperty = __w_pdfjs_require__2(22).f;
                var create = __w_pdfjs_require__2(67);
                var redefineAll = __w_pdfjs_require__2(112);
                var bind = __w_pdfjs_require__2(58);
                var anInstance = __w_pdfjs_require__2(114);
                var iterate = __w_pdfjs_require__2(115);
                var defineIterator = __w_pdfjs_require__2(75);
                var setSpecies = __w_pdfjs_require__2(113);
                var DESCRIPTORS = __w_pdfjs_require__2(8);
                var fastKey = __w_pdfjs_require__2(139).fastKey;
                var InternalStateModule = __w_pdfjs_require__2(28);
                var setInternalState = InternalStateModule.set;
                var internalStateGetterFor = InternalStateModule.getterFor;
                module2.exports = { getConstructor: function(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
                  var C = wrapper(function(that, iterable) {
                    anInstance(that, C, CONSTRUCTOR_NAME);
                    setInternalState(that, { type: CONSTRUCTOR_NAME, index: create(null), first: void 0, last: void 0, size: 0 });
                    if (!DESCRIPTORS)
                      that.size = 0;
                    if (iterable != void 0)
                      iterate(iterable, that[ADDER], that, IS_MAP);
                  });
                  var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);
                  var define2 = function(that, key, value) {
                    var state = getInternalState(that);
                    var entry = getEntry(that, key);
                    var previous, index;
                    if (entry) {
                      entry.value = value;
                    } else {
                      state.last = entry = { index: index = fastKey(key, true), key, value, previous: previous = state.last, next: void 0, removed: false };
                      if (!state.first)
                        state.first = entry;
                      if (previous)
                        previous.next = entry;
                      if (DESCRIPTORS)
                        state.size++;
                      else
                        that.size++;
                      if (index !== "F")
                        state.index[index] = entry;
                    }
                    return that;
                  };
                  var getEntry = function(that, key) {
                    var state = getInternalState(that);
                    var index = fastKey(key);
                    var entry;
                    if (index !== "F")
                      return state.index[index];
                    for (entry = state.first; entry; entry = entry.next) {
                      if (entry.key == key)
                        return entry;
                    }
                  };
                  redefineAll(C.prototype, { clear: function clear() {
                    var that = this;
                    var state = getInternalState(that);
                    var data = state.index;
                    var entry = state.first;
                    while (entry) {
                      entry.removed = true;
                      if (entry.previous)
                        entry.previous = entry.previous.next = void 0;
                      delete data[entry.index];
                      entry = entry.next;
                    }
                    state.first = state.last = void 0;
                    if (DESCRIPTORS)
                      state.size = 0;
                    else
                      that.size = 0;
                  }, "delete": function(key) {
                    var that = this;
                    var state = getInternalState(that);
                    var entry = getEntry(that, key);
                    if (entry) {
                      var next = entry.next;
                      var prev = entry.previous;
                      delete state.index[entry.index];
                      entry.removed = true;
                      if (prev)
                        prev.next = next;
                      if (next)
                        next.previous = prev;
                      if (state.first == entry)
                        state.first = next;
                      if (state.last == entry)
                        state.last = prev;
                      if (DESCRIPTORS)
                        state.size--;
                      else
                        that.size--;
                    }
                    return !!entry;
                  }, forEach: function forEach(callbackfn) {
                    var state = getInternalState(this);
                    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : void 0, 3);
                    var entry;
                    while (entry = entry ? entry.next : state.first) {
                      boundFunction(entry.value, entry.key, this);
                      while (entry && entry.removed)
                        entry = entry.previous;
                    }
                  }, has: function has(key) {
                    return !!getEntry(this, key);
                  } });
                  redefineAll(C.prototype, IS_MAP ? { get: function get(key) {
                    var entry = getEntry(this, key);
                    return entry && entry.value;
                  }, set: function set(key, value) {
                    return define2(this, key === 0 ? 0 : key, value);
                  } } : { add: function add(value) {
                    return define2(this, value = value === 0 ? 0 : value, value);
                  } });
                  if (DESCRIPTORS)
                    defineProperty(C.prototype, "size", { get: function() {
                      return getInternalState(this).size;
                    } });
                  return C;
                }, setStrong: function(C, CONSTRUCTOR_NAME, IS_MAP) {
                  var ITERATOR_NAME = CONSTRUCTOR_NAME + " Iterator";
                  var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
                  var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);
                  defineIterator(C, CONSTRUCTOR_NAME, function(iterated, kind) {
                    setInternalState(this, { type: ITERATOR_NAME, target: iterated, state: getInternalCollectionState(iterated), kind, last: void 0 });
                  }, function() {
                    var state = getInternalIteratorState(this);
                    var kind = state.kind;
                    var entry = state.last;
                    while (entry && entry.removed)
                      entry = entry.previous;
                    if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
                      state.target = void 0;
                      return { value: void 0, done: true };
                    }
                    if (kind == "keys")
                      return { value: entry.key, done: false };
                    if (kind == "values")
                      return { value: entry.value, done: false };
                    return { value: [entry.key, entry.value], done: false };
                  }, IS_MAP ? "entries" : "values", !IS_MAP, true);
                  setSpecies(CONSTRUCTOR_NAME);
                } };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                __w_pdfjs_require__2(144);
                __w_pdfjs_require__2(105);
                __w_pdfjs_require__2(73);
                __w_pdfjs_require__2(107);
                var path = __w_pdfjs_require__2(38);
                module2.exports = path.Set;
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                var collection = __w_pdfjs_require__2(138);
                var collectionStrong = __w_pdfjs_require__2(142);
                module2.exports = collection("Set", function(init) {
                  return function Set2() {
                    return init(this, arguments.length ? arguments[0] : void 0);
                  };
                }, collectionStrong);
              }, function(module2, exports2, __w_pdfjs_require__2) {
                __w_pdfjs_require__2(105);
                __w_pdfjs_require__2(146);
                __w_pdfjs_require__2(107);
                var path = __w_pdfjs_require__2(38);
                module2.exports = path.WeakMap;
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                var global = __w_pdfjs_require__2(6);
                var redefineAll = __w_pdfjs_require__2(112);
                var InternalMetadataModule = __w_pdfjs_require__2(139);
                var collection = __w_pdfjs_require__2(138);
                var collectionWeak = __w_pdfjs_require__2(147);
                var isObject = __w_pdfjs_require__2(17);
                var enforceIternalState = __w_pdfjs_require__2(28).enforce;
                var NATIVE_WEAK_MAP = __w_pdfjs_require__2(29);
                var IS_IE11 = !global.ActiveXObject && "ActiveXObject" in global;
                var isExtensible = Object.isExtensible;
                var InternalWeakMap;
                var wrapper = function(init) {
                  return function WeakMap2() {
                    return init(this, arguments.length ? arguments[0] : void 0);
                  };
                };
                var $WeakMap = module2.exports = collection("WeakMap", wrapper, collectionWeak);
                if (NATIVE_WEAK_MAP && IS_IE11) {
                  InternalWeakMap = collectionWeak.getConstructor(wrapper, "WeakMap", true);
                  InternalMetadataModule.REQUIRED = true;
                  var WeakMapPrototype = $WeakMap.prototype;
                  var nativeDelete = WeakMapPrototype["delete"];
                  var nativeHas = WeakMapPrototype.has;
                  var nativeGet = WeakMapPrototype.get;
                  var nativeSet = WeakMapPrototype.set;
                  redefineAll(WeakMapPrototype, { "delete": function(key) {
                    if (isObject(key) && !isExtensible(key)) {
                      var state = enforceIternalState(this);
                      if (!state.frozen)
                        state.frozen = new InternalWeakMap();
                      return nativeDelete.call(this, key) || state.frozen["delete"](key);
                    }
                    return nativeDelete.call(this, key);
                  }, has: function has(key) {
                    if (isObject(key) && !isExtensible(key)) {
                      var state = enforceIternalState(this);
                      if (!state.frozen)
                        state.frozen = new InternalWeakMap();
                      return nativeHas.call(this, key) || state.frozen.has(key);
                    }
                    return nativeHas.call(this, key);
                  }, get: function get(key) {
                    if (isObject(key) && !isExtensible(key)) {
                      var state = enforceIternalState(this);
                      if (!state.frozen)
                        state.frozen = new InternalWeakMap();
                      return nativeHas.call(this, key) ? nativeGet.call(this, key) : state.frozen.get(key);
                    }
                    return nativeGet.call(this, key);
                  }, set: function set(key, value) {
                    if (isObject(key) && !isExtensible(key)) {
                      var state = enforceIternalState(this);
                      if (!state.frozen)
                        state.frozen = new InternalWeakMap();
                      nativeHas.call(this, key) ? nativeSet.call(this, key, value) : state.frozen.set(key, value);
                    } else
                      nativeSet.call(this, key, value);
                    return this;
                  } });
                }
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                var redefineAll = __w_pdfjs_require__2(112);
                var getWeakData = __w_pdfjs_require__2(139).getWeakData;
                var anObject = __w_pdfjs_require__2(23);
                var isObject = __w_pdfjs_require__2(17);
                var anInstance = __w_pdfjs_require__2(114);
                var iterate = __w_pdfjs_require__2(115);
                var ArrayIterationModule = __w_pdfjs_require__2(148);
                var $has = __w_pdfjs_require__2(18);
                var InternalStateModule = __w_pdfjs_require__2(28);
                var setInternalState = InternalStateModule.set;
                var internalStateGetterFor = InternalStateModule.getterFor;
                var find = ArrayIterationModule.find;
                var findIndex = ArrayIterationModule.findIndex;
                var id = 0;
                var uncaughtFrozenStore = function(store) {
                  return store.frozen || (store.frozen = new UncaughtFrozenStore());
                };
                var UncaughtFrozenStore = function() {
                  this.entries = [];
                };
                var findUncaughtFrozen = function(store, key) {
                  return find(store.entries, function(it) {
                    return it[0] === key;
                  });
                };
                UncaughtFrozenStore.prototype = { get: function(key) {
                  var entry = findUncaughtFrozen(this, key);
                  if (entry)
                    return entry[1];
                }, has: function(key) {
                  return !!findUncaughtFrozen(this, key);
                }, set: function(key, value) {
                  var entry = findUncaughtFrozen(this, key);
                  if (entry)
                    entry[1] = value;
                  else
                    this.entries.push([key, value]);
                }, "delete": function(key) {
                  var index = findIndex(this.entries, function(it) {
                    return it[0] === key;
                  });
                  if (~index)
                    this.entries.splice(index, 1);
                  return !!~index;
                } };
                module2.exports = { getConstructor: function(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
                  var C = wrapper(function(that, iterable) {
                    anInstance(that, C, CONSTRUCTOR_NAME);
                    setInternalState(that, { type: CONSTRUCTOR_NAME, id: id++, frozen: void 0 });
                    if (iterable != void 0)
                      iterate(iterable, that[ADDER], that, IS_MAP);
                  });
                  var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);
                  var define2 = function(that, key, value) {
                    var state = getInternalState(that);
                    var data = getWeakData(anObject(key), true);
                    if (data === true)
                      uncaughtFrozenStore(state).set(key, value);
                    else
                      data[state.id] = value;
                    return that;
                  };
                  redefineAll(C.prototype, { "delete": function(key) {
                    var state = getInternalState(this);
                    if (!isObject(key))
                      return false;
                    var data = getWeakData(key);
                    if (data === true)
                      return uncaughtFrozenStore(state)["delete"](key);
                    return data && $has(data, state.id) && delete data[state.id];
                  }, has: function has(key) {
                    var state = getInternalState(this);
                    if (!isObject(key))
                      return false;
                    var data = getWeakData(key);
                    if (data === true)
                      return uncaughtFrozenStore(state).has(key);
                    return data && $has(data, state.id);
                  } });
                  redefineAll(C.prototype, IS_MAP ? { get: function get(key) {
                    var state = getInternalState(this);
                    if (isObject(key)) {
                      var data = getWeakData(key);
                      if (data === true)
                        return uncaughtFrozenStore(state).get(key);
                      return data ? data[state.id] : void 0;
                    }
                  }, set: function set(key, value) {
                    return define2(this, key, value);
                  } } : { add: function add(value) {
                    return define2(this, value, true);
                  } });
                  return C;
                } };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var bind = __w_pdfjs_require__2(58);
                var IndexedObject = __w_pdfjs_require__2(13);
                var toObject = __w_pdfjs_require__2(79);
                var toLength = __w_pdfjs_require__2(42);
                var arraySpeciesCreate = __w_pdfjs_require__2(149);
                var push = [].push;
                var createMethod = function(TYPE) {
                  var IS_MAP = TYPE == 1;
                  var IS_FILTER = TYPE == 2;
                  var IS_SOME = TYPE == 3;
                  var IS_EVERY = TYPE == 4;
                  var IS_FIND_INDEX = TYPE == 6;
                  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
                  return function($this, callbackfn, that, specificCreate) {
                    var O = toObject($this);
                    var self2 = IndexedObject(O);
                    var boundFunction = bind(callbackfn, that, 3);
                    var length = toLength(self2.length);
                    var index = 0;
                    var create = specificCreate || arraySpeciesCreate;
                    var target = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : void 0;
                    var value, result;
                    for (; length > index; index++)
                      if (NO_HOLES || index in self2) {
                        value = self2[index];
                        result = boundFunction(value, index, O);
                        if (TYPE) {
                          if (IS_MAP)
                            target[index] = result;
                          else if (result)
                            switch (TYPE) {
                              case 3:
                                return true;
                              case 5:
                                return value;
                              case 6:
                                return index;
                              case 2:
                                push.call(target, value);
                            }
                          else if (IS_EVERY)
                            return false;
                        }
                      }
                    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
                  };
                };
                module2.exports = { forEach: createMethod(0), map: createMethod(1), filter: createMethod(2), some: createMethod(3), every: createMethod(4), find: createMethod(5), findIndex: createMethod(6) };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var isObject = __w_pdfjs_require__2(17);
                var isArray = __w_pdfjs_require__2(150);
                var wellKnownSymbol = __w_pdfjs_require__2(53);
                var SPECIES = wellKnownSymbol("species");
                module2.exports = function(originalArray, length) {
                  var C;
                  if (isArray(originalArray)) {
                    C = originalArray.constructor;
                    if (typeof C == "function" && (C === Array || isArray(C.prototype)))
                      C = void 0;
                    else if (isObject(C)) {
                      C = C[SPECIES];
                      if (C === null)
                        C = void 0;
                    }
                  }
                  return new (C === void 0 ? Array : C)(length === 0 ? 0 : length);
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var classof = __w_pdfjs_require__2(14);
                module2.exports = Array.isArray || function isArray(arg) {
                  return classof(arg) == "Array";
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                __w_pdfjs_require__2(105);
                __w_pdfjs_require__2(152);
                __w_pdfjs_require__2(107);
                var path = __w_pdfjs_require__2(38);
                module2.exports = path.WeakSet;
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                var collection = __w_pdfjs_require__2(138);
                var collectionWeak = __w_pdfjs_require__2(147);
                collection("WeakSet", function(init) {
                  return function WeakSet2() {
                    return init(this, arguments.length ? arguments[0] : void 0);
                  };
                }, collectionWeak);
              }, function(module2, exports2, __w_pdfjs_require__2) {
                __w_pdfjs_require__2(154);
                var entryUnbind = __w_pdfjs_require__2(57);
                module2.exports = entryUnbind("String", "codePointAt");
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                var $ = __w_pdfjs_require__2(5);
                var codeAt = __w_pdfjs_require__2(74).codeAt;
                $({ target: "String", proto: true }, { codePointAt: function codePointAt(pos) {
                  return codeAt(this, pos);
                } });
              }, function(module2, exports2, __w_pdfjs_require__2) {
                __w_pdfjs_require__2(156);
                var path = __w_pdfjs_require__2(38);
                module2.exports = path.String.fromCodePoint;
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var $ = __w_pdfjs_require__2(5);
                var toAbsoluteIndex = __w_pdfjs_require__2(44);
                var fromCharCode = String.fromCharCode;
                var nativeFromCodePoint = String.fromCodePoint;
                var INCORRECT_LENGTH = !!nativeFromCodePoint && nativeFromCodePoint.length != 1;
                $({ target: "String", stat: true, forced: INCORRECT_LENGTH }, { fromCodePoint: function fromCodePoint(x) {
                  var elements = [];
                  var length = arguments.length;
                  var i = 0;
                  var code;
                  while (length > i) {
                    code = +arguments[i++];
                    if (toAbsoluteIndex(code, 1114111) !== code)
                      throw RangeError(code + " is not a valid code point");
                    elements.push(code < 65536 ? fromCharCode(code) : fromCharCode(((code -= 65536) >> 10) + 55296, code % 1024 + 56320));
                  }
                  return elements.join("");
                } });
              }, function(module2, exports2, __w_pdfjs_require__2) {
                __w_pdfjs_require__2(158);
                __w_pdfjs_require__2(105);
                __w_pdfjs_require__2(160);
                __w_pdfjs_require__2(164);
                __w_pdfjs_require__2(165);
                __w_pdfjs_require__2(166);
                __w_pdfjs_require__2(167);
                __w_pdfjs_require__2(168);
                __w_pdfjs_require__2(169);
                __w_pdfjs_require__2(170);
                __w_pdfjs_require__2(171);
                __w_pdfjs_require__2(172);
                __w_pdfjs_require__2(173);
                __w_pdfjs_require__2(174);
                __w_pdfjs_require__2(175);
                __w_pdfjs_require__2(176);
                __w_pdfjs_require__2(177);
                __w_pdfjs_require__2(178);
                __w_pdfjs_require__2(179);
                var path = __w_pdfjs_require__2(38);
                module2.exports = path.Symbol;
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                var $ = __w_pdfjs_require__2(5);
                var fails = __w_pdfjs_require__2(9);
                var isArray = __w_pdfjs_require__2(150);
                var isObject = __w_pdfjs_require__2(17);
                var toObject = __w_pdfjs_require__2(79);
                var toLength = __w_pdfjs_require__2(42);
                var createProperty = __w_pdfjs_require__2(89);
                var arraySpeciesCreate = __w_pdfjs_require__2(149);
                var arrayMethodHasSpeciesSupport = __w_pdfjs_require__2(159);
                var wellKnownSymbol = __w_pdfjs_require__2(53);
                var V8_VERSION = __w_pdfjs_require__2(125);
                var IS_CONCAT_SPREADABLE = wellKnownSymbol("isConcatSpreadable");
                var MAX_SAFE_INTEGER = 9007199254740991;
                var MAXIMUM_ALLOWED_INDEX_EXCEEDED = "Maximum allowed index exceeded";
                var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function() {
                  var array = [];
                  array[IS_CONCAT_SPREADABLE] = false;
                  return array.concat()[0] !== array;
                });
                var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("concat");
                var isConcatSpreadable = function(O) {
                  if (!isObject(O))
                    return false;
                  var spreadable = O[IS_CONCAT_SPREADABLE];
                  return spreadable !== void 0 ? !!spreadable : isArray(O);
                };
                var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;
                $({ target: "Array", proto: true, forced: FORCED }, { concat: function concat(arg) {
                  var O = toObject(this);
                  var A = arraySpeciesCreate(O, 0);
                  var n = 0;
                  var i, k, length, len, E;
                  for (i = -1, length = arguments.length; i < length; i++) {
                    E = i === -1 ? O : arguments[i];
                    if (isConcatSpreadable(E)) {
                      len = toLength(E.length);
                      if (n + len > MAX_SAFE_INTEGER)
                        throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
                      for (k = 0; k < len; k++, n++)
                        if (k in E)
                          createProperty(A, n, E[k]);
                    } else {
                      if (n >= MAX_SAFE_INTEGER)
                        throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
                      createProperty(A, n++, E);
                    }
                  }
                  A.length = n;
                  return A;
                } });
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var fails = __w_pdfjs_require__2(9);
                var wellKnownSymbol = __w_pdfjs_require__2(53);
                var V8_VERSION = __w_pdfjs_require__2(125);
                var SPECIES = wellKnownSymbol("species");
                module2.exports = function(METHOD_NAME) {
                  return V8_VERSION >= 51 || !fails(function() {
                    var array = [];
                    var constructor = array.constructor = {};
                    constructor[SPECIES] = function() {
                      return { foo: 1 };
                    };
                    return array[METHOD_NAME](Boolean).foo !== 1;
                  });
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                var $ = __w_pdfjs_require__2(5);
                var global = __w_pdfjs_require__2(6);
                var getBuiltIn = __w_pdfjs_require__2(37);
                var IS_PURE = __w_pdfjs_require__2(32);
                var DESCRIPTORS = __w_pdfjs_require__2(8);
                var NATIVE_SYMBOL = __w_pdfjs_require__2(54);
                var USE_SYMBOL_AS_UID = __w_pdfjs_require__2(55);
                var fails = __w_pdfjs_require__2(9);
                var has = __w_pdfjs_require__2(18);
                var isArray = __w_pdfjs_require__2(150);
                var isObject = __w_pdfjs_require__2(17);
                var anObject = __w_pdfjs_require__2(23);
                var toObject = __w_pdfjs_require__2(79);
                var toIndexedObject = __w_pdfjs_require__2(12);
                var toPrimitive = __w_pdfjs_require__2(16);
                var createPropertyDescriptor = __w_pdfjs_require__2(11);
                var nativeObjectCreate = __w_pdfjs_require__2(67);
                var objectKeys = __w_pdfjs_require__2(69);
                var getOwnPropertyNamesModule = __w_pdfjs_require__2(39);
                var getOwnPropertyNamesExternal = __w_pdfjs_require__2(161);
                var getOwnPropertySymbolsModule = __w_pdfjs_require__2(46);
                var getOwnPropertyDescriptorModule = __w_pdfjs_require__2(7);
                var definePropertyModule = __w_pdfjs_require__2(22);
                var propertyIsEnumerableModule = __w_pdfjs_require__2(10);
                var createNonEnumerableProperty = __w_pdfjs_require__2(21);
                var redefine = __w_pdfjs_require__2(24);
                var shared = __w_pdfjs_require__2(31);
                var sharedKey = __w_pdfjs_require__2(30);
                var hiddenKeys = __w_pdfjs_require__2(34);
                var uid = __w_pdfjs_require__2(33);
                var wellKnownSymbol = __w_pdfjs_require__2(53);
                var wrappedWellKnownSymbolModule = __w_pdfjs_require__2(162);
                var defineWellKnownSymbol = __w_pdfjs_require__2(163);
                var setToStringTag = __w_pdfjs_require__2(81);
                var InternalStateModule = __w_pdfjs_require__2(28);
                var $forEach = __w_pdfjs_require__2(148).forEach;
                var HIDDEN = sharedKey("hidden");
                var SYMBOL = "Symbol";
                var PROTOTYPE = "prototype";
                var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
                var setInternalState = InternalStateModule.set;
                var getInternalState = InternalStateModule.getterFor(SYMBOL);
                var ObjectPrototype = Object[PROTOTYPE];
                var $Symbol = global.Symbol;
                var $stringify = getBuiltIn("JSON", "stringify");
                var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
                var nativeDefineProperty = definePropertyModule.f;
                var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
                var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
                var AllSymbols = shared("symbols");
                var ObjectPrototypeSymbols = shared("op-symbols");
                var StringToSymbolRegistry = shared("string-to-symbol-registry");
                var SymbolToStringRegistry = shared("symbol-to-string-registry");
                var WellKnownSymbolsStore = shared("wks");
                var QObject = global.QObject;
                var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
                var setSymbolDescriptor = DESCRIPTORS && fails(function() {
                  return nativeObjectCreate(nativeDefineProperty({}, "a", { get: function() {
                    return nativeDefineProperty(this, "a", { value: 7 }).a;
                  } })).a != 7;
                }) ? function(O, P, Attributes) {
                  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
                  if (ObjectPrototypeDescriptor)
                    delete ObjectPrototype[P];
                  nativeDefineProperty(O, P, Attributes);
                  if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
                    nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
                  }
                } : nativeDefineProperty;
                var wrap = function(tag, description) {
                  var symbol = AllSymbols[tag] = nativeObjectCreate($Symbol[PROTOTYPE]);
                  setInternalState(symbol, { type: SYMBOL, tag, description });
                  if (!DESCRIPTORS)
                    symbol.description = description;
                  return symbol;
                };
                var isSymbol = USE_SYMBOL_AS_UID ? function(it) {
                  return typeof it == "symbol";
                } : function(it) {
                  return Object(it) instanceof $Symbol;
                };
                var $defineProperty = function defineProperty(O, P, Attributes) {
                  if (O === ObjectPrototype)
                    $defineProperty(ObjectPrototypeSymbols, P, Attributes);
                  anObject(O);
                  var key = toPrimitive(P, true);
                  anObject(Attributes);
                  if (has(AllSymbols, key)) {
                    if (!Attributes.enumerable) {
                      if (!has(O, HIDDEN))
                        nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));
                      O[HIDDEN][key] = true;
                    } else {
                      if (has(O, HIDDEN) && O[HIDDEN][key])
                        O[HIDDEN][key] = false;
                      Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
                    }
                    return setSymbolDescriptor(O, key, Attributes);
                  }
                  return nativeDefineProperty(O, key, Attributes);
                };
                var $defineProperties = function defineProperties(O, Properties) {
                  anObject(O);
                  var properties = toIndexedObject(Properties);
                  var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
                  $forEach(keys, function(key) {
                    if (!DESCRIPTORS || $propertyIsEnumerable.call(properties, key))
                      $defineProperty(O, key, properties[key]);
                  });
                  return O;
                };
                var $create = function create(O, Properties) {
                  return Properties === void 0 ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
                };
                var $propertyIsEnumerable = function propertyIsEnumerable(V) {
                  var P = toPrimitive(V, true);
                  var enumerable = nativePropertyIsEnumerable.call(this, P);
                  if (this === ObjectPrototype && has(AllSymbols, P) && !has(ObjectPrototypeSymbols, P))
                    return false;
                  return enumerable || !has(this, P) || !has(AllSymbols, P) || has(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
                };
                var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
                  var it = toIndexedObject(O);
                  var key = toPrimitive(P, true);
                  if (it === ObjectPrototype && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key))
                    return;
                  var descriptor = nativeGetOwnPropertyDescriptor(it, key);
                  if (descriptor && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) {
                    descriptor.enumerable = true;
                  }
                  return descriptor;
                };
                var $getOwnPropertyNames = function getOwnPropertyNames(O) {
                  var names = nativeGetOwnPropertyNames(toIndexedObject(O));
                  var result = [];
                  $forEach(names, function(key) {
                    if (!has(AllSymbols, key) && !has(hiddenKeys, key))
                      result.push(key);
                  });
                  return result;
                };
                var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
                  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
                  var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
                  var result = [];
                  $forEach(names, function(key) {
                    if (has(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || has(ObjectPrototype, key))) {
                      result.push(AllSymbols[key]);
                    }
                  });
                  return result;
                };
                if (!NATIVE_SYMBOL) {
                  $Symbol = function Symbol2() {
                    if (this instanceof $Symbol)
                      throw TypeError("Symbol is not a constructor");
                    var description = !arguments.length || arguments[0] === void 0 ? void 0 : String(arguments[0]);
                    var tag = uid(description);
                    var setter = function(value) {
                      if (this === ObjectPrototype)
                        setter.call(ObjectPrototypeSymbols, value);
                      if (has(this, HIDDEN) && has(this[HIDDEN], tag))
                        this[HIDDEN][tag] = false;
                      setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
                    };
                    if (DESCRIPTORS && USE_SETTER)
                      setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
                    return wrap(tag, description);
                  };
                  redefine($Symbol[PROTOTYPE], "toString", function toString() {
                    return getInternalState(this).tag;
                  });
                  redefine($Symbol, "withoutSetter", function(description) {
                    return wrap(uid(description), description);
                  });
                  propertyIsEnumerableModule.f = $propertyIsEnumerable;
                  definePropertyModule.f = $defineProperty;
                  getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
                  getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
                  getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;
                  wrappedWellKnownSymbolModule.f = function(name) {
                    return wrap(wellKnownSymbol(name), name);
                  };
                  if (DESCRIPTORS) {
                    nativeDefineProperty($Symbol[PROTOTYPE], "description", { configurable: true, get: function description() {
                      return getInternalState(this).description;
                    } });
                    if (!IS_PURE) {
                      redefine(ObjectPrototype, "propertyIsEnumerable", $propertyIsEnumerable, { unsafe: true });
                    }
                  }
                }
                $({ global: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, { Symbol: $Symbol });
                $forEach(objectKeys(WellKnownSymbolsStore), function(name) {
                  defineWellKnownSymbol(name);
                });
                $({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, { "for": function(key) {
                  var string = String(key);
                  if (has(StringToSymbolRegistry, string))
                    return StringToSymbolRegistry[string];
                  var symbol = $Symbol(string);
                  StringToSymbolRegistry[string] = symbol;
                  SymbolToStringRegistry[symbol] = string;
                  return symbol;
                }, keyFor: function keyFor(sym) {
                  if (!isSymbol(sym))
                    throw TypeError(sym + " is not a symbol");
                  if (has(SymbolToStringRegistry, sym))
                    return SymbolToStringRegistry[sym];
                }, useSetter: function() {
                  USE_SETTER = true;
                }, useSimple: function() {
                  USE_SETTER = false;
                } });
                $({ target: "Object", stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, { create: $create, defineProperty: $defineProperty, defineProperties: $defineProperties, getOwnPropertyDescriptor: $getOwnPropertyDescriptor });
                $({ target: "Object", stat: true, forced: !NATIVE_SYMBOL }, { getOwnPropertyNames: $getOwnPropertyNames, getOwnPropertySymbols: $getOwnPropertySymbols });
                $({ target: "Object", stat: true, forced: fails(function() {
                  getOwnPropertySymbolsModule.f(1);
                }) }, { getOwnPropertySymbols: function getOwnPropertySymbols(it) {
                  return getOwnPropertySymbolsModule.f(toObject(it));
                } });
                if ($stringify) {
                  var FORCED_JSON_STRINGIFY = !NATIVE_SYMBOL || fails(function() {
                    var symbol = $Symbol();
                    return $stringify([symbol]) != "[null]" || $stringify({ a: symbol }) != "{}" || $stringify(Object(symbol)) != "{}";
                  });
                  $({ target: "JSON", stat: true, forced: FORCED_JSON_STRINGIFY }, { stringify: function stringify(it, replacer, space) {
                    var args = [it];
                    var index = 1;
                    var $replacer;
                    while (arguments.length > index)
                      args.push(arguments[index++]);
                    $replacer = replacer;
                    if (!isObject(replacer) && it === void 0 || isSymbol(it))
                      return;
                    if (!isArray(replacer))
                      replacer = function(key, value) {
                        if (typeof $replacer == "function")
                          value = $replacer.call(this, key, value);
                        if (!isSymbol(value))
                          return value;
                      };
                    args[1] = replacer;
                    return $stringify.apply(null, args);
                  } });
                }
                if (!$Symbol[PROTOTYPE][TO_PRIMITIVE]) {
                  createNonEnumerableProperty($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
                }
                setToStringTag($Symbol, SYMBOL);
                hiddenKeys[HIDDEN] = true;
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var toIndexedObject = __w_pdfjs_require__2(12);
                var nativeGetOwnPropertyNames = __w_pdfjs_require__2(39).f;
                var toString = {}.toString;
                var windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
                var getWindowNames = function(it) {
                  try {
                    return nativeGetOwnPropertyNames(it);
                  } catch (error) {
                    return windowNames.slice();
                  }
                };
                module2.exports.f = function getOwnPropertyNames(it) {
                  return windowNames && toString.call(it) == "[object Window]" ? getWindowNames(it) : nativeGetOwnPropertyNames(toIndexedObject(it));
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var wellKnownSymbol = __w_pdfjs_require__2(53);
                exports2.f = wellKnownSymbol;
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var path = __w_pdfjs_require__2(38);
                var has = __w_pdfjs_require__2(18);
                var wrappedWellKnownSymbolModule = __w_pdfjs_require__2(162);
                var defineProperty = __w_pdfjs_require__2(22).f;
                module2.exports = function(NAME) {
                  var Symbol2 = path.Symbol || (path.Symbol = {});
                  if (!has(Symbol2, NAME))
                    defineProperty(Symbol2, NAME, { value: wrappedWellKnownSymbolModule.f(NAME) });
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var defineWellKnownSymbol = __w_pdfjs_require__2(163);
                defineWellKnownSymbol("asyncIterator");
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                var $ = __w_pdfjs_require__2(5);
                var DESCRIPTORS = __w_pdfjs_require__2(8);
                var global = __w_pdfjs_require__2(6);
                var has = __w_pdfjs_require__2(18);
                var isObject = __w_pdfjs_require__2(17);
                var defineProperty = __w_pdfjs_require__2(22).f;
                var copyConstructorProperties = __w_pdfjs_require__2(35);
                var NativeSymbol = global.Symbol;
                if (DESCRIPTORS && typeof NativeSymbol == "function" && (!("description" in NativeSymbol.prototype) || NativeSymbol().description !== void 0)) {
                  var EmptyStringDescriptionStore = {};
                  var SymbolWrapper = function Symbol2() {
                    var description = arguments.length < 1 || arguments[0] === void 0 ? void 0 : String(arguments[0]);
                    var result = this instanceof SymbolWrapper ? new NativeSymbol(description) : description === void 0 ? NativeSymbol() : NativeSymbol(description);
                    if (description === "")
                      EmptyStringDescriptionStore[result] = true;
                    return result;
                  };
                  copyConstructorProperties(SymbolWrapper, NativeSymbol);
                  var symbolPrototype = SymbolWrapper.prototype = NativeSymbol.prototype;
                  symbolPrototype.constructor = SymbolWrapper;
                  var symbolToString = symbolPrototype.toString;
                  var native = String(NativeSymbol("test")) == "Symbol(test)";
                  var regexp = /^Symbol\((.*)\)[^)]+$/;
                  defineProperty(symbolPrototype, "description", { configurable: true, get: function description() {
                    var symbol = isObject(this) ? this.valueOf() : this;
                    var string = symbolToString.call(symbol);
                    if (has(EmptyStringDescriptionStore, symbol))
                      return "";
                    var desc = native ? string.slice(7, -1) : string.replace(regexp, "$1");
                    return desc === "" ? void 0 : desc;
                  } });
                  $({ global: true, forced: true }, { Symbol: SymbolWrapper });
                }
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var defineWellKnownSymbol = __w_pdfjs_require__2(163);
                defineWellKnownSymbol("hasInstance");
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var defineWellKnownSymbol = __w_pdfjs_require__2(163);
                defineWellKnownSymbol("isConcatSpreadable");
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var defineWellKnownSymbol = __w_pdfjs_require__2(163);
                defineWellKnownSymbol("iterator");
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var defineWellKnownSymbol = __w_pdfjs_require__2(163);
                defineWellKnownSymbol("match");
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var defineWellKnownSymbol = __w_pdfjs_require__2(163);
                defineWellKnownSymbol("matchAll");
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var defineWellKnownSymbol = __w_pdfjs_require__2(163);
                defineWellKnownSymbol("replace");
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var defineWellKnownSymbol = __w_pdfjs_require__2(163);
                defineWellKnownSymbol("search");
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var defineWellKnownSymbol = __w_pdfjs_require__2(163);
                defineWellKnownSymbol("species");
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var defineWellKnownSymbol = __w_pdfjs_require__2(163);
                defineWellKnownSymbol("split");
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var defineWellKnownSymbol = __w_pdfjs_require__2(163);
                defineWellKnownSymbol("toPrimitive");
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var defineWellKnownSymbol = __w_pdfjs_require__2(163);
                defineWellKnownSymbol("toStringTag");
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var defineWellKnownSymbol = __w_pdfjs_require__2(163);
                defineWellKnownSymbol("unscopables");
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var setToStringTag = __w_pdfjs_require__2(81);
                setToStringTag(Math, "Math", true);
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var global = __w_pdfjs_require__2(6);
                var setToStringTag = __w_pdfjs_require__2(81);
                setToStringTag(global.JSON, "JSON", true);
              }, function(module2, exports2, __w_pdfjs_require__2) {
                __w_pdfjs_require__2(181);
                var entryUnbind = __w_pdfjs_require__2(57);
                module2.exports = entryUnbind("String", "padStart");
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                var $ = __w_pdfjs_require__2(5);
                var $padStart = __w_pdfjs_require__2(182).start;
                var WEBKIT_BUG = __w_pdfjs_require__2(184);
                $({ target: "String", proto: true, forced: WEBKIT_BUG }, { padStart: function padStart(maxLength) {
                  return $padStart(this, maxLength, arguments.length > 1 ? arguments[1] : void 0);
                } });
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var toLength = __w_pdfjs_require__2(42);
                var repeat = __w_pdfjs_require__2(183);
                var requireObjectCoercible = __w_pdfjs_require__2(15);
                var ceil = Math.ceil;
                var createMethod = function(IS_END) {
                  return function($this, maxLength, fillString) {
                    var S = String(requireObjectCoercible($this));
                    var stringLength = S.length;
                    var fillStr = fillString === void 0 ? " " : String(fillString);
                    var intMaxLength = toLength(maxLength);
                    var fillLen, stringFiller;
                    if (intMaxLength <= stringLength || fillStr == "")
                      return S;
                    fillLen = intMaxLength - stringLength;
                    stringFiller = repeat.call(fillStr, ceil(fillLen / fillStr.length));
                    if (stringFiller.length > fillLen)
                      stringFiller = stringFiller.slice(0, fillLen);
                    return IS_END ? S + stringFiller : stringFiller + S;
                  };
                };
                module2.exports = { start: createMethod(false), end: createMethod(true) };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                var toInteger = __w_pdfjs_require__2(43);
                var requireObjectCoercible = __w_pdfjs_require__2(15);
                module2.exports = "".repeat || function repeat(count) {
                  var str = String(requireObjectCoercible(this));
                  var result = "";
                  var n = toInteger(count);
                  if (n < 0 || n == Infinity)
                    throw RangeError("Wrong number of repetitions");
                  for (; n > 0; (n >>>= 1) && (str += str))
                    if (n & 1)
                      result += str;
                  return result;
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var userAgent = __w_pdfjs_require__2(119);
                module2.exports = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent);
              }, function(module2, exports2, __w_pdfjs_require__2) {
                __w_pdfjs_require__2(186);
                var entryUnbind = __w_pdfjs_require__2(57);
                module2.exports = entryUnbind("String", "padEnd");
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                var $ = __w_pdfjs_require__2(5);
                var $padEnd = __w_pdfjs_require__2(182).end;
                var WEBKIT_BUG = __w_pdfjs_require__2(184);
                $({ target: "String", proto: true, forced: WEBKIT_BUG }, { padEnd: function padEnd(maxLength) {
                  return $padEnd(this, maxLength, arguments.length > 1 ? arguments[1] : void 0);
                } });
              }, function(module2, exports2, __w_pdfjs_require__2) {
                __w_pdfjs_require__2(188);
                var path = __w_pdfjs_require__2(38);
                module2.exports = path.Object.values;
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var $ = __w_pdfjs_require__2(5);
                var $values = __w_pdfjs_require__2(189).values;
                $({ target: "Object", stat: true }, { values: function values(O) {
                  return $values(O);
                } });
              }, function(module2, exports2, __w_pdfjs_require__2) {
                var DESCRIPTORS = __w_pdfjs_require__2(8);
                var objectKeys = __w_pdfjs_require__2(69);
                var toIndexedObject = __w_pdfjs_require__2(12);
                var propertyIsEnumerable = __w_pdfjs_require__2(10).f;
                var createMethod = function(TO_ENTRIES) {
                  return function(it) {
                    var O = toIndexedObject(it);
                    var keys = objectKeys(O);
                    var length = keys.length;
                    var i = 0;
                    var result = [];
                    var key;
                    while (length > i) {
                      key = keys[i++];
                      if (!DESCRIPTORS || propertyIsEnumerable.call(O, key)) {
                        result.push(TO_ENTRIES ? [key, O[key]] : O[key]);
                      }
                    }
                    return result;
                  };
                };
                module2.exports = { entries: createMethod(true), values: createMethod(false) };
              }, function(module, exports, __w_pdfjs_require__) {
                "use strict";
                Object.defineProperty(exports, "__esModule", { value: true });
                exports.getDocument = getDocument;
                exports.setPDFNetworkStreamFactory = setPDFNetworkStreamFactory;
                exports.build = exports.version = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFWorker = exports.PDFDataRangeTransport = exports.LoopbackPort = void 0;
                var _regenerator = _interopRequireDefault(__w_pdfjs_require__(191));
                var _util = __w_pdfjs_require__(1);
                var _display_utils = __w_pdfjs_require__(194);
                var _font_loader = __w_pdfjs_require__(195);
                var _api_compatibility = __w_pdfjs_require__(196);
                var _canvas = __w_pdfjs_require__(197);
                var _worker_options = __w_pdfjs_require__(199);
                var _is_node = __w_pdfjs_require__(48);
                var _message_handler = __w_pdfjs_require__(200);
                var _metadata = __w_pdfjs_require__(201);
                var _transport_stream = __w_pdfjs_require__(203);
                var _webgl = __w_pdfjs_require__(204);
                function _interopRequireDefault(obj) {
                  return obj && obj.__esModule ? obj : { "default": obj };
                }
                function _slicedToArray(arr, i) {
                  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
                }
                function _nonIterableRest() {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
                function _iterableToArrayLimit(arr, i) {
                  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
                    return;
                  }
                  var _arr = [];
                  var _n = true;
                  var _d = false;
                  var _e = void 0;
                  try {
                    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                      _arr.push(_s.value);
                      if (i && _arr.length === i)
                        break;
                    }
                  } catch (err) {
                    _d = true;
                    _e = err;
                  } finally {
                    try {
                      if (!_n && _i["return"] != null)
                        _i["return"]();
                    } finally {
                      if (_d)
                        throw _e;
                    }
                  }
                  return _arr;
                }
                function _arrayWithHoles(arr) {
                  if (Array.isArray(arr))
                    return arr;
                }
                function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
                  try {
                    var info = gen[key](arg);
                    var value = info.value;
                  } catch (error) {
                    reject(error);
                    return;
                  }
                  if (info.done) {
                    resolve(value);
                  } else {
                    Promise.resolve(value).then(_next, _throw);
                  }
                }
                function _asyncToGenerator(fn) {
                  return function() {
                    var self2 = this, args = arguments;
                    return new Promise(function(resolve, reject) {
                      var gen = fn.apply(self2, args);
                      function _next(value) {
                        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
                      }
                      function _throw(err) {
                        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
                      }
                      _next(void 0);
                    });
                  };
                }
                function _toConsumableArray(arr) {
                  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
                }
                function _nonIterableSpread() {
                  throw new TypeError("Invalid attempt to spread non-iterable instance");
                }
                function _iterableToArray(iter) {
                  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]")
                    return Array.from(iter);
                }
                function _arrayWithoutHoles(arr) {
                  if (Array.isArray(arr)) {
                    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
                      arr2[i] = arr[i];
                    }
                    return arr2;
                  }
                }
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                  if (protoProps)
                    _defineProperties(Constructor.prototype, protoProps);
                  if (staticProps)
                    _defineProperties(Constructor, staticProps);
                  return Constructor;
                }
                function _typeof(obj) {
                  "@babel/helpers - typeof";
                  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                    _typeof = function _typeof2(obj2) {
                      return typeof obj2;
                    };
                  } else {
                    _typeof = function _typeof2(obj2) {
                      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                    };
                  }
                  return _typeof(obj);
                }
                var DEFAULT_RANGE_CHUNK_SIZE = 65536;
                var RENDERING_CANCELLED_TIMEOUT = 100;
                var createPDFNetworkStream;
                function setPDFNetworkStreamFactory(pdfNetworkStreamFactory) {
                  createPDFNetworkStream = pdfNetworkStreamFactory;
                }
                function getDocument(src) {
                  var task = new PDFDocumentLoadingTask();
                  var source;
                  if (typeof src === "string") {
                    source = { url: src };
                  } else if ((0, _util.isArrayBuffer)(src)) {
                    source = { data: src };
                  } else if (src instanceof PDFDataRangeTransport) {
                    source = { range: src };
                  } else {
                    if (_typeof(src) !== "object") {
                      throw new Error("Invalid parameter in getDocument, need either Uint8Array, string or a parameter object");
                    }
                    if (!src.url && !src.data && !src.range) {
                      throw new Error("Invalid parameter object: need either .data, .range or .url");
                    }
                    source = src;
                  }
                  var params = /* @__PURE__ */ Object.create(null);
                  var rangeTransport = null, worker2 = null;
                  for (var key in source) {
                    if (key === "url" && typeof window !== "undefined") {
                      params[key] = new URL(source[key], window.location).href;
                      continue;
                    } else if (key === "range") {
                      rangeTransport = source[key];
                      continue;
                    } else if (key === "worker") {
                      worker2 = source[key];
                      continue;
                    } else if (key === "data" && !(source[key] instanceof Uint8Array)) {
                      var pdfBytes = source[key];
                      if (typeof pdfBytes === "string") {
                        params[key] = (0, _util.stringToBytes)(pdfBytes);
                      } else if (_typeof(pdfBytes) === "object" && pdfBytes !== null && !isNaN(pdfBytes.length)) {
                        params[key] = new Uint8Array(pdfBytes);
                      } else if ((0, _util.isArrayBuffer)(pdfBytes)) {
                        params[key] = new Uint8Array(pdfBytes);
                      } else {
                        throw new Error("Invalid PDF binary data: either typed array, string or array-like object is expected in the data property.");
                      }
                      continue;
                    }
                    params[key] = source[key];
                  }
                  params.rangeChunkSize = params.rangeChunkSize || DEFAULT_RANGE_CHUNK_SIZE;
                  params.CMapReaderFactory = params.CMapReaderFactory || _display_utils.DOMCMapReaderFactory;
                  params.ignoreErrors = params.stopAtErrors !== true;
                  params.pdfBug = params.pdfBug === true;
                  var NativeImageDecoderValues = Object.values(_util.NativeImageDecoding);
                  if (params.nativeImageDecoderSupport === void 0 || !NativeImageDecoderValues.includes(params.nativeImageDecoderSupport)) {
                    params.nativeImageDecoderSupport = _api_compatibility.apiCompatibilityParams.nativeImageDecoderSupport || _util.NativeImageDecoding.DECODE;
                  }
                  if (!Number.isInteger(params.maxImageSize)) {
                    params.maxImageSize = -1;
                  }
                  if (typeof params.isEvalSupported !== "boolean") {
                    params.isEvalSupported = true;
                  }
                  if (typeof params.disableFontFace !== "boolean") {
                    params.disableFontFace = _api_compatibility.apiCompatibilityParams.disableFontFace || false;
                  }
                  if (typeof params.disableRange !== "boolean") {
                    params.disableRange = false;
                  }
                  if (typeof params.disableStream !== "boolean") {
                    params.disableStream = false;
                  }
                  if (typeof params.disableAutoFetch !== "boolean") {
                    params.disableAutoFetch = false;
                  }
                  if (typeof params.disableCreateObjectURL !== "boolean") {
                    params.disableCreateObjectURL = _api_compatibility.apiCompatibilityParams.disableCreateObjectURL || false;
                  }
                  (0, _util.setVerbosityLevel)(params.verbosity);
                  if (!worker2) {
                    var workerParams = { verbosity: params.verbosity, port: _worker_options.GlobalWorkerOptions.workerPort };
                    worker2 = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams);
                    task._worker = worker2;
                  }
                  var docId = task.docId;
                  worker2.promise.then(function() {
                    if (task.destroyed) {
                      throw new Error("Loading aborted");
                    }
                    return _fetchDocument(worker2, params, rangeTransport, docId).then(function(workerId) {
                      if (task.destroyed) {
                        throw new Error("Loading aborted");
                      }
                      var networkStream;
                      if (rangeTransport) {
                        networkStream = new _transport_stream.PDFDataTransportStream({ length: params.length, initialData: params.initialData, progressiveDone: params.progressiveDone, disableRange: params.disableRange, disableStream: params.disableStream }, rangeTransport);
                      } else if (!params.data) {
                        networkStream = createPDFNetworkStream({ url: params.url, length: params.length, httpHeaders: params.httpHeaders, withCredentials: params.withCredentials, rangeChunkSize: params.rangeChunkSize, disableRange: params.disableRange, disableStream: params.disableStream });
                      }
                      var messageHandler = new _message_handler.MessageHandler(docId, workerId, worker2.port);
                      messageHandler.postMessageTransfers = worker2.postMessageTransfers;
                      var transport = new WorkerTransport(messageHandler, task, networkStream, params);
                      task._transport = transport;
                      messageHandler.send("Ready", null);
                    });
                  })["catch"](task._capability.reject);
                  return task;
                }
                function _fetchDocument(worker2, source, pdfDataRangeTransport, docId) {
                  if (worker2.destroyed) {
                    return Promise.reject(new Error("Worker was destroyed"));
                  }
                  if (pdfDataRangeTransport) {
                    source.length = pdfDataRangeTransport.length;
                    source.initialData = pdfDataRangeTransport.initialData;
                    source.progressiveDone = pdfDataRangeTransport.progressiveDone;
                  }
                  return worker2.messageHandler.sendWithPromise("GetDocRequest", { docId, apiVersion: "2.4.456", source: { data: source.data, url: source.url, password: source.password, disableAutoFetch: source.disableAutoFetch, rangeChunkSize: source.rangeChunkSize, length: source.length }, maxImageSize: source.maxImageSize, disableFontFace: source.disableFontFace, disableCreateObjectURL: source.disableCreateObjectURL, postMessageTransfers: worker2.postMessageTransfers, docBaseUrl: source.docBaseUrl, nativeImageDecoderSupport: source.nativeImageDecoderSupport, ignoreErrors: source.ignoreErrors, isEvalSupported: source.isEvalSupported }).then(function(workerId) {
                    if (worker2.destroyed) {
                      throw new Error("Worker was destroyed");
                    }
                    return workerId;
                  });
                }
                var PDFDocumentLoadingTask = function PDFDocumentLoadingTaskClosure() {
                  var nextDocumentId = 0;
                  var PDFDocumentLoadingTask2 = function() {
                    function PDFDocumentLoadingTask3() {
                      _classCallCheck(this, PDFDocumentLoadingTask3);
                      this._capability = (0, _util.createPromiseCapability)();
                      this._transport = null;
                      this._worker = null;
                      this.docId = "d" + nextDocumentId++;
                      this.destroyed = false;
                      this.onPassword = null;
                      this.onProgress = null;
                      this.onUnsupportedFeature = null;
                    }
                    _createClass(PDFDocumentLoadingTask3, [{ key: "destroy", value: function destroy() {
                      var _this = this;
                      this.destroyed = true;
                      var transportDestroyed = !this._transport ? Promise.resolve() : this._transport.destroy();
                      return transportDestroyed.then(function() {
                        _this._transport = null;
                        if (_this._worker) {
                          _this._worker.destroy();
                          _this._worker = null;
                        }
                      });
                    } }, { key: "then", value: function then(onFulfilled, onRejected) {
                      throw new Error("Removed API method: PDFDocumentLoadingTask.then, use the `promise` getter instead.");
                    } }, { key: "promise", get: function get() {
                      return this._capability.promise;
                    } }]);
                    return PDFDocumentLoadingTask3;
                  }();
                  return PDFDocumentLoadingTask2;
                }();
                var PDFDataRangeTransport = function() {
                  function PDFDataRangeTransport2(length, initialData) {
                    var progressiveDone = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                    _classCallCheck(this, PDFDataRangeTransport2);
                    this.length = length;
                    this.initialData = initialData;
                    this.progressiveDone = progressiveDone;
                    this._rangeListeners = [];
                    this._progressListeners = [];
                    this._progressiveReadListeners = [];
                    this._progressiveDoneListeners = [];
                    this._readyCapability = (0, _util.createPromiseCapability)();
                  }
                  _createClass(PDFDataRangeTransport2, [{ key: "addRangeListener", value: function addRangeListener(listener) {
                    this._rangeListeners.push(listener);
                  } }, { key: "addProgressListener", value: function addProgressListener(listener) {
                    this._progressListeners.push(listener);
                  } }, { key: "addProgressiveReadListener", value: function addProgressiveReadListener(listener) {
                    this._progressiveReadListeners.push(listener);
                  } }, { key: "addProgressiveDoneListener", value: function addProgressiveDoneListener(listener) {
                    this._progressiveDoneListeners.push(listener);
                  } }, { key: "onDataRange", value: function onDataRange(begin, chunk) {
                    var _iteratorNormalCompletion = true;
                    var _didIteratorError = false;
                    var _iteratorError = void 0;
                    try {
                      for (var _iterator = this._rangeListeners[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var listener = _step.value;
                        listener(begin, chunk);
                      }
                    } catch (err) {
                      _didIteratorError = true;
                      _iteratorError = err;
                    } finally {
                      try {
                        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                          _iterator["return"]();
                        }
                      } finally {
                        if (_didIteratorError) {
                          throw _iteratorError;
                        }
                      }
                    }
                  } }, { key: "onDataProgress", value: function onDataProgress(loaded, total) {
                    var _this2 = this;
                    this._readyCapability.promise.then(function() {
                      var _iteratorNormalCompletion2 = true;
                      var _didIteratorError2 = false;
                      var _iteratorError2 = void 0;
                      try {
                        for (var _iterator2 = _this2._progressListeners[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                          var listener = _step2.value;
                          listener(loaded, total);
                        }
                      } catch (err) {
                        _didIteratorError2 = true;
                        _iteratorError2 = err;
                      } finally {
                        try {
                          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                            _iterator2["return"]();
                          }
                        } finally {
                          if (_didIteratorError2) {
                            throw _iteratorError2;
                          }
                        }
                      }
                    });
                  } }, { key: "onDataProgressiveRead", value: function onDataProgressiveRead(chunk) {
                    var _this3 = this;
                    this._readyCapability.promise.then(function() {
                      var _iteratorNormalCompletion3 = true;
                      var _didIteratorError3 = false;
                      var _iteratorError3 = void 0;
                      try {
                        for (var _iterator3 = _this3._progressiveReadListeners[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                          var listener = _step3.value;
                          listener(chunk);
                        }
                      } catch (err) {
                        _didIteratorError3 = true;
                        _iteratorError3 = err;
                      } finally {
                        try {
                          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                            _iterator3["return"]();
                          }
                        } finally {
                          if (_didIteratorError3) {
                            throw _iteratorError3;
                          }
                        }
                      }
                    });
                  } }, { key: "onDataProgressiveDone", value: function onDataProgressiveDone() {
                    var _this4 = this;
                    this._readyCapability.promise.then(function() {
                      var _iteratorNormalCompletion4 = true;
                      var _didIteratorError4 = false;
                      var _iteratorError4 = void 0;
                      try {
                        for (var _iterator4 = _this4._progressiveDoneListeners[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                          var listener = _step4.value;
                          listener();
                        }
                      } catch (err) {
                        _didIteratorError4 = true;
                        _iteratorError4 = err;
                      } finally {
                        try {
                          if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
                            _iterator4["return"]();
                          }
                        } finally {
                          if (_didIteratorError4) {
                            throw _iteratorError4;
                          }
                        }
                      }
                    });
                  } }, { key: "transportReady", value: function transportReady() {
                    this._readyCapability.resolve();
                  } }, { key: "requestDataRange", value: function requestDataRange(begin, end) {
                    (0, _util.unreachable)("Abstract method PDFDataRangeTransport.requestDataRange");
                  } }, { key: "abort", value: function abort() {
                  } }]);
                  return PDFDataRangeTransport2;
                }();
                exports.PDFDataRangeTransport = PDFDataRangeTransport;
                var PDFDocumentProxy = function() {
                  function PDFDocumentProxy2(pdfInfo, transport) {
                    _classCallCheck(this, PDFDocumentProxy2);
                    this._pdfInfo = pdfInfo;
                    this._transport = transport;
                  }
                  _createClass(PDFDocumentProxy2, [{ key: "getPage", value: function getPage(pageNumber) {
                    return this._transport.getPage(pageNumber);
                  } }, { key: "getPageIndex", value: function getPageIndex(ref) {
                    return this._transport.getPageIndex(ref);
                  } }, { key: "getDestinations", value: function getDestinations() {
                    return this._transport.getDestinations();
                  } }, { key: "getDestination", value: function getDestination(id) {
                    return this._transport.getDestination(id);
                  } }, { key: "getPageLabels", value: function getPageLabels() {
                    return this._transport.getPageLabels();
                  } }, { key: "getPageLayout", value: function getPageLayout() {
                    return this._transport.getPageLayout();
                  } }, { key: "getPageMode", value: function getPageMode() {
                    return this._transport.getPageMode();
                  } }, { key: "getViewerPreferences", value: function getViewerPreferences() {
                    return this._transport.getViewerPreferences();
                  } }, { key: "getOpenAction", value: function getOpenAction() {
                    return this._transport.getOpenAction();
                  } }, { key: "getOpenActionDestination", value: function getOpenActionDestination() {
                    (0, _display_utils.deprecated)("getOpenActionDestination, use getOpenAction instead.");
                    return this.getOpenAction().then(function(openAction) {
                      return openAction && openAction.dest ? openAction.dest : null;
                    });
                  } }, { key: "getAttachments", value: function getAttachments() {
                    return this._transport.getAttachments();
                  } }, { key: "getJavaScript", value: function getJavaScript() {
                    return this._transport.getJavaScript();
                  } }, { key: "getOutline", value: function getOutline() {
                    return this._transport.getOutline();
                  } }, { key: "getPermissions", value: function getPermissions() {
                    return this._transport.getPermissions();
                  } }, { key: "getMetadata", value: function getMetadata() {
                    return this._transport.getMetadata();
                  } }, { key: "getData", value: function getData() {
                    return this._transport.getData();
                  } }, { key: "getDownloadInfo", value: function getDownloadInfo() {
                    return this._transport.downloadInfoCapability.promise;
                  } }, { key: "getStats", value: function getStats() {
                    return this._transport.getStats();
                  } }, { key: "cleanup", value: function cleanup() {
                    return this._transport.startCleanup();
                  } }, { key: "destroy", value: function destroy() {
                    return this.loadingTask.destroy();
                  } }, { key: "numPages", get: function get() {
                    return this._pdfInfo.numPages;
                  } }, { key: "fingerprint", get: function get() {
                    return this._pdfInfo.fingerprint;
                  } }, { key: "loadingParams", get: function get() {
                    return this._transport.loadingParams;
                  } }, { key: "loadingTask", get: function get() {
                    return this._transport.loadingTask;
                  } }]);
                  return PDFDocumentProxy2;
                }();
                exports.PDFDocumentProxy = PDFDocumentProxy;
                var PDFPageProxy = function() {
                  function PDFPageProxy2(pageIndex, pageInfo, transport) {
                    var pdfBug = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
                    _classCallCheck(this, PDFPageProxy2);
                    this._pageIndex = pageIndex;
                    this._pageInfo = pageInfo;
                    this._transport = transport;
                    this._stats = pdfBug ? new _display_utils.StatTimer() : null;
                    this._pdfBug = pdfBug;
                    this.commonObjs = transport.commonObjs;
                    this.objs = new PDFObjects();
                    this.cleanupAfterRender = false;
                    this.pendingCleanup = false;
                    this.intentStates = /* @__PURE__ */ Object.create(null);
                    this.destroyed = false;
                  }
                  _createClass(PDFPageProxy2, [{ key: "getViewport", value: function getViewport() {
                    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, scale = _ref.scale, _ref$rotation = _ref.rotation, rotation = _ref$rotation === void 0 ? this.rotate : _ref$rotation, _ref$offsetX = _ref.offsetX, offsetX = _ref$offsetX === void 0 ? 0 : _ref$offsetX, _ref$offsetY = _ref.offsetY, offsetY = _ref$offsetY === void 0 ? 0 : _ref$offsetY, _ref$dontFlip = _ref.dontFlip, dontFlip = _ref$dontFlip === void 0 ? false : _ref$dontFlip;
                    if (arguments.length > 1 || typeof arguments[0] === "number") {
                      throw new Error("PDFPageProxy.getViewport is called with obsolete arguments.");
                    }
                    return new _display_utils.PageViewport({ viewBox: this.view, scale, rotation, offsetX, offsetY, dontFlip });
                  } }, { key: "getAnnotations", value: function getAnnotations() {
                    var _ref2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref2$intent = _ref2.intent, intent = _ref2$intent === void 0 ? null : _ref2$intent;
                    if (!this.annotationsPromise || this.annotationsIntent !== intent) {
                      this.annotationsPromise = this._transport.getAnnotations(this._pageIndex, intent);
                      this.annotationsIntent = intent;
                    }
                    return this.annotationsPromise;
                  } }, { key: "render", value: function render(_ref3) {
                    var _this5 = this;
                    var canvasContext = _ref3.canvasContext, viewport = _ref3.viewport, _ref3$intent = _ref3.intent, intent = _ref3$intent === void 0 ? "display" : _ref3$intent, _ref3$enableWebGL = _ref3.enableWebGL, enableWebGL = _ref3$enableWebGL === void 0 ? false : _ref3$enableWebGL, _ref3$renderInteracti = _ref3.renderInteractiveForms, renderInteractiveForms = _ref3$renderInteracti === void 0 ? false : _ref3$renderInteracti, _ref3$transform = _ref3.transform, transform = _ref3$transform === void 0 ? null : _ref3$transform, _ref3$imageLayer = _ref3.imageLayer, imageLayer = _ref3$imageLayer === void 0 ? null : _ref3$imageLayer, _ref3$canvasFactory = _ref3.canvasFactory, canvasFactory = _ref3$canvasFactory === void 0 ? null : _ref3$canvasFactory, _ref3$background = _ref3.background, background = _ref3$background === void 0 ? null : _ref3$background;
                    if (this._stats) {
                      this._stats.time("Overall");
                    }
                    var renderingIntent = intent === "print" ? "print" : "display";
                    this.pendingCleanup = false;
                    if (!this.intentStates[renderingIntent]) {
                      this.intentStates[renderingIntent] = /* @__PURE__ */ Object.create(null);
                    }
                    var intentState = this.intentStates[renderingIntent];
                    if (intentState.streamReaderCancelTimeout) {
                      clearTimeout(intentState.streamReaderCancelTimeout);
                      intentState.streamReaderCancelTimeout = null;
                    }
                    var canvasFactoryInstance = canvasFactory || new _display_utils.DOMCanvasFactory();
                    var webGLContext = new _webgl.WebGLContext({ enable: enableWebGL });
                    if (!intentState.displayReadyCapability) {
                      intentState.displayReadyCapability = (0, _util.createPromiseCapability)();
                      intentState.operatorList = { fnArray: [], argsArray: [], lastChunk: false };
                      if (this._stats) {
                        this._stats.time("Page Request");
                      }
                      this._pumpOperatorList({ pageIndex: this._pageIndex, intent: renderingIntent, renderInteractiveForms: renderInteractiveForms === true });
                    }
                    var complete = function complete2(error) {
                      var i = intentState.renderTasks.indexOf(internalRenderTask);
                      if (i >= 0) {
                        intentState.renderTasks.splice(i, 1);
                      }
                      if (_this5.cleanupAfterRender || renderingIntent === "print") {
                        _this5.pendingCleanup = true;
                      }
                      _this5._tryCleanup();
                      if (error) {
                        internalRenderTask.capability.reject(error);
                        _this5._abortOperatorList({ intentState, reason: error });
                      } else {
                        internalRenderTask.capability.resolve();
                      }
                      if (_this5._stats) {
                        _this5._stats.timeEnd("Rendering");
                        _this5._stats.timeEnd("Overall");
                      }
                    };
                    var internalRenderTask = new InternalRenderTask({ callback: complete, params: { canvasContext, viewport, transform, imageLayer, background }, objs: this.objs, commonObjs: this.commonObjs, operatorList: intentState.operatorList, pageIndex: this._pageIndex, canvasFactory: canvasFactoryInstance, webGLContext, useRequestAnimationFrame: renderingIntent !== "print", pdfBug: this._pdfBug });
                    if (!intentState.renderTasks) {
                      intentState.renderTasks = [];
                    }
                    intentState.renderTasks.push(internalRenderTask);
                    var renderTask = internalRenderTask.task;
                    intentState.displayReadyCapability.promise.then(function(transparency) {
                      if (_this5.pendingCleanup) {
                        complete();
                        return;
                      }
                      if (_this5._stats) {
                        _this5._stats.time("Rendering");
                      }
                      internalRenderTask.initializeGraphics(transparency);
                      internalRenderTask.operatorListChanged();
                    })["catch"](complete);
                    return renderTask;
                  } }, { key: "getOperatorList", value: function getOperatorList() {
                    function operatorListChanged() {
                      if (intentState.operatorList.lastChunk) {
                        intentState.opListReadCapability.resolve(intentState.operatorList);
                        var i = intentState.renderTasks.indexOf(opListTask);
                        if (i >= 0) {
                          intentState.renderTasks.splice(i, 1);
                        }
                      }
                    }
                    var renderingIntent = "oplist";
                    if (!this.intentStates[renderingIntent]) {
                      this.intentStates[renderingIntent] = /* @__PURE__ */ Object.create(null);
                    }
                    var intentState = this.intentStates[renderingIntent];
                    var opListTask;
                    if (!intentState.opListReadCapability) {
                      opListTask = {};
                      opListTask.operatorListChanged = operatorListChanged;
                      intentState.opListReadCapability = (0, _util.createPromiseCapability)();
                      intentState.renderTasks = [];
                      intentState.renderTasks.push(opListTask);
                      intentState.operatorList = { fnArray: [], argsArray: [], lastChunk: false };
                      if (this._stats) {
                        this._stats.time("Page Request");
                      }
                      this._pumpOperatorList({ pageIndex: this._pageIndex, intent: renderingIntent });
                    }
                    return intentState.opListReadCapability.promise;
                  } }, { key: "streamTextContent", value: function streamTextContent() {
                    var _ref4 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref4$normalizeWhites = _ref4.normalizeWhitespace, normalizeWhitespace = _ref4$normalizeWhites === void 0 ? false : _ref4$normalizeWhites, _ref4$disableCombineT = _ref4.disableCombineTextItems, disableCombineTextItems = _ref4$disableCombineT === void 0 ? false : _ref4$disableCombineT;
                    var TEXT_CONTENT_CHUNK_SIZE = 100;
                    return this._transport.messageHandler.sendWithStream("GetTextContent", { pageIndex: this._pageIndex, normalizeWhitespace: normalizeWhitespace === true, combineTextItems: disableCombineTextItems !== true }, { highWaterMark: TEXT_CONTENT_CHUNK_SIZE, size: function size(textContent) {
                      return textContent.items.length;
                    } });
                  } }, { key: "getTextContent", value: function getTextContent() {
                    var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                    var readableStream = this.streamTextContent(params);
                    return new Promise(function(resolve, reject) {
                      function pump() {
                        reader.read().then(function(_ref5) {
                          var _textContent$items;
                          var value = _ref5.value, done = _ref5.done;
                          if (done) {
                            resolve(textContent);
                            return;
                          }
                          Object.assign(textContent.styles, value.styles);
                          (_textContent$items = textContent.items).push.apply(_textContent$items, _toConsumableArray(value.items));
                          pump();
                        }, reject);
                      }
                      var reader = readableStream.getReader();
                      var textContent = { items: [], styles: /* @__PURE__ */ Object.create(null) };
                      pump();
                    });
                  } }, { key: "_destroy", value: function _destroy() {
                    var _this6 = this;
                    this.destroyed = true;
                    this._transport.pageCache[this._pageIndex] = null;
                    var waitOn = [];
                    Object.keys(this.intentStates).forEach(function(intent) {
                      var intentState = _this6.intentStates[intent];
                      _this6._abortOperatorList({ intentState, reason: new Error("Page was destroyed."), force: true });
                      if (intent === "oplist") {
                        return;
                      }
                      intentState.renderTasks.forEach(function(renderTask) {
                        var renderCompleted = renderTask.capability.promise["catch"](function() {
                        });
                        waitOn.push(renderCompleted);
                        renderTask.cancel();
                      });
                    });
                    this.objs.clear();
                    this.annotationsPromise = null;
                    this.pendingCleanup = false;
                    return Promise.all(waitOn);
                  } }, { key: "cleanup", value: function cleanup() {
                    var resetStats = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                    this.pendingCleanup = true;
                    return this._tryCleanup(resetStats);
                  } }, { key: "_tryCleanup", value: function _tryCleanup() {
                    var _this7 = this;
                    var resetStats = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                    if (!this.pendingCleanup || Object.keys(this.intentStates).some(function(intent) {
                      var intentState = _this7.intentStates[intent];
                      return intentState.renderTasks.length !== 0 || !intentState.operatorList.lastChunk;
                    })) {
                      return false;
                    }
                    Object.keys(this.intentStates).forEach(function(intent) {
                      delete _this7.intentStates[intent];
                    });
                    this.objs.clear();
                    this.annotationsPromise = null;
                    if (resetStats && this._stats) {
                      this._stats = new _display_utils.StatTimer();
                    }
                    this.pendingCleanup = false;
                    return true;
                  } }, { key: "_startRenderPage", value: function _startRenderPage(transparency, intent) {
                    var intentState = this.intentStates[intent];
                    if (!intentState) {
                      return;
                    }
                    if (this._stats) {
                      this._stats.timeEnd("Page Request");
                    }
                    if (intentState.displayReadyCapability) {
                      intentState.displayReadyCapability.resolve(transparency);
                    }
                  } }, { key: "_renderPageChunk", value: function _renderPageChunk(operatorListChunk, intentState) {
                    for (var i = 0, ii = operatorListChunk.length; i < ii; i++) {
                      intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);
                      intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);
                    }
                    intentState.operatorList.lastChunk = operatorListChunk.lastChunk;
                    for (var _i = 0; _i < intentState.renderTasks.length; _i++) {
                      intentState.renderTasks[_i].operatorListChanged();
                    }
                    if (operatorListChunk.lastChunk) {
                      this._tryCleanup();
                    }
                  } }, { key: "_pumpOperatorList", value: function _pumpOperatorList(args) {
                    var _this8 = this;
                    (0, _util.assert)(args.intent, 'PDFPageProxy._pumpOperatorList: Expected "intent" argument.');
                    var readableStream = this._transport.messageHandler.sendWithStream("GetOperatorList", args);
                    var reader = readableStream.getReader();
                    var intentState = this.intentStates[args.intent];
                    intentState.streamReader = reader;
                    var pump = function pump2() {
                      reader.read().then(function(_ref6) {
                        var value = _ref6.value, done = _ref6.done;
                        if (done) {
                          intentState.streamReader = null;
                          return;
                        }
                        if (_this8._transport.destroyed) {
                          return;
                        }
                        _this8._renderPageChunk(value, intentState);
                        pump2();
                      }, function(reason) {
                        intentState.streamReader = null;
                        if (_this8._transport.destroyed) {
                          return;
                        }
                        if (intentState.operatorList) {
                          intentState.operatorList.lastChunk = true;
                          for (var i = 0; i < intentState.renderTasks.length; i++) {
                            intentState.renderTasks[i].operatorListChanged();
                          }
                          _this8._tryCleanup();
                        }
                        if (intentState.displayReadyCapability) {
                          intentState.displayReadyCapability.reject(reason);
                        } else if (intentState.opListReadCapability) {
                          intentState.opListReadCapability.reject(reason);
                        } else {
                          throw reason;
                        }
                      });
                    };
                    pump();
                  } }, { key: "_abortOperatorList", value: function _abortOperatorList(_ref7) {
                    var _this9 = this;
                    var intentState = _ref7.intentState, reason = _ref7.reason, _ref7$force = _ref7.force, force = _ref7$force === void 0 ? false : _ref7$force;
                    (0, _util.assert)(reason instanceof Error || _typeof(reason) === "object" && reason !== null, 'PDFPageProxy._abortOperatorList: Expected "reason" argument.');
                    if (!intentState.streamReader) {
                      return;
                    }
                    if (!force) {
                      if (intentState.renderTasks.length !== 0) {
                        return;
                      }
                      if (reason instanceof _display_utils.RenderingCancelledException) {
                        intentState.streamReaderCancelTimeout = setTimeout(function() {
                          _this9._abortOperatorList({ intentState, reason, force: true });
                          intentState.streamReaderCancelTimeout = null;
                        }, RENDERING_CANCELLED_TIMEOUT);
                        return;
                      }
                    }
                    intentState.streamReader.cancel(new _util.AbortException(reason && reason.message));
                    intentState.streamReader = null;
                    if (this._transport.destroyed) {
                      return;
                    }
                    Object.keys(this.intentStates).some(function(intent) {
                      if (_this9.intentStates[intent] === intentState) {
                        delete _this9.intentStates[intent];
                        return true;
                      }
                      return false;
                    });
                    this.cleanup();
                  } }, { key: "pageNumber", get: function get() {
                    return this._pageIndex + 1;
                  } }, { key: "rotate", get: function get() {
                    return this._pageInfo.rotate;
                  } }, { key: "ref", get: function get() {
                    return this._pageInfo.ref;
                  } }, { key: "userUnit", get: function get() {
                    return this._pageInfo.userUnit;
                  } }, { key: "view", get: function get() {
                    return this._pageInfo.view;
                  } }, { key: "stats", get: function get() {
                    return this._stats;
                  } }]);
                  return PDFPageProxy2;
                }();
                exports.PDFPageProxy = PDFPageProxy;
                var LoopbackPort = function() {
                  function LoopbackPort2() {
                    var defer = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
                    _classCallCheck(this, LoopbackPort2);
                    this._listeners = [];
                    this._defer = defer;
                    this._deferred = Promise.resolve(void 0);
                  }
                  _createClass(LoopbackPort2, [{ key: "postMessage", value: function postMessage2(obj, transfers) {
                    var _this10 = this;
                    function cloneValue(value) {
                      if (_typeof(value) !== "object" || value === null) {
                        return value;
                      }
                      if (cloned.has(value)) {
                        return cloned.get(value);
                      }
                      var buffer, result;
                      if ((buffer = value.buffer) && (0, _util.isArrayBuffer)(buffer)) {
                        var transferable = transfers && transfers.includes(buffer);
                        if (transferable) {
                          result = new value.constructor(buffer, value.byteOffset, value.byteLength);
                        } else {
                          result = new value.constructor(value);
                        }
                        cloned.set(value, result);
                        return result;
                      }
                      result = Array.isArray(value) ? [] : {};
                      cloned.set(value, result);
                      for (var i in value) {
                        var desc = void 0, p = value;
                        while (!(desc = Object.getOwnPropertyDescriptor(p, i))) {
                          p = Object.getPrototypeOf(p);
                        }
                        if (typeof desc.value === "undefined") {
                          continue;
                        }
                        if (typeof desc.value === "function") {
                          if (value.hasOwnProperty && value.hasOwnProperty(i)) {
                            throw new Error("LoopbackPort.postMessage - cannot clone: ".concat(value[i]));
                          }
                          continue;
                        }
                        result[i] = cloneValue(desc.value);
                      }
                      return result;
                    }
                    if (!this._defer) {
                      this._listeners.forEach(function(listener) {
                        listener.call(_this10, { data: obj });
                      });
                      return;
                    }
                    var cloned = /* @__PURE__ */ new WeakMap();
                    var e = { data: cloneValue(obj) };
                    this._deferred.then(function() {
                      _this10._listeners.forEach(function(listener) {
                        listener.call(_this10, e);
                      });
                    });
                  } }, { key: "addEventListener", value: function addEventListener(name, listener) {
                    this._listeners.push(listener);
                  } }, { key: "removeEventListener", value: function removeEventListener(name, listener) {
                    var i = this._listeners.indexOf(listener);
                    this._listeners.splice(i, 1);
                  } }, { key: "terminate", value: function terminate() {
                    this._listeners.length = 0;
                  } }]);
                  return LoopbackPort2;
                }();
                exports.LoopbackPort = LoopbackPort;
                var PDFWorker = function PDFWorkerClosure() {
                  var pdfWorkerPorts = /* @__PURE__ */ new WeakMap();
                  var isWorkerDisabled = false;
                  var fallbackWorkerSrc;
                  var nextFakeWorkerId = 0;
                  var fakeWorkerCapability;
                  if (_is_node.isNodeJS && true) {
                    isWorkerDisabled = true;
                    fallbackWorkerSrc = "./pdf.worker.js";
                  } else if ((typeof document === "undefined" ? "undefined" : _typeof(document)) === "object" && "currentScript" in document) {
                    var pdfjsFilePath = document.currentScript && document.currentScript.src;
                    if (pdfjsFilePath) {
                      fallbackWorkerSrc = pdfjsFilePath.replace(/(\.(?:min\.)?js)(\?.*)?$/i, ".worker$1$2");
                    }
                  }
                  function _getWorkerSrc() {
                    if (_worker_options.GlobalWorkerOptions.workerSrc) {
                      return _worker_options.GlobalWorkerOptions.workerSrc;
                    }
                    if (typeof fallbackWorkerSrc !== "undefined") {
                      if (!_is_node.isNodeJS) {
                        (0, _display_utils.deprecated)('No "GlobalWorkerOptions.workerSrc" specified.');
                      }
                      return fallbackWorkerSrc;
                    }
                    throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
                  }
                  function getMainThreadWorkerMessageHandler() {
                    var mainWorkerMessageHandler2;
                    try {
                      mainWorkerMessageHandler2 = globalThis.pdfjsWorker && globalThis.pdfjsWorker.WorkerMessageHandler;
                    } catch (ex) {
                    }
                    return mainWorkerMessageHandler2 || null;
                  }
                  function setupFakeWorkerGlobal() {
                    if (fakeWorkerCapability) {
                      return fakeWorkerCapability.promise;
                    }
                    fakeWorkerCapability = (0, _util.createPromiseCapability)();
                    var loader = function() {
                      var _ref8 = _asyncToGenerator(_regenerator["default"].mark(function _callee() {
                        var mainWorkerMessageHandler, worker;
                        return _regenerator["default"].wrap(function _callee$(_context) {
                          while (1) {
                            switch (_context.prev = _context.next) {
                              case 0:
                                mainWorkerMessageHandler = getMainThreadWorkerMessageHandler();
                                if (!mainWorkerMessageHandler) {
                                  _context.next = 3;
                                  break;
                                }
                                return _context.abrupt("return", mainWorkerMessageHandler);
                              case 3:
                                if (!(_is_node.isNodeJS && true)) {
                                  _context.next = 6;
                                  break;
                                }
                                worker = eval("require")(_getWorkerSrc());
                                return _context.abrupt("return", worker.WorkerMessageHandler);
                              case 6:
                                _context.next = 8;
                                return (0, _display_utils.loadScript)(_getWorkerSrc());
                              case 8:
                                return _context.abrupt("return", window.pdfjsWorker.WorkerMessageHandler);
                              case 9:
                              case "end":
                                return _context.stop();
                            }
                          }
                        }, _callee);
                      }));
                      return function loader2() {
                        return _ref8.apply(this, arguments);
                      };
                    }();
                    loader().then(fakeWorkerCapability.resolve, fakeWorkerCapability.reject);
                    return fakeWorkerCapability.promise;
                  }
                  function createCDNWrapper(url) {
                    var wrapper = "importScripts('" + url + "');";
                    return URL.createObjectURL(new Blob([wrapper]));
                  }
                  var PDFWorker = function() {
                    function PDFWorker2() {
                      var _ref9 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref9$name = _ref9.name, name = _ref9$name === void 0 ? null : _ref9$name, _ref9$port = _ref9.port, port = _ref9$port === void 0 ? null : _ref9$port, _ref9$verbosity = _ref9.verbosity, verbosity = _ref9$verbosity === void 0 ? (0, _util.getVerbosityLevel)() : _ref9$verbosity;
                      _classCallCheck(this, PDFWorker2);
                      if (port && pdfWorkerPorts.has(port)) {
                        throw new Error("Cannot use more than one PDFWorker per port");
                      }
                      this.name = name;
                      this.destroyed = false;
                      this.postMessageTransfers = true;
                      this.verbosity = verbosity;
                      this._readyCapability = (0, _util.createPromiseCapability)();
                      this._port = null;
                      this._webWorker = null;
                      this._messageHandler = null;
                      if (port) {
                        pdfWorkerPorts.set(port, this);
                        this._initializeFromPort(port);
                        return;
                      }
                      this._initialize();
                    }
                    _createClass(PDFWorker2, [{ key: "_initializeFromPort", value: function _initializeFromPort(port) {
                      this._port = port;
                      this._messageHandler = new _message_handler.MessageHandler("main", "worker", port);
                      this._messageHandler.on("ready", function() {
                      });
                      this._readyCapability.resolve();
                    } }, { key: "_initialize", value: function _initialize() {
                      var _this11 = this;
                      if (typeof Worker !== "undefined" && !isWorkerDisabled && !getMainThreadWorkerMessageHandler()) {
                        var workerSrc = _getWorkerSrc();
                        try {
                          if (!(0, _util.isSameOrigin)(window.location.href, workerSrc)) {
                            workerSrc = createCDNWrapper(new URL(workerSrc, window.location).href);
                          }
                          var worker2 = new Worker(workerSrc);
                          var messageHandler = new _message_handler.MessageHandler("main", "worker", worker2);
                          var terminateEarly = function terminateEarly2() {
                            worker2.removeEventListener("error", onWorkerError);
                            messageHandler.destroy();
                            worker2.terminate();
                            if (_this11.destroyed) {
                              _this11._readyCapability.reject(new Error("Worker was destroyed"));
                            } else {
                              _this11._setupFakeWorker();
                            }
                          };
                          var onWorkerError = function onWorkerError2() {
                            if (!_this11._webWorker) {
                              terminateEarly();
                            }
                          };
                          worker2.addEventListener("error", onWorkerError);
                          messageHandler.on("test", function(data) {
                            worker2.removeEventListener("error", onWorkerError);
                            if (_this11.destroyed) {
                              terminateEarly();
                              return;
                            }
                            if (data) {
                              _this11._messageHandler = messageHandler;
                              _this11._port = worker2;
                              _this11._webWorker = worker2;
                              if (!data.supportTransfers) {
                                _this11.postMessageTransfers = false;
                              }
                              _this11._readyCapability.resolve();
                              messageHandler.send("configure", { verbosity: _this11.verbosity });
                            } else {
                              _this11._setupFakeWorker();
                              messageHandler.destroy();
                              worker2.terminate();
                            }
                          });
                          messageHandler.on("ready", function(data) {
                            worker2.removeEventListener("error", onWorkerError);
                            if (_this11.destroyed) {
                              terminateEarly();
                              return;
                            }
                            try {
                              sendTest();
                            } catch (e) {
                              _this11._setupFakeWorker();
                            }
                          });
                          var sendTest = function sendTest2() {
                            var testObj = new Uint8Array([_this11.postMessageTransfers ? 255 : 0]);
                            try {
                              messageHandler.send("test", testObj, [testObj.buffer]);
                            } catch (ex) {
                              (0, _util.warn)("Cannot use postMessage transfers.");
                              testObj[0] = 0;
                              messageHandler.send("test", testObj);
                            }
                          };
                          sendTest();
                          return;
                        } catch (e) {
                          (0, _util.info)("The worker has been disabled.");
                        }
                      }
                      this._setupFakeWorker();
                    } }, { key: "_setupFakeWorker", value: function _setupFakeWorker() {
                      var _this12 = this;
                      if (!isWorkerDisabled) {
                        (0, _util.warn)("Setting up fake worker.");
                        isWorkerDisabled = true;
                      }
                      setupFakeWorkerGlobal().then(function(WorkerMessageHandler) {
                        if (_this12.destroyed) {
                          _this12._readyCapability.reject(new Error("Worker was destroyed"));
                          return;
                        }
                        var port = new LoopbackPort();
                        _this12._port = port;
                        var id = "fake" + nextFakeWorkerId++;
                        var workerHandler = new _message_handler.MessageHandler(id + "_worker", id, port);
                        WorkerMessageHandler.setup(workerHandler, port);
                        var messageHandler = new _message_handler.MessageHandler(id, id + "_worker", port);
                        _this12._messageHandler = messageHandler;
                        _this12._readyCapability.resolve();
                        messageHandler.send("configure", { verbosity: _this12.verbosity });
                      })["catch"](function(reason) {
                        _this12._readyCapability.reject(new Error('Setting up fake worker failed: "'.concat(reason.message, '".')));
                      });
                    } }, { key: "destroy", value: function destroy() {
                      this.destroyed = true;
                      if (this._webWorker) {
                        this._webWorker.terminate();
                        this._webWorker = null;
                      }
                      pdfWorkerPorts["delete"](this._port);
                      this._port = null;
                      if (this._messageHandler) {
                        this._messageHandler.destroy();
                        this._messageHandler = null;
                      }
                    } }, { key: "promise", get: function get() {
                      return this._readyCapability.promise;
                    } }, { key: "port", get: function get() {
                      return this._port;
                    } }, { key: "messageHandler", get: function get() {
                      return this._messageHandler;
                    } }], [{ key: "fromPort", value: function fromPort(params) {
                      if (!params || !params.port) {
                        throw new Error("PDFWorker.fromPort - invalid method signature.");
                      }
                      if (pdfWorkerPorts.has(params.port)) {
                        return pdfWorkerPorts.get(params.port);
                      }
                      return new PDFWorker2(params);
                    } }, { key: "getWorkerSrc", value: function getWorkerSrc2() {
                      return _getWorkerSrc();
                    } }]);
                    return PDFWorker2;
                  }();
                  return PDFWorker;
                }();
                exports.PDFWorker = PDFWorker;
                var WorkerTransport = function() {
                  function WorkerTransport2(messageHandler, loadingTask, networkStream, params) {
                    _classCallCheck(this, WorkerTransport2);
                    this.messageHandler = messageHandler;
                    this.loadingTask = loadingTask;
                    this.commonObjs = new PDFObjects();
                    this.fontLoader = new _font_loader.FontLoader({ docId: loadingTask.docId, onUnsupportedFeature: this._onUnsupportedFeature.bind(this) });
                    this._params = params;
                    this.CMapReaderFactory = new params.CMapReaderFactory({ baseUrl: params.cMapUrl, isCompressed: params.cMapPacked });
                    this.destroyed = false;
                    this.destroyCapability = null;
                    this._passwordCapability = null;
                    this._networkStream = networkStream;
                    this._fullReader = null;
                    this._lastProgress = null;
                    this.pageCache = [];
                    this.pagePromises = [];
                    this.downloadInfoCapability = (0, _util.createPromiseCapability)();
                    this.setupMessageHandler();
                  }
                  _createClass(WorkerTransport2, [{ key: "destroy", value: function destroy() {
                    var _this13 = this;
                    if (this.destroyCapability) {
                      return this.destroyCapability.promise;
                    }
                    this.destroyed = true;
                    this.destroyCapability = (0, _util.createPromiseCapability)();
                    if (this._passwordCapability) {
                      this._passwordCapability.reject(new Error("Worker was destroyed during onPassword callback"));
                    }
                    var waitOn = [];
                    this.pageCache.forEach(function(page) {
                      if (page) {
                        waitOn.push(page._destroy());
                      }
                    });
                    this.pageCache.length = 0;
                    this.pagePromises.length = 0;
                    var terminated = this.messageHandler.sendWithPromise("Terminate", null);
                    waitOn.push(terminated);
                    Promise.all(waitOn).then(function() {
                      _this13.fontLoader.clear();
                      if (_this13._networkStream) {
                        _this13._networkStream.cancelAllRequests(new _util.AbortException("Worker was terminated."));
                      }
                      if (_this13.messageHandler) {
                        _this13.messageHandler.destroy();
                        _this13.messageHandler = null;
                      }
                      _this13.destroyCapability.resolve();
                    }, this.destroyCapability.reject);
                    return this.destroyCapability.promise;
                  } }, { key: "setupMessageHandler", value: function setupMessageHandler() {
                    var _this14 = this;
                    var messageHandler = this.messageHandler, loadingTask = this.loadingTask;
                    messageHandler.on("GetReader", function(data, sink) {
                      (0, _util.assert)(_this14._networkStream);
                      _this14._fullReader = _this14._networkStream.getFullReader();
                      _this14._fullReader.onProgress = function(evt) {
                        _this14._lastProgress = { loaded: evt.loaded, total: evt.total };
                      };
                      sink.onPull = function() {
                        _this14._fullReader.read().then(function(_ref10) {
                          var value = _ref10.value, done = _ref10.done;
                          if (done) {
                            sink.close();
                            return;
                          }
                          (0, _util.assert)((0, _util.isArrayBuffer)(value));
                          sink.enqueue(new Uint8Array(value), 1, [value]);
                        })["catch"](function(reason) {
                          sink.error(reason);
                        });
                      };
                      sink.onCancel = function(reason) {
                        _this14._fullReader.cancel(reason);
                      };
                    });
                    messageHandler.on("ReaderHeadersReady", function(data) {
                      var headersCapability = (0, _util.createPromiseCapability)();
                      var fullReader = _this14._fullReader;
                      fullReader.headersReady.then(function() {
                        if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {
                          if (_this14._lastProgress && loadingTask.onProgress) {
                            loadingTask.onProgress(_this14._lastProgress);
                          }
                          fullReader.onProgress = function(evt) {
                            if (loadingTask.onProgress) {
                              loadingTask.onProgress({ loaded: evt.loaded, total: evt.total });
                            }
                          };
                        }
                        headersCapability.resolve({ isStreamingSupported: fullReader.isStreamingSupported, isRangeSupported: fullReader.isRangeSupported, contentLength: fullReader.contentLength });
                      }, headersCapability.reject);
                      return headersCapability.promise;
                    });
                    messageHandler.on("GetRangeReader", function(data, sink) {
                      (0, _util.assert)(_this14._networkStream);
                      var rangeReader = _this14._networkStream.getRangeReader(data.begin, data.end);
                      if (!rangeReader) {
                        sink.close();
                        return;
                      }
                      sink.onPull = function() {
                        rangeReader.read().then(function(_ref11) {
                          var value = _ref11.value, done = _ref11.done;
                          if (done) {
                            sink.close();
                            return;
                          }
                          (0, _util.assert)((0, _util.isArrayBuffer)(value));
                          sink.enqueue(new Uint8Array(value), 1, [value]);
                        })["catch"](function(reason) {
                          sink.error(reason);
                        });
                      };
                      sink.onCancel = function(reason) {
                        rangeReader.cancel(reason);
                      };
                    });
                    messageHandler.on("GetDoc", function(_ref12) {
                      var pdfInfo = _ref12.pdfInfo;
                      _this14._numPages = pdfInfo.numPages;
                      loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, _this14));
                    });
                    messageHandler.on("DocException", function(ex) {
                      var reason;
                      switch (ex.name) {
                        case "PasswordException":
                          reason = new _util.PasswordException(ex.message, ex.code);
                          break;
                        case "InvalidPDFException":
                          reason = new _util.InvalidPDFException(ex.message);
                          break;
                        case "MissingPDFException":
                          reason = new _util.MissingPDFException(ex.message);
                          break;
                        case "UnexpectedResponseException":
                          reason = new _util.UnexpectedResponseException(ex.message, ex.status);
                          break;
                        case "UnknownErrorException":
                          reason = new _util.UnknownErrorException(ex.message, ex.details);
                          break;
                      }
                      loadingTask._capability.reject(reason);
                    });
                    messageHandler.on("PasswordRequest", function(exception) {
                      _this14._passwordCapability = (0, _util.createPromiseCapability)();
                      if (loadingTask.onPassword) {
                        var updatePassword = function updatePassword2(password) {
                          _this14._passwordCapability.resolve({ password });
                        };
                        try {
                          loadingTask.onPassword(updatePassword, exception.code);
                        } catch (ex) {
                          _this14._passwordCapability.reject(ex);
                        }
                      } else {
                        _this14._passwordCapability.reject(new _util.PasswordException(exception.message, exception.code));
                      }
                      return _this14._passwordCapability.promise;
                    });
                    messageHandler.on("DataLoaded", function(data) {
                      if (loadingTask.onProgress) {
                        loadingTask.onProgress({ loaded: data.length, total: data.length });
                      }
                      _this14.downloadInfoCapability.resolve(data);
                    });
                    messageHandler.on("StartRenderPage", function(data) {
                      if (_this14.destroyed) {
                        return;
                      }
                      var page = _this14.pageCache[data.pageIndex];
                      page._startRenderPage(data.transparency, data.intent);
                    });
                    messageHandler.on("commonobj", function(data) {
                      if (_this14.destroyed) {
                        return;
                      }
                      var _data = _slicedToArray(data, 3), id = _data[0], type = _data[1], exportedData = _data[2];
                      if (_this14.commonObjs.has(id)) {
                        return;
                      }
                      switch (type) {
                        case "Font":
                          var params = _this14._params;
                          if ("error" in exportedData) {
                            var exportedError = exportedData.error;
                            (0, _util.warn)("Error during font loading: ".concat(exportedError));
                            _this14.commonObjs.resolve(id, exportedError);
                            break;
                          }
                          var fontRegistry = null;
                          if (params.pdfBug && globalThis.FontInspector && globalThis.FontInspector.enabled) {
                            fontRegistry = { registerFont: function registerFont(font2, url) {
                              globalThis.FontInspector.fontAdded(font2, url);
                            } };
                          }
                          var font = new _font_loader.FontFaceObject(exportedData, { isEvalSupported: params.isEvalSupported, disableFontFace: params.disableFontFace, ignoreErrors: params.ignoreErrors, onUnsupportedFeature: _this14._onUnsupportedFeature.bind(_this14), fontRegistry });
                          _this14.fontLoader.bind(font).then(function() {
                            _this14.commonObjs.resolve(id, font);
                          }, function(reason) {
                            messageHandler.sendWithPromise("FontFallback", { id })["finally"](function() {
                              _this14.commonObjs.resolve(id, font);
                            });
                          });
                          break;
                        case "FontPath":
                        case "FontType3Res":
                          _this14.commonObjs.resolve(id, exportedData);
                          break;
                        default:
                          throw new Error("Got unknown common object type ".concat(type));
                      }
                    });
                    messageHandler.on("obj", function(data) {
                      if (_this14.destroyed) {
                        return void 0;
                      }
                      var _data2 = _slicedToArray(data, 4), id = _data2[0], pageIndex = _data2[1], type = _data2[2], imageData = _data2[3];
                      var pageProxy = _this14.pageCache[pageIndex];
                      if (pageProxy.objs.has(id)) {
                        return void 0;
                      }
                      switch (type) {
                        case "JpegStream":
                          return new Promise(function(resolve, reject) {
                            var img = new Image();
                            img.onload = function() {
                              resolve(img);
                            };
                            img.onerror = function() {
                              reject(new Error("Error during JPEG image loading"));
                              (0, _display_utils.releaseImageResources)(img);
                            };
                            img.src = imageData;
                          }).then(function(img) {
                            pageProxy.objs.resolve(id, img);
                          });
                        case "Image":
                          pageProxy.objs.resolve(id, imageData);
                          var MAX_IMAGE_SIZE_TO_STORE = 8e6;
                          if (imageData && "data" in imageData && imageData.data.length > MAX_IMAGE_SIZE_TO_STORE) {
                            pageProxy.cleanupAfterRender = true;
                          }
                          break;
                        default:
                          throw new Error("Got unknown object type ".concat(type));
                      }
                      return void 0;
                    });
                    messageHandler.on("DocProgress", function(data) {
                      if (_this14.destroyed) {
                        return;
                      }
                      if (loadingTask.onProgress) {
                        loadingTask.onProgress({ loaded: data.loaded, total: data.total });
                      }
                    });
                    messageHandler.on("UnsupportedFeature", this._onUnsupportedFeature.bind(this));
                    messageHandler.on("JpegDecode", function(data) {
                      if (_this14.destroyed) {
                        return Promise.reject(new Error("Worker was destroyed"));
                      }
                      if (typeof document === "undefined") {
                        return Promise.reject(new Error('"document" is not defined.'));
                      }
                      var _data3 = _slicedToArray(data, 2), imageUrl = _data3[0], components = _data3[1];
                      if (components !== 3 && components !== 1) {
                        return Promise.reject(new Error("Only 3 components or 1 component can be returned"));
                      }
                      return new Promise(function(resolve, reject) {
                        var img = new Image();
                        img.onload = function() {
                          var width = img.width, height = img.height;
                          var size = width * height;
                          var rgbaLength = size * 4;
                          var buf = new Uint8ClampedArray(size * components);
                          var tmpCanvas = document.createElement("canvas");
                          tmpCanvas.width = width;
                          tmpCanvas.height = height;
                          var tmpCtx = tmpCanvas.getContext("2d");
                          tmpCtx.drawImage(img, 0, 0);
                          var data2 = tmpCtx.getImageData(0, 0, width, height).data;
                          if (components === 3) {
                            for (var i = 0, j = 0; i < rgbaLength; i += 4, j += 3) {
                              buf[j] = data2[i];
                              buf[j + 1] = data2[i + 1];
                              buf[j + 2] = data2[i + 2];
                            }
                          } else if (components === 1) {
                            for (var _i2 = 0, _j = 0; _i2 < rgbaLength; _i2 += 4, _j++) {
                              buf[_j] = data2[_i2];
                            }
                          }
                          resolve({ data: buf, width, height });
                          (0, _display_utils.releaseImageResources)(img);
                          tmpCanvas.width = 0;
                          tmpCanvas.height = 0;
                          tmpCanvas = null;
                          tmpCtx = null;
                        };
                        img.onerror = function() {
                          reject(new Error("JpegDecode failed to load image"));
                          (0, _display_utils.releaseImageResources)(img);
                        };
                        img.src = imageUrl;
                      });
                    });
                    messageHandler.on("FetchBuiltInCMap", function(data, sink) {
                      if (_this14.destroyed) {
                        sink.error(new Error("Worker was destroyed"));
                        return;
                      }
                      var fetched = false;
                      sink.onPull = function() {
                        if (fetched) {
                          sink.close();
                          return;
                        }
                        fetched = true;
                        _this14.CMapReaderFactory.fetch(data).then(function(builtInCMap) {
                          sink.enqueue(builtInCMap, 1, [builtInCMap.cMapData.buffer]);
                        })["catch"](function(reason) {
                          sink.error(reason);
                        });
                      };
                    });
                  } }, { key: "_onUnsupportedFeature", value: function _onUnsupportedFeature(_ref13) {
                    var featureId = _ref13.featureId;
                    if (this.destroyed) {
                      return;
                    }
                    if (this.loadingTask.onUnsupportedFeature) {
                      this.loadingTask.onUnsupportedFeature(featureId);
                    }
                  } }, { key: "getData", value: function getData() {
                    return this.messageHandler.sendWithPromise("GetData", null);
                  } }, { key: "getPage", value: function getPage(pageNumber) {
                    var _this15 = this;
                    if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {
                      return Promise.reject(new Error("Invalid page request"));
                    }
                    var pageIndex = pageNumber - 1;
                    if (pageIndex in this.pagePromises) {
                      return this.pagePromises[pageIndex];
                    }
                    var promise = this.messageHandler.sendWithPromise("GetPage", { pageIndex }).then(function(pageInfo) {
                      if (_this15.destroyed) {
                        throw new Error("Transport destroyed");
                      }
                      var page = new PDFPageProxy(pageIndex, pageInfo, _this15, _this15._params.pdfBug);
                      _this15.pageCache[pageIndex] = page;
                      return page;
                    });
                    this.pagePromises[pageIndex] = promise;
                    return promise;
                  } }, { key: "getPageIndex", value: function getPageIndex(ref) {
                    return this.messageHandler.sendWithPromise("GetPageIndex", { ref })["catch"](function(reason) {
                      return Promise.reject(new Error(reason));
                    });
                  } }, { key: "getAnnotations", value: function getAnnotations(pageIndex, intent) {
                    return this.messageHandler.sendWithPromise("GetAnnotations", { pageIndex, intent });
                  } }, { key: "getDestinations", value: function getDestinations() {
                    return this.messageHandler.sendWithPromise("GetDestinations", null);
                  } }, { key: "getDestination", value: function getDestination(id) {
                    if (typeof id !== "string") {
                      return Promise.reject(new Error("Invalid destination request."));
                    }
                    return this.messageHandler.sendWithPromise("GetDestination", { id });
                  } }, { key: "getPageLabels", value: function getPageLabels() {
                    return this.messageHandler.sendWithPromise("GetPageLabels", null);
                  } }, { key: "getPageLayout", value: function getPageLayout() {
                    return this.messageHandler.sendWithPromise("GetPageLayout", null);
                  } }, { key: "getPageMode", value: function getPageMode() {
                    return this.messageHandler.sendWithPromise("GetPageMode", null);
                  } }, { key: "getViewerPreferences", value: function getViewerPreferences() {
                    return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
                  } }, { key: "getOpenAction", value: function getOpenAction() {
                    return this.messageHandler.sendWithPromise("GetOpenAction", null);
                  } }, { key: "getAttachments", value: function getAttachments() {
                    return this.messageHandler.sendWithPromise("GetAttachments", null);
                  } }, { key: "getJavaScript", value: function getJavaScript() {
                    return this.messageHandler.sendWithPromise("GetJavaScript", null);
                  } }, { key: "getOutline", value: function getOutline() {
                    return this.messageHandler.sendWithPromise("GetOutline", null);
                  } }, { key: "getPermissions", value: function getPermissions() {
                    return this.messageHandler.sendWithPromise("GetPermissions", null);
                  } }, { key: "getMetadata", value: function getMetadata() {
                    var _this16 = this;
                    return this.messageHandler.sendWithPromise("GetMetadata", null).then(function(results) {
                      return { info: results[0], metadata: results[1] ? new _metadata.Metadata(results[1]) : null, contentDispositionFilename: _this16._fullReader ? _this16._fullReader.filename : null };
                    });
                  } }, { key: "getStats", value: function getStats() {
                    return this.messageHandler.sendWithPromise("GetStats", null);
                  } }, { key: "startCleanup", value: function startCleanup() {
                    var _this17 = this;
                    return this.messageHandler.sendWithPromise("Cleanup", null).then(function() {
                      for (var i = 0, ii = _this17.pageCache.length; i < ii; i++) {
                        var page = _this17.pageCache[i];
                        if (page) {
                          var cleanupSuccessful = page.cleanup();
                          if (!cleanupSuccessful) {
                            throw new Error("startCleanup: Page ".concat(i + 1, " is currently rendering."));
                          }
                        }
                      }
                      _this17.commonObjs.clear();
                      _this17.fontLoader.clear();
                    });
                  } }, { key: "loadingParams", get: function get() {
                    var params = this._params;
                    return (0, _util.shadow)(this, "loadingParams", { disableAutoFetch: params.disableAutoFetch, disableCreateObjectURL: params.disableCreateObjectURL, disableFontFace: params.disableFontFace, nativeImageDecoderSupport: params.nativeImageDecoderSupport });
                  } }]);
                  return WorkerTransport2;
                }();
                var PDFObjects = function() {
                  function PDFObjects2() {
                    _classCallCheck(this, PDFObjects2);
                    this._objs = /* @__PURE__ */ Object.create(null);
                  }
                  _createClass(PDFObjects2, [{ key: "_ensureObj", value: function _ensureObj(objId) {
                    if (this._objs[objId]) {
                      return this._objs[objId];
                    }
                    return this._objs[objId] = { capability: (0, _util.createPromiseCapability)(), data: null, resolved: false };
                  } }, { key: "get", value: function get(objId) {
                    var callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                    if (callback) {
                      this._ensureObj(objId).capability.promise.then(callback);
                      return null;
                    }
                    var obj = this._objs[objId];
                    if (!obj || !obj.resolved) {
                      throw new Error("Requesting object that isn't resolved yet ".concat(objId, "."));
                    }
                    return obj.data;
                  } }, { key: "has", value: function has(objId) {
                    var obj = this._objs[objId];
                    return obj ? obj.resolved : false;
                  } }, { key: "resolve", value: function resolve(objId, data) {
                    var obj = this._ensureObj(objId);
                    obj.resolved = true;
                    obj.data = data;
                    obj.capability.resolve(data);
                  } }, { key: "clear", value: function clear() {
                    for (var objId in this._objs) {
                      var data = this._objs[objId].data;
                      if (typeof Image !== "undefined" && data instanceof Image) {
                        (0, _display_utils.releaseImageResources)(data);
                      }
                    }
                    this._objs = /* @__PURE__ */ Object.create(null);
                  } }]);
                  return PDFObjects2;
                }();
                var RenderTask = function() {
                  function RenderTask2(internalRenderTask) {
                    _classCallCheck(this, RenderTask2);
                    this._internalRenderTask = internalRenderTask;
                    this.onContinue = null;
                  }
                  _createClass(RenderTask2, [{ key: "cancel", value: function cancel() {
                    this._internalRenderTask.cancel();
                  } }, { key: "then", value: function then(onFulfilled, onRejected) {
                    throw new Error("Removed API method: RenderTask.then, use the `promise` getter instead.");
                  } }, { key: "promise", get: function get() {
                    return this._internalRenderTask.capability.promise;
                  } }]);
                  return RenderTask2;
                }();
                var InternalRenderTask = function InternalRenderTaskClosure() {
                  var canvasInRendering = /* @__PURE__ */ new WeakSet();
                  var InternalRenderTask2 = function() {
                    function InternalRenderTask3(_ref14) {
                      var callback = _ref14.callback, params = _ref14.params, objs = _ref14.objs, commonObjs = _ref14.commonObjs, operatorList = _ref14.operatorList, pageIndex = _ref14.pageIndex, canvasFactory = _ref14.canvasFactory, webGLContext = _ref14.webGLContext, _ref14$useRequestAnim = _ref14.useRequestAnimationFrame, useRequestAnimationFrame = _ref14$useRequestAnim === void 0 ? false : _ref14$useRequestAnim, _ref14$pdfBug = _ref14.pdfBug, pdfBug = _ref14$pdfBug === void 0 ? false : _ref14$pdfBug;
                      _classCallCheck(this, InternalRenderTask3);
                      this.callback = callback;
                      this.params = params;
                      this.objs = objs;
                      this.commonObjs = commonObjs;
                      this.operatorListIdx = null;
                      this.operatorList = operatorList;
                      this._pageIndex = pageIndex;
                      this.canvasFactory = canvasFactory;
                      this.webGLContext = webGLContext;
                      this._pdfBug = pdfBug;
                      this.running = false;
                      this.graphicsReadyCallback = null;
                      this.graphicsReady = false;
                      this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== "undefined";
                      this.cancelled = false;
                      this.capability = (0, _util.createPromiseCapability)();
                      this.task = new RenderTask(this);
                      this._continueBound = this._continue.bind(this);
                      this._scheduleNextBound = this._scheduleNext.bind(this);
                      this._nextBound = this._next.bind(this);
                      this._canvas = params.canvasContext.canvas;
                    }
                    _createClass(InternalRenderTask3, [{ key: "initializeGraphics", value: function initializeGraphics() {
                      var transparency = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                      if (this.cancelled) {
                        return;
                      }
                      if (this._canvas) {
                        if (canvasInRendering.has(this._canvas)) {
                          throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");
                        }
                        canvasInRendering.add(this._canvas);
                      }
                      if (this._pdfBug && globalThis.StepperManager && globalThis.StepperManager.enabled) {
                        this.stepper = globalThis.StepperManager.create(this._pageIndex);
                        this.stepper.init(this.operatorList);
                        this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();
                      }
                      var _this$params = this.params, canvasContext = _this$params.canvasContext, viewport = _this$params.viewport, transform = _this$params.transform, imageLayer = _this$params.imageLayer, background = _this$params.background;
                      this.gfx = new _canvas.CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, this.webGLContext, imageLayer);
                      this.gfx.beginDrawing({ transform, viewport, transparency, background });
                      this.operatorListIdx = 0;
                      this.graphicsReady = true;
                      if (this.graphicsReadyCallback) {
                        this.graphicsReadyCallback();
                      }
                    } }, { key: "cancel", value: function cancel() {
                      var error = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
                      this.running = false;
                      this.cancelled = true;
                      if (this.gfx) {
                        this.gfx.endDrawing();
                      }
                      if (this._canvas) {
                        canvasInRendering["delete"](this._canvas);
                      }
                      this.callback(error || new _display_utils.RenderingCancelledException("Rendering cancelled, page ".concat(this._pageIndex + 1), "canvas"));
                    } }, { key: "operatorListChanged", value: function operatorListChanged() {
                      if (!this.graphicsReady) {
                        if (!this.graphicsReadyCallback) {
                          this.graphicsReadyCallback = this._continueBound;
                        }
                        return;
                      }
                      if (this.stepper) {
                        this.stepper.updateOperatorList(this.operatorList);
                      }
                      if (this.running) {
                        return;
                      }
                      this._continue();
                    } }, { key: "_continue", value: function _continue() {
                      this.running = true;
                      if (this.cancelled) {
                        return;
                      }
                      if (this.task.onContinue) {
                        this.task.onContinue(this._scheduleNextBound);
                      } else {
                        this._scheduleNext();
                      }
                    } }, { key: "_scheduleNext", value: function _scheduleNext() {
                      var _this18 = this;
                      if (this._useRequestAnimationFrame) {
                        window.requestAnimationFrame(function() {
                          _this18._nextBound()["catch"](_this18.cancel.bind(_this18));
                        });
                      } else {
                        Promise.resolve().then(this._nextBound)["catch"](this.cancel.bind(this));
                      }
                    } }, { key: "_next", value: function() {
                      var _next2 = _asyncToGenerator(_regenerator["default"].mark(function _callee2() {
                        return _regenerator["default"].wrap(function _callee2$(_context2) {
                          while (1) {
                            switch (_context2.prev = _context2.next) {
                              case 0:
                                if (!this.cancelled) {
                                  _context2.next = 2;
                                  break;
                                }
                                return _context2.abrupt("return");
                              case 2:
                                this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);
                                if (this.operatorListIdx === this.operatorList.argsArray.length) {
                                  this.running = false;
                                  if (this.operatorList.lastChunk) {
                                    this.gfx.endDrawing();
                                    if (this._canvas) {
                                      canvasInRendering["delete"](this._canvas);
                                    }
                                    this.callback();
                                  }
                                }
                              case 4:
                              case "end":
                                return _context2.stop();
                            }
                          }
                        }, _callee2, this);
                      }));
                      function _next() {
                        return _next2.apply(this, arguments);
                      }
                      return _next;
                    }() }]);
                    return InternalRenderTask3;
                  }();
                  return InternalRenderTask2;
                }();
                var version = "2.4.456";
                exports.version = version;
                var build = "228a591c";
                exports.build = build;
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                module2.exports = __w_pdfjs_require__2(192);
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                (function(module3) {
                  function _typeof2(obj) {
                    "@babel/helpers - typeof";
                    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                      _typeof2 = function _typeof3(obj2) {
                        return typeof obj2;
                      };
                    } else {
                      _typeof2 = function _typeof3(obj2) {
                        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                      };
                    }
                    return _typeof2(obj);
                  }
                  var runtime = function(exports3) {
                    "use strict";
                    var Op = Object.prototype;
                    var hasOwn = Op.hasOwnProperty;
                    var undefined2;
                    var $Symbol = typeof Symbol === "function" ? Symbol : {};
                    var iteratorSymbol = $Symbol.iterator || "@@iterator";
                    var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
                    var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
                    function wrap(innerFn, outerFn, self2, tryLocsList) {
                      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
                      var generator = Object.create(protoGenerator.prototype);
                      var context = new Context(tryLocsList || []);
                      generator._invoke = makeInvokeMethod(innerFn, self2, context);
                      return generator;
                    }
                    exports3.wrap = wrap;
                    function tryCatch(fn, obj, arg) {
                      try {
                        return { type: "normal", arg: fn.call(obj, arg) };
                      } catch (err) {
                        return { type: "throw", arg: err };
                      }
                    }
                    var GenStateSuspendedStart = "suspendedStart";
                    var GenStateSuspendedYield = "suspendedYield";
                    var GenStateExecuting = "executing";
                    var GenStateCompleted = "completed";
                    var ContinueSentinel = {};
                    function Generator() {
                    }
                    function GeneratorFunction() {
                    }
                    function GeneratorFunctionPrototype() {
                    }
                    var IteratorPrototype = {};
                    IteratorPrototype[iteratorSymbol] = function() {
                      return this;
                    };
                    var getProto = Object.getPrototypeOf;
                    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
                    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
                      IteratorPrototype = NativeIteratorPrototype;
                    }
                    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
                    GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
                    GeneratorFunctionPrototype.constructor = GeneratorFunction;
                    GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";
                    function defineIteratorMethods(prototype) {
                      ["next", "throw", "return"].forEach(function(method) {
                        prototype[method] = function(arg) {
                          return this._invoke(method, arg);
                        };
                      });
                    }
                    exports3.isGeneratorFunction = function(genFun) {
                      var ctor = typeof genFun === "function" && genFun.constructor;
                      return ctor ? ctor === GeneratorFunction || (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
                    };
                    exports3.mark = function(genFun) {
                      if (Object.setPrototypeOf) {
                        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
                      } else {
                        genFun.__proto__ = GeneratorFunctionPrototype;
                        if (!(toStringTagSymbol in genFun)) {
                          genFun[toStringTagSymbol] = "GeneratorFunction";
                        }
                      }
                      genFun.prototype = Object.create(Gp);
                      return genFun;
                    };
                    exports3.awrap = function(arg) {
                      return { __await: arg };
                    };
                    function AsyncIterator(generator, PromiseImpl) {
                      function invoke(method, arg, resolve, reject) {
                        var record = tryCatch(generator[method], generator, arg);
                        if (record.type === "throw") {
                          reject(record.arg);
                        } else {
                          var result = record.arg;
                          var value = result.value;
                          if (value && _typeof2(value) === "object" && hasOwn.call(value, "__await")) {
                            return PromiseImpl.resolve(value.__await).then(function(value2) {
                              invoke("next", value2, resolve, reject);
                            }, function(err) {
                              invoke("throw", err, resolve, reject);
                            });
                          }
                          return PromiseImpl.resolve(value).then(function(unwrapped) {
                            result.value = unwrapped;
                            resolve(result);
                          }, function(error) {
                            return invoke("throw", error, resolve, reject);
                          });
                        }
                      }
                      var previousPromise;
                      function enqueue(method, arg) {
                        function callInvokeWithMethodAndArg() {
                          return new PromiseImpl(function(resolve, reject) {
                            invoke(method, arg, resolve, reject);
                          });
                        }
                        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
                      }
                      this._invoke = enqueue;
                    }
                    defineIteratorMethods(AsyncIterator.prototype);
                    AsyncIterator.prototype[asyncIteratorSymbol] = function() {
                      return this;
                    };
                    exports3.AsyncIterator = AsyncIterator;
                    exports3.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
                      if (PromiseImpl === void 0)
                        PromiseImpl = Promise;
                      var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
                      return exports3.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
                        return result.done ? result.value : iter.next();
                      });
                    };
                    function makeInvokeMethod(innerFn, self2, context) {
                      var state = GenStateSuspendedStart;
                      return function invoke(method, arg) {
                        if (state === GenStateExecuting) {
                          throw new Error("Generator is already running");
                        }
                        if (state === GenStateCompleted) {
                          if (method === "throw") {
                            throw arg;
                          }
                          return doneResult();
                        }
                        context.method = method;
                        context.arg = arg;
                        while (true) {
                          var delegate = context.delegate;
                          if (delegate) {
                            var delegateResult = maybeInvokeDelegate(delegate, context);
                            if (delegateResult) {
                              if (delegateResult === ContinueSentinel)
                                continue;
                              return delegateResult;
                            }
                          }
                          if (context.method === "next") {
                            context.sent = context._sent = context.arg;
                          } else if (context.method === "throw") {
                            if (state === GenStateSuspendedStart) {
                              state = GenStateCompleted;
                              throw context.arg;
                            }
                            context.dispatchException(context.arg);
                          } else if (context.method === "return") {
                            context.abrupt("return", context.arg);
                          }
                          state = GenStateExecuting;
                          var record = tryCatch(innerFn, self2, context);
                          if (record.type === "normal") {
                            state = context.done ? GenStateCompleted : GenStateSuspendedYield;
                            if (record.arg === ContinueSentinel) {
                              continue;
                            }
                            return { value: record.arg, done: context.done };
                          } else if (record.type === "throw") {
                            state = GenStateCompleted;
                            context.method = "throw";
                            context.arg = record.arg;
                          }
                        }
                      };
                    }
                    function maybeInvokeDelegate(delegate, context) {
                      var method = delegate.iterator[context.method];
                      if (method === undefined2) {
                        context.delegate = null;
                        if (context.method === "throw") {
                          if (delegate.iterator["return"]) {
                            context.method = "return";
                            context.arg = undefined2;
                            maybeInvokeDelegate(delegate, context);
                            if (context.method === "throw") {
                              return ContinueSentinel;
                            }
                          }
                          context.method = "throw";
                          context.arg = new TypeError("The iterator does not provide a 'throw' method");
                        }
                        return ContinueSentinel;
                      }
                      var record = tryCatch(method, delegate.iterator, context.arg);
                      if (record.type === "throw") {
                        context.method = "throw";
                        context.arg = record.arg;
                        context.delegate = null;
                        return ContinueSentinel;
                      }
                      var info = record.arg;
                      if (!info) {
                        context.method = "throw";
                        context.arg = new TypeError("iterator result is not an object");
                        context.delegate = null;
                        return ContinueSentinel;
                      }
                      if (info.done) {
                        context[delegate.resultName] = info.value;
                        context.next = delegate.nextLoc;
                        if (context.method !== "return") {
                          context.method = "next";
                          context.arg = undefined2;
                        }
                      } else {
                        return info;
                      }
                      context.delegate = null;
                      return ContinueSentinel;
                    }
                    defineIteratorMethods(Gp);
                    Gp[toStringTagSymbol] = "Generator";
                    Gp[iteratorSymbol] = function() {
                      return this;
                    };
                    Gp.toString = function() {
                      return "[object Generator]";
                    };
                    function pushTryEntry(locs) {
                      var entry = { tryLoc: locs[0] };
                      if (1 in locs) {
                        entry.catchLoc = locs[1];
                      }
                      if (2 in locs) {
                        entry.finallyLoc = locs[2];
                        entry.afterLoc = locs[3];
                      }
                      this.tryEntries.push(entry);
                    }
                    function resetTryEntry(entry) {
                      var record = entry.completion || {};
                      record.type = "normal";
                      delete record.arg;
                      entry.completion = record;
                    }
                    function Context(tryLocsList) {
                      this.tryEntries = [{ tryLoc: "root" }];
                      tryLocsList.forEach(pushTryEntry, this);
                      this.reset(true);
                    }
                    exports3.keys = function(object) {
                      var keys = [];
                      for (var key in object) {
                        keys.push(key);
                      }
                      keys.reverse();
                      return function next() {
                        while (keys.length) {
                          var key2 = keys.pop();
                          if (key2 in object) {
                            next.value = key2;
                            next.done = false;
                            return next;
                          }
                        }
                        next.done = true;
                        return next;
                      };
                    };
                    function values(iterable) {
                      if (iterable) {
                        var iteratorMethod = iterable[iteratorSymbol];
                        if (iteratorMethod) {
                          return iteratorMethod.call(iterable);
                        }
                        if (typeof iterable.next === "function") {
                          return iterable;
                        }
                        if (!isNaN(iterable.length)) {
                          var i = -1, next = function next2() {
                            while (++i < iterable.length) {
                              if (hasOwn.call(iterable, i)) {
                                next2.value = iterable[i];
                                next2.done = false;
                                return next2;
                              }
                            }
                            next2.value = undefined2;
                            next2.done = true;
                            return next2;
                          };
                          return next.next = next;
                        }
                      }
                      return { next: doneResult };
                    }
                    exports3.values = values;
                    function doneResult() {
                      return { value: undefined2, done: true };
                    }
                    Context.prototype = { constructor: Context, reset: function reset(skipTempReset) {
                      this.prev = 0;
                      this.next = 0;
                      this.sent = this._sent = undefined2;
                      this.done = false;
                      this.delegate = null;
                      this.method = "next";
                      this.arg = undefined2;
                      this.tryEntries.forEach(resetTryEntry);
                      if (!skipTempReset) {
                        for (var name in this) {
                          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
                            this[name] = undefined2;
                          }
                        }
                      }
                    }, stop: function stop() {
                      this.done = true;
                      var rootEntry = this.tryEntries[0];
                      var rootRecord = rootEntry.completion;
                      if (rootRecord.type === "throw") {
                        throw rootRecord.arg;
                      }
                      return this.rval;
                    }, dispatchException: function dispatchException(exception) {
                      if (this.done) {
                        throw exception;
                      }
                      var context = this;
                      function handle(loc, caught) {
                        record.type = "throw";
                        record.arg = exception;
                        context.next = loc;
                        if (caught) {
                          context.method = "next";
                          context.arg = undefined2;
                        }
                        return !!caught;
                      }
                      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                        var entry = this.tryEntries[i];
                        var record = entry.completion;
                        if (entry.tryLoc === "root") {
                          return handle("end");
                        }
                        if (entry.tryLoc <= this.prev) {
                          var hasCatch = hasOwn.call(entry, "catchLoc");
                          var hasFinally = hasOwn.call(entry, "finallyLoc");
                          if (hasCatch && hasFinally) {
                            if (this.prev < entry.catchLoc) {
                              return handle(entry.catchLoc, true);
                            } else if (this.prev < entry.finallyLoc) {
                              return handle(entry.finallyLoc);
                            }
                          } else if (hasCatch) {
                            if (this.prev < entry.catchLoc) {
                              return handle(entry.catchLoc, true);
                            }
                          } else if (hasFinally) {
                            if (this.prev < entry.finallyLoc) {
                              return handle(entry.finallyLoc);
                            }
                          } else {
                            throw new Error("try statement without catch or finally");
                          }
                        }
                      }
                    }, abrupt: function abrupt(type, arg) {
                      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                        var entry = this.tryEntries[i];
                        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
                          var finallyEntry = entry;
                          break;
                        }
                      }
                      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
                        finallyEntry = null;
                      }
                      var record = finallyEntry ? finallyEntry.completion : {};
                      record.type = type;
                      record.arg = arg;
                      if (finallyEntry) {
                        this.method = "next";
                        this.next = finallyEntry.finallyLoc;
                        return ContinueSentinel;
                      }
                      return this.complete(record);
                    }, complete: function complete(record, afterLoc) {
                      if (record.type === "throw") {
                        throw record.arg;
                      }
                      if (record.type === "break" || record.type === "continue") {
                        this.next = record.arg;
                      } else if (record.type === "return") {
                        this.rval = this.arg = record.arg;
                        this.method = "return";
                        this.next = "end";
                      } else if (record.type === "normal" && afterLoc) {
                        this.next = afterLoc;
                      }
                      return ContinueSentinel;
                    }, finish: function finish(finallyLoc) {
                      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                        var entry = this.tryEntries[i];
                        if (entry.finallyLoc === finallyLoc) {
                          this.complete(entry.completion, entry.afterLoc);
                          resetTryEntry(entry);
                          return ContinueSentinel;
                        }
                      }
                    }, "catch": function _catch(tryLoc) {
                      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                        var entry = this.tryEntries[i];
                        if (entry.tryLoc === tryLoc) {
                          var record = entry.completion;
                          if (record.type === "throw") {
                            var thrown = record.arg;
                            resetTryEntry(entry);
                          }
                          return thrown;
                        }
                      }
                      throw new Error("illegal catch attempt");
                    }, delegateYield: function delegateYield(iterable, resultName, nextLoc) {
                      this.delegate = { iterator: values(iterable), resultName, nextLoc };
                      if (this.method === "next") {
                        this.arg = undefined2;
                      }
                      return ContinueSentinel;
                    } };
                    return exports3;
                  }((false ? 0 : _typeof2(module3)) === "object" ? module3.exports : {});
                  try {
                    regeneratorRuntime = runtime;
                  } catch (accidentalStrictMode) {
                    Function("r", "regeneratorRuntime = r")(runtime);
                  }
                }).call(this, __w_pdfjs_require__2(193)(module2));
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                module2.exports = function(module3) {
                  if (!module3.webpackPolyfill) {
                    module3.deprecate = function() {
                    };
                    module3.paths = [];
                    if (!module3.children)
                      module3.children = [];
                    Object.defineProperty(module3, "loaded", { enumerable: true, get: function get() {
                      return module3.l;
                    } });
                    Object.defineProperty(module3, "id", { enumerable: true, get: function get() {
                      return module3.i;
                    } });
                    module3.webpackPolyfill = 1;
                  }
                  return module3;
                };
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.addLinkAttributes = addLinkAttributes;
                exports2.getFilenameFromUrl = getFilenameFromUrl;
                exports2.isFetchSupported = isFetchSupported;
                exports2.isValidFetchUrl = isValidFetchUrl;
                exports2.loadScript = loadScript;
                exports2.deprecated = deprecated;
                exports2.releaseImageResources = releaseImageResources;
                exports2.PDFDateString = exports2.StatTimer = exports2.DOMSVGFactory = exports2.DOMCMapReaderFactory = exports2.DOMCanvasFactory = exports2.DEFAULT_LINK_REL = exports2.LinkTarget = exports2.RenderingCancelledException = exports2.PageViewport = void 0;
                var _regenerator2 = _interopRequireDefault2(__w_pdfjs_require__2(191));
                var _util2 = __w_pdfjs_require__2(1);
                function _interopRequireDefault2(obj) {
                  return obj && obj.__esModule ? obj : { "default": obj };
                }
                function _typeof2(obj) {
                  "@babel/helpers - typeof";
                  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                    _typeof2 = function _typeof3(obj2) {
                      return typeof obj2;
                    };
                  } else {
                    _typeof2 = function _typeof3(obj2) {
                      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                    };
                  }
                  return _typeof2(obj);
                }
                function _possibleConstructorReturn(self2, call) {
                  if (call && (_typeof2(call) === "object" || typeof call === "function")) {
                    return call;
                  }
                  return _assertThisInitialized(self2);
                }
                function _assertThisInitialized(self2) {
                  if (self2 === void 0) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  }
                  return self2;
                }
                function _getPrototypeOf(o) {
                  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                    return o2.__proto__ || Object.getPrototypeOf(o2);
                  };
                  return _getPrototypeOf(o);
                }
                function _inherits(subClass, superClass) {
                  if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function");
                  }
                  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
                  if (superClass)
                    _setPrototypeOf(subClass, superClass);
                }
                function _setPrototypeOf(o, p) {
                  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                    o2.__proto__ = p2;
                    return o2;
                  };
                  return _setPrototypeOf(o, p);
                }
                function asyncGeneratorStep2(gen, resolve, reject, _next, _throw, key, arg) {
                  try {
                    var info = gen[key](arg);
                    var value = info.value;
                  } catch (error) {
                    reject(error);
                    return;
                  }
                  if (info.done) {
                    resolve(value);
                  } else {
                    Promise.resolve(value).then(_next, _throw);
                  }
                }
                function _asyncToGenerator2(fn) {
                  return function() {
                    var self2 = this, args = arguments;
                    return new Promise(function(resolve, reject) {
                      var gen = fn.apply(self2, args);
                      function _next(value) {
                        asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "next", value);
                      }
                      function _throw(err) {
                        asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "throw", err);
                      }
                      _next(void 0);
                    });
                  };
                }
                function _classCallCheck2(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _defineProperties2(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                function _createClass2(Constructor, protoProps, staticProps) {
                  if (protoProps)
                    _defineProperties2(Constructor.prototype, protoProps);
                  if (staticProps)
                    _defineProperties2(Constructor, staticProps);
                  return Constructor;
                }
                var DEFAULT_LINK_REL = "noopener noreferrer nofollow";
                exports2.DEFAULT_LINK_REL = DEFAULT_LINK_REL;
                var SVG_NS = "http://www.w3.org/2000/svg";
                var DOMCanvasFactory = function() {
                  function DOMCanvasFactory2() {
                    _classCallCheck2(this, DOMCanvasFactory2);
                  }
                  _createClass2(DOMCanvasFactory2, [{ key: "create", value: function create(width, height) {
                    if (width <= 0 || height <= 0) {
                      throw new Error("Invalid canvas size");
                    }
                    var canvas = document.createElement("canvas");
                    var context = canvas.getContext("2d");
                    canvas.width = width;
                    canvas.height = height;
                    return { canvas, context };
                  } }, { key: "reset", value: function reset(canvasAndContext, width, height) {
                    if (!canvasAndContext.canvas) {
                      throw new Error("Canvas is not specified");
                    }
                    if (width <= 0 || height <= 0) {
                      throw new Error("Invalid canvas size");
                    }
                    canvasAndContext.canvas.width = width;
                    canvasAndContext.canvas.height = height;
                  } }, { key: "destroy", value: function destroy(canvasAndContext) {
                    if (!canvasAndContext.canvas) {
                      throw new Error("Canvas is not specified");
                    }
                    canvasAndContext.canvas.width = 0;
                    canvasAndContext.canvas.height = 0;
                    canvasAndContext.canvas = null;
                    canvasAndContext.context = null;
                  } }]);
                  return DOMCanvasFactory2;
                }();
                exports2.DOMCanvasFactory = DOMCanvasFactory;
                var DOMCMapReaderFactory = function() {
                  function DOMCMapReaderFactory2(_ref) {
                    var _ref$baseUrl = _ref.baseUrl, baseUrl = _ref$baseUrl === void 0 ? null : _ref$baseUrl, _ref$isCompressed = _ref.isCompressed, isCompressed = _ref$isCompressed === void 0 ? false : _ref$isCompressed;
                    _classCallCheck2(this, DOMCMapReaderFactory2);
                    this.baseUrl = baseUrl;
                    this.isCompressed = isCompressed;
                  }
                  _createClass2(DOMCMapReaderFactory2, [{ key: "fetch", value: function(_fetch) {
                    function fetch2(_x) {
                      return _fetch.apply(this, arguments);
                    }
                    fetch2.toString = function() {
                      return _fetch.toString();
                    };
                    return fetch2;
                  }(function() {
                    var _ref2 = _asyncToGenerator2(_regenerator2["default"].mark(function _callee2(_ref3) {
                      var _this = this;
                      var name, url, compressionType;
                      return _regenerator2["default"].wrap(function _callee2$(_context2) {
                        while (1) {
                          switch (_context2.prev = _context2.next) {
                            case 0:
                              name = _ref3.name;
                              if (this.baseUrl) {
                                _context2.next = 3;
                                break;
                              }
                              throw new Error('The CMap "baseUrl" parameter must be specified, ensure that the "cMapUrl" and "cMapPacked" API parameters are provided.');
                            case 3:
                              if (name) {
                                _context2.next = 5;
                                break;
                              }
                              throw new Error("CMap name must be specified.");
                            case 5:
                              url = this.baseUrl + name + (this.isCompressed ? ".bcmap" : "");
                              compressionType = this.isCompressed ? _util2.CMapCompressionType.BINARY : _util2.CMapCompressionType.NONE;
                              if (!(isFetchSupported() && isValidFetchUrl(url, document.baseURI))) {
                                _context2.next = 9;
                                break;
                              }
                              return _context2.abrupt("return", fetch(url).then(function() {
                                var _ref4 = _asyncToGenerator2(_regenerator2["default"].mark(function _callee3(response) {
                                  var cMapData;
                                  return _regenerator2["default"].wrap(function _callee$2(_context3) {
                                    while (1) {
                                      switch (_context3.prev = _context3.next) {
                                        case 0:
                                          if (response.ok) {
                                            _context3.next = 2;
                                            break;
                                          }
                                          throw new Error(response.statusText);
                                        case 2:
                                          if (!_this.isCompressed) {
                                            _context3.next = 10;
                                            break;
                                          }
                                          _context3.t0 = Uint8Array;
                                          _context3.next = 6;
                                          return response.arrayBuffer();
                                        case 6:
                                          _context3.t1 = _context3.sent;
                                          cMapData = new _context3.t0(_context3.t1);
                                          _context3.next = 15;
                                          break;
                                        case 10:
                                          _context3.t2 = _util2.stringToBytes;
                                          _context3.next = 13;
                                          return response.text();
                                        case 13:
                                          _context3.t3 = _context3.sent;
                                          cMapData = (0, _context3.t2)(_context3.t3);
                                        case 15:
                                          return _context3.abrupt("return", { cMapData, compressionType });
                                        case 16:
                                        case "end":
                                          return _context3.stop();
                                      }
                                    }
                                  }, _callee3);
                                }));
                                return function(_x3) {
                                  return _ref4.apply(this, arguments);
                                };
                              }())["catch"](function(reason) {
                                throw new Error("Unable to load ".concat(_this.isCompressed ? "binary " : "") + "CMap at: ".concat(url));
                              }));
                            case 9:
                              return _context2.abrupt("return", new Promise(function(resolve, reject) {
                                var request = new XMLHttpRequest();
                                request.open("GET", url, true);
                                if (_this.isCompressed) {
                                  request.responseType = "arraybuffer";
                                }
                                request.onreadystatechange = function() {
                                  if (request.readyState !== XMLHttpRequest.DONE) {
                                    return;
                                  }
                                  if (request.status === 200 || request.status === 0) {
                                    var cMapData;
                                    if (_this.isCompressed && request.response) {
                                      cMapData = new Uint8Array(request.response);
                                    } else if (!_this.isCompressed && request.responseText) {
                                      cMapData = (0, _util2.stringToBytes)(request.responseText);
                                    }
                                    if (cMapData) {
                                      resolve({ cMapData, compressionType });
                                      return;
                                    }
                                  }
                                  reject(new Error(request.statusText));
                                };
                                request.send(null);
                              })["catch"](function(reason) {
                                throw new Error("Unable to load ".concat(_this.isCompressed ? "binary " : "") + "CMap at: ".concat(url));
                              }));
                            case 10:
                            case "end":
                              return _context2.stop();
                          }
                        }
                      }, _callee2, this);
                    }));
                    return function(_x2) {
                      return _ref2.apply(this, arguments);
                    };
                  }()) }]);
                  return DOMCMapReaderFactory2;
                }();
                exports2.DOMCMapReaderFactory = DOMCMapReaderFactory;
                var DOMSVGFactory = function() {
                  function DOMSVGFactory2() {
                    _classCallCheck2(this, DOMSVGFactory2);
                  }
                  _createClass2(DOMSVGFactory2, [{ key: "create", value: function create(width, height) {
                    (0, _util2.assert)(width > 0 && height > 0, "Invalid SVG dimensions");
                    var svg = document.createElementNS(SVG_NS, "svg:svg");
                    svg.setAttribute("version", "1.1");
                    svg.setAttribute("width", width + "px");
                    svg.setAttribute("height", height + "px");
                    svg.setAttribute("preserveAspectRatio", "none");
                    svg.setAttribute("viewBox", "0 0 " + width + " " + height);
                    return svg;
                  } }, { key: "createElement", value: function createElement(type) {
                    (0, _util2.assert)(typeof type === "string", "Invalid SVG element type");
                    return document.createElementNS(SVG_NS, type);
                  } }]);
                  return DOMSVGFactory2;
                }();
                exports2.DOMSVGFactory = DOMSVGFactory;
                var PageViewport = function() {
                  function PageViewport2(_ref5) {
                    var viewBox = _ref5.viewBox, scale = _ref5.scale, rotation = _ref5.rotation, _ref5$offsetX = _ref5.offsetX, offsetX = _ref5$offsetX === void 0 ? 0 : _ref5$offsetX, _ref5$offsetY = _ref5.offsetY, offsetY = _ref5$offsetY === void 0 ? 0 : _ref5$offsetY, _ref5$dontFlip = _ref5.dontFlip, dontFlip = _ref5$dontFlip === void 0 ? false : _ref5$dontFlip;
                    _classCallCheck2(this, PageViewport2);
                    this.viewBox = viewBox;
                    this.scale = scale;
                    this.rotation = rotation;
                    this.offsetX = offsetX;
                    this.offsetY = offsetY;
                    var centerX = (viewBox[2] + viewBox[0]) / 2;
                    var centerY = (viewBox[3] + viewBox[1]) / 2;
                    var rotateA, rotateB, rotateC, rotateD;
                    rotation = rotation % 360;
                    rotation = rotation < 0 ? rotation + 360 : rotation;
                    switch (rotation) {
                      case 180:
                        rotateA = -1;
                        rotateB = 0;
                        rotateC = 0;
                        rotateD = 1;
                        break;
                      case 90:
                        rotateA = 0;
                        rotateB = 1;
                        rotateC = 1;
                        rotateD = 0;
                        break;
                      case 270:
                        rotateA = 0;
                        rotateB = -1;
                        rotateC = -1;
                        rotateD = 0;
                        break;
                      default:
                        rotateA = 1;
                        rotateB = 0;
                        rotateC = 0;
                        rotateD = -1;
                        break;
                    }
                    if (dontFlip) {
                      rotateC = -rotateC;
                      rotateD = -rotateD;
                    }
                    var offsetCanvasX, offsetCanvasY;
                    var width, height;
                    if (rotateA === 0) {
                      offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;
                      offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;
                      width = Math.abs(viewBox[3] - viewBox[1]) * scale;
                      height = Math.abs(viewBox[2] - viewBox[0]) * scale;
                    } else {
                      offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;
                      offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;
                      width = Math.abs(viewBox[2] - viewBox[0]) * scale;
                      height = Math.abs(viewBox[3] - viewBox[1]) * scale;
                    }
                    this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];
                    this.width = width;
                    this.height = height;
                  }
                  _createClass2(PageViewport2, [{ key: "clone", value: function clone() {
                    var _ref6 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref6$scale = _ref6.scale, scale = _ref6$scale === void 0 ? this.scale : _ref6$scale, _ref6$rotation = _ref6.rotation, rotation = _ref6$rotation === void 0 ? this.rotation : _ref6$rotation, _ref6$offsetX = _ref6.offsetX, offsetX = _ref6$offsetX === void 0 ? this.offsetX : _ref6$offsetX, _ref6$offsetY = _ref6.offsetY, offsetY = _ref6$offsetY === void 0 ? this.offsetY : _ref6$offsetY, _ref6$dontFlip = _ref6.dontFlip, dontFlip = _ref6$dontFlip === void 0 ? false : _ref6$dontFlip;
                    return new PageViewport2({ viewBox: this.viewBox.slice(), scale, rotation, offsetX, offsetY, dontFlip });
                  } }, { key: "convertToViewportPoint", value: function convertToViewportPoint(x, y) {
                    return _util2.Util.applyTransform([x, y], this.transform);
                  } }, { key: "convertToViewportRectangle", value: function convertToViewportRectangle(rect) {
                    var topLeft = _util2.Util.applyTransform([rect[0], rect[1]], this.transform);
                    var bottomRight = _util2.Util.applyTransform([rect[2], rect[3]], this.transform);
                    return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]];
                  } }, { key: "convertToPdfPoint", value: function convertToPdfPoint(x, y) {
                    return _util2.Util.applyInverseTransform([x, y], this.transform);
                  } }]);
                  return PageViewport2;
                }();
                exports2.PageViewport = PageViewport;
                var RenderingCancelledException = function(_BaseException) {
                  _inherits(RenderingCancelledException2, _BaseException);
                  function RenderingCancelledException2(msg, type) {
                    var _this2;
                    _classCallCheck2(this, RenderingCancelledException2);
                    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(RenderingCancelledException2).call(this, msg));
                    _this2.type = type;
                    return _this2;
                  }
                  return RenderingCancelledException2;
                }(_util2.BaseException);
                exports2.RenderingCancelledException = RenderingCancelledException;
                var LinkTarget = { NONE: 0, SELF: 1, BLANK: 2, PARENT: 3, TOP: 4 };
                exports2.LinkTarget = LinkTarget;
                function addLinkAttributes(link) {
                  var _ref7 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, url = _ref7.url, target = _ref7.target, rel = _ref7.rel, _ref7$enabled = _ref7.enabled, enabled = _ref7$enabled === void 0 ? true : _ref7$enabled;
                  (0, _util2.assert)(url && typeof url === "string", 'addLinkAttributes: A valid "url" parameter must provided.');
                  var urlNullRemoved = (0, _util2.removeNullCharacters)(url);
                  if (enabled) {
                    link.href = link.title = urlNullRemoved;
                  } else {
                    link.href = "";
                    link.title = "Disabled: ".concat(urlNullRemoved);
                    link.onclick = function() {
                      return false;
                    };
                  }
                  var targetStr = "";
                  switch (target) {
                    case LinkTarget.NONE:
                      break;
                    case LinkTarget.SELF:
                      targetStr = "_self";
                      break;
                    case LinkTarget.BLANK:
                      targetStr = "_blank";
                      break;
                    case LinkTarget.PARENT:
                      targetStr = "_parent";
                      break;
                    case LinkTarget.TOP:
                      targetStr = "_top";
                      break;
                  }
                  link.target = targetStr;
                  link.rel = typeof rel === "string" ? rel : DEFAULT_LINK_REL;
                }
                function getFilenameFromUrl(url) {
                  var anchor = url.indexOf("#");
                  var query = url.indexOf("?");
                  var end = Math.min(anchor > 0 ? anchor : url.length, query > 0 ? query : url.length);
                  return url.substring(url.lastIndexOf("/", end) + 1, end);
                }
                var StatTimer = function() {
                  function StatTimer2() {
                    _classCallCheck2(this, StatTimer2);
                    this.started = /* @__PURE__ */ Object.create(null);
                    this.times = [];
                  }
                  _createClass2(StatTimer2, [{ key: "time", value: function time(name) {
                    if (name in this.started) {
                      (0, _util2.warn)("Timer is already running for ".concat(name));
                    }
                    this.started[name] = Date.now();
                  } }, { key: "timeEnd", value: function timeEnd(name) {
                    if (!(name in this.started)) {
                      (0, _util2.warn)("Timer has not been started for ".concat(name));
                    }
                    this.times.push({ name, start: this.started[name], end: Date.now() });
                    delete this.started[name];
                  } }, { key: "toString", value: function toString() {
                    var outBuf = [];
                    var longest = 0;
                    var _iteratorNormalCompletion = true;
                    var _didIteratorError = false;
                    var _iteratorError = void 0;
                    try {
                      for (var _iterator = this.times[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var time = _step.value;
                        var name = time.name;
                        if (name.length > longest) {
                          longest = name.length;
                        }
                      }
                    } catch (err) {
                      _didIteratorError = true;
                      _iteratorError = err;
                    } finally {
                      try {
                        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                          _iterator["return"]();
                        }
                      } finally {
                        if (_didIteratorError) {
                          throw _iteratorError;
                        }
                      }
                    }
                    var _iteratorNormalCompletion2 = true;
                    var _didIteratorError2 = false;
                    var _iteratorError2 = void 0;
                    try {
                      for (var _iterator2 = this.times[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                        var _time = _step2.value;
                        var duration = _time.end - _time.start;
                        outBuf.push("".concat(_time.name.padEnd(longest), " ").concat(duration, "ms\n"));
                      }
                    } catch (err) {
                      _didIteratorError2 = true;
                      _iteratorError2 = err;
                    } finally {
                      try {
                        if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                          _iterator2["return"]();
                        }
                      } finally {
                        if (_didIteratorError2) {
                          throw _iteratorError2;
                        }
                      }
                    }
                    return outBuf.join("");
                  } }]);
                  return StatTimer2;
                }();
                exports2.StatTimer = StatTimer;
                function isFetchSupported() {
                  return typeof fetch !== "undefined" && typeof Response !== "undefined" && "body" in Response.prototype && typeof ReadableStream !== "undefined";
                }
                function isValidFetchUrl(url, baseUrl) {
                  try {
                    var _ref82 = baseUrl ? new URL(url, baseUrl) : new URL(url), protocol = _ref82.protocol;
                    return protocol === "http:" || protocol === "https:";
                  } catch (ex) {
                    return false;
                  }
                }
                function loadScript(src) {
                  return new Promise(function(resolve, reject) {
                    var script = document.createElement("script");
                    script.src = src;
                    script.onload = resolve;
                    script.onerror = function() {
                      reject(new Error("Cannot load script at: ".concat(script.src)));
                    };
                    (document.head || document.documentElement).appendChild(script);
                  });
                }
                function deprecated(details) {
                  console.log("Deprecated API usage: " + details);
                }
                function releaseImageResources(img) {
                  (0, _util2.assert)(img instanceof Image, "Invalid `img` parameter.");
                  var url = img.src;
                  if (typeof url === "string" && url.startsWith("blob:") && URL.revokeObjectURL) {
                    URL.revokeObjectURL(url);
                  }
                  img.removeAttribute("src");
                }
                var pdfDateStringRegex;
                var PDFDateString = function() {
                  function PDFDateString2() {
                    _classCallCheck2(this, PDFDateString2);
                  }
                  _createClass2(PDFDateString2, null, [{ key: "toDateObject", value: function toDateObject(input) {
                    if (!input || !(0, _util2.isString)(input)) {
                      return null;
                    }
                    if (!pdfDateStringRegex) {
                      pdfDateStringRegex = new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?");
                    }
                    var matches = pdfDateStringRegex.exec(input);
                    if (!matches) {
                      return null;
                    }
                    var year = parseInt(matches[1], 10);
                    var month = parseInt(matches[2], 10);
                    month = month >= 1 && month <= 12 ? month - 1 : 0;
                    var day = parseInt(matches[3], 10);
                    day = day >= 1 && day <= 31 ? day : 1;
                    var hour = parseInt(matches[4], 10);
                    hour = hour >= 0 && hour <= 23 ? hour : 0;
                    var minute = parseInt(matches[5], 10);
                    minute = minute >= 0 && minute <= 59 ? minute : 0;
                    var second = parseInt(matches[6], 10);
                    second = second >= 0 && second <= 59 ? second : 0;
                    var universalTimeRelation = matches[7] || "Z";
                    var offsetHour = parseInt(matches[8], 10);
                    offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;
                    var offsetMinute = parseInt(matches[9], 10) || 0;
                    offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;
                    if (universalTimeRelation === "-") {
                      hour += offsetHour;
                      minute += offsetMinute;
                    } else if (universalTimeRelation === "+") {
                      hour -= offsetHour;
                      minute -= offsetMinute;
                    }
                    return new Date(Date.UTC(year, month, day, hour, minute, second));
                  } }]);
                  return PDFDateString2;
                }();
                exports2.PDFDateString = PDFDateString;
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.FontLoader = exports2.FontFaceObject = void 0;
                var _regenerator2 = _interopRequireDefault2(__w_pdfjs_require__2(191));
                var _util2 = __w_pdfjs_require__2(1);
                function _interopRequireDefault2(obj) {
                  return obj && obj.__esModule ? obj : { "default": obj };
                }
                function _typeof2(obj) {
                  "@babel/helpers - typeof";
                  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                    _typeof2 = function _typeof3(obj2) {
                      return typeof obj2;
                    };
                  } else {
                    _typeof2 = function _typeof3(obj2) {
                      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                    };
                  }
                  return _typeof2(obj);
                }
                function _possibleConstructorReturn(self2, call) {
                  if (call && (_typeof2(call) === "object" || typeof call === "function")) {
                    return call;
                  }
                  return _assertThisInitialized(self2);
                }
                function _assertThisInitialized(self2) {
                  if (self2 === void 0) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  }
                  return self2;
                }
                function _getPrototypeOf(o) {
                  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                    return o2.__proto__ || Object.getPrototypeOf(o2);
                  };
                  return _getPrototypeOf(o);
                }
                function _inherits(subClass, superClass) {
                  if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function");
                  }
                  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
                  if (superClass)
                    _setPrototypeOf(subClass, superClass);
                }
                function _setPrototypeOf(o, p) {
                  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                    o2.__proto__ = p2;
                    return o2;
                  };
                  return _setPrototypeOf(o, p);
                }
                function asyncGeneratorStep2(gen, resolve, reject, _next, _throw, key, arg) {
                  try {
                    var info = gen[key](arg);
                    var value = info.value;
                  } catch (error) {
                    reject(error);
                    return;
                  }
                  if (info.done) {
                    resolve(value);
                  } else {
                    Promise.resolve(value).then(_next, _throw);
                  }
                }
                function _asyncToGenerator2(fn) {
                  return function() {
                    var self2 = this, args = arguments;
                    return new Promise(function(resolve, reject) {
                      var gen = fn.apply(self2, args);
                      function _next(value) {
                        asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "next", value);
                      }
                      function _throw(err) {
                        asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "throw", err);
                      }
                      _next(void 0);
                    });
                  };
                }
                function _classCallCheck2(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _defineProperties2(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                function _createClass2(Constructor, protoProps, staticProps) {
                  if (protoProps)
                    _defineProperties2(Constructor.prototype, protoProps);
                  if (staticProps)
                    _defineProperties2(Constructor, staticProps);
                  return Constructor;
                }
                var BaseFontLoader = function() {
                  function BaseFontLoader2(_ref) {
                    var docId = _ref.docId, onUnsupportedFeature = _ref.onUnsupportedFeature;
                    _classCallCheck2(this, BaseFontLoader2);
                    if (this.constructor === BaseFontLoader2) {
                      (0, _util2.unreachable)("Cannot initialize BaseFontLoader.");
                    }
                    this.docId = docId;
                    this._onUnsupportedFeature = onUnsupportedFeature;
                    this.nativeFontFaces = [];
                    this.styleElement = null;
                  }
                  _createClass2(BaseFontLoader2, [{ key: "addNativeFontFace", value: function addNativeFontFace(nativeFontFace) {
                    this.nativeFontFaces.push(nativeFontFace);
                    document.fonts.add(nativeFontFace);
                  } }, { key: "insertRule", value: function insertRule(rule) {
                    var styleElement = this.styleElement;
                    if (!styleElement) {
                      styleElement = this.styleElement = document.createElement("style");
                      styleElement.id = "PDFJS_FONT_STYLE_TAG_".concat(this.docId);
                      document.documentElement.getElementsByTagName("head")[0].appendChild(styleElement);
                    }
                    var styleSheet = styleElement.sheet;
                    styleSheet.insertRule(rule, styleSheet.cssRules.length);
                  } }, { key: "clear", value: function clear() {
                    this.nativeFontFaces.forEach(function(nativeFontFace) {
                      document.fonts["delete"](nativeFontFace);
                    });
                    this.nativeFontFaces.length = 0;
                    if (this.styleElement) {
                      this.styleElement.remove();
                      this.styleElement = null;
                    }
                  } }, { key: "bind", value: function() {
                    var _bind = _asyncToGenerator2(_regenerator2["default"].mark(function _callee2(font) {
                      var _this = this;
                      var nativeFontFace, rule;
                      return _regenerator2["default"].wrap(function _callee$2(_context2) {
                        while (1) {
                          switch (_context2.prev = _context2.next) {
                            case 0:
                              if (!(font.attached || font.missingFile)) {
                                _context2.next = 2;
                                break;
                              }
                              return _context2.abrupt("return");
                            case 2:
                              font.attached = true;
                              if (!this.isFontLoadingAPISupported) {
                                _context2.next = 19;
                                break;
                              }
                              nativeFontFace = font.createNativeFontFace();
                              if (!nativeFontFace) {
                                _context2.next = 18;
                                break;
                              }
                              this.addNativeFontFace(nativeFontFace);
                              _context2.prev = 7;
                              _context2.next = 10;
                              return nativeFontFace.loaded;
                            case 10:
                              _context2.next = 18;
                              break;
                            case 12:
                              _context2.prev = 12;
                              _context2.t0 = _context2["catch"](7);
                              this._onUnsupportedFeature({ featureId: _util2.UNSUPPORTED_FEATURES.font });
                              (0, _util2.warn)("Failed to load font '".concat(nativeFontFace.family, "': '").concat(_context2.t0, "'."));
                              font.disableFontFace = true;
                              throw _context2.t0;
                            case 18:
                              return _context2.abrupt("return");
                            case 19:
                              rule = font.createFontFaceRule();
                              if (!rule) {
                                _context2.next = 26;
                                break;
                              }
                              this.insertRule(rule);
                              if (!this.isSyncFontLoadingSupported) {
                                _context2.next = 24;
                                break;
                              }
                              return _context2.abrupt("return");
                            case 24:
                              _context2.next = 26;
                              return new Promise(function(resolve) {
                                var request = _this._queueLoadingCallback(resolve);
                                _this._prepareFontLoadEvent([rule], [font], request);
                              });
                            case 26:
                            case "end":
                              return _context2.stop();
                          }
                        }
                      }, _callee2, this, [[7, 12]]);
                    }));
                    function bind(_x) {
                      return _bind.apply(this, arguments);
                    }
                    return bind;
                  }() }, { key: "_queueLoadingCallback", value: function _queueLoadingCallback(callback) {
                    (0, _util2.unreachable)("Abstract method `_queueLoadingCallback`.");
                  } }, { key: "_prepareFontLoadEvent", value: function _prepareFontLoadEvent(rules, fontsToLoad, request) {
                    (0, _util2.unreachable)("Abstract method `_prepareFontLoadEvent`.");
                  } }, { key: "isFontLoadingAPISupported", get: function get() {
                    var supported = typeof document !== "undefined" && !!document.fonts;
                    return (0, _util2.shadow)(this, "isFontLoadingAPISupported", supported);
                  } }, { key: "isSyncFontLoadingSupported", get: function get() {
                    (0, _util2.unreachable)("Abstract method `isSyncFontLoadingSupported`.");
                  } }, { key: "_loadTestFont", get: function get() {
                    (0, _util2.unreachable)("Abstract method `_loadTestFont`.");
                  } }]);
                  return BaseFontLoader2;
                }();
                var FontLoader;
                exports2.FontLoader = FontLoader;
                {
                  exports2.FontLoader = FontLoader = function(_BaseFontLoader) {
                    _inherits(GenericFontLoader, _BaseFontLoader);
                    function GenericFontLoader(docId) {
                      var _this2;
                      _classCallCheck2(this, GenericFontLoader);
                      _this2 = _possibleConstructorReturn(this, _getPrototypeOf(GenericFontLoader).call(this, docId));
                      _this2.loadingContext = { requests: [], nextRequestId: 0 };
                      _this2.loadTestFontId = 0;
                      return _this2;
                    }
                    _createClass2(GenericFontLoader, [{ key: "_queueLoadingCallback", value: function _queueLoadingCallback(callback) {
                      function completeRequest() {
                        (0, _util2.assert)(!request.done, "completeRequest() cannot be called twice.");
                        request.done = true;
                        while (context.requests.length > 0 && context.requests[0].done) {
                          var otherRequest = context.requests.shift();
                          setTimeout(otherRequest.callback, 0);
                        }
                      }
                      var context = this.loadingContext;
                      var request = { id: "pdfjs-font-loading-".concat(context.nextRequestId++), done: false, complete: completeRequest, callback };
                      context.requests.push(request);
                      return request;
                    } }, { key: "_prepareFontLoadEvent", value: function _prepareFontLoadEvent(rules, fonts, request) {
                      function int32(data2, offset) {
                        return data2.charCodeAt(offset) << 24 | data2.charCodeAt(offset + 1) << 16 | data2.charCodeAt(offset + 2) << 8 | data2.charCodeAt(offset + 3) & 255;
                      }
                      function spliceString(s, offset, remove, insert) {
                        var chunk1 = s.substring(0, offset);
                        var chunk2 = s.substring(offset + remove);
                        return chunk1 + insert + chunk2;
                      }
                      var i, ii;
                      var canvas = document.createElement("canvas");
                      canvas.width = 1;
                      canvas.height = 1;
                      var ctx = canvas.getContext("2d");
                      var called = 0;
                      function isFontReady(name, callback) {
                        called++;
                        if (called > 30) {
                          (0, _util2.warn)("Load test font never loaded.");
                          callback();
                          return;
                        }
                        ctx.font = "30px " + name;
                        ctx.fillText(".", 0, 20);
                        var imageData = ctx.getImageData(0, 0, 1, 1);
                        if (imageData.data[3] > 0) {
                          callback();
                          return;
                        }
                        setTimeout(isFontReady.bind(null, name, callback));
                      }
                      var loadTestFontId = "lt".concat(Date.now()).concat(this.loadTestFontId++);
                      var data = this._loadTestFont;
                      var COMMENT_OFFSET = 976;
                      data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);
                      var CFF_CHECKSUM_OFFSET = 16;
                      var XXXX_VALUE = 1482184792;
                      var checksum = int32(data, CFF_CHECKSUM_OFFSET);
                      for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {
                        checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;
                      }
                      if (i < loadTestFontId.length) {
                        checksum = checksum - XXXX_VALUE + int32(loadTestFontId + "XXX", i) | 0;
                      }
                      data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, (0, _util2.string32)(checksum));
                      var url = "url(data:font/opentype;base64,".concat(btoa(data), ");");
                      var rule = '@font-face {font-family:"'.concat(loadTestFontId, '";src:').concat(url, "}");
                      this.insertRule(rule);
                      var names = [];
                      for (i = 0, ii = fonts.length; i < ii; i++) {
                        names.push(fonts[i].loadedName);
                      }
                      names.push(loadTestFontId);
                      var div = document.createElement("div");
                      div.style.visibility = "hidden";
                      div.style.width = div.style.height = "10px";
                      div.style.position = "absolute";
                      div.style.top = div.style.left = "0px";
                      for (i = 0, ii = names.length; i < ii; ++i) {
                        var span = document.createElement("span");
                        span.textContent = "Hi";
                        span.style.fontFamily = names[i];
                        div.appendChild(span);
                      }
                      document.body.appendChild(div);
                      isFontReady(loadTestFontId, function() {
                        document.body.removeChild(div);
                        request.complete();
                      });
                    } }, { key: "isSyncFontLoadingSupported", get: function get() {
                      var supported = false;
                      if (typeof navigator === "undefined") {
                        supported = true;
                      } else {
                        var m = /Mozilla\/5.0.*?rv:(\d+).*? Gecko/.exec(navigator.userAgent);
                        if (m && m[1] >= 14) {
                          supported = true;
                        }
                      }
                      return (0, _util2.shadow)(this, "isSyncFontLoadingSupported", supported);
                    } }, { key: "_loadTestFont", get: function get() {
                      var getLoadTestFont = function getLoadTestFont2() {
                        return atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
                      };
                      return (0, _util2.shadow)(this, "_loadTestFont", getLoadTestFont());
                    } }]);
                    return GenericFontLoader;
                  }(BaseFontLoader);
                }
                var FontFaceObject = function() {
                  function FontFaceObject2(translatedData, _ref2) {
                    var _ref2$isEvalSupported = _ref2.isEvalSupported, isEvalSupported = _ref2$isEvalSupported === void 0 ? true : _ref2$isEvalSupported, _ref2$disableFontFace = _ref2.disableFontFace, disableFontFace = _ref2$disableFontFace === void 0 ? false : _ref2$disableFontFace, _ref2$ignoreErrors = _ref2.ignoreErrors, ignoreErrors = _ref2$ignoreErrors === void 0 ? false : _ref2$ignoreErrors, _ref2$onUnsupportedFe = _ref2.onUnsupportedFeature, onUnsupportedFeature = _ref2$onUnsupportedFe === void 0 ? null : _ref2$onUnsupportedFe, _ref2$fontRegistry = _ref2.fontRegistry, fontRegistry = _ref2$fontRegistry === void 0 ? null : _ref2$fontRegistry;
                    _classCallCheck2(this, FontFaceObject2);
                    this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
                    for (var i in translatedData) {
                      this[i] = translatedData[i];
                    }
                    this.isEvalSupported = isEvalSupported !== false;
                    this.disableFontFace = disableFontFace === true;
                    this.ignoreErrors = ignoreErrors === true;
                    this._onUnsupportedFeature = onUnsupportedFeature;
                    this.fontRegistry = fontRegistry;
                  }
                  _createClass2(FontFaceObject2, [{ key: "createNativeFontFace", value: function createNativeFontFace() {
                    if (!this.data || this.disableFontFace) {
                      return null;
                    }
                    var nativeFontFace = new FontFace(this.loadedName, this.data, {});
                    if (this.fontRegistry) {
                      this.fontRegistry.registerFont(this);
                    }
                    return nativeFontFace;
                  } }, { key: "createFontFaceRule", value: function createFontFaceRule() {
                    if (!this.data || this.disableFontFace) {
                      return null;
                    }
                    var data = (0, _util2.bytesToString)(new Uint8Array(this.data));
                    var url = "url(data:".concat(this.mimetype, ";base64,").concat(btoa(data), ");");
                    var rule = '@font-face {font-family:"'.concat(this.loadedName, '";src:').concat(url, "}");
                    if (this.fontRegistry) {
                      this.fontRegistry.registerFont(this, url);
                    }
                    return rule;
                  } }, { key: "getPathGenerator", value: function getPathGenerator(objs, character) {
                    if (this.compiledGlyphs[character] !== void 0) {
                      return this.compiledGlyphs[character];
                    }
                    var cmds, current;
                    try {
                      cmds = objs.get(this.loadedName + "_path_" + character);
                    } catch (ex) {
                      if (!this.ignoreErrors) {
                        throw ex;
                      }
                      if (this._onUnsupportedFeature) {
                        this._onUnsupportedFeature({ featureId: _util2.UNSUPPORTED_FEATURES.font });
                      }
                      (0, _util2.warn)('getPathGenerator - ignoring character: "'.concat(ex, '".'));
                      return this.compiledGlyphs[character] = function(c, size) {
                      };
                    }
                    if (this.isEvalSupported && _util2.IsEvalSupportedCached.value) {
                      var args, js = "";
                      for (var i = 0, ii = cmds.length; i < ii; i++) {
                        current = cmds[i];
                        if (current.args !== void 0) {
                          args = current.args.join(",");
                        } else {
                          args = "";
                        }
                        js += "c." + current.cmd + "(" + args + ");\n";
                      }
                      return this.compiledGlyphs[character] = new Function("c", "size", js);
                    }
                    return this.compiledGlyphs[character] = function(c, size) {
                      for (var _i = 0, _ii = cmds.length; _i < _ii; _i++) {
                        current = cmds[_i];
                        if (current.cmd === "scale") {
                          current.args = [size, -size];
                        }
                        c[current.cmd].apply(c, current.args);
                      }
                    };
                  } }]);
                  return FontFaceObject2;
                }();
                exports2.FontFaceObject = FontFaceObject;
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                var compatibilityParams = /* @__PURE__ */ Object.create(null);
                {
                  var _require = __w_pdfjs_require__2(48), isNodeJS = _require.isNodeJS;
                  var userAgent = typeof navigator !== "undefined" && navigator.userAgent || "";
                  var isIE = /Trident/.test(userAgent);
                  var isIOSChrome = /CriOS/.test(userAgent);
                  (function checkOnBlobSupport() {
                    if (isIE || isIOSChrome) {
                      compatibilityParams.disableCreateObjectURL = true;
                    }
                  })();
                  (function checkFontFaceAndImage() {
                    if (isNodeJS) {
                      compatibilityParams.disableFontFace = true;
                      compatibilityParams.nativeImageDecoderSupport = "none";
                    }
                  })();
                }
                exports2.apiCompatibilityParams = Object.freeze(compatibilityParams);
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.CanvasGraphics = void 0;
                var _util2 = __w_pdfjs_require__2(1);
                var _pattern_helper = __w_pdfjs_require__2(198);
                var MIN_FONT_SIZE = 16;
                var MAX_FONT_SIZE = 100;
                var MAX_GROUP_SIZE = 4096;
                var MIN_WIDTH_FACTOR = 0.65;
                var COMPILE_TYPE3_GLYPHS = true;
                var MAX_SIZE_TO_COMPILE = 1e3;
                var FULL_CHUNK_HEIGHT = 16;
                function addContextCurrentTransform(ctx) {
                  if (!ctx.mozCurrentTransform) {
                    ctx._originalSave = ctx.save;
                    ctx._originalRestore = ctx.restore;
                    ctx._originalRotate = ctx.rotate;
                    ctx._originalScale = ctx.scale;
                    ctx._originalTranslate = ctx.translate;
                    ctx._originalTransform = ctx.transform;
                    ctx._originalSetTransform = ctx.setTransform;
                    ctx._transformMatrix = ctx._transformMatrix || [1, 0, 0, 1, 0, 0];
                    ctx._transformStack = [];
                    Object.defineProperty(ctx, "mozCurrentTransform", { get: function getCurrentTransform() {
                      return this._transformMatrix;
                    } });
                    Object.defineProperty(ctx, "mozCurrentTransformInverse", { get: function getCurrentTransformInverse() {
                      var m = this._transformMatrix;
                      var a = m[0], b = m[1], c = m[2], d = m[3], e = m[4], f = m[5];
                      var ad_bc = a * d - b * c;
                      var bc_ad = b * c - a * d;
                      return [d / ad_bc, b / bc_ad, c / bc_ad, a / ad_bc, (d * e - c * f) / bc_ad, (b * e - a * f) / ad_bc];
                    } });
                    ctx.save = function ctxSave() {
                      var old = this._transformMatrix;
                      this._transformStack.push(old);
                      this._transformMatrix = old.slice(0, 6);
                      this._originalSave();
                    };
                    ctx.restore = function ctxRestore() {
                      var prev = this._transformStack.pop();
                      if (prev) {
                        this._transformMatrix = prev;
                        this._originalRestore();
                      }
                    };
                    ctx.translate = function ctxTranslate(x, y) {
                      var m = this._transformMatrix;
                      m[4] = m[0] * x + m[2] * y + m[4];
                      m[5] = m[1] * x + m[3] * y + m[5];
                      this._originalTranslate(x, y);
                    };
                    ctx.scale = function ctxScale(x, y) {
                      var m = this._transformMatrix;
                      m[0] = m[0] * x;
                      m[1] = m[1] * x;
                      m[2] = m[2] * y;
                      m[3] = m[3] * y;
                      this._originalScale(x, y);
                    };
                    ctx.transform = function ctxTransform(a, b, c, d, e, f) {
                      var m = this._transformMatrix;
                      this._transformMatrix = [m[0] * a + m[2] * b, m[1] * a + m[3] * b, m[0] * c + m[2] * d, m[1] * c + m[3] * d, m[0] * e + m[2] * f + m[4], m[1] * e + m[3] * f + m[5]];
                      ctx._originalTransform(a, b, c, d, e, f);
                    };
                    ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {
                      this._transformMatrix = [a, b, c, d, e, f];
                      ctx._originalSetTransform(a, b, c, d, e, f);
                    };
                    ctx.rotate = function ctxRotate(angle) {
                      var cosValue = Math.cos(angle);
                      var sinValue = Math.sin(angle);
                      var m = this._transformMatrix;
                      this._transformMatrix = [m[0] * cosValue + m[2] * sinValue, m[1] * cosValue + m[3] * sinValue, m[0] * -sinValue + m[2] * cosValue, m[1] * -sinValue + m[3] * cosValue, m[4], m[5]];
                      this._originalRotate(angle);
                    };
                  }
                }
                var CachedCanvases = function CachedCanvasesClosure() {
                  function CachedCanvases2(canvasFactory) {
                    this.canvasFactory = canvasFactory;
                    this.cache = /* @__PURE__ */ Object.create(null);
                  }
                  CachedCanvases2.prototype = { getCanvas: function CachedCanvases_getCanvas(id, width, height, trackTransform) {
                    var canvasEntry;
                    if (this.cache[id] !== void 0) {
                      canvasEntry = this.cache[id];
                      this.canvasFactory.reset(canvasEntry, width, height);
                      canvasEntry.context.setTransform(1, 0, 0, 1, 0, 0);
                    } else {
                      canvasEntry = this.canvasFactory.create(width, height);
                      this.cache[id] = canvasEntry;
                    }
                    if (trackTransform) {
                      addContextCurrentTransform(canvasEntry.context);
                    }
                    return canvasEntry;
                  }, clear: function clear() {
                    for (var id in this.cache) {
                      var canvasEntry = this.cache[id];
                      this.canvasFactory.destroy(canvasEntry);
                      delete this.cache[id];
                    }
                  } };
                  return CachedCanvases2;
                }();
                function compileType3Glyph(imgData) {
                  var POINT_TO_PROCESS_LIMIT = 1e3;
                  var width = imgData.width, height = imgData.height;
                  var i, j, j0, width1 = width + 1;
                  var points = new Uint8Array(width1 * (height + 1));
                  var POINT_TYPES = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]);
                  var lineSize = width + 7 & ~7, data0 = imgData.data;
                  var data = new Uint8Array(lineSize * height), pos = 0, ii;
                  for (i = 0, ii = data0.length; i < ii; i++) {
                    var mask = 128, elem = data0[i];
                    while (mask > 0) {
                      data[pos++] = elem & mask ? 0 : 255;
                      mask >>= 1;
                    }
                  }
                  var count = 0;
                  pos = 0;
                  if (data[pos] !== 0) {
                    points[0] = 1;
                    ++count;
                  }
                  for (j = 1; j < width; j++) {
                    if (data[pos] !== data[pos + 1]) {
                      points[j] = data[pos] ? 2 : 1;
                      ++count;
                    }
                    pos++;
                  }
                  if (data[pos] !== 0) {
                    points[j] = 2;
                    ++count;
                  }
                  for (i = 1; i < height; i++) {
                    pos = i * lineSize;
                    j0 = i * width1;
                    if (data[pos - lineSize] !== data[pos]) {
                      points[j0] = data[pos] ? 1 : 8;
                      ++count;
                    }
                    var sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);
                    for (j = 1; j < width; j++) {
                      sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);
                      if (POINT_TYPES[sum]) {
                        points[j0 + j] = POINT_TYPES[sum];
                        ++count;
                      }
                      pos++;
                    }
                    if (data[pos - lineSize] !== data[pos]) {
                      points[j0 + j] = data[pos] ? 2 : 4;
                      ++count;
                    }
                    if (count > POINT_TO_PROCESS_LIMIT) {
                      return null;
                    }
                  }
                  pos = lineSize * (height - 1);
                  j0 = i * width1;
                  if (data[pos] !== 0) {
                    points[j0] = 8;
                    ++count;
                  }
                  for (j = 1; j < width; j++) {
                    if (data[pos] !== data[pos + 1]) {
                      points[j0 + j] = data[pos] ? 4 : 8;
                      ++count;
                    }
                    pos++;
                  }
                  if (data[pos] !== 0) {
                    points[j0 + j] = 4;
                    ++count;
                  }
                  if (count > POINT_TO_PROCESS_LIMIT) {
                    return null;
                  }
                  var steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);
                  var outlines = [];
                  for (i = 0; count && i <= height; i++) {
                    var p = i * width1;
                    var end = p + width;
                    while (p < end && !points[p]) {
                      p++;
                    }
                    if (p === end) {
                      continue;
                    }
                    var coords = [p % width1, i];
                    var type = points[p], p0 = p, pp;
                    do {
                      var step = steps[type];
                      do {
                        p += step;
                      } while (!points[p]);
                      pp = points[p];
                      if (pp !== 5 && pp !== 10) {
                        type = pp;
                        points[p] = 0;
                      } else {
                        type = pp & 51 * type >> 4;
                        points[p] &= type >> 2 | type << 2;
                      }
                      coords.push(p % width1);
                      coords.push(p / width1 | 0);
                      if (!points[p]) {
                        --count;
                      }
                    } while (p0 !== p);
                    outlines.push(coords);
                    --i;
                  }
                  var drawOutline = function drawOutline2(c) {
                    c.save();
                    c.scale(1 / width, -1 / height);
                    c.translate(0, -height);
                    c.beginPath();
                    for (var i2 = 0, ii2 = outlines.length; i2 < ii2; i2++) {
                      var o = outlines[i2];
                      c.moveTo(o[0], o[1]);
                      for (var j2 = 2, jj = o.length; j2 < jj; j2 += 2) {
                        c.lineTo(o[j2], o[j2 + 1]);
                      }
                    }
                    c.fill();
                    c.beginPath();
                    c.restore();
                  };
                  return drawOutline;
                }
                var CanvasExtraState = function CanvasExtraStateClosure() {
                  function CanvasExtraState2() {
                    this.alphaIsShape = false;
                    this.fontSize = 0;
                    this.fontSizeScale = 1;
                    this.textMatrix = _util2.IDENTITY_MATRIX;
                    this.textMatrixScale = 1;
                    this.fontMatrix = _util2.FONT_IDENTITY_MATRIX;
                    this.leading = 0;
                    this.x = 0;
                    this.y = 0;
                    this.lineX = 0;
                    this.lineY = 0;
                    this.charSpacing = 0;
                    this.wordSpacing = 0;
                    this.textHScale = 1;
                    this.textRenderingMode = _util2.TextRenderingMode.FILL;
                    this.textRise = 0;
                    this.fillColor = "#000000";
                    this.strokeColor = "#000000";
                    this.patternFill = false;
                    this.fillAlpha = 1;
                    this.strokeAlpha = 1;
                    this.lineWidth = 1;
                    this.activeSMask = null;
                    this.resumeSMaskCtx = null;
                  }
                  CanvasExtraState2.prototype = { clone: function CanvasExtraState_clone() {
                    return Object.create(this);
                  }, setCurrentPoint: function CanvasExtraState_setCurrentPoint(x, y) {
                    this.x = x;
                    this.y = y;
                  } };
                  return CanvasExtraState2;
                }();
                var CanvasGraphics = function CanvasGraphicsClosure() {
                  var EXECUTION_TIME = 15;
                  var EXECUTION_STEPS = 10;
                  function CanvasGraphics2(canvasCtx, commonObjs, objs, canvasFactory, webGLContext, imageLayer) {
                    this.ctx = canvasCtx;
                    this.current = new CanvasExtraState();
                    this.stateStack = [];
                    this.pendingClip = null;
                    this.pendingEOFill = false;
                    this.res = null;
                    this.xobjs = null;
                    this.commonObjs = commonObjs;
                    this.objs = objs;
                    this.canvasFactory = canvasFactory;
                    this.webGLContext = webGLContext;
                    this.imageLayer = imageLayer;
                    this.groupStack = [];
                    this.processingType3 = null;
                    this.baseTransform = null;
                    this.baseTransformStack = [];
                    this.groupLevel = 0;
                    this.smaskStack = [];
                    this.smaskCounter = 0;
                    this.tempSMask = null;
                    this.cachedCanvases = new CachedCanvases(this.canvasFactory);
                    if (canvasCtx) {
                      addContextCurrentTransform(canvasCtx);
                    }
                    this._cachedGetSinglePixelWidth = null;
                  }
                  function putBinaryImageData(ctx, imgData) {
                    if (typeof ImageData !== "undefined" && imgData instanceof ImageData) {
                      ctx.putImageData(imgData, 0, 0);
                      return;
                    }
                    var height = imgData.height, width = imgData.width;
                    var partialChunkHeight = height % FULL_CHUNK_HEIGHT;
                    var fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
                    var totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
                    var chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
                    var srcPos = 0, destPos;
                    var src = imgData.data;
                    var dest = chunkImgData.data;
                    var i, j, thisChunkHeight, elemsInThisChunk;
                    if (imgData.kind === _util2.ImageKind.GRAYSCALE_1BPP) {
                      var srcLength = src.byteLength;
                      var dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);
                      var dest32DataLength = dest32.length;
                      var fullSrcDiff = width + 7 >> 3;
                      var white = 4294967295;
                      var black = _util2.IsLittleEndianCached.value ? 4278190080 : 255;
                      for (i = 0; i < totalChunks; i++) {
                        thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
                        destPos = 0;
                        for (j = 0; j < thisChunkHeight; j++) {
                          var srcDiff = srcLength - srcPos;
                          var k = 0;
                          var kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;
                          var kEndUnrolled = kEnd & ~7;
                          var mask = 0;
                          var srcByte = 0;
                          for (; k < kEndUnrolled; k += 8) {
                            srcByte = src[srcPos++];
                            dest32[destPos++] = srcByte & 128 ? white : black;
                            dest32[destPos++] = srcByte & 64 ? white : black;
                            dest32[destPos++] = srcByte & 32 ? white : black;
                            dest32[destPos++] = srcByte & 16 ? white : black;
                            dest32[destPos++] = srcByte & 8 ? white : black;
                            dest32[destPos++] = srcByte & 4 ? white : black;
                            dest32[destPos++] = srcByte & 2 ? white : black;
                            dest32[destPos++] = srcByte & 1 ? white : black;
                          }
                          for (; k < kEnd; k++) {
                            if (mask === 0) {
                              srcByte = src[srcPos++];
                              mask = 128;
                            }
                            dest32[destPos++] = srcByte & mask ? white : black;
                            mask >>= 1;
                          }
                        }
                        while (destPos < dest32DataLength) {
                          dest32[destPos++] = 0;
                        }
                        ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
                      }
                    } else if (imgData.kind === _util2.ImageKind.RGBA_32BPP) {
                      j = 0;
                      elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;
                      for (i = 0; i < fullChunks; i++) {
                        dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
                        srcPos += elemsInThisChunk;
                        ctx.putImageData(chunkImgData, 0, j);
                        j += FULL_CHUNK_HEIGHT;
                      }
                      if (i < totalChunks) {
                        elemsInThisChunk = width * partialChunkHeight * 4;
                        dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
                        ctx.putImageData(chunkImgData, 0, j);
                      }
                    } else if (imgData.kind === _util2.ImageKind.RGB_24BPP) {
                      thisChunkHeight = FULL_CHUNK_HEIGHT;
                      elemsInThisChunk = width * thisChunkHeight;
                      for (i = 0; i < totalChunks; i++) {
                        if (i >= fullChunks) {
                          thisChunkHeight = partialChunkHeight;
                          elemsInThisChunk = width * thisChunkHeight;
                        }
                        destPos = 0;
                        for (j = elemsInThisChunk; j--; ) {
                          dest[destPos++] = src[srcPos++];
                          dest[destPos++] = src[srcPos++];
                          dest[destPos++] = src[srcPos++];
                          dest[destPos++] = 255;
                        }
                        ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
                      }
                    } else {
                      throw new Error("bad image kind: ".concat(imgData.kind));
                    }
                  }
                  function putBinaryImageMask(ctx, imgData) {
                    var height = imgData.height, width = imgData.width;
                    var partialChunkHeight = height % FULL_CHUNK_HEIGHT;
                    var fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
                    var totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
                    var chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
                    var srcPos = 0;
                    var src = imgData.data;
                    var dest = chunkImgData.data;
                    for (var i = 0; i < totalChunks; i++) {
                      var thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
                      var destPos = 3;
                      for (var j = 0; j < thisChunkHeight; j++) {
                        var mask = 0;
                        for (var k = 0; k < width; k++) {
                          if (!mask) {
                            var elem = src[srcPos++];
                            mask = 128;
                          }
                          dest[destPos] = elem & mask ? 0 : 255;
                          destPos += 4;
                          mask >>= 1;
                        }
                      }
                      ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
                    }
                  }
                  function copyCtxState(sourceCtx, destCtx) {
                    var properties = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font"];
                    for (var i = 0, ii = properties.length; i < ii; i++) {
                      var property = properties[i];
                      if (sourceCtx[property] !== void 0) {
                        destCtx[property] = sourceCtx[property];
                      }
                    }
                    if (sourceCtx.setLineDash !== void 0) {
                      destCtx.setLineDash(sourceCtx.getLineDash());
                      destCtx.lineDashOffset = sourceCtx.lineDashOffset;
                    }
                  }
                  function resetCtxToDefault(ctx) {
                    ctx.strokeStyle = "#000000";
                    ctx.fillStyle = "#000000";
                    ctx.fillRule = "nonzero";
                    ctx.globalAlpha = 1;
                    ctx.lineWidth = 1;
                    ctx.lineCap = "butt";
                    ctx.lineJoin = "miter";
                    ctx.miterLimit = 10;
                    ctx.globalCompositeOperation = "source-over";
                    ctx.font = "10px sans-serif";
                    if (ctx.setLineDash !== void 0) {
                      ctx.setLineDash([]);
                      ctx.lineDashOffset = 0;
                    }
                  }
                  function composeSMaskBackdrop(bytes, r0, g0, b0) {
                    var length = bytes.length;
                    for (var i = 3; i < length; i += 4) {
                      var alpha = bytes[i];
                      if (alpha === 0) {
                        bytes[i - 3] = r0;
                        bytes[i - 2] = g0;
                        bytes[i - 1] = b0;
                      } else if (alpha < 255) {
                        var alpha_ = 255 - alpha;
                        bytes[i - 3] = bytes[i - 3] * alpha + r0 * alpha_ >> 8;
                        bytes[i - 2] = bytes[i - 2] * alpha + g0 * alpha_ >> 8;
                        bytes[i - 1] = bytes[i - 1] * alpha + b0 * alpha_ >> 8;
                      }
                    }
                  }
                  function composeSMaskAlpha(maskData, layerData, transferMap) {
                    var length = maskData.length;
                    var scale = 1 / 255;
                    for (var i = 3; i < length; i += 4) {
                      var alpha = transferMap ? transferMap[maskData[i]] : maskData[i];
                      layerData[i] = layerData[i] * alpha * scale | 0;
                    }
                  }
                  function composeSMaskLuminosity(maskData, layerData, transferMap) {
                    var length = maskData.length;
                    for (var i = 3; i < length; i += 4) {
                      var y = maskData[i - 3] * 77 + maskData[i - 2] * 152 + maskData[i - 1] * 28;
                      layerData[i] = transferMap ? layerData[i] * transferMap[y >> 8] >> 8 : layerData[i] * y >> 16;
                    }
                  }
                  function genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap) {
                    var hasBackdrop = !!backdrop;
                    var r0 = hasBackdrop ? backdrop[0] : 0;
                    var g0 = hasBackdrop ? backdrop[1] : 0;
                    var b0 = hasBackdrop ? backdrop[2] : 0;
                    var composeFn;
                    if (subtype === "Luminosity") {
                      composeFn = composeSMaskLuminosity;
                    } else {
                      composeFn = composeSMaskAlpha;
                    }
                    var PIXELS_TO_PROCESS = 1048576;
                    var chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width));
                    for (var row = 0; row < height; row += chunkSize) {
                      var chunkHeight = Math.min(chunkSize, height - row);
                      var maskData = maskCtx.getImageData(0, row, width, chunkHeight);
                      var layerData = layerCtx.getImageData(0, row, width, chunkHeight);
                      if (hasBackdrop) {
                        composeSMaskBackdrop(maskData.data, r0, g0, b0);
                      }
                      composeFn(maskData.data, layerData.data, transferMap);
                      maskCtx.putImageData(layerData, 0, row);
                    }
                  }
                  function composeSMask(ctx, smask, layerCtx, webGLContext) {
                    var mask = smask.canvas;
                    var maskCtx = smask.context;
                    ctx.setTransform(smask.scaleX, 0, 0, smask.scaleY, smask.offsetX, smask.offsetY);
                    var backdrop = smask.backdrop || null;
                    if (!smask.transferMap && webGLContext.isEnabled) {
                      var composed = webGLContext.composeSMask({ layer: layerCtx.canvas, mask, properties: { subtype: smask.subtype, backdrop } });
                      ctx.setTransform(1, 0, 0, 1, 0, 0);
                      ctx.drawImage(composed, smask.offsetX, smask.offsetY);
                      return;
                    }
                    genericComposeSMask(maskCtx, layerCtx, mask.width, mask.height, smask.subtype, backdrop, smask.transferMap);
                    ctx.drawImage(mask, 0, 0);
                  }
                  var LINE_CAP_STYLES = ["butt", "round", "square"];
                  var LINE_JOIN_STYLES = ["miter", "round", "bevel"];
                  var NORMAL_CLIP = {};
                  var EO_CLIP = {};
                  CanvasGraphics2.prototype = { beginDrawing: function beginDrawing(_ref) {
                    var transform = _ref.transform, viewport = _ref.viewport, _ref$transparency = _ref.transparency, transparency = _ref$transparency === void 0 ? false : _ref$transparency, _ref$background = _ref.background, background = _ref$background === void 0 ? null : _ref$background;
                    var width = this.ctx.canvas.width;
                    var height = this.ctx.canvas.height;
                    this.ctx.save();
                    this.ctx.fillStyle = background || "rgb(255, 255, 255)";
                    this.ctx.fillRect(0, 0, width, height);
                    this.ctx.restore();
                    if (transparency) {
                      var transparentCanvas = this.cachedCanvases.getCanvas("transparent", width, height, true);
                      this.compositeCtx = this.ctx;
                      this.transparentCanvas = transparentCanvas.canvas;
                      this.ctx = transparentCanvas.context;
                      this.ctx.save();
                      this.ctx.transform.apply(this.ctx, this.compositeCtx.mozCurrentTransform);
                    }
                    this.ctx.save();
                    resetCtxToDefault(this.ctx);
                    if (transform) {
                      this.ctx.transform.apply(this.ctx, transform);
                    }
                    this.ctx.transform.apply(this.ctx, viewport.transform);
                    this.baseTransform = this.ctx.mozCurrentTransform.slice();
                    if (this.imageLayer) {
                      this.imageLayer.beginLayout();
                    }
                  }, executeOperatorList: function CanvasGraphics_executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {
                    var argsArray = operatorList.argsArray;
                    var fnArray = operatorList.fnArray;
                    var i = executionStartIdx || 0;
                    var argsArrayLen = argsArray.length;
                    if (argsArrayLen === i) {
                      return i;
                    }
                    var chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === "function";
                    var endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;
                    var steps = 0;
                    var commonObjs = this.commonObjs;
                    var objs = this.objs;
                    var fnId;
                    while (true) {
                      if (stepper !== void 0 && i === stepper.nextBreakPoint) {
                        stepper.breakIt(i, continueCallback);
                        return i;
                      }
                      fnId = fnArray[i];
                      if (fnId !== _util2.OPS.dependency) {
                        this[fnId].apply(this, argsArray[i]);
                      } else {
                        var _iteratorNormalCompletion = true;
                        var _didIteratorError = false;
                        var _iteratorError = void 0;
                        try {
                          for (var _iterator = argsArray[i][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                            var depObjId = _step.value;
                            var objsPool = depObjId.startsWith("g_") ? commonObjs : objs;
                            if (!objsPool.has(depObjId)) {
                              objsPool.get(depObjId, continueCallback);
                              return i;
                            }
                          }
                        } catch (err) {
                          _didIteratorError = true;
                          _iteratorError = err;
                        } finally {
                          try {
                            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                              _iterator["return"]();
                            }
                          } finally {
                            if (_didIteratorError) {
                              throw _iteratorError;
                            }
                          }
                        }
                      }
                      i++;
                      if (i === argsArrayLen) {
                        return i;
                      }
                      if (chunkOperations && ++steps > EXECUTION_STEPS) {
                        if (Date.now() > endTime) {
                          continueCallback();
                          return i;
                        }
                        steps = 0;
                      }
                    }
                  }, endDrawing: function CanvasGraphics_endDrawing() {
                    if (this.current.activeSMask !== null) {
                      this.endSMaskGroup();
                    }
                    this.ctx.restore();
                    if (this.transparentCanvas) {
                      this.ctx = this.compositeCtx;
                      this.ctx.save();
                      this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                      this.ctx.drawImage(this.transparentCanvas, 0, 0);
                      this.ctx.restore();
                      this.transparentCanvas = null;
                    }
                    this.cachedCanvases.clear();
                    this.webGLContext.clear();
                    if (this.imageLayer) {
                      this.imageLayer.endLayout();
                    }
                  }, setLineWidth: function CanvasGraphics_setLineWidth(width) {
                    this.current.lineWidth = width;
                    this.ctx.lineWidth = width;
                  }, setLineCap: function CanvasGraphics_setLineCap(style) {
                    this.ctx.lineCap = LINE_CAP_STYLES[style];
                  }, setLineJoin: function CanvasGraphics_setLineJoin(style) {
                    this.ctx.lineJoin = LINE_JOIN_STYLES[style];
                  }, setMiterLimit: function CanvasGraphics_setMiterLimit(limit) {
                    this.ctx.miterLimit = limit;
                  }, setDash: function CanvasGraphics_setDash(dashArray, dashPhase) {
                    var ctx = this.ctx;
                    if (ctx.setLineDash !== void 0) {
                      ctx.setLineDash(dashArray);
                      ctx.lineDashOffset = dashPhase;
                    }
                  }, setRenderingIntent: function setRenderingIntent(intent) {
                  }, setFlatness: function setFlatness(flatness) {
                  }, setGState: function CanvasGraphics_setGState(states) {
                    for (var i = 0, ii = states.length; i < ii; i++) {
                      var state = states[i];
                      var key = state[0];
                      var value = state[1];
                      switch (key) {
                        case "LW":
                          this.setLineWidth(value);
                          break;
                        case "LC":
                          this.setLineCap(value);
                          break;
                        case "LJ":
                          this.setLineJoin(value);
                          break;
                        case "ML":
                          this.setMiterLimit(value);
                          break;
                        case "D":
                          this.setDash(value[0], value[1]);
                          break;
                        case "RI":
                          this.setRenderingIntent(value);
                          break;
                        case "FL":
                          this.setFlatness(value);
                          break;
                        case "Font":
                          this.setFont(value[0], value[1]);
                          break;
                        case "CA":
                          this.current.strokeAlpha = state[1];
                          break;
                        case "ca":
                          this.current.fillAlpha = state[1];
                          this.ctx.globalAlpha = state[1];
                          break;
                        case "BM":
                          this.ctx.globalCompositeOperation = value;
                          break;
                        case "SMask":
                          if (this.current.activeSMask) {
                            if (this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1].activeSMask === this.current.activeSMask) {
                              this.suspendSMaskGroup();
                            } else {
                              this.endSMaskGroup();
                            }
                          }
                          this.current.activeSMask = value ? this.tempSMask : null;
                          if (this.current.activeSMask) {
                            this.beginSMaskGroup();
                          }
                          this.tempSMask = null;
                          break;
                      }
                    }
                  }, beginSMaskGroup: function CanvasGraphics_beginSMaskGroup() {
                    var activeSMask = this.current.activeSMask;
                    var drawnWidth = activeSMask.canvas.width;
                    var drawnHeight = activeSMask.canvas.height;
                    var cacheId = "smaskGroupAt" + this.groupLevel;
                    var scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);
                    var currentCtx = this.ctx;
                    var currentTransform = currentCtx.mozCurrentTransform;
                    this.ctx.save();
                    var groupCtx = scratchCanvas.context;
                    groupCtx.scale(1 / activeSMask.scaleX, 1 / activeSMask.scaleY);
                    groupCtx.translate(-activeSMask.offsetX, -activeSMask.offsetY);
                    groupCtx.transform.apply(groupCtx, currentTransform);
                    activeSMask.startTransformInverse = groupCtx.mozCurrentTransformInverse;
                    copyCtxState(currentCtx, groupCtx);
                    this.ctx = groupCtx;
                    this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
                    this.groupStack.push(currentCtx);
                    this.groupLevel++;
                  }, suspendSMaskGroup: function CanvasGraphics_endSMaskGroup() {
                    var groupCtx = this.ctx;
                    this.groupLevel--;
                    this.ctx = this.groupStack.pop();
                    composeSMask(this.ctx, this.current.activeSMask, groupCtx, this.webGLContext);
                    this.ctx.restore();
                    this.ctx.save();
                    copyCtxState(groupCtx, this.ctx);
                    this.current.resumeSMaskCtx = groupCtx;
                    var deltaTransform = _util2.Util.transform(this.current.activeSMask.startTransformInverse, groupCtx.mozCurrentTransform);
                    this.ctx.transform.apply(this.ctx, deltaTransform);
                    groupCtx.save();
                    groupCtx.setTransform(1, 0, 0, 1, 0, 0);
                    groupCtx.clearRect(0, 0, groupCtx.canvas.width, groupCtx.canvas.height);
                    groupCtx.restore();
                  }, resumeSMaskGroup: function CanvasGraphics_endSMaskGroup() {
                    var groupCtx = this.current.resumeSMaskCtx;
                    var currentCtx = this.ctx;
                    this.ctx = groupCtx;
                    this.groupStack.push(currentCtx);
                    this.groupLevel++;
                  }, endSMaskGroup: function CanvasGraphics_endSMaskGroup() {
                    var groupCtx = this.ctx;
                    this.groupLevel--;
                    this.ctx = this.groupStack.pop();
                    composeSMask(this.ctx, this.current.activeSMask, groupCtx, this.webGLContext);
                    this.ctx.restore();
                    copyCtxState(groupCtx, this.ctx);
                    var deltaTransform = _util2.Util.transform(this.current.activeSMask.startTransformInverse, groupCtx.mozCurrentTransform);
                    this.ctx.transform.apply(this.ctx, deltaTransform);
                  }, save: function CanvasGraphics_save() {
                    this.ctx.save();
                    var old = this.current;
                    this.stateStack.push(old);
                    this.current = old.clone();
                    this.current.resumeSMaskCtx = null;
                  }, restore: function CanvasGraphics_restore() {
                    if (this.current.resumeSMaskCtx) {
                      this.resumeSMaskGroup();
                    }
                    if (this.current.activeSMask !== null && (this.stateStack.length === 0 || this.stateStack[this.stateStack.length - 1].activeSMask !== this.current.activeSMask)) {
                      this.endSMaskGroup();
                    }
                    if (this.stateStack.length !== 0) {
                      this.current = this.stateStack.pop();
                      this.ctx.restore();
                      this.pendingClip = null;
                      this._cachedGetSinglePixelWidth = null;
                    }
                  }, transform: function CanvasGraphics_transform(a, b, c, d, e, f) {
                    this.ctx.transform(a, b, c, d, e, f);
                    this._cachedGetSinglePixelWidth = null;
                  }, constructPath: function CanvasGraphics_constructPath(ops, args) {
                    var ctx = this.ctx;
                    var current = this.current;
                    var x = current.x, y = current.y;
                    for (var i = 0, j = 0, ii = ops.length; i < ii; i++) {
                      switch (ops[i] | 0) {
                        case _util2.OPS.rectangle:
                          x = args[j++];
                          y = args[j++];
                          var width = args[j++];
                          var height = args[j++];
                          if (width === 0) {
                            width = this.getSinglePixelWidth();
                          }
                          if (height === 0) {
                            height = this.getSinglePixelWidth();
                          }
                          var xw = x + width;
                          var yh = y + height;
                          this.ctx.moveTo(x, y);
                          this.ctx.lineTo(xw, y);
                          this.ctx.lineTo(xw, yh);
                          this.ctx.lineTo(x, yh);
                          this.ctx.lineTo(x, y);
                          this.ctx.closePath();
                          break;
                        case _util2.OPS.moveTo:
                          x = args[j++];
                          y = args[j++];
                          ctx.moveTo(x, y);
                          break;
                        case _util2.OPS.lineTo:
                          x = args[j++];
                          y = args[j++];
                          ctx.lineTo(x, y);
                          break;
                        case _util2.OPS.curveTo:
                          x = args[j + 4];
                          y = args[j + 5];
                          ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y);
                          j += 6;
                          break;
                        case _util2.OPS.curveTo2:
                          ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);
                          x = args[j + 2];
                          y = args[j + 3];
                          j += 4;
                          break;
                        case _util2.OPS.curveTo3:
                          x = args[j + 2];
                          y = args[j + 3];
                          ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);
                          j += 4;
                          break;
                        case _util2.OPS.closePath:
                          ctx.closePath();
                          break;
                      }
                    }
                    current.setCurrentPoint(x, y);
                  }, closePath: function CanvasGraphics_closePath() {
                    this.ctx.closePath();
                  }, stroke: function CanvasGraphics_stroke(consumePath) {
                    consumePath = typeof consumePath !== "undefined" ? consumePath : true;
                    var ctx = this.ctx;
                    var strokeColor = this.current.strokeColor;
                    ctx.globalAlpha = this.current.strokeAlpha;
                    if (strokeColor && strokeColor.hasOwnProperty("type") && strokeColor.type === "Pattern") {
                      ctx.save();
                      var transform = ctx.mozCurrentTransform;
                      var scale = _util2.Util.singularValueDecompose2dScale(transform)[0];
                      ctx.strokeStyle = strokeColor.getPattern(ctx, this);
                      ctx.lineWidth = Math.max(this.getSinglePixelWidth() * MIN_WIDTH_FACTOR, this.current.lineWidth * scale);
                      ctx.stroke();
                      ctx.restore();
                    } else {
                      ctx.lineWidth = Math.max(this.getSinglePixelWidth() * MIN_WIDTH_FACTOR, this.current.lineWidth);
                      ctx.stroke();
                    }
                    if (consumePath) {
                      this.consumePath();
                    }
                    ctx.globalAlpha = this.current.fillAlpha;
                  }, closeStroke: function CanvasGraphics_closeStroke() {
                    this.closePath();
                    this.stroke();
                  }, fill: function CanvasGraphics_fill(consumePath) {
                    consumePath = typeof consumePath !== "undefined" ? consumePath : true;
                    var ctx = this.ctx;
                    var fillColor = this.current.fillColor;
                    var isPatternFill = this.current.patternFill;
                    var needRestore = false;
                    if (isPatternFill) {
                      ctx.save();
                      if (this.baseTransform) {
                        ctx.setTransform.apply(ctx, this.baseTransform);
                      }
                      ctx.fillStyle = fillColor.getPattern(ctx, this);
                      needRestore = true;
                    }
                    if (this.pendingEOFill) {
                      ctx.fill("evenodd");
                      this.pendingEOFill = false;
                    } else {
                      ctx.fill();
                    }
                    if (needRestore) {
                      ctx.restore();
                    }
                    if (consumePath) {
                      this.consumePath();
                    }
                  }, eoFill: function CanvasGraphics_eoFill() {
                    this.pendingEOFill = true;
                    this.fill();
                  }, fillStroke: function CanvasGraphics_fillStroke() {
                    this.fill(false);
                    this.stroke(false);
                    this.consumePath();
                  }, eoFillStroke: function CanvasGraphics_eoFillStroke() {
                    this.pendingEOFill = true;
                    this.fillStroke();
                  }, closeFillStroke: function CanvasGraphics_closeFillStroke() {
                    this.closePath();
                    this.fillStroke();
                  }, closeEOFillStroke: function CanvasGraphics_closeEOFillStroke() {
                    this.pendingEOFill = true;
                    this.closePath();
                    this.fillStroke();
                  }, endPath: function CanvasGraphics_endPath() {
                    this.consumePath();
                  }, clip: function CanvasGraphics_clip() {
                    this.pendingClip = NORMAL_CLIP;
                  }, eoClip: function CanvasGraphics_eoClip() {
                    this.pendingClip = EO_CLIP;
                  }, beginText: function CanvasGraphics_beginText() {
                    this.current.textMatrix = _util2.IDENTITY_MATRIX;
                    this.current.textMatrixScale = 1;
                    this.current.x = this.current.lineX = 0;
                    this.current.y = this.current.lineY = 0;
                  }, endText: function CanvasGraphics_endText() {
                    var paths = this.pendingTextPaths;
                    var ctx = this.ctx;
                    if (paths === void 0) {
                      ctx.beginPath();
                      return;
                    }
                    ctx.save();
                    ctx.beginPath();
                    for (var i = 0; i < paths.length; i++) {
                      var path = paths[i];
                      ctx.setTransform.apply(ctx, path.transform);
                      ctx.translate(path.x, path.y);
                      path.addToPath(ctx, path.fontSize);
                    }
                    ctx.restore();
                    ctx.clip();
                    ctx.beginPath();
                    delete this.pendingTextPaths;
                  }, setCharSpacing: function CanvasGraphics_setCharSpacing(spacing) {
                    this.current.charSpacing = spacing;
                  }, setWordSpacing: function CanvasGraphics_setWordSpacing(spacing) {
                    this.current.wordSpacing = spacing;
                  }, setHScale: function CanvasGraphics_setHScale(scale) {
                    this.current.textHScale = scale / 100;
                  }, setLeading: function CanvasGraphics_setLeading(leading) {
                    this.current.leading = -leading;
                  }, setFont: function CanvasGraphics_setFont(fontRefName, size) {
                    var fontObj = this.commonObjs.get(fontRefName);
                    var current = this.current;
                    if (!fontObj) {
                      throw new Error("Can't find font for ".concat(fontRefName));
                    }
                    current.fontMatrix = fontObj.fontMatrix ? fontObj.fontMatrix : _util2.FONT_IDENTITY_MATRIX;
                    if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {
                      (0, _util2.warn)("Invalid font matrix for font " + fontRefName);
                    }
                    if (size < 0) {
                      size = -size;
                      current.fontDirection = -1;
                    } else {
                      current.fontDirection = 1;
                    }
                    this.current.font = fontObj;
                    this.current.fontSize = size;
                    if (fontObj.isType3Font) {
                      return;
                    }
                    var name = fontObj.loadedName || "sans-serif";
                    var bold = "normal";
                    if (fontObj.black) {
                      bold = "900";
                    } else if (fontObj.bold) {
                      bold = "bold";
                    }
                    var italic = fontObj.italic ? "italic" : "normal";
                    var typeface = '"'.concat(name, '", ').concat(fontObj.fallbackName);
                    var browserFontSize = size;
                    if (size < MIN_FONT_SIZE) {
                      browserFontSize = MIN_FONT_SIZE;
                    } else if (size > MAX_FONT_SIZE) {
                      browserFontSize = MAX_FONT_SIZE;
                    }
                    this.current.fontSizeScale = size / browserFontSize;
                    this.ctx.font = "".concat(italic, " ").concat(bold, " ").concat(browserFontSize, "px ").concat(typeface);
                  }, setTextRenderingMode: function CanvasGraphics_setTextRenderingMode(mode) {
                    this.current.textRenderingMode = mode;
                  }, setTextRise: function CanvasGraphics_setTextRise(rise) {
                    this.current.textRise = rise;
                  }, moveText: function CanvasGraphics_moveText(x, y) {
                    this.current.x = this.current.lineX += x;
                    this.current.y = this.current.lineY += y;
                  }, setLeadingMoveText: function CanvasGraphics_setLeadingMoveText(x, y) {
                    this.setLeading(-y);
                    this.moveText(x, y);
                  }, setTextMatrix: function CanvasGraphics_setTextMatrix(a, b, c, d, e, f) {
                    this.current.textMatrix = [a, b, c, d, e, f];
                    this.current.textMatrixScale = Math.sqrt(a * a + b * b);
                    this.current.x = this.current.lineX = 0;
                    this.current.y = this.current.lineY = 0;
                  }, nextLine: function CanvasGraphics_nextLine() {
                    this.moveText(0, this.current.leading);
                  }, paintChar: function paintChar(character, x, y, patternTransform) {
                    var ctx = this.ctx;
                    var current = this.current;
                    var font = current.font;
                    var textRenderingMode = current.textRenderingMode;
                    var fontSize = current.fontSize / current.fontSizeScale;
                    var fillStrokeMode = textRenderingMode & _util2.TextRenderingMode.FILL_STROKE_MASK;
                    var isAddToPathSet = !!(textRenderingMode & _util2.TextRenderingMode.ADD_TO_PATH_FLAG);
                    var patternFill = current.patternFill && font.data;
                    var addToPath;
                    if (font.disableFontFace || isAddToPathSet || patternFill) {
                      addToPath = font.getPathGenerator(this.commonObjs, character);
                    }
                    if (font.disableFontFace || patternFill) {
                      ctx.save();
                      ctx.translate(x, y);
                      ctx.beginPath();
                      addToPath(ctx, fontSize);
                      if (patternTransform) {
                        ctx.setTransform.apply(ctx, patternTransform);
                      }
                      if (fillStrokeMode === _util2.TextRenderingMode.FILL || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                        ctx.fill();
                      }
                      if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                        ctx.stroke();
                      }
                      ctx.restore();
                    } else {
                      if (fillStrokeMode === _util2.TextRenderingMode.FILL || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                        ctx.fillText(character, x, y);
                      }
                      if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                        ctx.strokeText(character, x, y);
                      }
                    }
                    if (isAddToPathSet) {
                      var paths = this.pendingTextPaths || (this.pendingTextPaths = []);
                      paths.push({ transform: ctx.mozCurrentTransform, x, y, fontSize, addToPath });
                    }
                  }, get isFontSubpixelAAEnabled() {
                    var _this$cachedCanvases$ = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10), ctx = _this$cachedCanvases$.context;
                    ctx.scale(1.5, 1);
                    ctx.fillText("I", 0, 10);
                    var data = ctx.getImageData(0, 0, 10, 10).data;
                    var enabled = false;
                    for (var i = 3; i < data.length; i += 4) {
                      if (data[i] > 0 && data[i] < 255) {
                        enabled = true;
                        break;
                      }
                    }
                    return (0, _util2.shadow)(this, "isFontSubpixelAAEnabled", enabled);
                  }, showText: function CanvasGraphics_showText(glyphs) {
                    var current = this.current;
                    var font = current.font;
                    if (font.isType3Font) {
                      return this.showType3Text(glyphs);
                    }
                    var fontSize = current.fontSize;
                    if (fontSize === 0) {
                      return void 0;
                    }
                    var ctx = this.ctx;
                    var fontSizeScale = current.fontSizeScale;
                    var charSpacing = current.charSpacing;
                    var wordSpacing = current.wordSpacing;
                    var fontDirection = current.fontDirection;
                    var textHScale = current.textHScale * fontDirection;
                    var glyphsLength = glyphs.length;
                    var vertical = font.vertical;
                    var spacingDir = vertical ? 1 : -1;
                    var defaultVMetrics = font.defaultVMetrics;
                    var widthAdvanceScale = fontSize * current.fontMatrix[0];
                    var simpleFillText = current.textRenderingMode === _util2.TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;
                    ctx.save();
                    var patternTransform;
                    if (current.patternFill) {
                      ctx.save();
                      var pattern = current.fillColor.getPattern(ctx, this);
                      patternTransform = ctx.mozCurrentTransform;
                      ctx.restore();
                      ctx.fillStyle = pattern;
                    }
                    ctx.transform.apply(ctx, current.textMatrix);
                    ctx.translate(current.x, current.y + current.textRise);
                    if (fontDirection > 0) {
                      ctx.scale(textHScale, -1);
                    } else {
                      ctx.scale(textHScale, 1);
                    }
                    var lineWidth = current.lineWidth;
                    var scale = current.textMatrixScale;
                    if (scale === 0 || lineWidth === 0) {
                      var fillStrokeMode = current.textRenderingMode & _util2.TextRenderingMode.FILL_STROKE_MASK;
                      if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                        this._cachedGetSinglePixelWidth = null;
                        lineWidth = this.getSinglePixelWidth() * MIN_WIDTH_FACTOR;
                      }
                    } else {
                      lineWidth /= scale;
                    }
                    if (fontSizeScale !== 1) {
                      ctx.scale(fontSizeScale, fontSizeScale);
                      lineWidth /= fontSizeScale;
                    }
                    ctx.lineWidth = lineWidth;
                    var x = 0, i;
                    for (i = 0; i < glyphsLength; ++i) {
                      var glyph = glyphs[i];
                      if ((0, _util2.isNum)(glyph)) {
                        x += spacingDir * glyph * fontSize / 1e3;
                        continue;
                      }
                      var restoreNeeded = false;
                      var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                      var character = glyph.fontChar;
                      var accent = glyph.accent;
                      var scaledX, scaledY, scaledAccentX, scaledAccentY;
                      var width = glyph.width;
                      if (vertical) {
                        var vmetric, vx, vy;
                        vmetric = glyph.vmetric || defaultVMetrics;
                        vx = glyph.vmetric ? vmetric[1] : width * 0.5;
                        vx = -vx * widthAdvanceScale;
                        vy = vmetric[2] * widthAdvanceScale;
                        width = vmetric ? -vmetric[0] : width;
                        scaledX = vx / fontSizeScale;
                        scaledY = (x + vy) / fontSizeScale;
                      } else {
                        scaledX = x / fontSizeScale;
                        scaledY = 0;
                      }
                      if (font.remeasure && width > 0) {
                        var measuredWidth = ctx.measureText(character).width * 1e3 / fontSize * fontSizeScale;
                        if (width < measuredWidth && this.isFontSubpixelAAEnabled) {
                          var characterScaleX = width / measuredWidth;
                          restoreNeeded = true;
                          ctx.save();
                          ctx.scale(characterScaleX, 1);
                          scaledX /= characterScaleX;
                        } else if (width !== measuredWidth) {
                          scaledX += (width - measuredWidth) / 2e3 * fontSize / fontSizeScale;
                        }
                      }
                      if (glyph.isInFont || font.missingFile) {
                        if (simpleFillText && !accent) {
                          ctx.fillText(character, scaledX, scaledY);
                        } else {
                          this.paintChar(character, scaledX, scaledY, patternTransform);
                          if (accent) {
                            scaledAccentX = scaledX + accent.offset.x / fontSizeScale;
                            scaledAccentY = scaledY - accent.offset.y / fontSizeScale;
                            this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternTransform);
                          }
                        }
                      }
                      var charWidth;
                      if (vertical) {
                        charWidth = width * widthAdvanceScale - spacing * fontDirection;
                      } else {
                        charWidth = width * widthAdvanceScale + spacing * fontDirection;
                      }
                      x += charWidth;
                      if (restoreNeeded) {
                        ctx.restore();
                      }
                    }
                    if (vertical) {
                      current.y -= x;
                    } else {
                      current.x += x * textHScale;
                    }
                    ctx.restore();
                  }, showType3Text: function CanvasGraphics_showType3Text(glyphs) {
                    var ctx = this.ctx;
                    var current = this.current;
                    var font = current.font;
                    var fontSize = current.fontSize;
                    var fontDirection = current.fontDirection;
                    var spacingDir = font.vertical ? 1 : -1;
                    var charSpacing = current.charSpacing;
                    var wordSpacing = current.wordSpacing;
                    var textHScale = current.textHScale * fontDirection;
                    var fontMatrix = current.fontMatrix || _util2.FONT_IDENTITY_MATRIX;
                    var glyphsLength = glyphs.length;
                    var isTextInvisible = current.textRenderingMode === _util2.TextRenderingMode.INVISIBLE;
                    var i, glyph, width, spacingLength;
                    if (isTextInvisible || fontSize === 0) {
                      return;
                    }
                    this._cachedGetSinglePixelWidth = null;
                    ctx.save();
                    ctx.transform.apply(ctx, current.textMatrix);
                    ctx.translate(current.x, current.y);
                    ctx.scale(textHScale, fontDirection);
                    for (i = 0; i < glyphsLength; ++i) {
                      glyph = glyphs[i];
                      if ((0, _util2.isNum)(glyph)) {
                        spacingLength = spacingDir * glyph * fontSize / 1e3;
                        this.ctx.translate(spacingLength, 0);
                        current.x += spacingLength * textHScale;
                        continue;
                      }
                      var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                      var operatorList = font.charProcOperatorList[glyph.operatorListId];
                      if (!operatorList) {
                        (0, _util2.warn)('Type3 character "'.concat(glyph.operatorListId, '" is not available.'));
                        continue;
                      }
                      this.processingType3 = glyph;
                      this.save();
                      ctx.scale(fontSize, fontSize);
                      ctx.transform.apply(ctx, fontMatrix);
                      this.executeOperatorList(operatorList);
                      this.restore();
                      var transformed = _util2.Util.applyTransform([glyph.width, 0], fontMatrix);
                      width = transformed[0] * fontSize + spacing;
                      ctx.translate(width, 0);
                      current.x += width * textHScale;
                    }
                    ctx.restore();
                    this.processingType3 = null;
                  }, setCharWidth: function CanvasGraphics_setCharWidth(xWidth, yWidth) {
                  }, setCharWidthAndBounds: function CanvasGraphics_setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {
                    this.ctx.rect(llx, lly, urx - llx, ury - lly);
                    this.clip();
                    this.endPath();
                  }, getColorN_Pattern: function CanvasGraphics_getColorN_Pattern(IR) {
                    var _this = this;
                    var pattern;
                    if (IR[0] === "TilingPattern") {
                      var color = IR[1];
                      var baseTransform = this.baseTransform || this.ctx.mozCurrentTransform.slice();
                      var canvasGraphicsFactory = { createCanvasGraphics: function createCanvasGraphics(ctx) {
                        return new CanvasGraphics2(ctx, _this.commonObjs, _this.objs, _this.canvasFactory, _this.webGLContext);
                      } };
                      pattern = new _pattern_helper.TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);
                    } else {
                      pattern = (0, _pattern_helper.getShadingPatternFromIR)(IR);
                    }
                    return pattern;
                  }, setStrokeColorN: function CanvasGraphics_setStrokeColorN() {
                    this.current.strokeColor = this.getColorN_Pattern(arguments);
                  }, setFillColorN: function CanvasGraphics_setFillColorN() {
                    this.current.fillColor = this.getColorN_Pattern(arguments);
                    this.current.patternFill = true;
                  }, setStrokeRGBColor: function CanvasGraphics_setStrokeRGBColor(r, g, b) {
                    var color = _util2.Util.makeCssRgb(r, g, b);
                    this.ctx.strokeStyle = color;
                    this.current.strokeColor = color;
                  }, setFillRGBColor: function CanvasGraphics_setFillRGBColor(r, g, b) {
                    var color = _util2.Util.makeCssRgb(r, g, b);
                    this.ctx.fillStyle = color;
                    this.current.fillColor = color;
                    this.current.patternFill = false;
                  }, shadingFill: function CanvasGraphics_shadingFill(patternIR) {
                    var ctx = this.ctx;
                    this.save();
                    var pattern = (0, _pattern_helper.getShadingPatternFromIR)(patternIR);
                    ctx.fillStyle = pattern.getPattern(ctx, this, true);
                    var inv = ctx.mozCurrentTransformInverse;
                    if (inv) {
                      var canvas = ctx.canvas;
                      var width = canvas.width;
                      var height = canvas.height;
                      var bl = _util2.Util.applyTransform([0, 0], inv);
                      var br = _util2.Util.applyTransform([0, height], inv);
                      var ul = _util2.Util.applyTransform([width, 0], inv);
                      var ur = _util2.Util.applyTransform([width, height], inv);
                      var x0 = Math.min(bl[0], br[0], ul[0], ur[0]);
                      var y0 = Math.min(bl[1], br[1], ul[1], ur[1]);
                      var x1 = Math.max(bl[0], br[0], ul[0], ur[0]);
                      var y1 = Math.max(bl[1], br[1], ul[1], ur[1]);
                      this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);
                    } else {
                      this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
                    }
                    this.restore();
                  }, beginInlineImage: function CanvasGraphics_beginInlineImage() {
                    (0, _util2.unreachable)("Should not call beginInlineImage");
                  }, beginImageData: function CanvasGraphics_beginImageData() {
                    (0, _util2.unreachable)("Should not call beginImageData");
                  }, paintFormXObjectBegin: function CanvasGraphics_paintFormXObjectBegin(matrix, bbox) {
                    this.save();
                    this.baseTransformStack.push(this.baseTransform);
                    if (Array.isArray(matrix) && matrix.length === 6) {
                      this.transform.apply(this, matrix);
                    }
                    this.baseTransform = this.ctx.mozCurrentTransform;
                    if (bbox) {
                      var width = bbox[2] - bbox[0];
                      var height = bbox[3] - bbox[1];
                      this.ctx.rect(bbox[0], bbox[1], width, height);
                      this.clip();
                      this.endPath();
                    }
                  }, paintFormXObjectEnd: function CanvasGraphics_paintFormXObjectEnd() {
                    this.restore();
                    this.baseTransform = this.baseTransformStack.pop();
                  }, beginGroup: function CanvasGraphics_beginGroup(group) {
                    this.save();
                    var currentCtx = this.ctx;
                    if (!group.isolated) {
                      (0, _util2.info)("TODO: Support non-isolated groups.");
                    }
                    if (group.knockout) {
                      (0, _util2.warn)("Knockout groups not supported.");
                    }
                    var currentTransform = currentCtx.mozCurrentTransform;
                    if (group.matrix) {
                      currentCtx.transform.apply(currentCtx, group.matrix);
                    }
                    if (!group.bbox) {
                      throw new Error("Bounding box is required.");
                    }
                    var bounds = _util2.Util.getAxialAlignedBoundingBox(group.bbox, currentCtx.mozCurrentTransform);
                    var canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];
                    bounds = _util2.Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];
                    var offsetX = Math.floor(bounds[0]);
                    var offsetY = Math.floor(bounds[1]);
                    var drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);
                    var drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);
                    var scaleX = 1, scaleY = 1;
                    if (drawnWidth > MAX_GROUP_SIZE) {
                      scaleX = drawnWidth / MAX_GROUP_SIZE;
                      drawnWidth = MAX_GROUP_SIZE;
                    }
                    if (drawnHeight > MAX_GROUP_SIZE) {
                      scaleY = drawnHeight / MAX_GROUP_SIZE;
                      drawnHeight = MAX_GROUP_SIZE;
                    }
                    var cacheId = "groupAt" + this.groupLevel;
                    if (group.smask) {
                      cacheId += "_smask_" + this.smaskCounter++ % 2;
                    }
                    var scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);
                    var groupCtx = scratchCanvas.context;
                    groupCtx.scale(1 / scaleX, 1 / scaleY);
                    groupCtx.translate(-offsetX, -offsetY);
                    groupCtx.transform.apply(groupCtx, currentTransform);
                    if (group.smask) {
                      this.smaskStack.push({ canvas: scratchCanvas.canvas, context: groupCtx, offsetX, offsetY, scaleX, scaleY, subtype: group.smask.subtype, backdrop: group.smask.backdrop, transferMap: group.smask.transferMap || null, startTransformInverse: null });
                    } else {
                      currentCtx.setTransform(1, 0, 0, 1, 0, 0);
                      currentCtx.translate(offsetX, offsetY);
                      currentCtx.scale(scaleX, scaleY);
                    }
                    copyCtxState(currentCtx, groupCtx);
                    this.ctx = groupCtx;
                    this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
                    this.groupStack.push(currentCtx);
                    this.groupLevel++;
                    this.current.activeSMask = null;
                  }, endGroup: function CanvasGraphics_endGroup(group) {
                    this.groupLevel--;
                    var groupCtx = this.ctx;
                    this.ctx = this.groupStack.pop();
                    if (this.ctx.imageSmoothingEnabled !== void 0) {
                      this.ctx.imageSmoothingEnabled = false;
                    } else {
                      this.ctx.mozImageSmoothingEnabled = false;
                    }
                    if (group.smask) {
                      this.tempSMask = this.smaskStack.pop();
                    } else {
                      this.ctx.drawImage(groupCtx.canvas, 0, 0);
                    }
                    this.restore();
                  }, beginAnnotations: function CanvasGraphics_beginAnnotations() {
                    this.save();
                    if (this.baseTransform) {
                      this.ctx.setTransform.apply(this.ctx, this.baseTransform);
                    }
                  }, endAnnotations: function CanvasGraphics_endAnnotations() {
                    this.restore();
                  }, beginAnnotation: function CanvasGraphics_beginAnnotation(rect, transform, matrix) {
                    this.save();
                    resetCtxToDefault(this.ctx);
                    this.current = new CanvasExtraState();
                    if (Array.isArray(rect) && rect.length === 4) {
                      var width = rect[2] - rect[0];
                      var height = rect[3] - rect[1];
                      this.ctx.rect(rect[0], rect[1], width, height);
                      this.clip();
                      this.endPath();
                    }
                    this.transform.apply(this, transform);
                    this.transform.apply(this, matrix);
                  }, endAnnotation: function CanvasGraphics_endAnnotation() {
                    this.restore();
                  }, paintJpegXObject: function CanvasGraphics_paintJpegXObject(objId, w, h) {
                    var domImage = this.processingType3 ? this.commonObjs.get(objId) : this.objs.get(objId);
                    if (!domImage) {
                      (0, _util2.warn)("Dependent image isn't ready yet");
                      return;
                    }
                    this.save();
                    var ctx = this.ctx;
                    ctx.scale(1 / w, -1 / h);
                    ctx.drawImage(domImage, 0, 0, domImage.width, domImage.height, 0, -h, w, h);
                    if (this.imageLayer) {
                      var currentTransform = ctx.mozCurrentTransformInverse;
                      var position = this.getCanvasPosition(0, 0);
                      this.imageLayer.appendImage({ objId, left: position[0], top: position[1], width: w / currentTransform[0], height: h / currentTransform[3] });
                    }
                    this.restore();
                  }, paintImageMaskXObject: function CanvasGraphics_paintImageMaskXObject(img) {
                    var ctx = this.ctx;
                    var width = img.width, height = img.height;
                    var fillColor = this.current.fillColor;
                    var isPatternFill = this.current.patternFill;
                    var glyph = this.processingType3;
                    if (COMPILE_TYPE3_GLYPHS && glyph && glyph.compiled === void 0) {
                      if (width <= MAX_SIZE_TO_COMPILE && height <= MAX_SIZE_TO_COMPILE) {
                        glyph.compiled = compileType3Glyph({ data: img.data, width, height });
                      } else {
                        glyph.compiled = null;
                      }
                    }
                    if (glyph && glyph.compiled) {
                      glyph.compiled(ctx);
                      return;
                    }
                    var maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
                    var maskCtx = maskCanvas.context;
                    maskCtx.save();
                    putBinaryImageMask(maskCtx, img);
                    maskCtx.globalCompositeOperation = "source-in";
                    maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;
                    maskCtx.fillRect(0, 0, width, height);
                    maskCtx.restore();
                    this.paintInlineImageXObject(maskCanvas.canvas);
                  }, paintImageMaskXObjectRepeat: function CanvasGraphics_paintImageMaskXObjectRepeat(imgData, scaleX, scaleY, positions) {
                    var width = imgData.width;
                    var height = imgData.height;
                    var fillColor = this.current.fillColor;
                    var isPatternFill = this.current.patternFill;
                    var maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
                    var maskCtx = maskCanvas.context;
                    maskCtx.save();
                    putBinaryImageMask(maskCtx, imgData);
                    maskCtx.globalCompositeOperation = "source-in";
                    maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;
                    maskCtx.fillRect(0, 0, width, height);
                    maskCtx.restore();
                    var ctx = this.ctx;
                    for (var i = 0, ii = positions.length; i < ii; i += 2) {
                      ctx.save();
                      ctx.transform(scaleX, 0, 0, scaleY, positions[i], positions[i + 1]);
                      ctx.scale(1, -1);
                      ctx.drawImage(maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);
                      ctx.restore();
                    }
                  }, paintImageMaskXObjectGroup: function CanvasGraphics_paintImageMaskXObjectGroup(images) {
                    var ctx = this.ctx;
                    var fillColor = this.current.fillColor;
                    var isPatternFill = this.current.patternFill;
                    for (var i = 0, ii = images.length; i < ii; i++) {
                      var image = images[i];
                      var width = image.width, height = image.height;
                      var maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
                      var maskCtx = maskCanvas.context;
                      maskCtx.save();
                      putBinaryImageMask(maskCtx, image);
                      maskCtx.globalCompositeOperation = "source-in";
                      maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;
                      maskCtx.fillRect(0, 0, width, height);
                      maskCtx.restore();
                      ctx.save();
                      ctx.transform.apply(ctx, image.transform);
                      ctx.scale(1, -1);
                      ctx.drawImage(maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);
                      ctx.restore();
                    }
                  }, paintImageXObject: function CanvasGraphics_paintImageXObject(objId) {
                    var imgData = this.processingType3 ? this.commonObjs.get(objId) : this.objs.get(objId);
                    if (!imgData) {
                      (0, _util2.warn)("Dependent image isn't ready yet");
                      return;
                    }
                    this.paintInlineImageXObject(imgData);
                  }, paintImageXObjectRepeat: function CanvasGraphics_paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {
                    var imgData = this.processingType3 ? this.commonObjs.get(objId) : this.objs.get(objId);
                    if (!imgData) {
                      (0, _util2.warn)("Dependent image isn't ready yet");
                      return;
                    }
                    var width = imgData.width;
                    var height = imgData.height;
                    var map = [];
                    for (var i = 0, ii = positions.length; i < ii; i += 2) {
                      map.push({ transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]], x: 0, y: 0, w: width, h: height });
                    }
                    this.paintInlineImageXObjectGroup(imgData, map);
                  }, paintInlineImageXObject: function CanvasGraphics_paintInlineImageXObject(imgData) {
                    var width = imgData.width;
                    var height = imgData.height;
                    var ctx = this.ctx;
                    this.save();
                    ctx.scale(1 / width, -1 / height);
                    var currentTransform = ctx.mozCurrentTransformInverse;
                    var a = currentTransform[0], b = currentTransform[1];
                    var widthScale = Math.max(Math.sqrt(a * a + b * b), 1);
                    var c = currentTransform[2], d = currentTransform[3];
                    var heightScale = Math.max(Math.sqrt(c * c + d * d), 1);
                    var imgToPaint, tmpCanvas;
                    if (typeof HTMLElement === "function" && imgData instanceof HTMLElement || !imgData.data) {
                      imgToPaint = imgData;
                    } else {
                      tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", width, height);
                      var tmpCtx = tmpCanvas.context;
                      putBinaryImageData(tmpCtx, imgData);
                      imgToPaint = tmpCanvas.canvas;
                    }
                    var paintWidth = width, paintHeight = height;
                    var tmpCanvasId = "prescale1";
                    while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {
                      var newWidth = paintWidth, newHeight = paintHeight;
                      if (widthScale > 2 && paintWidth > 1) {
                        newWidth = Math.ceil(paintWidth / 2);
                        widthScale /= paintWidth / newWidth;
                      }
                      if (heightScale > 2 && paintHeight > 1) {
                        newHeight = Math.ceil(paintHeight / 2);
                        heightScale /= paintHeight / newHeight;
                      }
                      tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);
                      tmpCtx = tmpCanvas.context;
                      tmpCtx.clearRect(0, 0, newWidth, newHeight);
                      tmpCtx.drawImage(imgToPaint, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);
                      imgToPaint = tmpCanvas.canvas;
                      paintWidth = newWidth;
                      paintHeight = newHeight;
                      tmpCanvasId = tmpCanvasId === "prescale1" ? "prescale2" : "prescale1";
                    }
                    ctx.drawImage(imgToPaint, 0, 0, paintWidth, paintHeight, 0, -height, width, height);
                    if (this.imageLayer) {
                      var position = this.getCanvasPosition(0, -height);
                      this.imageLayer.appendImage({ imgData, left: position[0], top: position[1], width: width / currentTransform[0], height: height / currentTransform[3] });
                    }
                    this.restore();
                  }, paintInlineImageXObjectGroup: function CanvasGraphics_paintInlineImageXObjectGroup(imgData, map) {
                    var ctx = this.ctx;
                    var w = imgData.width;
                    var h = imgData.height;
                    var tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", w, h);
                    var tmpCtx = tmpCanvas.context;
                    putBinaryImageData(tmpCtx, imgData);
                    for (var i = 0, ii = map.length; i < ii; i++) {
                      var entry = map[i];
                      ctx.save();
                      ctx.transform.apply(ctx, entry.transform);
                      ctx.scale(1, -1);
                      ctx.drawImage(tmpCanvas.canvas, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);
                      if (this.imageLayer) {
                        var position = this.getCanvasPosition(entry.x, entry.y);
                        this.imageLayer.appendImage({ imgData, left: position[0], top: position[1], width: w, height: h });
                      }
                      ctx.restore();
                    }
                  }, paintSolidColorImageMask: function CanvasGraphics_paintSolidColorImageMask() {
                    this.ctx.fillRect(0, 0, 1, 1);
                  }, paintXObject: function CanvasGraphics_paintXObject() {
                    (0, _util2.warn)("Unsupported 'paintXObject' command.");
                  }, markPoint: function CanvasGraphics_markPoint(tag) {
                  }, markPointProps: function CanvasGraphics_markPointProps(tag, properties) {
                  }, beginMarkedContent: function CanvasGraphics_beginMarkedContent(tag) {
                  }, beginMarkedContentProps: function CanvasGraphics_beginMarkedContentProps(tag, properties) {
                  }, endMarkedContent: function CanvasGraphics_endMarkedContent() {
                  }, beginCompat: function CanvasGraphics_beginCompat() {
                  }, endCompat: function CanvasGraphics_endCompat() {
                  }, consumePath: function CanvasGraphics_consumePath() {
                    var ctx = this.ctx;
                    if (this.pendingClip) {
                      if (this.pendingClip === EO_CLIP) {
                        ctx.clip("evenodd");
                      } else {
                        ctx.clip();
                      }
                      this.pendingClip = null;
                    }
                    ctx.beginPath();
                  }, getSinglePixelWidth: function getSinglePixelWidth(scale) {
                    if (this._cachedGetSinglePixelWidth === null) {
                      var inverse = this.ctx.mozCurrentTransformInverse;
                      this._cachedGetSinglePixelWidth = Math.sqrt(Math.max(inverse[0] * inverse[0] + inverse[1] * inverse[1], inverse[2] * inverse[2] + inverse[3] * inverse[3]));
                    }
                    return this._cachedGetSinglePixelWidth;
                  }, getCanvasPosition: function CanvasGraphics_getCanvasPosition(x, y) {
                    var transform = this.ctx.mozCurrentTransform;
                    return [transform[0] * x + transform[2] * y + transform[4], transform[1] * x + transform[3] * y + transform[5]];
                  } };
                  for (var op in _util2.OPS) {
                    CanvasGraphics2.prototype[_util2.OPS[op]] = CanvasGraphics2.prototype[op];
                  }
                  return CanvasGraphics2;
                }();
                exports2.CanvasGraphics = CanvasGraphics;
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.getShadingPatternFromIR = getShadingPatternFromIR;
                exports2.TilingPattern = void 0;
                var _util2 = __w_pdfjs_require__2(1);
                var ShadingIRs = {};
                function applyBoundingBox(ctx, bbox) {
                  if (!bbox || typeof Path2D === "undefined") {
                    return;
                  }
                  var width = bbox[2] - bbox[0];
                  var height = bbox[3] - bbox[1];
                  var region = new Path2D();
                  region.rect(bbox[0], bbox[1], width, height);
                  ctx.clip(region);
                }
                ShadingIRs.RadialAxial = { fromIR: function RadialAxial_fromIR(raw) {
                  var type = raw[1];
                  var bbox = raw[2];
                  var colorStops = raw[3];
                  var p0 = raw[4];
                  var p1 = raw[5];
                  var r0 = raw[6];
                  var r1 = raw[7];
                  return { type: "Pattern", getPattern: function RadialAxial_getPattern(ctx) {
                    applyBoundingBox(ctx, bbox);
                    var grad;
                    if (type === "axial") {
                      grad = ctx.createLinearGradient(p0[0], p0[1], p1[0], p1[1]);
                    } else if (type === "radial") {
                      grad = ctx.createRadialGradient(p0[0], p0[1], r0, p1[0], p1[1], r1);
                    }
                    for (var i = 0, ii = colorStops.length; i < ii; ++i) {
                      var c = colorStops[i];
                      grad.addColorStop(c[0], c[1]);
                    }
                    return grad;
                  } };
                } };
                var createMeshCanvas = function createMeshCanvasClosure() {
                  function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {
                    var coords = context.coords, colors = context.colors;
                    var bytes = data.data, rowSize = data.width * 4;
                    var tmp;
                    if (coords[p1 + 1] > coords[p2 + 1]) {
                      tmp = p1;
                      p1 = p2;
                      p2 = tmp;
                      tmp = c1;
                      c1 = c2;
                      c2 = tmp;
                    }
                    if (coords[p2 + 1] > coords[p3 + 1]) {
                      tmp = p2;
                      p2 = p3;
                      p3 = tmp;
                      tmp = c2;
                      c2 = c3;
                      c3 = tmp;
                    }
                    if (coords[p1 + 1] > coords[p2 + 1]) {
                      tmp = p1;
                      p1 = p2;
                      p2 = tmp;
                      tmp = c1;
                      c1 = c2;
                      c2 = tmp;
                    }
                    var x1 = (coords[p1] + context.offsetX) * context.scaleX;
                    var y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;
                    var x2 = (coords[p2] + context.offsetX) * context.scaleX;
                    var y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;
                    var x3 = (coords[p3] + context.offsetX) * context.scaleX;
                    var y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;
                    if (y1 >= y3) {
                      return;
                    }
                    var c1r = colors[c1], c1g = colors[c1 + 1], c1b = colors[c1 + 2];
                    var c2r = colors[c2], c2g = colors[c2 + 1], c2b = colors[c2 + 2];
                    var c3r = colors[c3], c3g = colors[c3 + 1], c3b = colors[c3 + 2];
                    var minY = Math.round(y1), maxY = Math.round(y3);
                    var xa, car, cag, cab;
                    var xb, cbr, cbg, cbb;
                    for (var y = minY; y <= maxY; y++) {
                      if (y < y2) {
                        var _k = void 0;
                        if (y < y1) {
                          _k = 0;
                        } else if (y1 === y2) {
                          _k = 1;
                        } else {
                          _k = (y1 - y) / (y1 - y2);
                        }
                        xa = x1 - (x1 - x2) * _k;
                        car = c1r - (c1r - c2r) * _k;
                        cag = c1g - (c1g - c2g) * _k;
                        cab = c1b - (c1b - c2b) * _k;
                      } else {
                        var _k2 = void 0;
                        if (y > y3) {
                          _k2 = 1;
                        } else if (y2 === y3) {
                          _k2 = 0;
                        } else {
                          _k2 = (y2 - y) / (y2 - y3);
                        }
                        xa = x2 - (x2 - x3) * _k2;
                        car = c2r - (c2r - c3r) * _k2;
                        cag = c2g - (c2g - c3g) * _k2;
                        cab = c2b - (c2b - c3b) * _k2;
                      }
                      var k = void 0;
                      if (y < y1) {
                        k = 0;
                      } else if (y > y3) {
                        k = 1;
                      } else {
                        k = (y1 - y) / (y1 - y3);
                      }
                      xb = x1 - (x1 - x3) * k;
                      cbr = c1r - (c1r - c3r) * k;
                      cbg = c1g - (c1g - c3g) * k;
                      cbb = c1b - (c1b - c3b) * k;
                      var x1_ = Math.round(Math.min(xa, xb));
                      var x2_ = Math.round(Math.max(xa, xb));
                      var j = rowSize * y + x1_ * 4;
                      for (var x = x1_; x <= x2_; x++) {
                        var _k3 = (xa - x) / (xa - xb);
                        if (_k3 < 0) {
                          _k3 = 0;
                        } else if (_k3 > 1) {
                          _k3 = 1;
                        }
                        bytes[j++] = car - (car - cbr) * _k3 | 0;
                        bytes[j++] = cag - (cag - cbg) * _k3 | 0;
                        bytes[j++] = cab - (cab - cbb) * _k3 | 0;
                        bytes[j++] = 255;
                      }
                    }
                  }
                  function drawFigure(data, figure, context) {
                    var ps = figure.coords;
                    var cs = figure.colors;
                    var i, ii;
                    switch (figure.type) {
                      case "lattice":
                        var verticesPerRow = figure.verticesPerRow;
                        var rows = Math.floor(ps.length / verticesPerRow) - 1;
                        var cols = verticesPerRow - 1;
                        for (i = 0; i < rows; i++) {
                          var q = i * verticesPerRow;
                          for (var j = 0; j < cols; j++, q++) {
                            drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);
                            drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);
                          }
                        }
                        break;
                      case "triangles":
                        for (i = 0, ii = ps.length; i < ii; i += 3) {
                          drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);
                        }
                        break;
                      default:
                        throw new Error("illegal figure");
                    }
                  }
                  function createMeshCanvas2(bounds, combinesScale, coords, colors, figures, backgroundColor, cachedCanvases, webGLContext) {
                    var EXPECTED_SCALE = 1.1;
                    var MAX_PATTERN_SIZE = 3e3;
                    var BORDER_SIZE = 2;
                    var offsetX = Math.floor(bounds[0]);
                    var offsetY = Math.floor(bounds[1]);
                    var boundsWidth = Math.ceil(bounds[2]) - offsetX;
                    var boundsHeight = Math.ceil(bounds[3]) - offsetY;
                    var width = Math.min(Math.ceil(Math.abs(boundsWidth * combinesScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
                    var height = Math.min(Math.ceil(Math.abs(boundsHeight * combinesScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
                    var scaleX = boundsWidth / width;
                    var scaleY = boundsHeight / height;
                    var context = { coords, colors, offsetX: -offsetX, offsetY: -offsetY, scaleX: 1 / scaleX, scaleY: 1 / scaleY };
                    var paddedWidth = width + BORDER_SIZE * 2;
                    var paddedHeight = height + BORDER_SIZE * 2;
                    var canvas, tmpCanvas, i, ii;
                    if (webGLContext.isEnabled) {
                      canvas = webGLContext.drawFigures({ width, height, backgroundColor, figures, context });
                      tmpCanvas = cachedCanvases.getCanvas("mesh", paddedWidth, paddedHeight, false);
                      tmpCanvas.context.drawImage(canvas, BORDER_SIZE, BORDER_SIZE);
                      canvas = tmpCanvas.canvas;
                    } else {
                      tmpCanvas = cachedCanvases.getCanvas("mesh", paddedWidth, paddedHeight, false);
                      var tmpCtx = tmpCanvas.context;
                      var data = tmpCtx.createImageData(width, height);
                      if (backgroundColor) {
                        var bytes = data.data;
                        for (i = 0, ii = bytes.length; i < ii; i += 4) {
                          bytes[i] = backgroundColor[0];
                          bytes[i + 1] = backgroundColor[1];
                          bytes[i + 2] = backgroundColor[2];
                          bytes[i + 3] = 255;
                        }
                      }
                      for (i = 0; i < figures.length; i++) {
                        drawFigure(data, figures[i], context);
                      }
                      tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);
                      canvas = tmpCanvas.canvas;
                    }
                    return { canvas, offsetX: offsetX - BORDER_SIZE * scaleX, offsetY: offsetY - BORDER_SIZE * scaleY, scaleX, scaleY };
                  }
                  return createMeshCanvas2;
                }();
                ShadingIRs.Mesh = { fromIR: function Mesh_fromIR(raw) {
                  var coords = raw[2];
                  var colors = raw[3];
                  var figures = raw[4];
                  var bounds = raw[5];
                  var matrix = raw[6];
                  var bbox = raw[7];
                  var background = raw[8];
                  return { type: "Pattern", getPattern: function Mesh_getPattern(ctx, owner, shadingFill) {
                    applyBoundingBox(ctx, bbox);
                    var scale;
                    if (shadingFill) {
                      scale = _util2.Util.singularValueDecompose2dScale(ctx.mozCurrentTransform);
                    } else {
                      scale = _util2.Util.singularValueDecompose2dScale(owner.baseTransform);
                      if (matrix) {
                        var matrixScale = _util2.Util.singularValueDecompose2dScale(matrix);
                        scale = [scale[0] * matrixScale[0], scale[1] * matrixScale[1]];
                      }
                    }
                    var temporaryPatternCanvas = createMeshCanvas(bounds, scale, coords, colors, figures, shadingFill ? null : background, owner.cachedCanvases, owner.webGLContext);
                    if (!shadingFill) {
                      ctx.setTransform.apply(ctx, owner.baseTransform);
                      if (matrix) {
                        ctx.transform.apply(ctx, matrix);
                      }
                    }
                    ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
                    ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);
                    return ctx.createPattern(temporaryPatternCanvas.canvas, "no-repeat");
                  } };
                } };
                ShadingIRs.Dummy = { fromIR: function Dummy_fromIR() {
                  return { type: "Pattern", getPattern: function Dummy_fromIR_getPattern() {
                    return "hotpink";
                  } };
                } };
                function getShadingPatternFromIR(raw) {
                  var shadingIR = ShadingIRs[raw[0]];
                  if (!shadingIR) {
                    throw new Error("Unknown IR type: ".concat(raw[0]));
                  }
                  return shadingIR.fromIR(raw);
                }
                var TilingPattern = function TilingPatternClosure() {
                  var PaintType = { COLORED: 1, UNCOLORED: 2 };
                  var MAX_PATTERN_SIZE = 3e3;
                  function TilingPattern2(IR, color, ctx, canvasGraphicsFactory, baseTransform) {
                    this.operatorList = IR[2];
                    this.matrix = IR[3] || [1, 0, 0, 1, 0, 0];
                    this.bbox = IR[4];
                    this.xstep = IR[5];
                    this.ystep = IR[6];
                    this.paintType = IR[7];
                    this.tilingType = IR[8];
                    this.color = color;
                    this.canvasGraphicsFactory = canvasGraphicsFactory;
                    this.baseTransform = baseTransform;
                    this.type = "Pattern";
                    this.ctx = ctx;
                  }
                  TilingPattern2.prototype = { createPatternCanvas: function TilinPattern_createPatternCanvas(owner) {
                    var operatorList = this.operatorList;
                    var bbox = this.bbox;
                    var xstep = this.xstep;
                    var ystep = this.ystep;
                    var paintType = this.paintType;
                    var tilingType = this.tilingType;
                    var color = this.color;
                    var canvasGraphicsFactory = this.canvasGraphicsFactory;
                    (0, _util2.info)("TilingType: " + tilingType);
                    var x0 = bbox[0], y0 = bbox[1], x1 = bbox[2], y1 = bbox[3];
                    var matrixScale = _util2.Util.singularValueDecompose2dScale(this.matrix);
                    var curMatrixScale = _util2.Util.singularValueDecompose2dScale(this.baseTransform);
                    var combinedScale = [matrixScale[0] * curMatrixScale[0], matrixScale[1] * curMatrixScale[1]];
                    var dimx = this.getSizeAndScale(xstep, this.ctx.canvas.width, combinedScale[0]);
                    var dimy = this.getSizeAndScale(ystep, this.ctx.canvas.height, combinedScale[1]);
                    var tmpCanvas = owner.cachedCanvases.getCanvas("pattern", dimx.size, dimy.size, true);
                    var tmpCtx = tmpCanvas.context;
                    var graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);
                    graphics.groupLevel = owner.groupLevel;
                    this.setFillAndStrokeStyleToContext(graphics, paintType, color);
                    graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0);
                    graphics.transform(1, 0, 0, 1, -x0, -y0);
                    this.clipBbox(graphics, bbox, x0, y0, x1, y1);
                    graphics.executeOperatorList(operatorList);
                    this.ctx.transform(1, 0, 0, 1, x0, y0);
                    this.ctx.scale(1 / dimx.scale, 1 / dimy.scale);
                    return tmpCanvas.canvas;
                  }, getSizeAndScale: function TilingPattern_getSizeAndScale(step, realOutputSize, scale) {
                    step = Math.abs(step);
                    var maxSize = Math.max(MAX_PATTERN_SIZE, realOutputSize);
                    var size = Math.ceil(step * scale);
                    if (size >= maxSize) {
                      size = maxSize;
                    } else {
                      scale = size / step;
                    }
                    return { scale, size };
                  }, clipBbox: function clipBbox(graphics, bbox, x0, y0, x1, y1) {
                    if (Array.isArray(bbox) && bbox.length === 4) {
                      var bboxWidth = x1 - x0;
                      var bboxHeight = y1 - y0;
                      graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);
                      graphics.clip();
                      graphics.endPath();
                    }
                  }, setFillAndStrokeStyleToContext: function setFillAndStrokeStyleToContext(graphics, paintType, color) {
                    var context = graphics.ctx, current = graphics.current;
                    switch (paintType) {
                      case PaintType.COLORED:
                        var ctx = this.ctx;
                        context.fillStyle = ctx.fillStyle;
                        context.strokeStyle = ctx.strokeStyle;
                        current.fillColor = ctx.fillStyle;
                        current.strokeColor = ctx.strokeStyle;
                        break;
                      case PaintType.UNCOLORED:
                        var cssColor = _util2.Util.makeCssRgb(color[0], color[1], color[2]);
                        context.fillStyle = cssColor;
                        context.strokeStyle = cssColor;
                        current.fillColor = cssColor;
                        current.strokeColor = cssColor;
                        break;
                      default:
                        throw new _util2.FormatError("Unsupported paint type: ".concat(paintType));
                    }
                  }, getPattern: function TilingPattern_getPattern(ctx, owner) {
                    ctx = this.ctx;
                    ctx.setTransform.apply(ctx, this.baseTransform);
                    ctx.transform.apply(ctx, this.matrix);
                    var temporaryPatternCanvas = this.createPatternCanvas(owner);
                    return ctx.createPattern(temporaryPatternCanvas, "repeat");
                  } };
                  return TilingPattern2;
                }();
                exports2.TilingPattern = TilingPattern;
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.GlobalWorkerOptions = void 0;
                var GlobalWorkerOptions = /* @__PURE__ */ Object.create(null);
                exports2.GlobalWorkerOptions = GlobalWorkerOptions;
                GlobalWorkerOptions.workerPort = GlobalWorkerOptions.workerPort === void 0 ? null : GlobalWorkerOptions.workerPort;
                GlobalWorkerOptions.workerSrc = GlobalWorkerOptions.workerSrc === void 0 ? "" : GlobalWorkerOptions.workerSrc;
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.MessageHandler = void 0;
                var _regenerator2 = _interopRequireDefault2(__w_pdfjs_require__2(191));
                var _util2 = __w_pdfjs_require__2(1);
                function _interopRequireDefault2(obj) {
                  return obj && obj.__esModule ? obj : { "default": obj };
                }
                function asyncGeneratorStep2(gen, resolve, reject, _next, _throw, key, arg) {
                  try {
                    var info = gen[key](arg);
                    var value = info.value;
                  } catch (error) {
                    reject(error);
                    return;
                  }
                  if (info.done) {
                    resolve(value);
                  } else {
                    Promise.resolve(value).then(_next, _throw);
                  }
                }
                function _asyncToGenerator2(fn) {
                  return function() {
                    var self2 = this, args = arguments;
                    return new Promise(function(resolve, reject) {
                      var gen = fn.apply(self2, args);
                      function _next(value) {
                        asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "next", value);
                      }
                      function _throw(err) {
                        asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "throw", err);
                      }
                      _next(void 0);
                    });
                  };
                }
                function _classCallCheck2(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _defineProperties2(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                function _createClass2(Constructor, protoProps, staticProps) {
                  if (protoProps)
                    _defineProperties2(Constructor.prototype, protoProps);
                  if (staticProps)
                    _defineProperties2(Constructor, staticProps);
                  return Constructor;
                }
                function _typeof2(obj) {
                  "@babel/helpers - typeof";
                  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                    _typeof2 = function _typeof3(obj2) {
                      return typeof obj2;
                    };
                  } else {
                    _typeof2 = function _typeof3(obj2) {
                      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                    };
                  }
                  return _typeof2(obj);
                }
                var CallbackKind = { UNKNOWN: 0, DATA: 1, ERROR: 2 };
                var StreamKind = { UNKNOWN: 0, CANCEL: 1, CANCEL_COMPLETE: 2, CLOSE: 3, ENQUEUE: 4, ERROR: 5, PULL: 6, PULL_COMPLETE: 7, START_COMPLETE: 8 };
                function wrapReason(reason) {
                  if (_typeof2(reason) !== "object" || reason === null) {
                    return reason;
                  }
                  switch (reason.name) {
                    case "AbortException":
                      return new _util2.AbortException(reason.message);
                    case "MissingPDFException":
                      return new _util2.MissingPDFException(reason.message);
                    case "UnexpectedResponseException":
                      return new _util2.UnexpectedResponseException(reason.message, reason.status);
                    case "UnknownErrorException":
                      return new _util2.UnknownErrorException(reason.message, reason.details);
                    default:
                      return new _util2.UnknownErrorException(reason.message, reason.toString());
                  }
                }
                var MessageHandler = function() {
                  function MessageHandler2(sourceName, targetName, comObj) {
                    var _this = this;
                    _classCallCheck2(this, MessageHandler2);
                    this.sourceName = sourceName;
                    this.targetName = targetName;
                    this.comObj = comObj;
                    this.callbackId = 1;
                    this.streamId = 1;
                    this.postMessageTransfers = true;
                    this.streamSinks = /* @__PURE__ */ Object.create(null);
                    this.streamControllers = /* @__PURE__ */ Object.create(null);
                    this.callbackCapabilities = /* @__PURE__ */ Object.create(null);
                    this.actionHandler = /* @__PURE__ */ Object.create(null);
                    this._onComObjOnMessage = function(event) {
                      var data = event.data;
                      if (data.targetName !== _this.sourceName) {
                        return;
                      }
                      if (data.stream) {
                        _this._processStreamMessage(data);
                        return;
                      }
                      if (data.callback) {
                        var callbackId = data.callbackId;
                        var capability = _this.callbackCapabilities[callbackId];
                        if (!capability) {
                          throw new Error("Cannot resolve callback ".concat(callbackId));
                        }
                        delete _this.callbackCapabilities[callbackId];
                        if (data.callback === CallbackKind.DATA) {
                          capability.resolve(data.data);
                        } else if (data.callback === CallbackKind.ERROR) {
                          capability.reject(wrapReason(data.reason));
                        } else {
                          throw new Error("Unexpected callback case");
                        }
                        return;
                      }
                      var action = _this.actionHandler[data.action];
                      if (!action) {
                        throw new Error("Unknown action from worker: ".concat(data.action));
                      }
                      if (data.callbackId) {
                        var _sourceName = _this.sourceName;
                        var _targetName = data.sourceName;
                        new Promise(function(resolve) {
                          resolve(action(data.data));
                        }).then(function(result) {
                          comObj.postMessage({ sourceName: _sourceName, targetName: _targetName, callback: CallbackKind.DATA, callbackId: data.callbackId, data: result });
                        }, function(reason) {
                          comObj.postMessage({ sourceName: _sourceName, targetName: _targetName, callback: CallbackKind.ERROR, callbackId: data.callbackId, reason: wrapReason(reason) });
                        });
                        return;
                      }
                      if (data.streamId) {
                        _this._createStreamSink(data);
                        return;
                      }
                      action(data.data);
                    };
                    comObj.addEventListener("message", this._onComObjOnMessage);
                  }
                  _createClass2(MessageHandler2, [{ key: "on", value: function on(actionName, handler) {
                    var ah = this.actionHandler;
                    if (ah[actionName]) {
                      throw new Error('There is already an actionName called "'.concat(actionName, '"'));
                    }
                    ah[actionName] = handler;
                  } }, { key: "send", value: function send(actionName, data, transfers) {
                    this._postMessage({ sourceName: this.sourceName, targetName: this.targetName, action: actionName, data }, transfers);
                  } }, { key: "sendWithPromise", value: function sendWithPromise(actionName, data, transfers) {
                    var callbackId = this.callbackId++;
                    var capability = (0, _util2.createPromiseCapability)();
                    this.callbackCapabilities[callbackId] = capability;
                    try {
                      this._postMessage({ sourceName: this.sourceName, targetName: this.targetName, action: actionName, callbackId, data }, transfers);
                    } catch (ex) {
                      capability.reject(ex);
                    }
                    return capability.promise;
                  } }, { key: "sendWithStream", value: function sendWithStream(actionName, data, queueingStrategy, transfers) {
                    var _this2 = this;
                    var streamId = this.streamId++;
                    var sourceName = this.sourceName;
                    var targetName = this.targetName;
                    var comObj = this.comObj;
                    return new ReadableStream({ start: function start(controller) {
                      var startCapability = (0, _util2.createPromiseCapability)();
                      _this2.streamControllers[streamId] = { controller, startCall: startCapability, pullCall: null, cancelCall: null, isClosed: false };
                      _this2._postMessage({ sourceName, targetName, action: actionName, streamId, data, desiredSize: controller.desiredSize }, transfers);
                      return startCapability.promise;
                    }, pull: function pull(controller) {
                      var pullCapability = (0, _util2.createPromiseCapability)();
                      _this2.streamControllers[streamId].pullCall = pullCapability;
                      comObj.postMessage({ sourceName, targetName, stream: StreamKind.PULL, streamId, desiredSize: controller.desiredSize });
                      return pullCapability.promise;
                    }, cancel: function cancel(reason) {
                      (0, _util2.assert)(reason instanceof Error, "cancel must have a valid reason");
                      var cancelCapability = (0, _util2.createPromiseCapability)();
                      _this2.streamControllers[streamId].cancelCall = cancelCapability;
                      _this2.streamControllers[streamId].isClosed = true;
                      comObj.postMessage({ sourceName, targetName, stream: StreamKind.CANCEL, streamId, reason: wrapReason(reason) });
                      return cancelCapability.promise;
                    } }, queueingStrategy);
                  } }, { key: "_createStreamSink", value: function _createStreamSink(data) {
                    var self2 = this;
                    var action = this.actionHandler[data.action];
                    var streamId = data.streamId;
                    var sourceName = this.sourceName;
                    var targetName = data.sourceName;
                    var comObj = this.comObj;
                    var streamSink = { enqueue: function enqueue(chunk) {
                      var size = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
                      var transfers = arguments.length > 2 ? arguments[2] : void 0;
                      if (this.isCancelled) {
                        return;
                      }
                      var lastDesiredSize = this.desiredSize;
                      this.desiredSize -= size;
                      if (lastDesiredSize > 0 && this.desiredSize <= 0) {
                        this.sinkCapability = (0, _util2.createPromiseCapability)();
                        this.ready = this.sinkCapability.promise;
                      }
                      self2._postMessage({ sourceName, targetName, stream: StreamKind.ENQUEUE, streamId, chunk }, transfers);
                    }, close: function close() {
                      if (this.isCancelled) {
                        return;
                      }
                      this.isCancelled = true;
                      comObj.postMessage({ sourceName, targetName, stream: StreamKind.CLOSE, streamId });
                      delete self2.streamSinks[streamId];
                    }, error: function error(reason) {
                      (0, _util2.assert)(reason instanceof Error, "error must have a valid reason");
                      if (this.isCancelled) {
                        return;
                      }
                      this.isCancelled = true;
                      comObj.postMessage({ sourceName, targetName, stream: StreamKind.ERROR, streamId, reason: wrapReason(reason) });
                    }, sinkCapability: (0, _util2.createPromiseCapability)(), onPull: null, onCancel: null, isCancelled: false, desiredSize: data.desiredSize, ready: null };
                    streamSink.sinkCapability.resolve();
                    streamSink.ready = streamSink.sinkCapability.promise;
                    this.streamSinks[streamId] = streamSink;
                    new Promise(function(resolve) {
                      resolve(action(data.data, streamSink));
                    }).then(function() {
                      comObj.postMessage({ sourceName, targetName, stream: StreamKind.START_COMPLETE, streamId, success: true });
                    }, function(reason) {
                      comObj.postMessage({ sourceName, targetName, stream: StreamKind.START_COMPLETE, streamId, reason: wrapReason(reason) });
                    });
                  } }, { key: "_processStreamMessage", value: function _processStreamMessage(data) {
                    var streamId = data.streamId;
                    var sourceName = this.sourceName;
                    var targetName = data.sourceName;
                    var comObj = this.comObj;
                    switch (data.stream) {
                      case StreamKind.START_COMPLETE:
                        if (data.success) {
                          this.streamControllers[streamId].startCall.resolve();
                        } else {
                          this.streamControllers[streamId].startCall.reject(wrapReason(data.reason));
                        }
                        break;
                      case StreamKind.PULL_COMPLETE:
                        if (data.success) {
                          this.streamControllers[streamId].pullCall.resolve();
                        } else {
                          this.streamControllers[streamId].pullCall.reject(wrapReason(data.reason));
                        }
                        break;
                      case StreamKind.PULL:
                        if (!this.streamSinks[streamId]) {
                          comObj.postMessage({ sourceName, targetName, stream: StreamKind.PULL_COMPLETE, streamId, success: true });
                          break;
                        }
                        if (this.streamSinks[streamId].desiredSize <= 0 && data.desiredSize > 0) {
                          this.streamSinks[streamId].sinkCapability.resolve();
                        }
                        this.streamSinks[streamId].desiredSize = data.desiredSize;
                        var onPull = this.streamSinks[data.streamId].onPull;
                        new Promise(function(resolve) {
                          resolve(onPull && onPull());
                        }).then(function() {
                          comObj.postMessage({ sourceName, targetName, stream: StreamKind.PULL_COMPLETE, streamId, success: true });
                        }, function(reason) {
                          comObj.postMessage({ sourceName, targetName, stream: StreamKind.PULL_COMPLETE, streamId, reason: wrapReason(reason) });
                        });
                        break;
                      case StreamKind.ENQUEUE:
                        (0, _util2.assert)(this.streamControllers[streamId], "enqueue should have stream controller");
                        if (this.streamControllers[streamId].isClosed) {
                          break;
                        }
                        this.streamControllers[streamId].controller.enqueue(data.chunk);
                        break;
                      case StreamKind.CLOSE:
                        (0, _util2.assert)(this.streamControllers[streamId], "close should have stream controller");
                        if (this.streamControllers[streamId].isClosed) {
                          break;
                        }
                        this.streamControllers[streamId].isClosed = true;
                        this.streamControllers[streamId].controller.close();
                        this._deleteStreamController(streamId);
                        break;
                      case StreamKind.ERROR:
                        (0, _util2.assert)(this.streamControllers[streamId], "error should have stream controller");
                        this.streamControllers[streamId].controller.error(wrapReason(data.reason));
                        this._deleteStreamController(streamId);
                        break;
                      case StreamKind.CANCEL_COMPLETE:
                        if (data.success) {
                          this.streamControllers[streamId].cancelCall.resolve();
                        } else {
                          this.streamControllers[streamId].cancelCall.reject(wrapReason(data.reason));
                        }
                        this._deleteStreamController(streamId);
                        break;
                      case StreamKind.CANCEL:
                        if (!this.streamSinks[streamId]) {
                          break;
                        }
                        var onCancel = this.streamSinks[data.streamId].onCancel;
                        new Promise(function(resolve) {
                          resolve(onCancel && onCancel(wrapReason(data.reason)));
                        }).then(function() {
                          comObj.postMessage({ sourceName, targetName, stream: StreamKind.CANCEL_COMPLETE, streamId, success: true });
                        }, function(reason) {
                          comObj.postMessage({ sourceName, targetName, stream: StreamKind.CANCEL_COMPLETE, streamId, reason: wrapReason(reason) });
                        });
                        this.streamSinks[streamId].sinkCapability.reject(wrapReason(data.reason));
                        this.streamSinks[streamId].isCancelled = true;
                        delete this.streamSinks[streamId];
                        break;
                      default:
                        throw new Error("Unexpected stream case");
                    }
                  } }, { key: "_deleteStreamController", value: function() {
                    var _deleteStreamController2 = _asyncToGenerator2(_regenerator2["default"].mark(function _callee2(streamId) {
                      return _regenerator2["default"].wrap(function _callee$2(_context2) {
                        while (1) {
                          switch (_context2.prev = _context2.next) {
                            case 0:
                              _context2.next = 2;
                              return Promise.allSettled([this.streamControllers[streamId].startCall, this.streamControllers[streamId].pullCall, this.streamControllers[streamId].cancelCall].map(function(capability) {
                                return capability && capability.promise;
                              }));
                            case 2:
                              delete this.streamControllers[streamId];
                            case 3:
                            case "end":
                              return _context2.stop();
                          }
                        }
                      }, _callee2, this);
                    }));
                    function _deleteStreamController(_x) {
                      return _deleteStreamController2.apply(this, arguments);
                    }
                    return _deleteStreamController;
                  }() }, { key: "_postMessage", value: function _postMessage(message, transfers) {
                    if (transfers && this.postMessageTransfers) {
                      this.comObj.postMessage(message, transfers);
                    } else {
                      this.comObj.postMessage(message);
                    }
                  } }, { key: "destroy", value: function destroy() {
                    this.comObj.removeEventListener("message", this._onComObjOnMessage);
                  } }]);
                  return MessageHandler2;
                }();
                exports2.MessageHandler = MessageHandler;
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.Metadata = void 0;
                var _util2 = __w_pdfjs_require__2(1);
                var _xml_parser = __w_pdfjs_require__2(202);
                function _slicedToArray2(arr, i) {
                  return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i) || _nonIterableRest2();
                }
                function _nonIterableRest2() {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
                function _iterableToArrayLimit2(arr, i) {
                  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
                    return;
                  }
                  var _arr = [];
                  var _n = true;
                  var _d = false;
                  var _e = void 0;
                  try {
                    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                      _arr.push(_s.value);
                      if (i && _arr.length === i)
                        break;
                    }
                  } catch (err) {
                    _d = true;
                    _e = err;
                  } finally {
                    try {
                      if (!_n && _i["return"] != null)
                        _i["return"]();
                    } finally {
                      if (_d)
                        throw _e;
                    }
                  }
                  return _arr;
                }
                function _arrayWithHoles2(arr) {
                  if (Array.isArray(arr))
                    return arr;
                }
                function _classCallCheck2(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _defineProperties2(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                function _createClass2(Constructor, protoProps, staticProps) {
                  if (protoProps)
                    _defineProperties2(Constructor.prototype, protoProps);
                  if (staticProps)
                    _defineProperties2(Constructor, staticProps);
                  return Constructor;
                }
                var Metadata = function() {
                  function Metadata2(data) {
                    _classCallCheck2(this, Metadata2);
                    (0, _util2.assert)(typeof data === "string", "Metadata: input is not a string");
                    data = this._repair(data);
                    var parser = new _xml_parser.SimpleXMLParser();
                    var xmlDocument = parser.parseFromString(data);
                    this._metadataMap = /* @__PURE__ */ new Map();
                    if (xmlDocument) {
                      this._parse(xmlDocument);
                    }
                  }
                  _createClass2(Metadata2, [{ key: "_repair", value: function _repair(data) {
                    return data.replace(/^[^<]+/, "").replace(/>\\376\\377([^<]+)/g, function(all, codes) {
                      var bytes = codes.replace(/\\([0-3])([0-7])([0-7])/g, function(code2, d1, d2, d3) {
                        return String.fromCharCode(d1 * 64 + d2 * 8 + d3 * 1);
                      }).replace(/&(amp|apos|gt|lt|quot);/g, function(str, name) {
                        switch (name) {
                          case "amp":
                            return "&";
                          case "apos":
                            return "'";
                          case "gt":
                            return ">";
                          case "lt":
                            return "<";
                          case "quot":
                            return '"';
                        }
                        throw new Error("_repair: ".concat(name, " isn't defined."));
                      });
                      var chars = "";
                      for (var i = 0, ii = bytes.length; i < ii; i += 2) {
                        var code = bytes.charCodeAt(i) * 256 + bytes.charCodeAt(i + 1);
                        if (code >= 32 && code < 127 && code !== 60 && code !== 62 && code !== 38) {
                          chars += String.fromCharCode(code);
                        } else {
                          chars += "&#x" + (65536 + code).toString(16).substring(1) + ";";
                        }
                      }
                      return ">" + chars;
                    });
                  } }, { key: "_parse", value: function _parse(xmlDocument) {
                    var rdf = xmlDocument.documentElement;
                    if (rdf.nodeName.toLowerCase() !== "rdf:rdf") {
                      rdf = rdf.firstChild;
                      while (rdf && rdf.nodeName.toLowerCase() !== "rdf:rdf") {
                        rdf = rdf.nextSibling;
                      }
                    }
                    var nodeName = rdf ? rdf.nodeName.toLowerCase() : null;
                    if (!rdf || nodeName !== "rdf:rdf" || !rdf.hasChildNodes()) {
                      return;
                    }
                    var children = rdf.childNodes;
                    for (var i = 0, ii = children.length; i < ii; i++) {
                      var desc = children[i];
                      if (desc.nodeName.toLowerCase() !== "rdf:description") {
                        continue;
                      }
                      for (var j = 0, jj = desc.childNodes.length; j < jj; j++) {
                        if (desc.childNodes[j].nodeName.toLowerCase() !== "#text") {
                          var entry = desc.childNodes[j];
                          var name = entry.nodeName.toLowerCase();
                          this._metadataMap.set(name, entry.textContent.trim());
                        }
                      }
                    }
                  } }, { key: "get", value: function get(name) {
                    return this._metadataMap.has(name) ? this._metadataMap.get(name) : null;
                  } }, { key: "getAll", value: function getAll() {
                    var obj = /* @__PURE__ */ Object.create(null);
                    var _iteratorNormalCompletion = true;
                    var _didIteratorError = false;
                    var _iteratorError = void 0;
                    try {
                      for (var _iterator = this._metadataMap[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var _step$value = _slicedToArray2(_step.value, 2), key = _step$value[0], value = _step$value[1];
                        obj[key] = value;
                      }
                    } catch (err) {
                      _didIteratorError = true;
                      _iteratorError = err;
                    } finally {
                      try {
                        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                          _iterator["return"]();
                        }
                      } finally {
                        if (_didIteratorError) {
                          throw _iteratorError;
                        }
                      }
                    }
                    return obj;
                  } }, { key: "has", value: function has(name) {
                    return this._metadataMap.has(name);
                  } }]);
                  return Metadata2;
                }();
                exports2.Metadata = Metadata;
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.SimpleXMLParser = void 0;
                function _typeof2(obj) {
                  "@babel/helpers - typeof";
                  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                    _typeof2 = function _typeof3(obj2) {
                      return typeof obj2;
                    };
                  } else {
                    _typeof2 = function _typeof3(obj2) {
                      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                    };
                  }
                  return _typeof2(obj);
                }
                function _slicedToArray2(arr, i) {
                  return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i) || _nonIterableRest2();
                }
                function _nonIterableRest2() {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
                function _iterableToArrayLimit2(arr, i) {
                  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
                    return;
                  }
                  var _arr = [];
                  var _n = true;
                  var _d = false;
                  var _e = void 0;
                  try {
                    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                      _arr.push(_s.value);
                      if (i && _arr.length === i)
                        break;
                    }
                  } catch (err) {
                    _d = true;
                    _e = err;
                  } finally {
                    try {
                      if (!_n && _i["return"] != null)
                        _i["return"]();
                    } finally {
                      if (_d)
                        throw _e;
                    }
                  }
                  return _arr;
                }
                function _arrayWithHoles2(arr) {
                  if (Array.isArray(arr))
                    return arr;
                }
                function _possibleConstructorReturn(self2, call) {
                  if (call && (_typeof2(call) === "object" || typeof call === "function")) {
                    return call;
                  }
                  return _assertThisInitialized(self2);
                }
                function _assertThisInitialized(self2) {
                  if (self2 === void 0) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  }
                  return self2;
                }
                function _get(target, property, receiver) {
                  if (typeof Reflect !== "undefined" && Reflect.get) {
                    _get = Reflect.get;
                  } else {
                    _get = function _get2(target2, property2, receiver2) {
                      var base = _superPropBase(target2, property2);
                      if (!base)
                        return;
                      var desc = Object.getOwnPropertyDescriptor(base, property2);
                      if (desc.get) {
                        return desc.get.call(receiver2);
                      }
                      return desc.value;
                    };
                  }
                  return _get(target, property, receiver || target);
                }
                function _superPropBase(object, property) {
                  while (!Object.prototype.hasOwnProperty.call(object, property)) {
                    object = _getPrototypeOf(object);
                    if (object === null)
                      break;
                  }
                  return object;
                }
                function _getPrototypeOf(o) {
                  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                    return o2.__proto__ || Object.getPrototypeOf(o2);
                  };
                  return _getPrototypeOf(o);
                }
                function _inherits(subClass, superClass) {
                  if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function");
                  }
                  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
                  if (superClass)
                    _setPrototypeOf(subClass, superClass);
                }
                function _setPrototypeOf(o, p) {
                  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                    o2.__proto__ = p2;
                    return o2;
                  };
                  return _setPrototypeOf(o, p);
                }
                function _classCallCheck2(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _defineProperties2(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                function _createClass2(Constructor, protoProps, staticProps) {
                  if (protoProps)
                    _defineProperties2(Constructor.prototype, protoProps);
                  if (staticProps)
                    _defineProperties2(Constructor, staticProps);
                  return Constructor;
                }
                var XMLParserErrorCode = { NoError: 0, EndOfDocument: -1, UnterminatedCdat: -2, UnterminatedXmlDeclaration: -3, UnterminatedDoctypeDeclaration: -4, UnterminatedComment: -5, MalformedElement: -6, OutOfMemory: -7, UnterminatedAttributeValue: -8, UnterminatedElement: -9, ElementNeverBegun: -10 };
                function isWhitespace(s, index) {
                  var ch = s[index];
                  return ch === " " || ch === "\n" || ch === "\r" || ch === "	";
                }
                function isWhitespaceString(s) {
                  for (var i = 0, ii = s.length; i < ii; i++) {
                    if (!isWhitespace(s, i)) {
                      return false;
                    }
                  }
                  return true;
                }
                var XMLParserBase = function() {
                  function XMLParserBase2() {
                    _classCallCheck2(this, XMLParserBase2);
                  }
                  _createClass2(XMLParserBase2, [{ key: "_resolveEntities", value: function _resolveEntities(s) {
                    var _this = this;
                    return s.replace(/&([^;]+);/g, function(all, entity) {
                      if (entity.substring(0, 2) === "#x") {
                        return String.fromCharCode(parseInt(entity.substring(2), 16));
                      } else if (entity.substring(0, 1) === "#") {
                        return String.fromCharCode(parseInt(entity.substring(1), 10));
                      }
                      switch (entity) {
                        case "lt":
                          return "<";
                        case "gt":
                          return ">";
                        case "amp":
                          return "&";
                        case "quot":
                          return '"';
                      }
                      return _this.onResolveEntity(entity);
                    });
                  } }, { key: "_parseContent", value: function _parseContent(s, start) {
                    var attributes = [];
                    var pos = start;
                    function skipWs() {
                      while (pos < s.length && isWhitespace(s, pos)) {
                        ++pos;
                      }
                    }
                    while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== ">" && s[pos] !== "/") {
                      ++pos;
                    }
                    var name = s.substring(start, pos);
                    skipWs();
                    while (pos < s.length && s[pos] !== ">" && s[pos] !== "/" && s[pos] !== "?") {
                      skipWs();
                      var attrName = "", attrValue = "";
                      while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== "=") {
                        attrName += s[pos];
                        ++pos;
                      }
                      skipWs();
                      if (s[pos] !== "=") {
                        return null;
                      }
                      ++pos;
                      skipWs();
                      var attrEndChar = s[pos];
                      if (attrEndChar !== '"' && attrEndChar !== "'") {
                        return null;
                      }
                      var attrEndIndex = s.indexOf(attrEndChar, ++pos);
                      if (attrEndIndex < 0) {
                        return null;
                      }
                      attrValue = s.substring(pos, attrEndIndex);
                      attributes.push({ name: attrName, value: this._resolveEntities(attrValue) });
                      pos = attrEndIndex + 1;
                      skipWs();
                    }
                    return { name, attributes, parsed: pos - start };
                  } }, { key: "_parseProcessingInstruction", value: function _parseProcessingInstruction(s, start) {
                    var pos = start;
                    function skipWs() {
                      while (pos < s.length && isWhitespace(s, pos)) {
                        ++pos;
                      }
                    }
                    while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== ">" && s[pos] !== "/") {
                      ++pos;
                    }
                    var name = s.substring(start, pos);
                    skipWs();
                    var attrStart = pos;
                    while (pos < s.length && (s[pos] !== "?" || s[pos + 1] !== ">")) {
                      ++pos;
                    }
                    var value = s.substring(attrStart, pos);
                    return { name, value, parsed: pos - start };
                  } }, { key: "parseXml", value: function parseXml(s) {
                    var i = 0;
                    while (i < s.length) {
                      var ch = s[i];
                      var j = i;
                      if (ch === "<") {
                        ++j;
                        var ch2 = s[j];
                        var q = void 0;
                        switch (ch2) {
                          case "/":
                            ++j;
                            q = s.indexOf(">", j);
                            if (q < 0) {
                              this.onError(XMLParserErrorCode.UnterminatedElement);
                              return;
                            }
                            this.onEndElement(s.substring(j, q));
                            j = q + 1;
                            break;
                          case "?":
                            ++j;
                            var pi = this._parseProcessingInstruction(s, j);
                            if (s.substring(j + pi.parsed, j + pi.parsed + 2) !== "?>") {
                              this.onError(XMLParserErrorCode.UnterminatedXmlDeclaration);
                              return;
                            }
                            this.onPi(pi.name, pi.value);
                            j += pi.parsed + 2;
                            break;
                          case "!":
                            if (s.substring(j + 1, j + 3) === "--") {
                              q = s.indexOf("-->", j + 3);
                              if (q < 0) {
                                this.onError(XMLParserErrorCode.UnterminatedComment);
                                return;
                              }
                              this.onComment(s.substring(j + 3, q));
                              j = q + 3;
                            } else if (s.substring(j + 1, j + 8) === "[CDATA[") {
                              q = s.indexOf("]]>", j + 8);
                              if (q < 0) {
                                this.onError(XMLParserErrorCode.UnterminatedCdat);
                                return;
                              }
                              this.onCdata(s.substring(j + 8, q));
                              j = q + 3;
                            } else if (s.substring(j + 1, j + 8) === "DOCTYPE") {
                              var q2 = s.indexOf("[", j + 8);
                              var complexDoctype = false;
                              q = s.indexOf(">", j + 8);
                              if (q < 0) {
                                this.onError(XMLParserErrorCode.UnterminatedDoctypeDeclaration);
                                return;
                              }
                              if (q2 > 0 && q > q2) {
                                q = s.indexOf("]>", j + 8);
                                if (q < 0) {
                                  this.onError(XMLParserErrorCode.UnterminatedDoctypeDeclaration);
                                  return;
                                }
                                complexDoctype = true;
                              }
                              var doctypeContent = s.substring(j + 8, q + (complexDoctype ? 1 : 0));
                              this.onDoctype(doctypeContent);
                              j = q + (complexDoctype ? 2 : 1);
                            } else {
                              this.onError(XMLParserErrorCode.MalformedElement);
                              return;
                            }
                            break;
                          default:
                            var content = this._parseContent(s, j);
                            if (content === null) {
                              this.onError(XMLParserErrorCode.MalformedElement);
                              return;
                            }
                            var isClosed = false;
                            if (s.substring(j + content.parsed, j + content.parsed + 2) === "/>") {
                              isClosed = true;
                            } else if (s.substring(j + content.parsed, j + content.parsed + 1) !== ">") {
                              this.onError(XMLParserErrorCode.UnterminatedElement);
                              return;
                            }
                            this.onBeginElement(content.name, content.attributes, isClosed);
                            j += content.parsed + (isClosed ? 2 : 1);
                            break;
                        }
                      } else {
                        while (j < s.length && s[j] !== "<") {
                          j++;
                        }
                        var text = s.substring(i, j);
                        this.onText(this._resolveEntities(text));
                      }
                      i = j;
                    }
                  } }, { key: "onResolveEntity", value: function onResolveEntity(name) {
                    return "&".concat(name, ";");
                  } }, { key: "onPi", value: function onPi(name, value) {
                  } }, { key: "onComment", value: function onComment(text) {
                  } }, { key: "onCdata", value: function onCdata(text) {
                  } }, { key: "onDoctype", value: function onDoctype(doctypeContent) {
                  } }, { key: "onText", value: function onText(text) {
                  } }, { key: "onBeginElement", value: function onBeginElement(name, attributes, isEmpty) {
                  } }, { key: "onEndElement", value: function onEndElement(name) {
                  } }, { key: "onError", value: function onError(code) {
                  } }]);
                  return XMLParserBase2;
                }();
                var SimpleDOMNode = function() {
                  function SimpleDOMNode2(nodeName, nodeValue) {
                    _classCallCheck2(this, SimpleDOMNode2);
                    this.nodeName = nodeName;
                    this.nodeValue = nodeValue;
                    Object.defineProperty(this, "parentNode", { value: null, writable: true });
                  }
                  _createClass2(SimpleDOMNode2, [{ key: "hasChildNodes", value: function hasChildNodes() {
                    return this.childNodes && this.childNodes.length > 0;
                  } }, { key: "firstChild", get: function get() {
                    return this.childNodes && this.childNodes[0];
                  } }, { key: "nextSibling", get: function get() {
                    var childNodes = this.parentNode.childNodes;
                    if (!childNodes) {
                      return void 0;
                    }
                    var index = childNodes.indexOf(this);
                    if (index === -1) {
                      return void 0;
                    }
                    return childNodes[index + 1];
                  } }, { key: "textContent", get: function get() {
                    if (!this.childNodes) {
                      return this.nodeValue || "";
                    }
                    return this.childNodes.map(function(child) {
                      return child.textContent;
                    }).join("");
                  } }]);
                  return SimpleDOMNode2;
                }();
                var SimpleXMLParser = function(_XMLParserBase) {
                  _inherits(SimpleXMLParser2, _XMLParserBase);
                  function SimpleXMLParser2() {
                    var _this2;
                    _classCallCheck2(this, SimpleXMLParser2);
                    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(SimpleXMLParser2).call(this));
                    _this2._currentFragment = null;
                    _this2._stack = null;
                    _this2._errorCode = XMLParserErrorCode.NoError;
                    return _this2;
                  }
                  _createClass2(SimpleXMLParser2, [{ key: "parseFromString", value: function parseFromString(data) {
                    this._currentFragment = [];
                    this._stack = [];
                    this._errorCode = XMLParserErrorCode.NoError;
                    this.parseXml(data);
                    if (this._errorCode !== XMLParserErrorCode.NoError) {
                      return void 0;
                    }
                    var _this$_currentFragmen = _slicedToArray2(this._currentFragment, 1), documentElement = _this$_currentFragmen[0];
                    if (!documentElement) {
                      return void 0;
                    }
                    return { documentElement };
                  } }, { key: "onResolveEntity", value: function onResolveEntity(name) {
                    switch (name) {
                      case "apos":
                        return "'";
                    }
                    return _get(_getPrototypeOf(SimpleXMLParser2.prototype), "onResolveEntity", this).call(this, name);
                  } }, { key: "onText", value: function onText(text) {
                    if (isWhitespaceString(text)) {
                      return;
                    }
                    var node = new SimpleDOMNode("#text", text);
                    this._currentFragment.push(node);
                  } }, { key: "onCdata", value: function onCdata(text) {
                    var node = new SimpleDOMNode("#text", text);
                    this._currentFragment.push(node);
                  } }, { key: "onBeginElement", value: function onBeginElement(name, attributes, isEmpty) {
                    var node = new SimpleDOMNode(name);
                    node.childNodes = [];
                    this._currentFragment.push(node);
                    if (isEmpty) {
                      return;
                    }
                    this._stack.push(this._currentFragment);
                    this._currentFragment = node.childNodes;
                  } }, { key: "onEndElement", value: function onEndElement(name) {
                    this._currentFragment = this._stack.pop() || [];
                    var lastElement = this._currentFragment[this._currentFragment.length - 1];
                    if (!lastElement) {
                      return;
                    }
                    for (var i = 0, ii = lastElement.childNodes.length; i < ii; i++) {
                      lastElement.childNodes[i].parentNode = lastElement;
                    }
                  } }, { key: "onError", value: function onError(code) {
                    this._errorCode = code;
                  } }]);
                  return SimpleXMLParser2;
                }(XMLParserBase);
                exports2.SimpleXMLParser = SimpleXMLParser;
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.PDFDataTransportStream = void 0;
                var _regenerator2 = _interopRequireDefault2(__w_pdfjs_require__2(191));
                var _util2 = __w_pdfjs_require__2(1);
                function _interopRequireDefault2(obj) {
                  return obj && obj.__esModule ? obj : { default: obj };
                }
                function asyncGeneratorStep2(gen, resolve, reject, _next, _throw, key, arg) {
                  try {
                    var info = gen[key](arg);
                    var value = info.value;
                  } catch (error) {
                    reject(error);
                    return;
                  }
                  if (info.done) {
                    resolve(value);
                  } else {
                    Promise.resolve(value).then(_next, _throw);
                  }
                }
                function _asyncToGenerator2(fn) {
                  return function() {
                    var self2 = this, args = arguments;
                    return new Promise(function(resolve, reject) {
                      var gen = fn.apply(self2, args);
                      function _next(value) {
                        asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "next", value);
                      }
                      function _throw(err) {
                        asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "throw", err);
                      }
                      _next(void 0);
                    });
                  };
                }
                function _classCallCheck2(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _defineProperties2(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                function _createClass2(Constructor, protoProps, staticProps) {
                  if (protoProps)
                    _defineProperties2(Constructor.prototype, protoProps);
                  if (staticProps)
                    _defineProperties2(Constructor, staticProps);
                  return Constructor;
                }
                var PDFDataTransportStream = function() {
                  function PDFDataTransportStream2(params, pdfDataRangeTransport) {
                    var _this = this;
                    _classCallCheck2(this, PDFDataTransportStream2);
                    (0, _util2.assert)(pdfDataRangeTransport);
                    this._queuedChunks = [];
                    this._progressiveDone = params.progressiveDone || false;
                    var initialData = params.initialData;
                    if (initialData && initialData.length > 0) {
                      var buffer = new Uint8Array(initialData).buffer;
                      this._queuedChunks.push(buffer);
                    }
                    this._pdfDataRangeTransport = pdfDataRangeTransport;
                    this._isStreamingSupported = !params.disableStream;
                    this._isRangeSupported = !params.disableRange;
                    this._contentLength = params.length;
                    this._fullRequestReader = null;
                    this._rangeReaders = [];
                    this._pdfDataRangeTransport.addRangeListener(function(begin, chunk) {
                      _this._onReceiveData({ begin, chunk });
                    });
                    this._pdfDataRangeTransport.addProgressListener(function(loaded, total) {
                      _this._onProgress({ loaded, total });
                    });
                    this._pdfDataRangeTransport.addProgressiveReadListener(function(chunk) {
                      _this._onReceiveData({ chunk });
                    });
                    this._pdfDataRangeTransport.addProgressiveDoneListener(function() {
                      _this._onProgressiveDone();
                    });
                    this._pdfDataRangeTransport.transportReady();
                  }
                  _createClass2(PDFDataTransportStream2, [{ key: "_onReceiveData", value: function _onReceiveData(args) {
                    var buffer = new Uint8Array(args.chunk).buffer;
                    if (args.begin === void 0) {
                      if (this._fullRequestReader) {
                        this._fullRequestReader._enqueue(buffer);
                      } else {
                        this._queuedChunks.push(buffer);
                      }
                    } else {
                      var found = this._rangeReaders.some(function(rangeReader) {
                        if (rangeReader._begin !== args.begin) {
                          return false;
                        }
                        rangeReader._enqueue(buffer);
                        return true;
                      });
                      (0, _util2.assert)(found);
                    }
                  } }, { key: "_onProgress", value: function _onProgress(evt) {
                    if (evt.total === void 0) {
                      var firstReader = this._rangeReaders[0];
                      if (firstReader && firstReader.onProgress) {
                        firstReader.onProgress({ loaded: evt.loaded });
                      }
                    } else {
                      var fullReader = this._fullRequestReader;
                      if (fullReader && fullReader.onProgress) {
                        fullReader.onProgress({ loaded: evt.loaded, total: evt.total });
                      }
                    }
                  } }, { key: "_onProgressiveDone", value: function _onProgressiveDone() {
                    if (this._fullRequestReader) {
                      this._fullRequestReader.progressiveDone();
                    }
                    this._progressiveDone = true;
                  } }, { key: "_removeRangeReader", value: function _removeRangeReader(reader) {
                    var i = this._rangeReaders.indexOf(reader);
                    if (i >= 0) {
                      this._rangeReaders.splice(i, 1);
                    }
                  } }, { key: "getFullReader", value: function getFullReader() {
                    (0, _util2.assert)(!this._fullRequestReader);
                    var queuedChunks = this._queuedChunks;
                    this._queuedChunks = null;
                    return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone);
                  } }, { key: "getRangeReader", value: function getRangeReader(begin, end) {
                    if (end <= this._progressiveDataLength) {
                      return null;
                    }
                    var reader = new PDFDataTransportStreamRangeReader(this, begin, end);
                    this._pdfDataRangeTransport.requestDataRange(begin, end);
                    this._rangeReaders.push(reader);
                    return reader;
                  } }, { key: "cancelAllRequests", value: function cancelAllRequests(reason) {
                    if (this._fullRequestReader) {
                      this._fullRequestReader.cancel(reason);
                    }
                    var readers = this._rangeReaders.slice(0);
                    readers.forEach(function(rangeReader) {
                      rangeReader.cancel(reason);
                    });
                    this._pdfDataRangeTransport.abort();
                  } }, { key: "_progressiveDataLength", get: function get() {
                    return this._fullRequestReader ? this._fullRequestReader._loaded : 0;
                  } }]);
                  return PDFDataTransportStream2;
                }();
                exports2.PDFDataTransportStream = PDFDataTransportStream;
                var PDFDataTransportStreamReader = function() {
                  function PDFDataTransportStreamReader2(stream, queuedChunks) {
                    var progressiveDone = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                    _classCallCheck2(this, PDFDataTransportStreamReader2);
                    this._stream = stream;
                    this._done = progressiveDone || false;
                    this._filename = null;
                    this._queuedChunks = queuedChunks || [];
                    this._loaded = 0;
                    var _iteratorNormalCompletion = true;
                    var _didIteratorError = false;
                    var _iteratorError = void 0;
                    try {
                      for (var _iterator = this._queuedChunks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var chunk = _step.value;
                        this._loaded += chunk.byteLength;
                      }
                    } catch (err) {
                      _didIteratorError = true;
                      _iteratorError = err;
                    } finally {
                      try {
                        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                          _iterator["return"]();
                        }
                      } finally {
                        if (_didIteratorError) {
                          throw _iteratorError;
                        }
                      }
                    }
                    this._requests = [];
                    this._headersReady = Promise.resolve();
                    stream._fullRequestReader = this;
                    this.onProgress = null;
                  }
                  _createClass2(PDFDataTransportStreamReader2, [{ key: "_enqueue", value: function _enqueue(chunk) {
                    if (this._done) {
                      return;
                    }
                    if (this._requests.length > 0) {
                      var requestCapability = this._requests.shift();
                      requestCapability.resolve({ value: chunk, done: false });
                    } else {
                      this._queuedChunks.push(chunk);
                    }
                    this._loaded += chunk.byteLength;
                  } }, { key: "read", value: function() {
                    var _read = _asyncToGenerator2(_regenerator2["default"].mark(function _callee2() {
                      var chunk, requestCapability;
                      return _regenerator2["default"].wrap(function _callee$2(_context2) {
                        while (1) {
                          switch (_context2.prev = _context2.next) {
                            case 0:
                              if (!(this._queuedChunks.length > 0)) {
                                _context2.next = 3;
                                break;
                              }
                              chunk = this._queuedChunks.shift();
                              return _context2.abrupt("return", { value: chunk, done: false });
                            case 3:
                              if (!this._done) {
                                _context2.next = 5;
                                break;
                              }
                              return _context2.abrupt("return", { value: void 0, done: true });
                            case 5:
                              requestCapability = (0, _util2.createPromiseCapability)();
                              this._requests.push(requestCapability);
                              return _context2.abrupt("return", requestCapability.promise);
                            case 8:
                            case "end":
                              return _context2.stop();
                          }
                        }
                      }, _callee2, this);
                    }));
                    function read() {
                      return _read.apply(this, arguments);
                    }
                    return read;
                  }() }, { key: "cancel", value: function cancel(reason) {
                    this._done = true;
                    this._requests.forEach(function(requestCapability) {
                      requestCapability.resolve({ value: void 0, done: true });
                    });
                    this._requests = [];
                  } }, { key: "progressiveDone", value: function progressiveDone() {
                    if (this._done) {
                      return;
                    }
                    this._done = true;
                  } }, { key: "headersReady", get: function get() {
                    return this._headersReady;
                  } }, { key: "filename", get: function get() {
                    return this._filename;
                  } }, { key: "isRangeSupported", get: function get() {
                    return this._stream._isRangeSupported;
                  } }, { key: "isStreamingSupported", get: function get() {
                    return this._stream._isStreamingSupported;
                  } }, { key: "contentLength", get: function get() {
                    return this._stream._contentLength;
                  } }]);
                  return PDFDataTransportStreamReader2;
                }();
                var PDFDataTransportStreamRangeReader = function() {
                  function PDFDataTransportStreamRangeReader2(stream, begin, end) {
                    _classCallCheck2(this, PDFDataTransportStreamRangeReader2);
                    this._stream = stream;
                    this._begin = begin;
                    this._end = end;
                    this._queuedChunk = null;
                    this._requests = [];
                    this._done = false;
                    this.onProgress = null;
                  }
                  _createClass2(PDFDataTransportStreamRangeReader2, [{ key: "_enqueue", value: function _enqueue(chunk) {
                    if (this._done) {
                      return;
                    }
                    if (this._requests.length === 0) {
                      this._queuedChunk = chunk;
                    } else {
                      var requestsCapability = this._requests.shift();
                      requestsCapability.resolve({ value: chunk, done: false });
                      this._requests.forEach(function(requestCapability) {
                        requestCapability.resolve({ value: void 0, done: true });
                      });
                      this._requests = [];
                    }
                    this._done = true;
                    this._stream._removeRangeReader(this);
                  } }, { key: "read", value: function() {
                    var _read2 = _asyncToGenerator2(_regenerator2["default"].mark(function _callee2() {
                      var chunk, requestCapability;
                      return _regenerator2["default"].wrap(function _callee2$(_context2) {
                        while (1) {
                          switch (_context2.prev = _context2.next) {
                            case 0:
                              if (!this._queuedChunk) {
                                _context2.next = 4;
                                break;
                              }
                              chunk = this._queuedChunk;
                              this._queuedChunk = null;
                              return _context2.abrupt("return", { value: chunk, done: false });
                            case 4:
                              if (!this._done) {
                                _context2.next = 6;
                                break;
                              }
                              return _context2.abrupt("return", { value: void 0, done: true });
                            case 6:
                              requestCapability = (0, _util2.createPromiseCapability)();
                              this._requests.push(requestCapability);
                              return _context2.abrupt("return", requestCapability.promise);
                            case 9:
                            case "end":
                              return _context2.stop();
                          }
                        }
                      }, _callee2, this);
                    }));
                    function read() {
                      return _read2.apply(this, arguments);
                    }
                    return read;
                  }() }, { key: "cancel", value: function cancel(reason) {
                    this._done = true;
                    this._requests.forEach(function(requestCapability) {
                      requestCapability.resolve({ value: void 0, done: true });
                    });
                    this._requests = [];
                    this._stream._removeRangeReader(this);
                  } }, { key: "isStreamingSupported", get: function get() {
                    return false;
                  } }]);
                  return PDFDataTransportStreamRangeReader2;
                }();
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.WebGLContext = void 0;
                var _util2 = __w_pdfjs_require__2(1);
                function _classCallCheck2(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _defineProperties2(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                function _createClass2(Constructor, protoProps, staticProps) {
                  if (protoProps)
                    _defineProperties2(Constructor.prototype, protoProps);
                  if (staticProps)
                    _defineProperties2(Constructor, staticProps);
                  return Constructor;
                }
                var WebGLContext = function() {
                  function WebGLContext2(_ref) {
                    var _ref$enable = _ref.enable, enable = _ref$enable === void 0 ? false : _ref$enable;
                    _classCallCheck2(this, WebGLContext2);
                    this._enabled = enable === true;
                  }
                  _createClass2(WebGLContext2, [{ key: "composeSMask", value: function composeSMask(_ref2) {
                    var layer = _ref2.layer, mask = _ref2.mask, properties = _ref2.properties;
                    return WebGLUtils.composeSMask(layer, mask, properties);
                  } }, { key: "drawFigures", value: function drawFigures(_ref3) {
                    var width = _ref3.width, height = _ref3.height, backgroundColor = _ref3.backgroundColor, figures = _ref3.figures, context = _ref3.context;
                    return WebGLUtils.drawFigures(width, height, backgroundColor, figures, context);
                  } }, { key: "clear", value: function clear() {
                    WebGLUtils.cleanup();
                  } }, { key: "isEnabled", get: function get() {
                    var enabled = this._enabled;
                    if (enabled) {
                      enabled = WebGLUtils.tryInitGL();
                    }
                    return (0, _util2.shadow)(this, "isEnabled", enabled);
                  } }]);
                  return WebGLContext2;
                }();
                exports2.WebGLContext = WebGLContext;
                var WebGLUtils = function WebGLUtilsClosure() {
                  function loadShader(gl, code, shaderType) {
                    var shader = gl.createShader(shaderType);
                    gl.shaderSource(shader, code);
                    gl.compileShader(shader);
                    var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
                    if (!compiled) {
                      var errorMsg = gl.getShaderInfoLog(shader);
                      throw new Error("Error during shader compilation: " + errorMsg);
                    }
                    return shader;
                  }
                  function createVertexShader(gl, code) {
                    return loadShader(gl, code, gl.VERTEX_SHADER);
                  }
                  function createFragmentShader(gl, code) {
                    return loadShader(gl, code, gl.FRAGMENT_SHADER);
                  }
                  function createProgram(gl, shaders) {
                    var program = gl.createProgram();
                    for (var i = 0, ii = shaders.length; i < ii; ++i) {
                      gl.attachShader(program, shaders[i]);
                    }
                    gl.linkProgram(program);
                    var linked = gl.getProgramParameter(program, gl.LINK_STATUS);
                    if (!linked) {
                      var errorMsg = gl.getProgramInfoLog(program);
                      throw new Error("Error during program linking: " + errorMsg);
                    }
                    return program;
                  }
                  function createTexture(gl, image, textureId) {
                    gl.activeTexture(textureId);
                    var texture = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
                    return texture;
                  }
                  var currentGL, currentCanvas;
                  function generateGL() {
                    if (currentGL) {
                      return;
                    }
                    currentCanvas = document.createElement("canvas");
                    currentGL = currentCanvas.getContext("webgl", { premultipliedalpha: false });
                  }
                  var smaskVertexShaderCode = "  attribute vec2 a_position;                                      attribute vec2 a_texCoord;                                                                                                      uniform vec2 u_resolution;                                                                                                      varying vec2 v_texCoord;                                                                                                        void main() {                                                     vec2 clipSpace = (a_position / u_resolution) * 2.0 - 1.0;       gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);                                                                              v_texCoord = a_texCoord;                                      }                                                             ";
                  var smaskFragmentShaderCode = "  precision mediump float;                                                                                                        uniform vec4 u_backdrop;                                        uniform int u_subtype;                                          uniform sampler2D u_image;                                      uniform sampler2D u_mask;                                                                                                       varying vec2 v_texCoord;                                                                                                        void main() {                                                     vec4 imageColor = texture2D(u_image, v_texCoord);               vec4 maskColor = texture2D(u_mask, v_texCoord);                 if (u_backdrop.a > 0.0) {                                         maskColor.rgb = maskColor.rgb * maskColor.a +                                   u_backdrop.rgb * (1.0 - maskColor.a);         }                                                               float lum;                                                      if (u_subtype == 0) {                                             lum = maskColor.a;                                            } else {                                                          lum = maskColor.r * 0.3 + maskColor.g * 0.59 +                        maskColor.b * 0.11;                                     }                                                               imageColor.a *= lum;                                            imageColor.rgb *= imageColor.a;                                 gl_FragColor = imageColor;                                    }                                                             ";
                  var smaskCache = null;
                  function initSmaskGL() {
                    var canvas, gl;
                    generateGL();
                    canvas = currentCanvas;
                    currentCanvas = null;
                    gl = currentGL;
                    currentGL = null;
                    var vertexShader = createVertexShader(gl, smaskVertexShaderCode);
                    var fragmentShader = createFragmentShader(gl, smaskFragmentShaderCode);
                    var program = createProgram(gl, [vertexShader, fragmentShader]);
                    gl.useProgram(program);
                    var cache = {};
                    cache.gl = gl;
                    cache.canvas = canvas;
                    cache.resolutionLocation = gl.getUniformLocation(program, "u_resolution");
                    cache.positionLocation = gl.getAttribLocation(program, "a_position");
                    cache.backdropLocation = gl.getUniformLocation(program, "u_backdrop");
                    cache.subtypeLocation = gl.getUniformLocation(program, "u_subtype");
                    var texCoordLocation = gl.getAttribLocation(program, "a_texCoord");
                    var texLayerLocation = gl.getUniformLocation(program, "u_image");
                    var texMaskLocation = gl.getUniformLocation(program, "u_mask");
                    var texCoordBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1]), gl.STATIC_DRAW);
                    gl.enableVertexAttribArray(texCoordLocation);
                    gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);
                    gl.uniform1i(texLayerLocation, 0);
                    gl.uniform1i(texMaskLocation, 1);
                    smaskCache = cache;
                  }
                  function composeSMask(layer, mask, properties) {
                    var width = layer.width, height = layer.height;
                    if (!smaskCache) {
                      initSmaskGL();
                    }
                    var cache = smaskCache, canvas = cache.canvas, gl = cache.gl;
                    canvas.width = width;
                    canvas.height = height;
                    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
                    gl.uniform2f(cache.resolutionLocation, width, height);
                    if (properties.backdrop) {
                      gl.uniform4f(cache.resolutionLocation, properties.backdrop[0], properties.backdrop[1], properties.backdrop[2], 1);
                    } else {
                      gl.uniform4f(cache.resolutionLocation, 0, 0, 0, 0);
                    }
                    gl.uniform1i(cache.subtypeLocation, properties.subtype === "Luminosity" ? 1 : 0);
                    var texture = createTexture(gl, layer, gl.TEXTURE0);
                    var maskTexture = createTexture(gl, mask, gl.TEXTURE1);
                    var buffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, width, 0, 0, height, 0, height, width, 0, width, height]), gl.STATIC_DRAW);
                    gl.enableVertexAttribArray(cache.positionLocation);
                    gl.vertexAttribPointer(cache.positionLocation, 2, gl.FLOAT, false, 0, 0);
                    gl.clearColor(0, 0, 0, 0);
                    gl.enable(gl.BLEND);
                    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                    gl.flush();
                    gl.deleteTexture(texture);
                    gl.deleteTexture(maskTexture);
                    gl.deleteBuffer(buffer);
                    return canvas;
                  }
                  var figuresVertexShaderCode = "  attribute vec2 a_position;                                      attribute vec3 a_color;                                                                                                         uniform vec2 u_resolution;                                      uniform vec2 u_scale;                                           uniform vec2 u_offset;                                                                                                          varying vec4 v_color;                                                                                                           void main() {                                                     vec2 position = (a_position + u_offset) * u_scale;              vec2 clipSpace = (position / u_resolution) * 2.0 - 1.0;         gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);                                                                              v_color = vec4(a_color / 255.0, 1.0);                         }                                                             ";
                  var figuresFragmentShaderCode = "  precision mediump float;                                                                                                        varying vec4 v_color;                                                                                                           void main() {                                                     gl_FragColor = v_color;                                       }                                                             ";
                  var figuresCache = null;
                  function initFiguresGL() {
                    var canvas, gl;
                    generateGL();
                    canvas = currentCanvas;
                    currentCanvas = null;
                    gl = currentGL;
                    currentGL = null;
                    var vertexShader = createVertexShader(gl, figuresVertexShaderCode);
                    var fragmentShader = createFragmentShader(gl, figuresFragmentShaderCode);
                    var program = createProgram(gl, [vertexShader, fragmentShader]);
                    gl.useProgram(program);
                    var cache = {};
                    cache.gl = gl;
                    cache.canvas = canvas;
                    cache.resolutionLocation = gl.getUniformLocation(program, "u_resolution");
                    cache.scaleLocation = gl.getUniformLocation(program, "u_scale");
                    cache.offsetLocation = gl.getUniformLocation(program, "u_offset");
                    cache.positionLocation = gl.getAttribLocation(program, "a_position");
                    cache.colorLocation = gl.getAttribLocation(program, "a_color");
                    figuresCache = cache;
                  }
                  function drawFigures(width, height, backgroundColor, figures, context) {
                    if (!figuresCache) {
                      initFiguresGL();
                    }
                    var cache = figuresCache, canvas = cache.canvas, gl = cache.gl;
                    canvas.width = width;
                    canvas.height = height;
                    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
                    gl.uniform2f(cache.resolutionLocation, width, height);
                    var count = 0;
                    var i, ii, rows;
                    for (i = 0, ii = figures.length; i < ii; i++) {
                      switch (figures[i].type) {
                        case "lattice":
                          rows = figures[i].coords.length / figures[i].verticesPerRow | 0;
                          count += (rows - 1) * (figures[i].verticesPerRow - 1) * 6;
                          break;
                        case "triangles":
                          count += figures[i].coords.length;
                          break;
                      }
                    }
                    var coords = new Float32Array(count * 2);
                    var colors = new Uint8Array(count * 3);
                    var coordsMap = context.coords, colorsMap = context.colors;
                    var pIndex = 0, cIndex = 0;
                    for (i = 0, ii = figures.length; i < ii; i++) {
                      var figure = figures[i], ps = figure.coords, cs = figure.colors;
                      switch (figure.type) {
                        case "lattice":
                          var cols = figure.verticesPerRow;
                          rows = ps.length / cols | 0;
                          for (var row = 1; row < rows; row++) {
                            var offset = row * cols + 1;
                            for (var col = 1; col < cols; col++, offset++) {
                              coords[pIndex] = coordsMap[ps[offset - cols - 1]];
                              coords[pIndex + 1] = coordsMap[ps[offset - cols - 1] + 1];
                              coords[pIndex + 2] = coordsMap[ps[offset - cols]];
                              coords[pIndex + 3] = coordsMap[ps[offset - cols] + 1];
                              coords[pIndex + 4] = coordsMap[ps[offset - 1]];
                              coords[pIndex + 5] = coordsMap[ps[offset - 1] + 1];
                              colors[cIndex] = colorsMap[cs[offset - cols - 1]];
                              colors[cIndex + 1] = colorsMap[cs[offset - cols - 1] + 1];
                              colors[cIndex + 2] = colorsMap[cs[offset - cols - 1] + 2];
                              colors[cIndex + 3] = colorsMap[cs[offset - cols]];
                              colors[cIndex + 4] = colorsMap[cs[offset - cols] + 1];
                              colors[cIndex + 5] = colorsMap[cs[offset - cols] + 2];
                              colors[cIndex + 6] = colorsMap[cs[offset - 1]];
                              colors[cIndex + 7] = colorsMap[cs[offset - 1] + 1];
                              colors[cIndex + 8] = colorsMap[cs[offset - 1] + 2];
                              coords[pIndex + 6] = coords[pIndex + 2];
                              coords[pIndex + 7] = coords[pIndex + 3];
                              coords[pIndex + 8] = coords[pIndex + 4];
                              coords[pIndex + 9] = coords[pIndex + 5];
                              coords[pIndex + 10] = coordsMap[ps[offset]];
                              coords[pIndex + 11] = coordsMap[ps[offset] + 1];
                              colors[cIndex + 9] = colors[cIndex + 3];
                              colors[cIndex + 10] = colors[cIndex + 4];
                              colors[cIndex + 11] = colors[cIndex + 5];
                              colors[cIndex + 12] = colors[cIndex + 6];
                              colors[cIndex + 13] = colors[cIndex + 7];
                              colors[cIndex + 14] = colors[cIndex + 8];
                              colors[cIndex + 15] = colorsMap[cs[offset]];
                              colors[cIndex + 16] = colorsMap[cs[offset] + 1];
                              colors[cIndex + 17] = colorsMap[cs[offset] + 2];
                              pIndex += 12;
                              cIndex += 18;
                            }
                          }
                          break;
                        case "triangles":
                          for (var j = 0, jj = ps.length; j < jj; j++) {
                            coords[pIndex] = coordsMap[ps[j]];
                            coords[pIndex + 1] = coordsMap[ps[j] + 1];
                            colors[cIndex] = colorsMap[cs[j]];
                            colors[cIndex + 1] = colorsMap[cs[j] + 1];
                            colors[cIndex + 2] = colorsMap[cs[j] + 2];
                            pIndex += 2;
                            cIndex += 3;
                          }
                          break;
                      }
                    }
                    if (backgroundColor) {
                      gl.clearColor(backgroundColor[0] / 255, backgroundColor[1] / 255, backgroundColor[2] / 255, 1);
                    } else {
                      gl.clearColor(0, 0, 0, 0);
                    }
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    var coordsBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, coordsBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, coords, gl.STATIC_DRAW);
                    gl.enableVertexAttribArray(cache.positionLocation);
                    gl.vertexAttribPointer(cache.positionLocation, 2, gl.FLOAT, false, 0, 0);
                    var colorsBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, colorsBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
                    gl.enableVertexAttribArray(cache.colorLocation);
                    gl.vertexAttribPointer(cache.colorLocation, 3, gl.UNSIGNED_BYTE, false, 0, 0);
                    gl.uniform2f(cache.scaleLocation, context.scaleX, context.scaleY);
                    gl.uniform2f(cache.offsetLocation, context.offsetX, context.offsetY);
                    gl.drawArrays(gl.TRIANGLES, 0, count);
                    gl.flush();
                    gl.deleteBuffer(coordsBuffer);
                    gl.deleteBuffer(colorsBuffer);
                    return canvas;
                  }
                  return { tryInitGL: function tryInitGL() {
                    try {
                      generateGL();
                      return !!currentGL;
                    } catch (ex) {
                    }
                    return false;
                  }, composeSMask, drawFigures, cleanup: function cleanup() {
                    if (smaskCache && smaskCache.canvas) {
                      smaskCache.canvas.width = 0;
                      smaskCache.canvas.height = 0;
                    }
                    if (figuresCache && figuresCache.canvas) {
                      figuresCache.canvas.width = 0;
                      figuresCache.canvas.height = 0;
                    }
                    smaskCache = null;
                    figuresCache = null;
                  } };
                }();
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.renderTextLayer = void 0;
                var _util2 = __w_pdfjs_require__2(1);
                var renderTextLayer = function renderTextLayerClosure() {
                  var MAX_TEXT_DIVS_TO_RENDER = 1e5;
                  var NonWhitespaceRegexp = /\S/;
                  function isAllWhitespace(str) {
                    return !NonWhitespaceRegexp.test(str);
                  }
                  function appendText(task, geom, styles) {
                    var textDiv = document.createElement("span");
                    var textDivProperties = { angle: 0, canvasWidth: 0, isWhitespace: false, originalTransform: null, paddingBottom: 0, paddingLeft: 0, paddingRight: 0, paddingTop: 0, scale: 1 };
                    task._textDivs.push(textDiv);
                    if (isAllWhitespace(geom.str)) {
                      textDivProperties.isWhitespace = true;
                      task._textDivProperties.set(textDiv, textDivProperties);
                      return;
                    }
                    var tx = _util2.Util.transform(task._viewport.transform, geom.transform);
                    var angle = Math.atan2(tx[1], tx[0]);
                    var style = styles[geom.fontName];
                    if (style.vertical) {
                      angle += Math.PI / 2;
                    }
                    var fontHeight = Math.sqrt(tx[2] * tx[2] + tx[3] * tx[3]);
                    var fontAscent = fontHeight;
                    if (style.ascent) {
                      fontAscent = style.ascent * fontAscent;
                    } else if (style.descent) {
                      fontAscent = (1 + style.descent) * fontAscent;
                    }
                    var left, top;
                    if (angle === 0) {
                      left = tx[4];
                      top = tx[5] - fontAscent;
                    } else {
                      left = tx[4] + fontAscent * Math.sin(angle);
                      top = tx[5] - fontAscent * Math.cos(angle);
                    }
                    textDiv.style.left = "".concat(left, "px");
                    textDiv.style.top = "".concat(top, "px");
                    textDiv.style.fontSize = "".concat(fontHeight, "px");
                    textDiv.style.fontFamily = style.fontFamily;
                    textDiv.textContent = geom.str;
                    if (task._fontInspectorEnabled) {
                      textDiv.dataset.fontName = geom.fontName;
                    }
                    if (angle !== 0) {
                      textDivProperties.angle = angle * (180 / Math.PI);
                    }
                    if (geom.str.length > 1) {
                      if (style.vertical) {
                        textDivProperties.canvasWidth = geom.height * task._viewport.scale;
                      } else {
                        textDivProperties.canvasWidth = geom.width * task._viewport.scale;
                      }
                    }
                    task._textDivProperties.set(textDiv, textDivProperties);
                    if (task._textContentStream) {
                      task._layoutText(textDiv);
                    }
                    if (task._enhanceTextSelection) {
                      var angleCos = 1, angleSin = 0;
                      if (angle !== 0) {
                        angleCos = Math.cos(angle);
                        angleSin = Math.sin(angle);
                      }
                      var divWidth = (style.vertical ? geom.height : geom.width) * task._viewport.scale;
                      var divHeight = fontHeight;
                      var m, b;
                      if (angle !== 0) {
                        m = [angleCos, angleSin, -angleSin, angleCos, left, top];
                        b = _util2.Util.getAxialAlignedBoundingBox([0, 0, divWidth, divHeight], m);
                      } else {
                        b = [left, top, left + divWidth, top + divHeight];
                      }
                      task._bounds.push({ left: b[0], top: b[1], right: b[2], bottom: b[3], div: textDiv, size: [divWidth, divHeight], m });
                    }
                  }
                  function render(task) {
                    if (task._canceled) {
                      return;
                    }
                    var textDivs = task._textDivs;
                    var capability = task._capability;
                    var textDivsLength = textDivs.length;
                    if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) {
                      task._renderingDone = true;
                      capability.resolve();
                      return;
                    }
                    if (!task._textContentStream) {
                      for (var i = 0; i < textDivsLength; i++) {
                        task._layoutText(textDivs[i]);
                      }
                    }
                    task._renderingDone = true;
                    capability.resolve();
                  }
                  function expand(task) {
                    var bounds = task._bounds;
                    var viewport = task._viewport;
                    var expanded = expandBounds(viewport.width, viewport.height, bounds);
                    for (var i = 0; i < expanded.length; i++) {
                      var div = bounds[i].div;
                      var divProperties = task._textDivProperties.get(div);
                      if (divProperties.angle === 0) {
                        divProperties.paddingLeft = bounds[i].left - expanded[i].left;
                        divProperties.paddingTop = bounds[i].top - expanded[i].top;
                        divProperties.paddingRight = expanded[i].right - bounds[i].right;
                        divProperties.paddingBottom = expanded[i].bottom - bounds[i].bottom;
                        task._textDivProperties.set(div, divProperties);
                        continue;
                      }
                      var e = expanded[i], b = bounds[i];
                      var m = b.m, c = m[0], s = m[1];
                      var points = [[0, 0], [0, b.size[1]], [b.size[0], 0], b.size];
                      var ts = new Float64Array(64);
                      points.forEach(function(p, i2) {
                        var t = _util2.Util.applyTransform(p, m);
                        ts[i2 + 0] = c && (e.left - t[0]) / c;
                        ts[i2 + 4] = s && (e.top - t[1]) / s;
                        ts[i2 + 8] = c && (e.right - t[0]) / c;
                        ts[i2 + 12] = s && (e.bottom - t[1]) / s;
                        ts[i2 + 16] = s && (e.left - t[0]) / -s;
                        ts[i2 + 20] = c && (e.top - t[1]) / c;
                        ts[i2 + 24] = s && (e.right - t[0]) / -s;
                        ts[i2 + 28] = c && (e.bottom - t[1]) / c;
                        ts[i2 + 32] = c && (e.left - t[0]) / -c;
                        ts[i2 + 36] = s && (e.top - t[1]) / -s;
                        ts[i2 + 40] = c && (e.right - t[0]) / -c;
                        ts[i2 + 44] = s && (e.bottom - t[1]) / -s;
                        ts[i2 + 48] = s && (e.left - t[0]) / s;
                        ts[i2 + 52] = c && (e.top - t[1]) / -c;
                        ts[i2 + 56] = s && (e.right - t[0]) / s;
                        ts[i2 + 60] = c && (e.bottom - t[1]) / -c;
                      });
                      var findPositiveMin = function findPositiveMin2(ts2, offset, count) {
                        var result = 0;
                        for (var i2 = 0; i2 < count; i2++) {
                          var t = ts2[offset++];
                          if (t > 0) {
                            result = result ? Math.min(t, result) : t;
                          }
                        }
                        return result;
                      };
                      var boxScale = 1 + Math.min(Math.abs(c), Math.abs(s));
                      divProperties.paddingLeft = findPositiveMin(ts, 32, 16) / boxScale;
                      divProperties.paddingTop = findPositiveMin(ts, 48, 16) / boxScale;
                      divProperties.paddingRight = findPositiveMin(ts, 0, 16) / boxScale;
                      divProperties.paddingBottom = findPositiveMin(ts, 16, 16) / boxScale;
                      task._textDivProperties.set(div, divProperties);
                    }
                  }
                  function expandBounds(width, height, boxes) {
                    var bounds = boxes.map(function(box, i) {
                      return { x1: box.left, y1: box.top, x2: box.right, y2: box.bottom, index: i, x1New: void 0, x2New: void 0 };
                    });
                    expandBoundsLTR(width, bounds);
                    var expanded = new Array(boxes.length);
                    bounds.forEach(function(b) {
                      var i = b.index;
                      expanded[i] = { left: b.x1New, top: 0, right: b.x2New, bottom: 0 };
                    });
                    boxes.map(function(box, i) {
                      var e = expanded[i], b = bounds[i];
                      b.x1 = box.top;
                      b.y1 = width - e.right;
                      b.x2 = box.bottom;
                      b.y2 = width - e.left;
                      b.index = i;
                      b.x1New = void 0;
                      b.x2New = void 0;
                    });
                    expandBoundsLTR(height, bounds);
                    bounds.forEach(function(b) {
                      var i = b.index;
                      expanded[i].top = b.x1New;
                      expanded[i].bottom = b.x2New;
                    });
                    return expanded;
                  }
                  function expandBoundsLTR(width, bounds) {
                    bounds.sort(function(a, b) {
                      return a.x1 - b.x1 || a.index - b.index;
                    });
                    var fakeBoundary = { x1: -Infinity, y1: -Infinity, x2: 0, y2: Infinity, index: -1, x1New: 0, x2New: 0 };
                    var horizon = [{ start: -Infinity, end: Infinity, boundary: fakeBoundary }];
                    bounds.forEach(function(boundary) {
                      var i = 0;
                      while (i < horizon.length && horizon[i].end <= boundary.y1) {
                        i++;
                      }
                      var j = horizon.length - 1;
                      while (j >= 0 && horizon[j].start >= boundary.y2) {
                        j--;
                      }
                      var horizonPart, affectedBoundary;
                      var q, k, maxXNew = -Infinity;
                      for (q = i; q <= j; q++) {
                        horizonPart = horizon[q];
                        affectedBoundary = horizonPart.boundary;
                        var xNew;
                        if (affectedBoundary.x2 > boundary.x1) {
                          xNew = affectedBoundary.index > boundary.index ? affectedBoundary.x1New : boundary.x1;
                        } else if (affectedBoundary.x2New === void 0) {
                          xNew = (affectedBoundary.x2 + boundary.x1) / 2;
                        } else {
                          xNew = affectedBoundary.x2New;
                        }
                        if (xNew > maxXNew) {
                          maxXNew = xNew;
                        }
                      }
                      boundary.x1New = maxXNew;
                      for (q = i; q <= j; q++) {
                        horizonPart = horizon[q];
                        affectedBoundary = horizonPart.boundary;
                        if (affectedBoundary.x2New === void 0) {
                          if (affectedBoundary.x2 > boundary.x1) {
                            if (affectedBoundary.index > boundary.index) {
                              affectedBoundary.x2New = affectedBoundary.x2;
                            }
                          } else {
                            affectedBoundary.x2New = maxXNew;
                          }
                        } else if (affectedBoundary.x2New > maxXNew) {
                          affectedBoundary.x2New = Math.max(maxXNew, affectedBoundary.x2);
                        }
                      }
                      var changedHorizon = [], lastBoundary = null;
                      for (q = i; q <= j; q++) {
                        horizonPart = horizon[q];
                        affectedBoundary = horizonPart.boundary;
                        var useBoundary = affectedBoundary.x2 > boundary.x2 ? affectedBoundary : boundary;
                        if (lastBoundary === useBoundary) {
                          changedHorizon[changedHorizon.length - 1].end = horizonPart.end;
                        } else {
                          changedHorizon.push({ start: horizonPart.start, end: horizonPart.end, boundary: useBoundary });
                          lastBoundary = useBoundary;
                        }
                      }
                      if (horizon[i].start < boundary.y1) {
                        changedHorizon[0].start = boundary.y1;
                        changedHorizon.unshift({ start: horizon[i].start, end: boundary.y1, boundary: horizon[i].boundary });
                      }
                      if (boundary.y2 < horizon[j].end) {
                        changedHorizon[changedHorizon.length - 1].end = boundary.y2;
                        changedHorizon.push({ start: boundary.y2, end: horizon[j].end, boundary: horizon[j].boundary });
                      }
                      for (q = i; q <= j; q++) {
                        horizonPart = horizon[q];
                        affectedBoundary = horizonPart.boundary;
                        if (affectedBoundary.x2New !== void 0) {
                          continue;
                        }
                        var used = false;
                        for (k = i - 1; !used && k >= 0 && horizon[k].start >= affectedBoundary.y1; k--) {
                          used = horizon[k].boundary === affectedBoundary;
                        }
                        for (k = j + 1; !used && k < horizon.length && horizon[k].end <= affectedBoundary.y2; k++) {
                          used = horizon[k].boundary === affectedBoundary;
                        }
                        for (k = 0; !used && k < changedHorizon.length; k++) {
                          used = changedHorizon[k].boundary === affectedBoundary;
                        }
                        if (!used) {
                          affectedBoundary.x2New = maxXNew;
                        }
                      }
                      Array.prototype.splice.apply(horizon, [i, j - i + 1].concat(changedHorizon));
                    });
                    horizon.forEach(function(horizonPart) {
                      var affectedBoundary = horizonPart.boundary;
                      if (affectedBoundary.x2New === void 0) {
                        affectedBoundary.x2New = Math.max(width, affectedBoundary.x2);
                      }
                    });
                  }
                  function TextLayerRenderTask(_ref) {
                    var _this = this;
                    var textContent = _ref.textContent, textContentStream = _ref.textContentStream, container = _ref.container, viewport = _ref.viewport, textDivs = _ref.textDivs, textContentItemsStr = _ref.textContentItemsStr, enhanceTextSelection = _ref.enhanceTextSelection;
                    this._textContent = textContent;
                    this._textContentStream = textContentStream;
                    this._container = container;
                    this._viewport = viewport;
                    this._textDivs = textDivs || [];
                    this._textContentItemsStr = textContentItemsStr || [];
                    this._enhanceTextSelection = !!enhanceTextSelection;
                    this._fontInspectorEnabled = !!(globalThis.FontInspector && globalThis.FontInspector.enabled);
                    this._reader = null;
                    this._layoutTextLastFontSize = null;
                    this._layoutTextLastFontFamily = null;
                    this._layoutTextCtx = null;
                    this._textDivProperties = /* @__PURE__ */ new WeakMap();
                    this._renderingDone = false;
                    this._canceled = false;
                    this._capability = (0, _util2.createPromiseCapability)();
                    this._renderTimer = null;
                    this._bounds = [];
                    this._capability.promise["finally"](function() {
                      if (_this._layoutTextCtx) {
                        _this._layoutTextCtx.canvas.width = 0;
                        _this._layoutTextCtx.canvas.height = 0;
                        _this._layoutTextCtx = null;
                      }
                    })["catch"](function() {
                    });
                  }
                  TextLayerRenderTask.prototype = { get promise() {
                    return this._capability.promise;
                  }, cancel: function TextLayer_cancel() {
                    this._canceled = true;
                    if (this._reader) {
                      this._reader.cancel(new _util2.AbortException("TextLayer task cancelled."));
                      this._reader = null;
                    }
                    if (this._renderTimer !== null) {
                      clearTimeout(this._renderTimer);
                      this._renderTimer = null;
                    }
                    this._capability.reject(new Error("TextLayer task cancelled."));
                  }, _processItems: function _processItems(items, styleCache) {
                    for (var i = 0, len = items.length; i < len; i++) {
                      this._textContentItemsStr.push(items[i].str);
                      appendText(this, items[i], styleCache);
                    }
                  }, _layoutText: function _layoutText(textDiv) {
                    var textDivProperties = this._textDivProperties.get(textDiv);
                    if (textDivProperties.isWhitespace) {
                      return;
                    }
                    var transform = "";
                    if (textDivProperties.canvasWidth !== 0) {
                      var _textDiv$style = textDiv.style, fontSize = _textDiv$style.fontSize, fontFamily = _textDiv$style.fontFamily;
                      if (fontSize !== this._layoutTextLastFontSize || fontFamily !== this._layoutTextLastFontFamily) {
                        this._layoutTextCtx.font = "".concat(fontSize, " ").concat(fontFamily);
                        this._layoutTextLastFontSize = fontSize;
                        this._layoutTextLastFontFamily = fontFamily;
                      }
                      var _this$_layoutTextCtx$ = this._layoutTextCtx.measureText(textDiv.textContent), width = _this$_layoutTextCtx$.width;
                      if (width > 0) {
                        textDivProperties.scale = textDivProperties.canvasWidth / width;
                        transform = "scaleX(".concat(textDivProperties.scale, ")");
                      }
                    }
                    if (textDivProperties.angle !== 0) {
                      transform = "rotate(".concat(textDivProperties.angle, "deg) ").concat(transform);
                    }
                    if (transform.length > 0) {
                      if (this._enhanceTextSelection) {
                        textDivProperties.originalTransform = transform;
                      }
                      textDiv.style.transform = transform;
                    }
                    this._textDivProperties.set(textDiv, textDivProperties);
                    this._container.appendChild(textDiv);
                  }, _render: function TextLayer_render(timeout) {
                    var _this2 = this;
                    var capability = (0, _util2.createPromiseCapability)();
                    var styleCache = /* @__PURE__ */ Object.create(null);
                    var canvas = document.createElement("canvas");
                    canvas.mozOpaque = true;
                    this._layoutTextCtx = canvas.getContext("2d", { alpha: false });
                    if (this._textContent) {
                      var textItems = this._textContent.items;
                      var textStyles = this._textContent.styles;
                      this._processItems(textItems, textStyles);
                      capability.resolve();
                    } else if (this._textContentStream) {
                      var pump = function pump2() {
                        _this2._reader.read().then(function(_ref2) {
                          var value = _ref2.value, done = _ref2.done;
                          if (done) {
                            capability.resolve();
                            return;
                          }
                          Object.assign(styleCache, value.styles);
                          _this2._processItems(value.items, styleCache);
                          pump2();
                        }, capability.reject);
                      };
                      this._reader = this._textContentStream.getReader();
                      pump();
                    } else {
                      throw new Error('Neither "textContent" nor "textContentStream" parameters specified.');
                    }
                    capability.promise.then(function() {
                      styleCache = null;
                      if (!timeout) {
                        render(_this2);
                      } else {
                        _this2._renderTimer = setTimeout(function() {
                          render(_this2);
                          _this2._renderTimer = null;
                        }, timeout);
                      }
                    }, this._capability.reject);
                  }, expandTextDivs: function TextLayer_expandTextDivs(expandDivs) {
                    if (!this._enhanceTextSelection || !this._renderingDone) {
                      return;
                    }
                    if (this._bounds !== null) {
                      expand(this);
                      this._bounds = null;
                    }
                    var transformBuf = [], paddingBuf = [];
                    for (var i = 0, ii = this._textDivs.length; i < ii; i++) {
                      var div = this._textDivs[i];
                      var divProps = this._textDivProperties.get(div);
                      if (divProps.isWhitespace) {
                        continue;
                      }
                      if (expandDivs) {
                        transformBuf.length = 0;
                        paddingBuf.length = 0;
                        if (divProps.originalTransform) {
                          transformBuf.push(divProps.originalTransform);
                        }
                        if (divProps.paddingTop > 0) {
                          paddingBuf.push("".concat(divProps.paddingTop, "px"));
                          transformBuf.push("translateY(".concat(-divProps.paddingTop, "px)"));
                        } else {
                          paddingBuf.push(0);
                        }
                        if (divProps.paddingRight > 0) {
                          paddingBuf.push("".concat(divProps.paddingRight / divProps.scale, "px"));
                        } else {
                          paddingBuf.push(0);
                        }
                        if (divProps.paddingBottom > 0) {
                          paddingBuf.push("".concat(divProps.paddingBottom, "px"));
                        } else {
                          paddingBuf.push(0);
                        }
                        if (divProps.paddingLeft > 0) {
                          paddingBuf.push("".concat(divProps.paddingLeft / divProps.scale, "px"));
                          transformBuf.push("translateX(".concat(-divProps.paddingLeft / divProps.scale, "px)"));
                        } else {
                          paddingBuf.push(0);
                        }
                        div.style.padding = paddingBuf.join(" ");
                        if (transformBuf.length) {
                          div.style.transform = transformBuf.join(" ");
                        }
                      } else {
                        div.style.padding = null;
                        div.style.transform = divProps.originalTransform;
                      }
                    }
                  } };
                  function renderTextLayer2(renderParameters) {
                    var task = new TextLayerRenderTask({ textContent: renderParameters.textContent, textContentStream: renderParameters.textContentStream, container: renderParameters.container, viewport: renderParameters.viewport, textDivs: renderParameters.textDivs, textContentItemsStr: renderParameters.textContentItemsStr, enhanceTextSelection: renderParameters.enhanceTextSelection });
                    task._render(renderParameters.timeout);
                    return task;
                  }
                  return renderTextLayer2;
                }();
                exports2.renderTextLayer = renderTextLayer;
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.AnnotationLayer = void 0;
                var _display_utils2 = __w_pdfjs_require__2(194);
                var _util2 = __w_pdfjs_require__2(1);
                function _get(target, property, receiver) {
                  if (typeof Reflect !== "undefined" && Reflect.get) {
                    _get = Reflect.get;
                  } else {
                    _get = function _get2(target2, property2, receiver2) {
                      var base = _superPropBase(target2, property2);
                      if (!base)
                        return;
                      var desc = Object.getOwnPropertyDescriptor(base, property2);
                      if (desc.get) {
                        return desc.get.call(receiver2);
                      }
                      return desc.value;
                    };
                  }
                  return _get(target, property, receiver || target);
                }
                function _superPropBase(object, property) {
                  while (!Object.prototype.hasOwnProperty.call(object, property)) {
                    object = _getPrototypeOf(object);
                    if (object === null)
                      break;
                  }
                  return object;
                }
                function _typeof2(obj) {
                  "@babel/helpers - typeof";
                  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                    _typeof2 = function _typeof3(obj2) {
                      return typeof obj2;
                    };
                  } else {
                    _typeof2 = function _typeof3(obj2) {
                      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                    };
                  }
                  return _typeof2(obj);
                }
                function _possibleConstructorReturn(self2, call) {
                  if (call && (_typeof2(call) === "object" || typeof call === "function")) {
                    return call;
                  }
                  return _assertThisInitialized(self2);
                }
                function _assertThisInitialized(self2) {
                  if (self2 === void 0) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  }
                  return self2;
                }
                function _getPrototypeOf(o) {
                  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                    return o2.__proto__ || Object.getPrototypeOf(o2);
                  };
                  return _getPrototypeOf(o);
                }
                function _inherits(subClass, superClass) {
                  if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function");
                  }
                  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
                  if (superClass)
                    _setPrototypeOf(subClass, superClass);
                }
                function _setPrototypeOf(o, p) {
                  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                    o2.__proto__ = p2;
                    return o2;
                  };
                  return _setPrototypeOf(o, p);
                }
                function _classCallCheck2(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _defineProperties2(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                function _createClass2(Constructor, protoProps, staticProps) {
                  if (protoProps)
                    _defineProperties2(Constructor.prototype, protoProps);
                  if (staticProps)
                    _defineProperties2(Constructor, staticProps);
                  return Constructor;
                }
                var AnnotationElementFactory = function() {
                  function AnnotationElementFactory2() {
                    _classCallCheck2(this, AnnotationElementFactory2);
                  }
                  _createClass2(AnnotationElementFactory2, null, [{ key: "create", value: function create(parameters) {
                    var subtype = parameters.data.annotationType;
                    switch (subtype) {
                      case _util2.AnnotationType.LINK:
                        return new LinkAnnotationElement(parameters);
                      case _util2.AnnotationType.TEXT:
                        return new TextAnnotationElement(parameters);
                      case _util2.AnnotationType.WIDGET:
                        var fieldType = parameters.data.fieldType;
                        switch (fieldType) {
                          case "Tx":
                            return new TextWidgetAnnotationElement(parameters);
                          case "Btn":
                            if (parameters.data.radioButton) {
                              return new RadioButtonWidgetAnnotationElement(parameters);
                            } else if (parameters.data.checkBox) {
                              return new CheckboxWidgetAnnotationElement(parameters);
                            }
                            return new PushButtonWidgetAnnotationElement(parameters);
                          case "Ch":
                            return new ChoiceWidgetAnnotationElement(parameters);
                        }
                        return new WidgetAnnotationElement(parameters);
                      case _util2.AnnotationType.POPUP:
                        return new PopupAnnotationElement(parameters);
                      case _util2.AnnotationType.FREETEXT:
                        return new FreeTextAnnotationElement(parameters);
                      case _util2.AnnotationType.LINE:
                        return new LineAnnotationElement(parameters);
                      case _util2.AnnotationType.SQUARE:
                        return new SquareAnnotationElement(parameters);
                      case _util2.AnnotationType.CIRCLE:
                        return new CircleAnnotationElement(parameters);
                      case _util2.AnnotationType.POLYLINE:
                        return new PolylineAnnotationElement(parameters);
                      case _util2.AnnotationType.CARET:
                        return new CaretAnnotationElement(parameters);
                      case _util2.AnnotationType.INK:
                        return new InkAnnotationElement(parameters);
                      case _util2.AnnotationType.POLYGON:
                        return new PolygonAnnotationElement(parameters);
                      case _util2.AnnotationType.HIGHLIGHT:
                        return new HighlightAnnotationElement(parameters);
                      case _util2.AnnotationType.UNDERLINE:
                        return new UnderlineAnnotationElement(parameters);
                      case _util2.AnnotationType.SQUIGGLY:
                        return new SquigglyAnnotationElement(parameters);
                      case _util2.AnnotationType.STRIKEOUT:
                        return new StrikeOutAnnotationElement(parameters);
                      case _util2.AnnotationType.STAMP:
                        return new StampAnnotationElement(parameters);
                      case _util2.AnnotationType.FILEATTACHMENT:
                        return new FileAttachmentAnnotationElement(parameters);
                      default:
                        return new AnnotationElement(parameters);
                    }
                  } }]);
                  return AnnotationElementFactory2;
                }();
                var AnnotationElement = function() {
                  function AnnotationElement2(parameters) {
                    var isRenderable = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                    var ignoreBorder = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                    _classCallCheck2(this, AnnotationElement2);
                    this.isRenderable = isRenderable;
                    this.data = parameters.data;
                    this.layer = parameters.layer;
                    this.page = parameters.page;
                    this.viewport = parameters.viewport;
                    this.linkService = parameters.linkService;
                    this.downloadManager = parameters.downloadManager;
                    this.imageResourcesPath = parameters.imageResourcesPath;
                    this.renderInteractiveForms = parameters.renderInteractiveForms;
                    this.svgFactory = parameters.svgFactory;
                    if (isRenderable) {
                      this.container = this._createContainer(ignoreBorder);
                    }
                  }
                  _createClass2(AnnotationElement2, [{ key: "_createContainer", value: function _createContainer() {
                    var ignoreBorder = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                    var data = this.data, page = this.page, viewport = this.viewport;
                    var container = document.createElement("section");
                    var width = data.rect[2] - data.rect[0];
                    var height = data.rect[3] - data.rect[1];
                    container.setAttribute("data-annotation-id", data.id);
                    var rect = _util2.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);
                    container.style.transform = "matrix(".concat(viewport.transform.join(","), ")");
                    container.style.transformOrigin = "-".concat(rect[0], "px -").concat(rect[1], "px");
                    if (!ignoreBorder && data.borderStyle.width > 0) {
                      container.style.borderWidth = "".concat(data.borderStyle.width, "px");
                      if (data.borderStyle.style !== _util2.AnnotationBorderStyleType.UNDERLINE) {
                        width = width - 2 * data.borderStyle.width;
                        height = height - 2 * data.borderStyle.width;
                      }
                      var horizontalRadius = data.borderStyle.horizontalCornerRadius;
                      var verticalRadius = data.borderStyle.verticalCornerRadius;
                      if (horizontalRadius > 0 || verticalRadius > 0) {
                        var radius = "".concat(horizontalRadius, "px / ").concat(verticalRadius, "px");
                        container.style.borderRadius = radius;
                      }
                      switch (data.borderStyle.style) {
                        case _util2.AnnotationBorderStyleType.SOLID:
                          container.style.borderStyle = "solid";
                          break;
                        case _util2.AnnotationBorderStyleType.DASHED:
                          container.style.borderStyle = "dashed";
                          break;
                        case _util2.AnnotationBorderStyleType.BEVELED:
                          (0, _util2.warn)("Unimplemented border style: beveled");
                          break;
                        case _util2.AnnotationBorderStyleType.INSET:
                          (0, _util2.warn)("Unimplemented border style: inset");
                          break;
                        case _util2.AnnotationBorderStyleType.UNDERLINE:
                          container.style.borderBottomStyle = "solid";
                          break;
                        default:
                          break;
                      }
                      if (data.color) {
                        container.style.borderColor = _util2.Util.makeCssRgb(data.color[0] | 0, data.color[1] | 0, data.color[2] | 0);
                      } else {
                        container.style.borderWidth = 0;
                      }
                    }
                    container.style.left = "".concat(rect[0], "px");
                    container.style.top = "".concat(rect[1], "px");
                    container.style.width = "".concat(width, "px");
                    container.style.height = "".concat(height, "px");
                    return container;
                  } }, { key: "_createPopup", value: function _createPopup(container, trigger, data) {
                    if (!trigger) {
                      trigger = document.createElement("div");
                      trigger.style.height = container.style.height;
                      trigger.style.width = container.style.width;
                      container.appendChild(trigger);
                    }
                    var popupElement = new PopupElement({ container, trigger, color: data.color, title: data.title, modificationDate: data.modificationDate, contents: data.contents, hideWrapper: true });
                    var popup = popupElement.render();
                    popup.style.left = container.style.width;
                    container.appendChild(popup);
                  } }, { key: "render", value: function render() {
                    (0, _util2.unreachable)("Abstract method `AnnotationElement.render` called");
                  } }]);
                  return AnnotationElement2;
                }();
                var LinkAnnotationElement = function(_AnnotationElement) {
                  _inherits(LinkAnnotationElement2, _AnnotationElement);
                  function LinkAnnotationElement2(parameters) {
                    _classCallCheck2(this, LinkAnnotationElement2);
                    var isRenderable = !!(parameters.data.url || parameters.data.dest || parameters.data.action);
                    return _possibleConstructorReturn(this, _getPrototypeOf(LinkAnnotationElement2).call(this, parameters, isRenderable));
                  }
                  _createClass2(LinkAnnotationElement2, [{ key: "render", value: function render() {
                    this.container.className = "linkAnnotation";
                    var data = this.data, linkService = this.linkService;
                    var link = document.createElement("a");
                    if (data.url) {
                      (0, _display_utils2.addLinkAttributes)(link, { url: data.url, target: data.newWindow ? _display_utils2.LinkTarget.BLANK : linkService.externalLinkTarget, rel: linkService.externalLinkRel, enabled: linkService.externalLinkEnabled });
                    } else if (data.action) {
                      this._bindNamedAction(link, data.action);
                    } else {
                      this._bindLink(link, data.dest);
                    }
                    this.container.appendChild(link);
                    return this.container;
                  } }, { key: "_bindLink", value: function _bindLink(link, destination) {
                    var _this = this;
                    link.href = this.linkService.getDestinationHash(destination);
                    link.onclick = function() {
                      if (destination) {
                        _this.linkService.navigateTo(destination);
                      }
                      return false;
                    };
                    if (destination) {
                      link.className = "internalLink";
                    }
                  } }, { key: "_bindNamedAction", value: function _bindNamedAction(link, action) {
                    var _this2 = this;
                    link.href = this.linkService.getAnchorUrl("");
                    link.onclick = function() {
                      _this2.linkService.executeNamedAction(action);
                      return false;
                    };
                    link.className = "internalLink";
                  } }]);
                  return LinkAnnotationElement2;
                }(AnnotationElement);
                var TextAnnotationElement = function(_AnnotationElement2) {
                  _inherits(TextAnnotationElement2, _AnnotationElement2);
                  function TextAnnotationElement2(parameters) {
                    _classCallCheck2(this, TextAnnotationElement2);
                    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                    return _possibleConstructorReturn(this, _getPrototypeOf(TextAnnotationElement2).call(this, parameters, isRenderable));
                  }
                  _createClass2(TextAnnotationElement2, [{ key: "render", value: function render() {
                    this.container.className = "textAnnotation";
                    var image = document.createElement("img");
                    image.style.height = this.container.style.height;
                    image.style.width = this.container.style.width;
                    image.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg";
                    image.alt = "[{{type}} Annotation]";
                    image.dataset.l10nId = "text_annotation_type";
                    image.dataset.l10nArgs = JSON.stringify({ type: this.data.name });
                    if (!this.data.hasPopup) {
                      this._createPopup(this.container, image, this.data);
                    }
                    this.container.appendChild(image);
                    return this.container;
                  } }]);
                  return TextAnnotationElement2;
                }(AnnotationElement);
                var WidgetAnnotationElement = function(_AnnotationElement3) {
                  _inherits(WidgetAnnotationElement2, _AnnotationElement3);
                  function WidgetAnnotationElement2() {
                    _classCallCheck2(this, WidgetAnnotationElement2);
                    return _possibleConstructorReturn(this, _getPrototypeOf(WidgetAnnotationElement2).apply(this, arguments));
                  }
                  _createClass2(WidgetAnnotationElement2, [{ key: "render", value: function render() {
                    return this.container;
                  } }]);
                  return WidgetAnnotationElement2;
                }(AnnotationElement);
                var TextWidgetAnnotationElement = function(_WidgetAnnotationElem) {
                  _inherits(TextWidgetAnnotationElement2, _WidgetAnnotationElem);
                  function TextWidgetAnnotationElement2(parameters) {
                    _classCallCheck2(this, TextWidgetAnnotationElement2);
                    var isRenderable = parameters.renderInteractiveForms || !parameters.data.hasAppearance && !!parameters.data.fieldValue;
                    return _possibleConstructorReturn(this, _getPrototypeOf(TextWidgetAnnotationElement2).call(this, parameters, isRenderable));
                  }
                  _createClass2(TextWidgetAnnotationElement2, [{ key: "render", value: function render() {
                    var TEXT_ALIGNMENT = ["left", "center", "right"];
                    this.container.className = "textWidgetAnnotation";
                    var element = null;
                    if (this.renderInteractiveForms) {
                      if (this.data.multiLine) {
                        element = document.createElement("textarea");
                        element.textContent = this.data.fieldValue;
                      } else {
                        element = document.createElement("input");
                        element.type = "text";
                        element.setAttribute("value", this.data.fieldValue);
                      }
                      element.disabled = this.data.readOnly;
                      if (this.data.maxLen !== null) {
                        element.maxLength = this.data.maxLen;
                      }
                      if (this.data.comb) {
                        var fieldWidth = this.data.rect[2] - this.data.rect[0];
                        var combWidth = fieldWidth / this.data.maxLen;
                        element.classList.add("comb");
                        element.style.letterSpacing = "calc(".concat(combWidth, "px - 1ch)");
                      }
                    } else {
                      element = document.createElement("div");
                      element.textContent = this.data.fieldValue;
                      element.style.verticalAlign = "middle";
                      element.style.display = "table-cell";
                      var font = null;
                      if (this.data.fontRefName && this.page.commonObjs.has(this.data.fontRefName)) {
                        font = this.page.commonObjs.get(this.data.fontRefName);
                      }
                      this._setTextStyle(element, font);
                    }
                    if (this.data.textAlignment !== null) {
                      element.style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];
                    }
                    this.container.appendChild(element);
                    return this.container;
                  } }, { key: "_setTextStyle", value: function _setTextStyle(element, font) {
                    var style = element.style;
                    style.fontSize = "".concat(this.data.fontSize, "px");
                    style.direction = this.data.fontDirection < 0 ? "rtl" : "ltr";
                    if (!font) {
                      return;
                    }
                    var bold = "normal";
                    if (font.black) {
                      bold = "900";
                    } else if (font.bold) {
                      bold = "bold";
                    }
                    style.fontWeight = bold;
                    style.fontStyle = font.italic ? "italic" : "normal";
                    var fontFamily = font.loadedName ? '"'.concat(font.loadedName, '", ') : "";
                    var fallbackName = font.fallbackName || "Helvetica, sans-serif";
                    style.fontFamily = fontFamily + fallbackName;
                  } }]);
                  return TextWidgetAnnotationElement2;
                }(WidgetAnnotationElement);
                var CheckboxWidgetAnnotationElement = function(_WidgetAnnotationElem2) {
                  _inherits(CheckboxWidgetAnnotationElement2, _WidgetAnnotationElem2);
                  function CheckboxWidgetAnnotationElement2(parameters) {
                    _classCallCheck2(this, CheckboxWidgetAnnotationElement2);
                    return _possibleConstructorReturn(this, _getPrototypeOf(CheckboxWidgetAnnotationElement2).call(this, parameters, parameters.renderInteractiveForms));
                  }
                  _createClass2(CheckboxWidgetAnnotationElement2, [{ key: "render", value: function render() {
                    this.container.className = "buttonWidgetAnnotation checkBox";
                    var element = document.createElement("input");
                    element.disabled = this.data.readOnly;
                    element.type = "checkbox";
                    if (this.data.fieldValue && this.data.fieldValue !== "Off") {
                      element.setAttribute("checked", true);
                    }
                    this.container.appendChild(element);
                    return this.container;
                  } }]);
                  return CheckboxWidgetAnnotationElement2;
                }(WidgetAnnotationElement);
                var RadioButtonWidgetAnnotationElement = function(_WidgetAnnotationElem3) {
                  _inherits(RadioButtonWidgetAnnotationElement2, _WidgetAnnotationElem3);
                  function RadioButtonWidgetAnnotationElement2(parameters) {
                    _classCallCheck2(this, RadioButtonWidgetAnnotationElement2);
                    return _possibleConstructorReturn(this, _getPrototypeOf(RadioButtonWidgetAnnotationElement2).call(this, parameters, parameters.renderInteractiveForms));
                  }
                  _createClass2(RadioButtonWidgetAnnotationElement2, [{ key: "render", value: function render() {
                    this.container.className = "buttonWidgetAnnotation radioButton";
                    var element = document.createElement("input");
                    element.disabled = this.data.readOnly;
                    element.type = "radio";
                    element.name = this.data.fieldName;
                    if (this.data.fieldValue === this.data.buttonValue) {
                      element.setAttribute("checked", true);
                    }
                    this.container.appendChild(element);
                    return this.container;
                  } }]);
                  return RadioButtonWidgetAnnotationElement2;
                }(WidgetAnnotationElement);
                var PushButtonWidgetAnnotationElement = function(_LinkAnnotationElemen) {
                  _inherits(PushButtonWidgetAnnotationElement2, _LinkAnnotationElemen);
                  function PushButtonWidgetAnnotationElement2() {
                    _classCallCheck2(this, PushButtonWidgetAnnotationElement2);
                    return _possibleConstructorReturn(this, _getPrototypeOf(PushButtonWidgetAnnotationElement2).apply(this, arguments));
                  }
                  _createClass2(PushButtonWidgetAnnotationElement2, [{ key: "render", value: function render() {
                    var container = _get(_getPrototypeOf(PushButtonWidgetAnnotationElement2.prototype), "render", this).call(this);
                    container.className = "buttonWidgetAnnotation pushButton";
                    return container;
                  } }]);
                  return PushButtonWidgetAnnotationElement2;
                }(LinkAnnotationElement);
                var ChoiceWidgetAnnotationElement = function(_WidgetAnnotationElem4) {
                  _inherits(ChoiceWidgetAnnotationElement2, _WidgetAnnotationElem4);
                  function ChoiceWidgetAnnotationElement2(parameters) {
                    _classCallCheck2(this, ChoiceWidgetAnnotationElement2);
                    return _possibleConstructorReturn(this, _getPrototypeOf(ChoiceWidgetAnnotationElement2).call(this, parameters, parameters.renderInteractiveForms));
                  }
                  _createClass2(ChoiceWidgetAnnotationElement2, [{ key: "render", value: function render() {
                    this.container.className = "choiceWidgetAnnotation";
                    var selectElement = document.createElement("select");
                    selectElement.disabled = this.data.readOnly;
                    if (!this.data.combo) {
                      selectElement.size = this.data.options.length;
                      if (this.data.multiSelect) {
                        selectElement.multiple = true;
                      }
                    }
                    var _iteratorNormalCompletion = true;
                    var _didIteratorError = false;
                    var _iteratorError = void 0;
                    try {
                      for (var _iterator = this.data.options[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var option = _step.value;
                        var optionElement = document.createElement("option");
                        optionElement.textContent = option.displayValue;
                        optionElement.value = option.exportValue;
                        if (this.data.fieldValue.includes(option.displayValue)) {
                          optionElement.setAttribute("selected", true);
                        }
                        selectElement.appendChild(optionElement);
                      }
                    } catch (err) {
                      _didIteratorError = true;
                      _iteratorError = err;
                    } finally {
                      try {
                        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                          _iterator["return"]();
                        }
                      } finally {
                        if (_didIteratorError) {
                          throw _iteratorError;
                        }
                      }
                    }
                    this.container.appendChild(selectElement);
                    return this.container;
                  } }]);
                  return ChoiceWidgetAnnotationElement2;
                }(WidgetAnnotationElement);
                var PopupAnnotationElement = function(_AnnotationElement4) {
                  _inherits(PopupAnnotationElement2, _AnnotationElement4);
                  function PopupAnnotationElement2(parameters) {
                    _classCallCheck2(this, PopupAnnotationElement2);
                    var isRenderable = !!(parameters.data.title || parameters.data.contents);
                    return _possibleConstructorReturn(this, _getPrototypeOf(PopupAnnotationElement2).call(this, parameters, isRenderable));
                  }
                  _createClass2(PopupAnnotationElement2, [{ key: "render", value: function render() {
                    var IGNORE_TYPES = ["Line", "Square", "Circle", "PolyLine", "Polygon", "Ink"];
                    this.container.className = "popupAnnotation";
                    if (IGNORE_TYPES.includes(this.data.parentType)) {
                      return this.container;
                    }
                    var selector = '[data-annotation-id="'.concat(this.data.parentId, '"]');
                    var parentElement = this.layer.querySelector(selector);
                    if (!parentElement) {
                      return this.container;
                    }
                    var popup = new PopupElement({ container: this.container, trigger: parentElement, color: this.data.color, title: this.data.title, modificationDate: this.data.modificationDate, contents: this.data.contents });
                    var parentLeft = parseFloat(parentElement.style.left);
                    var parentWidth = parseFloat(parentElement.style.width);
                    this.container.style.transformOrigin = "-".concat(parentLeft + parentWidth, "px -").concat(parentElement.style.top);
                    this.container.style.left = "".concat(parentLeft + parentWidth, "px");
                    this.container.appendChild(popup.render());
                    return this.container;
                  } }]);
                  return PopupAnnotationElement2;
                }(AnnotationElement);
                var PopupElement = function() {
                  function PopupElement2(parameters) {
                    _classCallCheck2(this, PopupElement2);
                    this.container = parameters.container;
                    this.trigger = parameters.trigger;
                    this.color = parameters.color;
                    this.title = parameters.title;
                    this.modificationDate = parameters.modificationDate;
                    this.contents = parameters.contents;
                    this.hideWrapper = parameters.hideWrapper || false;
                    this.pinned = false;
                  }
                  _createClass2(PopupElement2, [{ key: "render", value: function render() {
                    var BACKGROUND_ENLIGHT = 0.7;
                    var wrapper = document.createElement("div");
                    wrapper.className = "popupWrapper";
                    this.hideElement = this.hideWrapper ? wrapper : this.container;
                    this.hideElement.setAttribute("hidden", true);
                    var popup = document.createElement("div");
                    popup.className = "popup";
                    var color = this.color;
                    if (color) {
                      var r = BACKGROUND_ENLIGHT * (255 - color[0]) + color[0];
                      var g = BACKGROUND_ENLIGHT * (255 - color[1]) + color[1];
                      var b = BACKGROUND_ENLIGHT * (255 - color[2]) + color[2];
                      popup.style.backgroundColor = _util2.Util.makeCssRgb(r | 0, g | 0, b | 0);
                    }
                    var title = document.createElement("h1");
                    title.textContent = this.title;
                    popup.appendChild(title);
                    var dateObject = _display_utils2.PDFDateString.toDateObject(this.modificationDate);
                    if (dateObject) {
                      var modificationDate = document.createElement("span");
                      modificationDate.textContent = "{{date}}, {{time}}";
                      modificationDate.dataset.l10nId = "annotation_date_string";
                      modificationDate.dataset.l10nArgs = JSON.stringify({ date: dateObject.toLocaleDateString(), time: dateObject.toLocaleTimeString() });
                      popup.appendChild(modificationDate);
                    }
                    var contents = this._formatContents(this.contents);
                    popup.appendChild(contents);
                    this.trigger.addEventListener("click", this._toggle.bind(this));
                    this.trigger.addEventListener("mouseover", this._show.bind(this, false));
                    this.trigger.addEventListener("mouseout", this._hide.bind(this, false));
                    popup.addEventListener("click", this._hide.bind(this, true));
                    wrapper.appendChild(popup);
                    return wrapper;
                  } }, { key: "_formatContents", value: function _formatContents(contents) {
                    var p = document.createElement("p");
                    var lines = contents.split(/(?:\r\n?|\n)/);
                    for (var i = 0, ii = lines.length; i < ii; ++i) {
                      var line = lines[i];
                      p.appendChild(document.createTextNode(line));
                      if (i < ii - 1) {
                        p.appendChild(document.createElement("br"));
                      }
                    }
                    return p;
                  } }, { key: "_toggle", value: function _toggle() {
                    if (this.pinned) {
                      this._hide(true);
                    } else {
                      this._show(true);
                    }
                  } }, { key: "_show", value: function _show() {
                    var pin = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                    if (pin) {
                      this.pinned = true;
                    }
                    if (this.hideElement.hasAttribute("hidden")) {
                      this.hideElement.removeAttribute("hidden");
                      this.container.style.zIndex += 1;
                    }
                  } }, { key: "_hide", value: function _hide() {
                    var unpin = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
                    if (unpin) {
                      this.pinned = false;
                    }
                    if (!this.hideElement.hasAttribute("hidden") && !this.pinned) {
                      this.hideElement.setAttribute("hidden", true);
                      this.container.style.zIndex -= 1;
                    }
                  } }]);
                  return PopupElement2;
                }();
                var FreeTextAnnotationElement = function(_AnnotationElement5) {
                  _inherits(FreeTextAnnotationElement2, _AnnotationElement5);
                  function FreeTextAnnotationElement2(parameters) {
                    _classCallCheck2(this, FreeTextAnnotationElement2);
                    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                    return _possibleConstructorReturn(this, _getPrototypeOf(FreeTextAnnotationElement2).call(this, parameters, isRenderable, true));
                  }
                  _createClass2(FreeTextAnnotationElement2, [{ key: "render", value: function render() {
                    this.container.className = "freeTextAnnotation";
                    if (!this.data.hasPopup) {
                      this._createPopup(this.container, null, this.data);
                    }
                    return this.container;
                  } }]);
                  return FreeTextAnnotationElement2;
                }(AnnotationElement);
                var LineAnnotationElement = function(_AnnotationElement6) {
                  _inherits(LineAnnotationElement2, _AnnotationElement6);
                  function LineAnnotationElement2(parameters) {
                    _classCallCheck2(this, LineAnnotationElement2);
                    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                    return _possibleConstructorReturn(this, _getPrototypeOf(LineAnnotationElement2).call(this, parameters, isRenderable, true));
                  }
                  _createClass2(LineAnnotationElement2, [{ key: "render", value: function render() {
                    this.container.className = "lineAnnotation";
                    var data = this.data;
                    var width = data.rect[2] - data.rect[0];
                    var height = data.rect[3] - data.rect[1];
                    var svg = this.svgFactory.create(width, height);
                    var line = this.svgFactory.createElement("svg:line");
                    line.setAttribute("x1", data.rect[2] - data.lineCoordinates[0]);
                    line.setAttribute("y1", data.rect[3] - data.lineCoordinates[1]);
                    line.setAttribute("x2", data.rect[2] - data.lineCoordinates[2]);
                    line.setAttribute("y2", data.rect[3] - data.lineCoordinates[3]);
                    line.setAttribute("stroke-width", data.borderStyle.width || 1);
                    line.setAttribute("stroke", "transparent");
                    svg.appendChild(line);
                    this.container.append(svg);
                    this._createPopup(this.container, line, data);
                    return this.container;
                  } }]);
                  return LineAnnotationElement2;
                }(AnnotationElement);
                var SquareAnnotationElement = function(_AnnotationElement7) {
                  _inherits(SquareAnnotationElement2, _AnnotationElement7);
                  function SquareAnnotationElement2(parameters) {
                    _classCallCheck2(this, SquareAnnotationElement2);
                    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                    return _possibleConstructorReturn(this, _getPrototypeOf(SquareAnnotationElement2).call(this, parameters, isRenderable, true));
                  }
                  _createClass2(SquareAnnotationElement2, [{ key: "render", value: function render() {
                    this.container.className = "squareAnnotation";
                    var data = this.data;
                    var width = data.rect[2] - data.rect[0];
                    var height = data.rect[3] - data.rect[1];
                    var svg = this.svgFactory.create(width, height);
                    var borderWidth = data.borderStyle.width;
                    var square = this.svgFactory.createElement("svg:rect");
                    square.setAttribute("x", borderWidth / 2);
                    square.setAttribute("y", borderWidth / 2);
                    square.setAttribute("width", width - borderWidth);
                    square.setAttribute("height", height - borderWidth);
                    square.setAttribute("stroke-width", borderWidth || 1);
                    square.setAttribute("stroke", "transparent");
                    square.setAttribute("fill", "none");
                    svg.appendChild(square);
                    this.container.append(svg);
                    this._createPopup(this.container, square, data);
                    return this.container;
                  } }]);
                  return SquareAnnotationElement2;
                }(AnnotationElement);
                var CircleAnnotationElement = function(_AnnotationElement8) {
                  _inherits(CircleAnnotationElement2, _AnnotationElement8);
                  function CircleAnnotationElement2(parameters) {
                    _classCallCheck2(this, CircleAnnotationElement2);
                    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                    return _possibleConstructorReturn(this, _getPrototypeOf(CircleAnnotationElement2).call(this, parameters, isRenderable, true));
                  }
                  _createClass2(CircleAnnotationElement2, [{ key: "render", value: function render() {
                    this.container.className = "circleAnnotation";
                    var data = this.data;
                    var width = data.rect[2] - data.rect[0];
                    var height = data.rect[3] - data.rect[1];
                    var svg = this.svgFactory.create(width, height);
                    var borderWidth = data.borderStyle.width;
                    var circle = this.svgFactory.createElement("svg:ellipse");
                    circle.setAttribute("cx", width / 2);
                    circle.setAttribute("cy", height / 2);
                    circle.setAttribute("rx", width / 2 - borderWidth / 2);
                    circle.setAttribute("ry", height / 2 - borderWidth / 2);
                    circle.setAttribute("stroke-width", borderWidth || 1);
                    circle.setAttribute("stroke", "transparent");
                    circle.setAttribute("fill", "none");
                    svg.appendChild(circle);
                    this.container.append(svg);
                    this._createPopup(this.container, circle, data);
                    return this.container;
                  } }]);
                  return CircleAnnotationElement2;
                }(AnnotationElement);
                var PolylineAnnotationElement = function(_AnnotationElement9) {
                  _inherits(PolylineAnnotationElement2, _AnnotationElement9);
                  function PolylineAnnotationElement2(parameters) {
                    var _this3;
                    _classCallCheck2(this, PolylineAnnotationElement2);
                    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(PolylineAnnotationElement2).call(this, parameters, isRenderable, true));
                    _this3.containerClassName = "polylineAnnotation";
                    _this3.svgElementName = "svg:polyline";
                    return _this3;
                  }
                  _createClass2(PolylineAnnotationElement2, [{ key: "render", value: function render() {
                    this.container.className = this.containerClassName;
                    var data = this.data;
                    var width = data.rect[2] - data.rect[0];
                    var height = data.rect[3] - data.rect[1];
                    var svg = this.svgFactory.create(width, height);
                    var points = [];
                    var _iteratorNormalCompletion2 = true;
                    var _didIteratorError2 = false;
                    var _iteratorError2 = void 0;
                    try {
                      for (var _iterator2 = data.vertices[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                        var coordinate = _step2.value;
                        var x = coordinate.x - data.rect[0];
                        var y = data.rect[3] - coordinate.y;
                        points.push(x + "," + y);
                      }
                    } catch (err) {
                      _didIteratorError2 = true;
                      _iteratorError2 = err;
                    } finally {
                      try {
                        if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                          _iterator2["return"]();
                        }
                      } finally {
                        if (_didIteratorError2) {
                          throw _iteratorError2;
                        }
                      }
                    }
                    points = points.join(" ");
                    var polyline = this.svgFactory.createElement(this.svgElementName);
                    polyline.setAttribute("points", points);
                    polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
                    polyline.setAttribute("stroke", "transparent");
                    polyline.setAttribute("fill", "none");
                    svg.appendChild(polyline);
                    this.container.append(svg);
                    this._createPopup(this.container, polyline, data);
                    return this.container;
                  } }]);
                  return PolylineAnnotationElement2;
                }(AnnotationElement);
                var PolygonAnnotationElement = function(_PolylineAnnotationEl) {
                  _inherits(PolygonAnnotationElement2, _PolylineAnnotationEl);
                  function PolygonAnnotationElement2(parameters) {
                    var _this4;
                    _classCallCheck2(this, PolygonAnnotationElement2);
                    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(PolygonAnnotationElement2).call(this, parameters));
                    _this4.containerClassName = "polygonAnnotation";
                    _this4.svgElementName = "svg:polygon";
                    return _this4;
                  }
                  return PolygonAnnotationElement2;
                }(PolylineAnnotationElement);
                var CaretAnnotationElement = function(_AnnotationElement10) {
                  _inherits(CaretAnnotationElement2, _AnnotationElement10);
                  function CaretAnnotationElement2(parameters) {
                    _classCallCheck2(this, CaretAnnotationElement2);
                    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                    return _possibleConstructorReturn(this, _getPrototypeOf(CaretAnnotationElement2).call(this, parameters, isRenderable, true));
                  }
                  _createClass2(CaretAnnotationElement2, [{ key: "render", value: function render() {
                    this.container.className = "caretAnnotation";
                    if (!this.data.hasPopup) {
                      this._createPopup(this.container, null, this.data);
                    }
                    return this.container;
                  } }]);
                  return CaretAnnotationElement2;
                }(AnnotationElement);
                var InkAnnotationElement = function(_AnnotationElement11) {
                  _inherits(InkAnnotationElement2, _AnnotationElement11);
                  function InkAnnotationElement2(parameters) {
                    var _this5;
                    _classCallCheck2(this, InkAnnotationElement2);
                    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                    _this5 = _possibleConstructorReturn(this, _getPrototypeOf(InkAnnotationElement2).call(this, parameters, isRenderable, true));
                    _this5.containerClassName = "inkAnnotation";
                    _this5.svgElementName = "svg:polyline";
                    return _this5;
                  }
                  _createClass2(InkAnnotationElement2, [{ key: "render", value: function render() {
                    this.container.className = this.containerClassName;
                    var data = this.data;
                    var width = data.rect[2] - data.rect[0];
                    var height = data.rect[3] - data.rect[1];
                    var svg = this.svgFactory.create(width, height);
                    var _iteratorNormalCompletion3 = true;
                    var _didIteratorError3 = false;
                    var _iteratorError3 = void 0;
                    try {
                      for (var _iterator3 = data.inkLists[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                        var inkList = _step3.value;
                        var points = [];
                        var _iteratorNormalCompletion4 = true;
                        var _didIteratorError4 = false;
                        var _iteratorError4 = void 0;
                        try {
                          for (var _iterator4 = inkList[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                            var coordinate = _step4.value;
                            var x = coordinate.x - data.rect[0];
                            var y = data.rect[3] - coordinate.y;
                            points.push("".concat(x, ",").concat(y));
                          }
                        } catch (err) {
                          _didIteratorError4 = true;
                          _iteratorError4 = err;
                        } finally {
                          try {
                            if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
                              _iterator4["return"]();
                            }
                          } finally {
                            if (_didIteratorError4) {
                              throw _iteratorError4;
                            }
                          }
                        }
                        points = points.join(" ");
                        var polyline = this.svgFactory.createElement(this.svgElementName);
                        polyline.setAttribute("points", points);
                        polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
                        polyline.setAttribute("stroke", "transparent");
                        polyline.setAttribute("fill", "none");
                        this._createPopup(this.container, polyline, data);
                        svg.appendChild(polyline);
                      }
                    } catch (err) {
                      _didIteratorError3 = true;
                      _iteratorError3 = err;
                    } finally {
                      try {
                        if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                          _iterator3["return"]();
                        }
                      } finally {
                        if (_didIteratorError3) {
                          throw _iteratorError3;
                        }
                      }
                    }
                    this.container.append(svg);
                    return this.container;
                  } }]);
                  return InkAnnotationElement2;
                }(AnnotationElement);
                var HighlightAnnotationElement = function(_AnnotationElement12) {
                  _inherits(HighlightAnnotationElement2, _AnnotationElement12);
                  function HighlightAnnotationElement2(parameters) {
                    _classCallCheck2(this, HighlightAnnotationElement2);
                    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                    return _possibleConstructorReturn(this, _getPrototypeOf(HighlightAnnotationElement2).call(this, parameters, isRenderable, true));
                  }
                  _createClass2(HighlightAnnotationElement2, [{ key: "render", value: function render() {
                    this.container.className = "highlightAnnotation";
                    if (!this.data.hasPopup) {
                      this._createPopup(this.container, null, this.data);
                    }
                    return this.container;
                  } }]);
                  return HighlightAnnotationElement2;
                }(AnnotationElement);
                var UnderlineAnnotationElement = function(_AnnotationElement13) {
                  _inherits(UnderlineAnnotationElement2, _AnnotationElement13);
                  function UnderlineAnnotationElement2(parameters) {
                    _classCallCheck2(this, UnderlineAnnotationElement2);
                    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                    return _possibleConstructorReturn(this, _getPrototypeOf(UnderlineAnnotationElement2).call(this, parameters, isRenderable, true));
                  }
                  _createClass2(UnderlineAnnotationElement2, [{ key: "render", value: function render() {
                    this.container.className = "underlineAnnotation";
                    if (!this.data.hasPopup) {
                      this._createPopup(this.container, null, this.data);
                    }
                    return this.container;
                  } }]);
                  return UnderlineAnnotationElement2;
                }(AnnotationElement);
                var SquigglyAnnotationElement = function(_AnnotationElement14) {
                  _inherits(SquigglyAnnotationElement2, _AnnotationElement14);
                  function SquigglyAnnotationElement2(parameters) {
                    _classCallCheck2(this, SquigglyAnnotationElement2);
                    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                    return _possibleConstructorReturn(this, _getPrototypeOf(SquigglyAnnotationElement2).call(this, parameters, isRenderable, true));
                  }
                  _createClass2(SquigglyAnnotationElement2, [{ key: "render", value: function render() {
                    this.container.className = "squigglyAnnotation";
                    if (!this.data.hasPopup) {
                      this._createPopup(this.container, null, this.data);
                    }
                    return this.container;
                  } }]);
                  return SquigglyAnnotationElement2;
                }(AnnotationElement);
                var StrikeOutAnnotationElement = function(_AnnotationElement15) {
                  _inherits(StrikeOutAnnotationElement2, _AnnotationElement15);
                  function StrikeOutAnnotationElement2(parameters) {
                    _classCallCheck2(this, StrikeOutAnnotationElement2);
                    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                    return _possibleConstructorReturn(this, _getPrototypeOf(StrikeOutAnnotationElement2).call(this, parameters, isRenderable, true));
                  }
                  _createClass2(StrikeOutAnnotationElement2, [{ key: "render", value: function render() {
                    this.container.className = "strikeoutAnnotation";
                    if (!this.data.hasPopup) {
                      this._createPopup(this.container, null, this.data);
                    }
                    return this.container;
                  } }]);
                  return StrikeOutAnnotationElement2;
                }(AnnotationElement);
                var StampAnnotationElement = function(_AnnotationElement16) {
                  _inherits(StampAnnotationElement2, _AnnotationElement16);
                  function StampAnnotationElement2(parameters) {
                    _classCallCheck2(this, StampAnnotationElement2);
                    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                    return _possibleConstructorReturn(this, _getPrototypeOf(StampAnnotationElement2).call(this, parameters, isRenderable, true));
                  }
                  _createClass2(StampAnnotationElement2, [{ key: "render", value: function render() {
                    this.container.className = "stampAnnotation";
                    if (!this.data.hasPopup) {
                      this._createPopup(this.container, null, this.data);
                    }
                    return this.container;
                  } }]);
                  return StampAnnotationElement2;
                }(AnnotationElement);
                var FileAttachmentAnnotationElement = function(_AnnotationElement17) {
                  _inherits(FileAttachmentAnnotationElement2, _AnnotationElement17);
                  function FileAttachmentAnnotationElement2(parameters) {
                    var _this6;
                    _classCallCheck2(this, FileAttachmentAnnotationElement2);
                    _this6 = _possibleConstructorReturn(this, _getPrototypeOf(FileAttachmentAnnotationElement2).call(this, parameters, true));
                    var _this6$data$file = _this6.data.file, filename = _this6$data$file.filename, content = _this6$data$file.content;
                    _this6.filename = (0, _display_utils2.getFilenameFromUrl)(filename);
                    _this6.content = content;
                    if (_this6.linkService.eventBus) {
                      _this6.linkService.eventBus.dispatch("fileattachmentannotation", { source: _assertThisInitialized(_this6), id: (0, _util2.stringToPDFString)(filename), filename, content });
                    }
                    return _this6;
                  }
                  _createClass2(FileAttachmentAnnotationElement2, [{ key: "render", value: function render() {
                    this.container.className = "fileAttachmentAnnotation";
                    var trigger = document.createElement("div");
                    trigger.style.height = this.container.style.height;
                    trigger.style.width = this.container.style.width;
                    trigger.addEventListener("dblclick", this._download.bind(this));
                    if (!this.data.hasPopup && (this.data.title || this.data.contents)) {
                      this._createPopup(this.container, trigger, this.data);
                    }
                    this.container.appendChild(trigger);
                    return this.container;
                  } }, { key: "_download", value: function _download() {
                    if (!this.downloadManager) {
                      (0, _util2.warn)("Download cannot be started due to unavailable download manager");
                      return;
                    }
                    this.downloadManager.downloadData(this.content, this.filename, "");
                  } }]);
                  return FileAttachmentAnnotationElement2;
                }(AnnotationElement);
                var AnnotationLayer = function() {
                  function AnnotationLayer2() {
                    _classCallCheck2(this, AnnotationLayer2);
                  }
                  _createClass2(AnnotationLayer2, null, [{ key: "render", value: function render(parameters) {
                    var sortedAnnotations = [], popupAnnotations = [];
                    var _iteratorNormalCompletion5 = true;
                    var _didIteratorError5 = false;
                    var _iteratorError5 = void 0;
                    try {
                      for (var _iterator5 = parameters.annotations[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                        var data = _step5.value;
                        if (!data) {
                          continue;
                        }
                        if (data.annotationType === _util2.AnnotationType.POPUP) {
                          popupAnnotations.push(data);
                          continue;
                        }
                        sortedAnnotations.push(data);
                      }
                    } catch (err) {
                      _didIteratorError5 = true;
                      _iteratorError5 = err;
                    } finally {
                      try {
                        if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
                          _iterator5["return"]();
                        }
                      } finally {
                        if (_didIteratorError5) {
                          throw _iteratorError5;
                        }
                      }
                    }
                    if (popupAnnotations.length) {
                      sortedAnnotations.push.apply(sortedAnnotations, popupAnnotations);
                    }
                    for (var _i = 0, _sortedAnnotations = sortedAnnotations; _i < _sortedAnnotations.length; _i++) {
                      var _data = _sortedAnnotations[_i];
                      var element = AnnotationElementFactory.create({ data: _data, layer: parameters.div, page: parameters.page, viewport: parameters.viewport, linkService: parameters.linkService, downloadManager: parameters.downloadManager, imageResourcesPath: parameters.imageResourcesPath || "", renderInteractiveForms: parameters.renderInteractiveForms || false, svgFactory: new _display_utils2.DOMSVGFactory() });
                      if (element.isRenderable) {
                        parameters.div.appendChild(element.render());
                      }
                    }
                  } }, { key: "update", value: function update(parameters) {
                    var _iteratorNormalCompletion6 = true;
                    var _didIteratorError6 = false;
                    var _iteratorError6 = void 0;
                    try {
                      for (var _iterator6 = parameters.annotations[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                        var data = _step6.value;
                        var element = parameters.div.querySelector('[data-annotation-id="'.concat(data.id, '"]'));
                        if (element) {
                          element.style.transform = "matrix(".concat(parameters.viewport.transform.join(","), ")");
                        }
                      }
                    } catch (err) {
                      _didIteratorError6 = true;
                      _iteratorError6 = err;
                    } finally {
                      try {
                        if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
                          _iterator6["return"]();
                        }
                      } finally {
                        if (_didIteratorError6) {
                          throw _iteratorError6;
                        }
                      }
                    }
                    parameters.div.removeAttribute("hidden");
                  } }]);
                  return AnnotationLayer2;
                }();
                exports2.AnnotationLayer = AnnotationLayer;
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.SVGGraphics = void 0;
                var _util2 = __w_pdfjs_require__2(1);
                var _display_utils2 = __w_pdfjs_require__2(194);
                var _is_node2 = __w_pdfjs_require__2(48);
                function _toConsumableArray2(arr) {
                  return _arrayWithoutHoles2(arr) || _iterableToArray2(arr) || _nonIterableSpread2();
                }
                function _nonIterableSpread2() {
                  throw new TypeError("Invalid attempt to spread non-iterable instance");
                }
                function _iterableToArray2(iter) {
                  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]")
                    return Array.from(iter);
                }
                function _arrayWithoutHoles2(arr) {
                  if (Array.isArray(arr)) {
                    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
                      arr2[i] = arr[i];
                    }
                    return arr2;
                  }
                }
                function _slicedToArray2(arr, i) {
                  return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i) || _nonIterableRest2();
                }
                function _nonIterableRest2() {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
                function _iterableToArrayLimit2(arr, i) {
                  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
                    return;
                  }
                  var _arr = [];
                  var _n = true;
                  var _d = false;
                  var _e = void 0;
                  try {
                    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                      _arr.push(_s.value);
                      if (i && _arr.length === i)
                        break;
                    }
                  } catch (err) {
                    _d = true;
                    _e = err;
                  } finally {
                    try {
                      if (!_n && _i["return"] != null)
                        _i["return"]();
                    } finally {
                      if (_d)
                        throw _e;
                    }
                  }
                  return _arr;
                }
                function _arrayWithHoles2(arr) {
                  if (Array.isArray(arr))
                    return arr;
                }
                function _classCallCheck2(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _defineProperties2(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                function _createClass2(Constructor, protoProps, staticProps) {
                  if (protoProps)
                    _defineProperties2(Constructor.prototype, protoProps);
                  if (staticProps)
                    _defineProperties2(Constructor, staticProps);
                  return Constructor;
                }
                var SVGGraphics = function SVGGraphics2() {
                  throw new Error("Not implemented: SVGGraphics");
                };
                exports2.SVGGraphics = SVGGraphics;
                {
                  var opListToTree = function opListToTree2(opList) {
                    var opTree = [];
                    var tmp = [];
                    var _iteratorNormalCompletion = true;
                    var _didIteratorError = false;
                    var _iteratorError = void 0;
                    try {
                      for (var _iterator = opList[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var opListElement = _step.value;
                        if (opListElement.fn === "save") {
                          opTree.push({ fnId: 92, fn: "group", items: [] });
                          tmp.push(opTree);
                          opTree = opTree[opTree.length - 1].items;
                          continue;
                        }
                        if (opListElement.fn === "restore") {
                          opTree = tmp.pop();
                        } else {
                          opTree.push(opListElement);
                        }
                      }
                    } catch (err) {
                      _didIteratorError = true;
                      _iteratorError = err;
                    } finally {
                      try {
                        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                          _iterator["return"]();
                        }
                      } finally {
                        if (_didIteratorError) {
                          throw _iteratorError;
                        }
                      }
                    }
                    return opTree;
                  };
                  var pf = function pf2(value) {
                    if (Number.isInteger(value)) {
                      return value.toString();
                    }
                    var s = value.toFixed(10);
                    var i = s.length - 1;
                    if (s[i] !== "0") {
                      return s;
                    }
                    do {
                      i--;
                    } while (s[i] === "0");
                    return s.substring(0, s[i] === "." ? i : i + 1);
                  };
                  var pm = function pm2(m) {
                    if (m[4] === 0 && m[5] === 0) {
                      if (m[1] === 0 && m[2] === 0) {
                        if (m[0] === 1 && m[3] === 1) {
                          return "";
                        }
                        return "scale(".concat(pf(m[0]), " ").concat(pf(m[3]), ")");
                      }
                      if (m[0] === m[3] && m[1] === -m[2]) {
                        var a = Math.acos(m[0]) * 180 / Math.PI;
                        return "rotate(".concat(pf(a), ")");
                      }
                    } else {
                      if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1) {
                        return "translate(".concat(pf(m[4]), " ").concat(pf(m[5]), ")");
                      }
                    }
                    return "matrix(".concat(pf(m[0]), " ").concat(pf(m[1]), " ").concat(pf(m[2]), " ").concat(pf(m[3]), " ").concat(pf(m[4]), " ") + "".concat(pf(m[5]), ")");
                  };
                  var SVG_DEFAULTS = { fontStyle: "normal", fontWeight: "normal", fillColor: "#000000" };
                  var XML_NS = "http://www.w3.org/XML/1998/namespace";
                  var XLINK_NS = "http://www.w3.org/1999/xlink";
                  var LINE_CAP_STYLES = ["butt", "round", "square"];
                  var LINE_JOIN_STYLES = ["miter", "round", "bevel"];
                  var convertImgDataToPng = function() {
                    var PNG_HEADER = new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10]);
                    var CHUNK_WRAPPER_SIZE = 12;
                    var crcTable = new Int32Array(256);
                    for (var i = 0; i < 256; i++) {
                      var c = i;
                      for (var h = 0; h < 8; h++) {
                        if (c & 1) {
                          c = 3988292384 ^ c >> 1 & 2147483647;
                        } else {
                          c = c >> 1 & 2147483647;
                        }
                      }
                      crcTable[i] = c;
                    }
                    function crc32(data, start, end) {
                      var crc = -1;
                      for (var _i = start; _i < end; _i++) {
                        var a = (crc ^ data[_i]) & 255;
                        var b = crcTable[a];
                        crc = crc >>> 8 ^ b;
                      }
                      return crc ^ -1;
                    }
                    function writePngChunk(type, body, data, offset) {
                      var p = offset;
                      var len = body.length;
                      data[p] = len >> 24 & 255;
                      data[p + 1] = len >> 16 & 255;
                      data[p + 2] = len >> 8 & 255;
                      data[p + 3] = len & 255;
                      p += 4;
                      data[p] = type.charCodeAt(0) & 255;
                      data[p + 1] = type.charCodeAt(1) & 255;
                      data[p + 2] = type.charCodeAt(2) & 255;
                      data[p + 3] = type.charCodeAt(3) & 255;
                      p += 4;
                      data.set(body, p);
                      p += body.length;
                      var crc = crc32(data, offset + 4, p);
                      data[p] = crc >> 24 & 255;
                      data[p + 1] = crc >> 16 & 255;
                      data[p + 2] = crc >> 8 & 255;
                      data[p + 3] = crc & 255;
                    }
                    function adler32(data, start, end) {
                      var a = 1;
                      var b = 0;
                      for (var _i2 = start; _i2 < end; ++_i2) {
                        a = (a + (data[_i2] & 255)) % 65521;
                        b = (b + a) % 65521;
                      }
                      return b << 16 | a;
                    }
                    function deflateSync(literals) {
                      if (!_is_node2.isNodeJS) {
                        return deflateSyncUncompressed(literals);
                      }
                      try {
                        var input;
                        if (parseInt(process.versions.node) >= 8) {
                          input = literals;
                        } else {
                          input = Buffer.from(literals);
                        }
                        var output = __webpack_require__(6659).deflateSync(input, { level: 9 });
                        return output instanceof Uint8Array ? output : new Uint8Array(output);
                      } catch (e) {
                        (0, _util2.warn)("Not compressing PNG because zlib.deflateSync is unavailable: " + e);
                      }
                      return deflateSyncUncompressed(literals);
                    }
                    function deflateSyncUncompressed(literals) {
                      var len = literals.length;
                      var maxBlockLength = 65535;
                      var deflateBlocks = Math.ceil(len / maxBlockLength);
                      var idat = new Uint8Array(2 + len + deflateBlocks * 5 + 4);
                      var pi = 0;
                      idat[pi++] = 120;
                      idat[pi++] = 156;
                      var pos = 0;
                      while (len > maxBlockLength) {
                        idat[pi++] = 0;
                        idat[pi++] = 255;
                        idat[pi++] = 255;
                        idat[pi++] = 0;
                        idat[pi++] = 0;
                        idat.set(literals.subarray(pos, pos + maxBlockLength), pi);
                        pi += maxBlockLength;
                        pos += maxBlockLength;
                        len -= maxBlockLength;
                      }
                      idat[pi++] = 1;
                      idat[pi++] = len & 255;
                      idat[pi++] = len >> 8 & 255;
                      idat[pi++] = ~len & 65535 & 255;
                      idat[pi++] = (~len & 65535) >> 8 & 255;
                      idat.set(literals.subarray(pos), pi);
                      pi += literals.length - pos;
                      var adler = adler32(literals, 0, literals.length);
                      idat[pi++] = adler >> 24 & 255;
                      idat[pi++] = adler >> 16 & 255;
                      idat[pi++] = adler >> 8 & 255;
                      idat[pi++] = adler & 255;
                      return idat;
                    }
                    function encode(imgData, kind, forceDataSchema, isMask) {
                      var width = imgData.width;
                      var height = imgData.height;
                      var bitDepth, colorType, lineSize;
                      var bytes = imgData.data;
                      switch (kind) {
                        case _util2.ImageKind.GRAYSCALE_1BPP:
                          colorType = 0;
                          bitDepth = 1;
                          lineSize = width + 7 >> 3;
                          break;
                        case _util2.ImageKind.RGB_24BPP:
                          colorType = 2;
                          bitDepth = 8;
                          lineSize = width * 3;
                          break;
                        case _util2.ImageKind.RGBA_32BPP:
                          colorType = 6;
                          bitDepth = 8;
                          lineSize = width * 4;
                          break;
                        default:
                          throw new Error("invalid format");
                      }
                      var literals = new Uint8Array((1 + lineSize) * height);
                      var offsetLiterals = 0, offsetBytes = 0;
                      for (var y = 0; y < height; ++y) {
                        literals[offsetLiterals++] = 0;
                        literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize), offsetLiterals);
                        offsetBytes += lineSize;
                        offsetLiterals += lineSize;
                      }
                      if (kind === _util2.ImageKind.GRAYSCALE_1BPP && isMask) {
                        offsetLiterals = 0;
                        for (var _y = 0; _y < height; _y++) {
                          offsetLiterals++;
                          for (var _i3 = 0; _i3 < lineSize; _i3++) {
                            literals[offsetLiterals++] ^= 255;
                          }
                        }
                      }
                      var ihdr = new Uint8Array([width >> 24 & 255, width >> 16 & 255, width >> 8 & 255, width & 255, height >> 24 & 255, height >> 16 & 255, height >> 8 & 255, height & 255, bitDepth, colorType, 0, 0, 0]);
                      var idat = deflateSync(literals);
                      var pngLength = PNG_HEADER.length + CHUNK_WRAPPER_SIZE * 3 + ihdr.length + idat.length;
                      var data = new Uint8Array(pngLength);
                      var offset = 0;
                      data.set(PNG_HEADER, offset);
                      offset += PNG_HEADER.length;
                      writePngChunk("IHDR", ihdr, data, offset);
                      offset += CHUNK_WRAPPER_SIZE + ihdr.length;
                      writePngChunk("IDATA", idat, data, offset);
                      offset += CHUNK_WRAPPER_SIZE + idat.length;
                      writePngChunk("IEND", new Uint8Array(0), data, offset);
                      return (0, _util2.createObjectURL)(data, "image/png", forceDataSchema);
                    }
                    return function convertImgDataToPng2(imgData, forceDataSchema, isMask) {
                      var kind = imgData.kind === void 0 ? _util2.ImageKind.GRAYSCALE_1BPP : imgData.kind;
                      return encode(imgData, kind, forceDataSchema, isMask);
                    };
                  }();
                  var SVGExtraState = function() {
                    function SVGExtraState2() {
                      _classCallCheck2(this, SVGExtraState2);
                      this.fontSizeScale = 1;
                      this.fontWeight = SVG_DEFAULTS.fontWeight;
                      this.fontSize = 0;
                      this.textMatrix = _util2.IDENTITY_MATRIX;
                      this.fontMatrix = _util2.FONT_IDENTITY_MATRIX;
                      this.leading = 0;
                      this.textRenderingMode = _util2.TextRenderingMode.FILL;
                      this.textMatrixScale = 1;
                      this.x = 0;
                      this.y = 0;
                      this.lineX = 0;
                      this.lineY = 0;
                      this.charSpacing = 0;
                      this.wordSpacing = 0;
                      this.textHScale = 1;
                      this.textRise = 0;
                      this.fillColor = SVG_DEFAULTS.fillColor;
                      this.strokeColor = "#000000";
                      this.fillAlpha = 1;
                      this.strokeAlpha = 1;
                      this.lineWidth = 1;
                      this.lineJoin = "";
                      this.lineCap = "";
                      this.miterLimit = 0;
                      this.dashArray = [];
                      this.dashPhase = 0;
                      this.dependencies = [];
                      this.activeClipUrl = null;
                      this.clipGroup = null;
                      this.maskId = "";
                    }
                    _createClass2(SVGExtraState2, [{ key: "clone", value: function clone() {
                      return Object.create(this);
                    } }, { key: "setCurrentPoint", value: function setCurrentPoint(x, y) {
                      this.x = x;
                      this.y = y;
                    } }]);
                    return SVGExtraState2;
                  }();
                  var clipCount = 0;
                  var maskCount = 0;
                  var shadingCount = 0;
                  exports2.SVGGraphics = SVGGraphics = function() {
                    function SVGGraphics2(commonObjs, objs, forceDataSchema) {
                      _classCallCheck2(this, SVGGraphics2);
                      this.svgFactory = new _display_utils2.DOMSVGFactory();
                      this.current = new SVGExtraState();
                      this.transformMatrix = _util2.IDENTITY_MATRIX;
                      this.transformStack = [];
                      this.extraStack = [];
                      this.commonObjs = commonObjs;
                      this.objs = objs;
                      this.pendingClip = null;
                      this.pendingEOFill = false;
                      this.embedFonts = false;
                      this.embeddedFonts = /* @__PURE__ */ Object.create(null);
                      this.cssStyle = null;
                      this.forceDataSchema = !!forceDataSchema;
                      this._operatorIdMapping = [];
                      for (var op in _util2.OPS) {
                        this._operatorIdMapping[_util2.OPS[op]] = op;
                      }
                    }
                    _createClass2(SVGGraphics2, [{ key: "save", value: function save() {
                      this.transformStack.push(this.transformMatrix);
                      var old = this.current;
                      this.extraStack.push(old);
                      this.current = old.clone();
                    } }, { key: "restore", value: function restore() {
                      this.transformMatrix = this.transformStack.pop();
                      this.current = this.extraStack.pop();
                      this.pendingClip = null;
                      this.tgrp = null;
                    } }, { key: "group", value: function group(items) {
                      this.save();
                      this.executeOpTree(items);
                      this.restore();
                    } }, { key: "loadDependencies", value: function loadDependencies(operatorList) {
                      var _this = this;
                      var fnArray = operatorList.fnArray;
                      var argsArray = operatorList.argsArray;
                      for (var i = 0, ii = fnArray.length; i < ii; i++) {
                        if (fnArray[i] !== _util2.OPS.dependency) {
                          continue;
                        }
                        var _iteratorNormalCompletion2 = true;
                        var _didIteratorError2 = false;
                        var _iteratorError2 = void 0;
                        try {
                          var _loop = function _loop2() {
                            var obj = _step2.value;
                            var objsPool = obj.startsWith("g_") ? _this.commonObjs : _this.objs;
                            var promise = new Promise(function(resolve) {
                              objsPool.get(obj, resolve);
                            });
                            _this.current.dependencies.push(promise);
                          };
                          for (var _iterator2 = argsArray[i][Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                            _loop();
                          }
                        } catch (err) {
                          _didIteratorError2 = true;
                          _iteratorError2 = err;
                        } finally {
                          try {
                            if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                              _iterator2["return"]();
                            }
                          } finally {
                            if (_didIteratorError2) {
                              throw _iteratorError2;
                            }
                          }
                        }
                      }
                      return Promise.all(this.current.dependencies);
                    } }, { key: "transform", value: function transform(a, b, c, d, e, f) {
                      var transformMatrix = [a, b, c, d, e, f];
                      this.transformMatrix = _util2.Util.transform(this.transformMatrix, transformMatrix);
                      this.tgrp = null;
                    } }, { key: "getSVG", value: function getSVG(operatorList, viewport) {
                      var _this2 = this;
                      this.viewport = viewport;
                      var svgElement = this._initialize(viewport);
                      return this.loadDependencies(operatorList).then(function() {
                        _this2.transformMatrix = _util2.IDENTITY_MATRIX;
                        _this2.executeOpTree(_this2.convertOpList(operatorList));
                        return svgElement;
                      });
                    } }, { key: "convertOpList", value: function convertOpList(operatorList) {
                      var operatorIdMapping = this._operatorIdMapping;
                      var argsArray = operatorList.argsArray;
                      var fnArray = operatorList.fnArray;
                      var opList = [];
                      for (var i = 0, ii = fnArray.length; i < ii; i++) {
                        var fnId = fnArray[i];
                        opList.push({ fnId, fn: operatorIdMapping[fnId], args: argsArray[i] });
                      }
                      return opListToTree(opList);
                    } }, { key: "executeOpTree", value: function executeOpTree(opTree) {
                      var _iteratorNormalCompletion3 = true;
                      var _didIteratorError3 = false;
                      var _iteratorError3 = void 0;
                      try {
                        for (var _iterator3 = opTree[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                          var opTreeElement = _step3.value;
                          var fn = opTreeElement.fn;
                          var fnId = opTreeElement.fnId;
                          var args = opTreeElement.args;
                          switch (fnId | 0) {
                            case _util2.OPS.beginText:
                              this.beginText();
                              break;
                            case _util2.OPS.dependency:
                              break;
                            case _util2.OPS.setLeading:
                              this.setLeading(args);
                              break;
                            case _util2.OPS.setLeadingMoveText:
                              this.setLeadingMoveText(args[0], args[1]);
                              break;
                            case _util2.OPS.setFont:
                              this.setFont(args);
                              break;
                            case _util2.OPS.showText:
                              this.showText(args[0]);
                              break;
                            case _util2.OPS.showSpacedText:
                              this.showText(args[0]);
                              break;
                            case _util2.OPS.endText:
                              this.endText();
                              break;
                            case _util2.OPS.moveText:
                              this.moveText(args[0], args[1]);
                              break;
                            case _util2.OPS.setCharSpacing:
                              this.setCharSpacing(args[0]);
                              break;
                            case _util2.OPS.setWordSpacing:
                              this.setWordSpacing(args[0]);
                              break;
                            case _util2.OPS.setHScale:
                              this.setHScale(args[0]);
                              break;
                            case _util2.OPS.setTextMatrix:
                              this.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
                              break;
                            case _util2.OPS.setTextRise:
                              this.setTextRise(args[0]);
                              break;
                            case _util2.OPS.setTextRenderingMode:
                              this.setTextRenderingMode(args[0]);
                              break;
                            case _util2.OPS.setLineWidth:
                              this.setLineWidth(args[0]);
                              break;
                            case _util2.OPS.setLineJoin:
                              this.setLineJoin(args[0]);
                              break;
                            case _util2.OPS.setLineCap:
                              this.setLineCap(args[0]);
                              break;
                            case _util2.OPS.setMiterLimit:
                              this.setMiterLimit(args[0]);
                              break;
                            case _util2.OPS.setFillRGBColor:
                              this.setFillRGBColor(args[0], args[1], args[2]);
                              break;
                            case _util2.OPS.setStrokeRGBColor:
                              this.setStrokeRGBColor(args[0], args[1], args[2]);
                              break;
                            case _util2.OPS.setStrokeColorN:
                              this.setStrokeColorN(args);
                              break;
                            case _util2.OPS.setFillColorN:
                              this.setFillColorN(args);
                              break;
                            case _util2.OPS.shadingFill:
                              this.shadingFill(args[0]);
                              break;
                            case _util2.OPS.setDash:
                              this.setDash(args[0], args[1]);
                              break;
                            case _util2.OPS.setRenderingIntent:
                              this.setRenderingIntent(args[0]);
                              break;
                            case _util2.OPS.setFlatness:
                              this.setFlatness(args[0]);
                              break;
                            case _util2.OPS.setGState:
                              this.setGState(args[0]);
                              break;
                            case _util2.OPS.fill:
                              this.fill();
                              break;
                            case _util2.OPS.eoFill:
                              this.eoFill();
                              break;
                            case _util2.OPS.stroke:
                              this.stroke();
                              break;
                            case _util2.OPS.fillStroke:
                              this.fillStroke();
                              break;
                            case _util2.OPS.eoFillStroke:
                              this.eoFillStroke();
                              break;
                            case _util2.OPS.clip:
                              this.clip("nonzero");
                              break;
                            case _util2.OPS.eoClip:
                              this.clip("evenodd");
                              break;
                            case _util2.OPS.paintSolidColorImageMask:
                              this.paintSolidColorImageMask();
                              break;
                            case _util2.OPS.paintJpegXObject:
                              this.paintJpegXObject(args[0], args[1], args[2]);
                              break;
                            case _util2.OPS.paintImageXObject:
                              this.paintImageXObject(args[0]);
                              break;
                            case _util2.OPS.paintInlineImageXObject:
                              this.paintInlineImageXObject(args[0]);
                              break;
                            case _util2.OPS.paintImageMaskXObject:
                              this.paintImageMaskXObject(args[0]);
                              break;
                            case _util2.OPS.paintFormXObjectBegin:
                              this.paintFormXObjectBegin(args[0], args[1]);
                              break;
                            case _util2.OPS.paintFormXObjectEnd:
                              this.paintFormXObjectEnd();
                              break;
                            case _util2.OPS.closePath:
                              this.closePath();
                              break;
                            case _util2.OPS.closeStroke:
                              this.closeStroke();
                              break;
                            case _util2.OPS.closeFillStroke:
                              this.closeFillStroke();
                              break;
                            case _util2.OPS.closeEOFillStroke:
                              this.closeEOFillStroke();
                              break;
                            case _util2.OPS.nextLine:
                              this.nextLine();
                              break;
                            case _util2.OPS.transform:
                              this.transform(args[0], args[1], args[2], args[3], args[4], args[5]);
                              break;
                            case _util2.OPS.constructPath:
                              this.constructPath(args[0], args[1]);
                              break;
                            case _util2.OPS.endPath:
                              this.endPath();
                              break;
                            case 92:
                              this.group(opTreeElement.items);
                              break;
                            default:
                              (0, _util2.warn)("Unimplemented operator ".concat(fn));
                              break;
                          }
                        }
                      } catch (err) {
                        _didIteratorError3 = true;
                        _iteratorError3 = err;
                      } finally {
                        try {
                          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                            _iterator3["return"]();
                          }
                        } finally {
                          if (_didIteratorError3) {
                            throw _iteratorError3;
                          }
                        }
                      }
                    } }, { key: "setWordSpacing", value: function setWordSpacing(wordSpacing) {
                      this.current.wordSpacing = wordSpacing;
                    } }, { key: "setCharSpacing", value: function setCharSpacing(charSpacing) {
                      this.current.charSpacing = charSpacing;
                    } }, { key: "nextLine", value: function nextLine() {
                      this.moveText(0, this.current.leading);
                    } }, { key: "setTextMatrix", value: function setTextMatrix(a, b, c, d, e, f) {
                      var current = this.current;
                      current.textMatrix = current.lineMatrix = [a, b, c, d, e, f];
                      current.textMatrixScale = Math.sqrt(a * a + b * b);
                      current.x = current.lineX = 0;
                      current.y = current.lineY = 0;
                      current.xcoords = [];
                      current.tspan = this.svgFactory.createElement("svg:tspan");
                      current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
                      current.tspan.setAttributeNS(null, "font-size", "".concat(pf(current.fontSize), "px"));
                      current.tspan.setAttributeNS(null, "y", pf(-current.y));
                      current.txtElement = this.svgFactory.createElement("svg:text");
                      current.txtElement.appendChild(current.tspan);
                    } }, { key: "beginText", value: function beginText() {
                      var current = this.current;
                      current.x = current.lineX = 0;
                      current.y = current.lineY = 0;
                      current.textMatrix = _util2.IDENTITY_MATRIX;
                      current.lineMatrix = _util2.IDENTITY_MATRIX;
                      current.textMatrixScale = 1;
                      current.tspan = this.svgFactory.createElement("svg:tspan");
                      current.txtElement = this.svgFactory.createElement("svg:text");
                      current.txtgrp = this.svgFactory.createElement("svg:g");
                      current.xcoords = [];
                    } }, { key: "moveText", value: function moveText(x, y) {
                      var current = this.current;
                      current.x = current.lineX += x;
                      current.y = current.lineY += y;
                      current.xcoords = [];
                      current.tspan = this.svgFactory.createElement("svg:tspan");
                      current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
                      current.tspan.setAttributeNS(null, "font-size", "".concat(pf(current.fontSize), "px"));
                      current.tspan.setAttributeNS(null, "y", pf(-current.y));
                    } }, { key: "showText", value: function showText(glyphs) {
                      var current = this.current;
                      var font = current.font;
                      var fontSize = current.fontSize;
                      if (fontSize === 0) {
                        return;
                      }
                      var charSpacing = current.charSpacing;
                      var wordSpacing = current.wordSpacing;
                      var fontDirection = current.fontDirection;
                      var textHScale = current.textHScale * fontDirection;
                      var vertical = font.vertical;
                      var widthAdvanceScale = fontSize * current.fontMatrix[0];
                      var x = 0;
                      var _iteratorNormalCompletion4 = true;
                      var _didIteratorError4 = false;
                      var _iteratorError4 = void 0;
                      try {
                        for (var _iterator4 = glyphs[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                          var glyph = _step4.value;
                          if (glyph === null) {
                            x += fontDirection * wordSpacing;
                            continue;
                          } else if ((0, _util2.isNum)(glyph)) {
                            x += -glyph * fontSize * 1e-3;
                            continue;
                          }
                          var width = glyph.width;
                          var character = glyph.fontChar;
                          var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                          var charWidth = width * widthAdvanceScale + spacing * fontDirection;
                          if (!glyph.isInFont && !font.missingFile) {
                            x += charWidth;
                            continue;
                          }
                          current.xcoords.push(current.x + x);
                          current.tspan.textContent += character;
                          x += charWidth;
                        }
                      } catch (err) {
                        _didIteratorError4 = true;
                        _iteratorError4 = err;
                      } finally {
                        try {
                          if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
                            _iterator4["return"]();
                          }
                        } finally {
                          if (_didIteratorError4) {
                            throw _iteratorError4;
                          }
                        }
                      }
                      if (vertical) {
                        current.y -= x * textHScale;
                      } else {
                        current.x += x * textHScale;
                      }
                      current.tspan.setAttributeNS(null, "x", current.xcoords.map(pf).join(" "));
                      current.tspan.setAttributeNS(null, "y", pf(-current.y));
                      current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
                      current.tspan.setAttributeNS(null, "font-size", "".concat(pf(current.fontSize), "px"));
                      if (current.fontStyle !== SVG_DEFAULTS.fontStyle) {
                        current.tspan.setAttributeNS(null, "font-style", current.fontStyle);
                      }
                      if (current.fontWeight !== SVG_DEFAULTS.fontWeight) {
                        current.tspan.setAttributeNS(null, "font-weight", current.fontWeight);
                      }
                      var fillStrokeMode = current.textRenderingMode & _util2.TextRenderingMode.FILL_STROKE_MASK;
                      if (fillStrokeMode === _util2.TextRenderingMode.FILL || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                        if (current.fillColor !== SVG_DEFAULTS.fillColor) {
                          current.tspan.setAttributeNS(null, "fill", current.fillColor);
                        }
                        if (current.fillAlpha < 1) {
                          current.tspan.setAttributeNS(null, "fill-opacity", current.fillAlpha);
                        }
                      } else if (current.textRenderingMode === _util2.TextRenderingMode.ADD_TO_PATH) {
                        current.tspan.setAttributeNS(null, "fill", "transparent");
                      } else {
                        current.tspan.setAttributeNS(null, "fill", "none");
                      }
                      if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                        var lineWidthScale = 1 / (current.textMatrixScale || 1);
                        this._setStrokeAttributes(current.tspan, lineWidthScale);
                      }
                      var textMatrix = current.textMatrix;
                      if (current.textRise !== 0) {
                        textMatrix = textMatrix.slice();
                        textMatrix[5] += current.textRise;
                      }
                      current.txtElement.setAttributeNS(null, "transform", "".concat(pm(textMatrix), " scale(").concat(pf(textHScale), ", -1)"));
                      current.txtElement.setAttributeNS(XML_NS, "xml:space", "preserve");
                      current.txtElement.appendChild(current.tspan);
                      current.txtgrp.appendChild(current.txtElement);
                      this._ensureTransformGroup().appendChild(current.txtElement);
                    } }, { key: "setLeadingMoveText", value: function setLeadingMoveText(x, y) {
                      this.setLeading(-y);
                      this.moveText(x, y);
                    } }, { key: "addFontStyle", value: function addFontStyle(fontObj) {
                      if (!this.cssStyle) {
                        this.cssStyle = this.svgFactory.createElement("svg:style");
                        this.cssStyle.setAttributeNS(null, "type", "text/css");
                        this.defs.appendChild(this.cssStyle);
                      }
                      var url = (0, _util2.createObjectURL)(fontObj.data, fontObj.mimetype, this.forceDataSchema);
                      this.cssStyle.textContent += '@font-face { font-family: "'.concat(fontObj.loadedName, '";') + " src: url(".concat(url, "); }\n");
                    } }, { key: "setFont", value: function setFont(details) {
                      var current = this.current;
                      var fontObj = this.commonObjs.get(details[0]);
                      var size = details[1];
                      current.font = fontObj;
                      if (this.embedFonts && fontObj.data && !this.embeddedFonts[fontObj.loadedName]) {
                        this.addFontStyle(fontObj);
                        this.embeddedFonts[fontObj.loadedName] = fontObj;
                      }
                      current.fontMatrix = fontObj.fontMatrix ? fontObj.fontMatrix : _util2.FONT_IDENTITY_MATRIX;
                      var bold = "normal";
                      if (fontObj.black) {
                        bold = "900";
                      } else if (fontObj.bold) {
                        bold = "bold";
                      }
                      var italic = fontObj.italic ? "italic" : "normal";
                      if (size < 0) {
                        size = -size;
                        current.fontDirection = -1;
                      } else {
                        current.fontDirection = 1;
                      }
                      current.fontSize = size;
                      current.fontFamily = fontObj.loadedName;
                      current.fontWeight = bold;
                      current.fontStyle = italic;
                      current.tspan = this.svgFactory.createElement("svg:tspan");
                      current.tspan.setAttributeNS(null, "y", pf(-current.y));
                      current.xcoords = [];
                    } }, { key: "endText", value: function endText() {
                      var current = this.current;
                      if (current.textRenderingMode & _util2.TextRenderingMode.ADD_TO_PATH_FLAG && current.txtElement && current.txtElement.hasChildNodes()) {
                        current.element = current.txtElement;
                        this.clip("nonzero");
                        this.endPath();
                      }
                    } }, { key: "setLineWidth", value: function setLineWidth(width) {
                      if (width > 0) {
                        this.current.lineWidth = width;
                      }
                    } }, { key: "setLineCap", value: function setLineCap(style) {
                      this.current.lineCap = LINE_CAP_STYLES[style];
                    } }, { key: "setLineJoin", value: function setLineJoin(style) {
                      this.current.lineJoin = LINE_JOIN_STYLES[style];
                    } }, { key: "setMiterLimit", value: function setMiterLimit(limit) {
                      this.current.miterLimit = limit;
                    } }, { key: "setStrokeAlpha", value: function setStrokeAlpha(strokeAlpha) {
                      this.current.strokeAlpha = strokeAlpha;
                    } }, { key: "setStrokeRGBColor", value: function setStrokeRGBColor(r, g, b) {
                      this.current.strokeColor = _util2.Util.makeCssRgb(r, g, b);
                    } }, { key: "setFillAlpha", value: function setFillAlpha(fillAlpha) {
                      this.current.fillAlpha = fillAlpha;
                    } }, { key: "setFillRGBColor", value: function setFillRGBColor(r, g, b) {
                      this.current.fillColor = _util2.Util.makeCssRgb(r, g, b);
                      this.current.tspan = this.svgFactory.createElement("svg:tspan");
                      this.current.xcoords = [];
                    } }, { key: "setStrokeColorN", value: function setStrokeColorN(args) {
                      this.current.strokeColor = this._makeColorN_Pattern(args);
                    } }, { key: "setFillColorN", value: function setFillColorN(args) {
                      this.current.fillColor = this._makeColorN_Pattern(args);
                    } }, { key: "shadingFill", value: function shadingFill(args) {
                      var width = this.viewport.width;
                      var height = this.viewport.height;
                      var inv = _util2.Util.inverseTransform(this.transformMatrix);
                      var bl = _util2.Util.applyTransform([0, 0], inv);
                      var br = _util2.Util.applyTransform([0, height], inv);
                      var ul = _util2.Util.applyTransform([width, 0], inv);
                      var ur = _util2.Util.applyTransform([width, height], inv);
                      var x0 = Math.min(bl[0], br[0], ul[0], ur[0]);
                      var y0 = Math.min(bl[1], br[1], ul[1], ur[1]);
                      var x1 = Math.max(bl[0], br[0], ul[0], ur[0]);
                      var y1 = Math.max(bl[1], br[1], ul[1], ur[1]);
                      var rect = this.svgFactory.createElement("svg:rect");
                      rect.setAttributeNS(null, "x", x0);
                      rect.setAttributeNS(null, "y", y0);
                      rect.setAttributeNS(null, "width", x1 - x0);
                      rect.setAttributeNS(null, "height", y1 - y0);
                      rect.setAttributeNS(null, "fill", this._makeShadingPattern(args));
                      this._ensureTransformGroup().appendChild(rect);
                    } }, { key: "_makeColorN_Pattern", value: function _makeColorN_Pattern(args) {
                      if (args[0] === "TilingPattern") {
                        return this._makeTilingPattern(args);
                      }
                      return this._makeShadingPattern(args);
                    } }, { key: "_makeTilingPattern", value: function _makeTilingPattern(args) {
                      var color = args[1];
                      var operatorList = args[2];
                      var matrix = args[3] || _util2.IDENTITY_MATRIX;
                      var _args$ = _slicedToArray2(args[4], 4), x0 = _args$[0], y0 = _args$[1], x1 = _args$[2], y1 = _args$[3];
                      var xstep = args[5];
                      var ystep = args[6];
                      var paintType = args[7];
                      var tilingId = "shading".concat(shadingCount++);
                      var _Util$applyTransform = _util2.Util.applyTransform([x0, y0], matrix), _Util$applyTransform2 = _slicedToArray2(_Util$applyTransform, 2), tx0 = _Util$applyTransform2[0], ty0 = _Util$applyTransform2[1];
                      var _Util$applyTransform3 = _util2.Util.applyTransform([x1, y1], matrix), _Util$applyTransform4 = _slicedToArray2(_Util$applyTransform3, 2), tx1 = _Util$applyTransform4[0], ty1 = _Util$applyTransform4[1];
                      var _Util$singularValueDe = _util2.Util.singularValueDecompose2dScale(matrix), _Util$singularValueDe2 = _slicedToArray2(_Util$singularValueDe, 2), xscale = _Util$singularValueDe2[0], yscale = _Util$singularValueDe2[1];
                      var txstep = xstep * xscale;
                      var tystep = ystep * yscale;
                      var tiling = this.svgFactory.createElement("svg:pattern");
                      tiling.setAttributeNS(null, "id", tilingId);
                      tiling.setAttributeNS(null, "patternUnits", "userSpaceOnUse");
                      tiling.setAttributeNS(null, "width", txstep);
                      tiling.setAttributeNS(null, "height", tystep);
                      tiling.setAttributeNS(null, "x", "".concat(tx0));
                      tiling.setAttributeNS(null, "y", "".concat(ty0));
                      var svg = this.svg;
                      var transformMatrix = this.transformMatrix;
                      var fillColor = this.current.fillColor;
                      var strokeColor = this.current.strokeColor;
                      var bbox = this.svgFactory.create(tx1 - tx0, ty1 - ty0);
                      this.svg = bbox;
                      this.transformMatrix = matrix;
                      if (paintType === 2) {
                        var cssColor = _util2.Util.makeCssRgb.apply(_util2.Util, _toConsumableArray2(color));
                        this.current.fillColor = cssColor;
                        this.current.strokeColor = cssColor;
                      }
                      this.executeOpTree(this.convertOpList(operatorList));
                      this.svg = svg;
                      this.transformMatrix = transformMatrix;
                      this.current.fillColor = fillColor;
                      this.current.strokeColor = strokeColor;
                      tiling.appendChild(bbox.childNodes[0]);
                      this.defs.appendChild(tiling);
                      return "url(#".concat(tilingId, ")");
                    } }, { key: "_makeShadingPattern", value: function _makeShadingPattern(args) {
                      switch (args[0]) {
                        case "RadialAxial":
                          var shadingId = "shading".concat(shadingCount++);
                          var colorStops = args[3];
                          var gradient;
                          switch (args[1]) {
                            case "axial":
                              var point0 = args[4];
                              var point1 = args[5];
                              gradient = this.svgFactory.createElement("svg:linearGradient");
                              gradient.setAttributeNS(null, "id", shadingId);
                              gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
                              gradient.setAttributeNS(null, "x1", point0[0]);
                              gradient.setAttributeNS(null, "y1", point0[1]);
                              gradient.setAttributeNS(null, "x2", point1[0]);
                              gradient.setAttributeNS(null, "y2", point1[1]);
                              break;
                            case "radial":
                              var focalPoint = args[4];
                              var circlePoint = args[5];
                              var focalRadius = args[6];
                              var circleRadius = args[7];
                              gradient = this.svgFactory.createElement("svg:radialGradient");
                              gradient.setAttributeNS(null, "id", shadingId);
                              gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
                              gradient.setAttributeNS(null, "cx", circlePoint[0]);
                              gradient.setAttributeNS(null, "cy", circlePoint[1]);
                              gradient.setAttributeNS(null, "r", circleRadius);
                              gradient.setAttributeNS(null, "fx", focalPoint[0]);
                              gradient.setAttributeNS(null, "fy", focalPoint[1]);
                              gradient.setAttributeNS(null, "fr", focalRadius);
                              break;
                            default:
                              throw new Error("Unknown RadialAxial type: ".concat(args[1]));
                          }
                          var _iteratorNormalCompletion5 = true;
                          var _didIteratorError5 = false;
                          var _iteratorError5 = void 0;
                          try {
                            for (var _iterator5 = colorStops[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                              var colorStop = _step5.value;
                              var stop = this.svgFactory.createElement("svg:stop");
                              stop.setAttributeNS(null, "offset", colorStop[0]);
                              stop.setAttributeNS(null, "stop-color", colorStop[1]);
                              gradient.appendChild(stop);
                            }
                          } catch (err) {
                            _didIteratorError5 = true;
                            _iteratorError5 = err;
                          } finally {
                            try {
                              if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
                                _iterator5["return"]();
                              }
                            } finally {
                              if (_didIteratorError5) {
                                throw _iteratorError5;
                              }
                            }
                          }
                          this.defs.appendChild(gradient);
                          return "url(#".concat(shadingId, ")");
                        case "Mesh":
                          (0, _util2.warn)("Unimplemented pattern Mesh");
                          return null;
                        case "Dummy":
                          return "hotpink";
                        default:
                          throw new Error("Unknown IR type: ".concat(args[0]));
                      }
                    } }, { key: "setDash", value: function setDash(dashArray, dashPhase) {
                      this.current.dashArray = dashArray;
                      this.current.dashPhase = dashPhase;
                    } }, { key: "constructPath", value: function constructPath(ops, args) {
                      var current = this.current;
                      var x = current.x, y = current.y;
                      var d = [];
                      var j = 0;
                      var _iteratorNormalCompletion6 = true;
                      var _didIteratorError6 = false;
                      var _iteratorError6 = void 0;
                      try {
                        for (var _iterator6 = ops[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                          var op = _step6.value;
                          switch (op | 0) {
                            case _util2.OPS.rectangle:
                              x = args[j++];
                              y = args[j++];
                              var width = args[j++];
                              var height = args[j++];
                              var xw = x + width;
                              var yh = y + height;
                              d.push("M", pf(x), pf(y), "L", pf(xw), pf(y), "L", pf(xw), pf(yh), "L", pf(x), pf(yh), "Z");
                              break;
                            case _util2.OPS.moveTo:
                              x = args[j++];
                              y = args[j++];
                              d.push("M", pf(x), pf(y));
                              break;
                            case _util2.OPS.lineTo:
                              x = args[j++];
                              y = args[j++];
                              d.push("L", pf(x), pf(y));
                              break;
                            case _util2.OPS.curveTo:
                              x = args[j + 4];
                              y = args[j + 5];
                              d.push("C", pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]), pf(x), pf(y));
                              j += 6;
                              break;
                            case _util2.OPS.curveTo2:
                              d.push("C", pf(x), pf(y), pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]));
                              x = args[j + 2];
                              y = args[j + 3];
                              j += 4;
                              break;
                            case _util2.OPS.curveTo3:
                              x = args[j + 2];
                              y = args[j + 3];
                              d.push("C", pf(args[j]), pf(args[j + 1]), pf(x), pf(y), pf(x), pf(y));
                              j += 4;
                              break;
                            case _util2.OPS.closePath:
                              d.push("Z");
                              break;
                          }
                        }
                      } catch (err) {
                        _didIteratorError6 = true;
                        _iteratorError6 = err;
                      } finally {
                        try {
                          if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
                            _iterator6["return"]();
                          }
                        } finally {
                          if (_didIteratorError6) {
                            throw _iteratorError6;
                          }
                        }
                      }
                      d = d.join(" ");
                      if (current.path && ops.length > 0 && ops[0] !== _util2.OPS.rectangle && ops[0] !== _util2.OPS.moveTo) {
                        d = current.path.getAttributeNS(null, "d") + d;
                      } else {
                        current.path = this.svgFactory.createElement("svg:path");
                        this._ensureTransformGroup().appendChild(current.path);
                      }
                      current.path.setAttributeNS(null, "d", d);
                      current.path.setAttributeNS(null, "fill", "none");
                      current.element = current.path;
                      current.setCurrentPoint(x, y);
                    } }, { key: "endPath", value: function endPath() {
                      var current = this.current;
                      current.path = null;
                      if (!this.pendingClip) {
                        return;
                      }
                      if (!current.element) {
                        this.pendingClip = null;
                        return;
                      }
                      var clipId = "clippath".concat(clipCount++);
                      var clipPath = this.svgFactory.createElement("svg:clipPath");
                      clipPath.setAttributeNS(null, "id", clipId);
                      clipPath.setAttributeNS(null, "transform", pm(this.transformMatrix));
                      var clipElement = current.element.cloneNode(true);
                      if (this.pendingClip === "evenodd") {
                        clipElement.setAttributeNS(null, "clip-rule", "evenodd");
                      } else {
                        clipElement.setAttributeNS(null, "clip-rule", "nonzero");
                      }
                      this.pendingClip = null;
                      clipPath.appendChild(clipElement);
                      this.defs.appendChild(clipPath);
                      if (current.activeClipUrl) {
                        current.clipGroup = null;
                        this.extraStack.forEach(function(prev) {
                          prev.clipGroup = null;
                        });
                        clipPath.setAttributeNS(null, "clip-path", current.activeClipUrl);
                      }
                      current.activeClipUrl = "url(#".concat(clipId, ")");
                      this.tgrp = null;
                    } }, { key: "clip", value: function clip(type) {
                      this.pendingClip = type;
                    } }, { key: "closePath", value: function closePath() {
                      var current = this.current;
                      if (current.path) {
                        var d = "".concat(current.path.getAttributeNS(null, "d"), "Z");
                        current.path.setAttributeNS(null, "d", d);
                      }
                    } }, { key: "setLeading", value: function setLeading(leading) {
                      this.current.leading = -leading;
                    } }, { key: "setTextRise", value: function setTextRise(textRise) {
                      this.current.textRise = textRise;
                    } }, { key: "setTextRenderingMode", value: function setTextRenderingMode(textRenderingMode) {
                      this.current.textRenderingMode = textRenderingMode;
                    } }, { key: "setHScale", value: function setHScale(scale) {
                      this.current.textHScale = scale / 100;
                    } }, { key: "setRenderingIntent", value: function setRenderingIntent(intent) {
                    } }, { key: "setFlatness", value: function setFlatness(flatness) {
                    } }, { key: "setGState", value: function setGState(states) {
                      var _iteratorNormalCompletion7 = true;
                      var _didIteratorError7 = false;
                      var _iteratorError7 = void 0;
                      try {
                        for (var _iterator7 = states[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                          var _step7$value = _slicedToArray2(_step7.value, 2), key = _step7$value[0], value = _step7$value[1];
                          switch (key) {
                            case "LW":
                              this.setLineWidth(value);
                              break;
                            case "LC":
                              this.setLineCap(value);
                              break;
                            case "LJ":
                              this.setLineJoin(value);
                              break;
                            case "ML":
                              this.setMiterLimit(value);
                              break;
                            case "D":
                              this.setDash(value[0], value[1]);
                              break;
                            case "RI":
                              this.setRenderingIntent(value);
                              break;
                            case "FL":
                              this.setFlatness(value);
                              break;
                            case "Font":
                              this.setFont(value);
                              break;
                            case "CA":
                              this.setStrokeAlpha(value);
                              break;
                            case "ca":
                              this.setFillAlpha(value);
                              break;
                            default:
                              (0, _util2.warn)("Unimplemented graphic state operator ".concat(key));
                              break;
                          }
                        }
                      } catch (err) {
                        _didIteratorError7 = true;
                        _iteratorError7 = err;
                      } finally {
                        try {
                          if (!_iteratorNormalCompletion7 && _iterator7["return"] != null) {
                            _iterator7["return"]();
                          }
                        } finally {
                          if (_didIteratorError7) {
                            throw _iteratorError7;
                          }
                        }
                      }
                    } }, { key: "fill", value: function fill() {
                      var current = this.current;
                      if (current.element) {
                        current.element.setAttributeNS(null, "fill", current.fillColor);
                        current.element.setAttributeNS(null, "fill-opacity", current.fillAlpha);
                        this.endPath();
                      }
                    } }, { key: "stroke", value: function stroke() {
                      var current = this.current;
                      if (current.element) {
                        this._setStrokeAttributes(current.element);
                        current.element.setAttributeNS(null, "fill", "none");
                        this.endPath();
                      }
                    } }, { key: "_setStrokeAttributes", value: function _setStrokeAttributes(element) {
                      var lineWidthScale = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
                      var current = this.current;
                      var dashArray = current.dashArray;
                      if (lineWidthScale !== 1 && dashArray.length > 0) {
                        dashArray = dashArray.map(function(value) {
                          return lineWidthScale * value;
                        });
                      }
                      element.setAttributeNS(null, "stroke", current.strokeColor);
                      element.setAttributeNS(null, "stroke-opacity", current.strokeAlpha);
                      element.setAttributeNS(null, "stroke-miterlimit", pf(current.miterLimit));
                      element.setAttributeNS(null, "stroke-linecap", current.lineCap);
                      element.setAttributeNS(null, "stroke-linejoin", current.lineJoin);
                      element.setAttributeNS(null, "stroke-width", pf(lineWidthScale * current.lineWidth) + "px");
                      element.setAttributeNS(null, "stroke-dasharray", dashArray.map(pf).join(" "));
                      element.setAttributeNS(null, "stroke-dashoffset", pf(lineWidthScale * current.dashPhase) + "px");
                    } }, { key: "eoFill", value: function eoFill() {
                      if (this.current.element) {
                        this.current.element.setAttributeNS(null, "fill-rule", "evenodd");
                      }
                      this.fill();
                    } }, { key: "fillStroke", value: function fillStroke() {
                      this.stroke();
                      this.fill();
                    } }, { key: "eoFillStroke", value: function eoFillStroke() {
                      if (this.current.element) {
                        this.current.element.setAttributeNS(null, "fill-rule", "evenodd");
                      }
                      this.fillStroke();
                    } }, { key: "closeStroke", value: function closeStroke() {
                      this.closePath();
                      this.stroke();
                    } }, { key: "closeFillStroke", value: function closeFillStroke() {
                      this.closePath();
                      this.fillStroke();
                    } }, { key: "closeEOFillStroke", value: function closeEOFillStroke() {
                      this.closePath();
                      this.eoFillStroke();
                    } }, { key: "paintSolidColorImageMask", value: function paintSolidColorImageMask() {
                      var rect = this.svgFactory.createElement("svg:rect");
                      rect.setAttributeNS(null, "x", "0");
                      rect.setAttributeNS(null, "y", "0");
                      rect.setAttributeNS(null, "width", "1px");
                      rect.setAttributeNS(null, "height", "1px");
                      rect.setAttributeNS(null, "fill", this.current.fillColor);
                      this._ensureTransformGroup().appendChild(rect);
                    } }, { key: "paintJpegXObject", value: function paintJpegXObject(objId, w, h) {
                      var imgObj = this.objs.get(objId);
                      var imgEl = this.svgFactory.createElement("svg:image");
                      imgEl.setAttributeNS(XLINK_NS, "xlink:href", imgObj.src);
                      imgEl.setAttributeNS(null, "width", pf(w));
                      imgEl.setAttributeNS(null, "height", pf(h));
                      imgEl.setAttributeNS(null, "x", "0");
                      imgEl.setAttributeNS(null, "y", pf(-h));
                      imgEl.setAttributeNS(null, "transform", "scale(".concat(pf(1 / w), " ").concat(pf(-1 / h), ")"));
                      this._ensureTransformGroup().appendChild(imgEl);
                    } }, { key: "paintImageXObject", value: function paintImageXObject(objId) {
                      var imgData = this.objs.get(objId);
                      if (!imgData) {
                        (0, _util2.warn)("Dependent image with object ID ".concat(objId, " is not ready yet"));
                        return;
                      }
                      this.paintInlineImageXObject(imgData);
                    } }, { key: "paintInlineImageXObject", value: function paintInlineImageXObject(imgData, mask) {
                      var width = imgData.width;
                      var height = imgData.height;
                      var imgSrc = convertImgDataToPng(imgData, this.forceDataSchema, !!mask);
                      var cliprect = this.svgFactory.createElement("svg:rect");
                      cliprect.setAttributeNS(null, "x", "0");
                      cliprect.setAttributeNS(null, "y", "0");
                      cliprect.setAttributeNS(null, "width", pf(width));
                      cliprect.setAttributeNS(null, "height", pf(height));
                      this.current.element = cliprect;
                      this.clip("nonzero");
                      var imgEl = this.svgFactory.createElement("svg:image");
                      imgEl.setAttributeNS(XLINK_NS, "xlink:href", imgSrc);
                      imgEl.setAttributeNS(null, "x", "0");
                      imgEl.setAttributeNS(null, "y", pf(-height));
                      imgEl.setAttributeNS(null, "width", pf(width) + "px");
                      imgEl.setAttributeNS(null, "height", pf(height) + "px");
                      imgEl.setAttributeNS(null, "transform", "scale(".concat(pf(1 / width), " ").concat(pf(-1 / height), ")"));
                      if (mask) {
                        mask.appendChild(imgEl);
                      } else {
                        this._ensureTransformGroup().appendChild(imgEl);
                      }
                    } }, { key: "paintImageMaskXObject", value: function paintImageMaskXObject(imgData) {
                      var current = this.current;
                      var width = imgData.width;
                      var height = imgData.height;
                      var fillColor = current.fillColor;
                      current.maskId = "mask".concat(maskCount++);
                      var mask = this.svgFactory.createElement("svg:mask");
                      mask.setAttributeNS(null, "id", current.maskId);
                      var rect = this.svgFactory.createElement("svg:rect");
                      rect.setAttributeNS(null, "x", "0");
                      rect.setAttributeNS(null, "y", "0");
                      rect.setAttributeNS(null, "width", pf(width));
                      rect.setAttributeNS(null, "height", pf(height));
                      rect.setAttributeNS(null, "fill", fillColor);
                      rect.setAttributeNS(null, "mask", "url(#".concat(current.maskId, ")"));
                      this.defs.appendChild(mask);
                      this._ensureTransformGroup().appendChild(rect);
                      this.paintInlineImageXObject(imgData, mask);
                    } }, { key: "paintFormXObjectBegin", value: function paintFormXObjectBegin(matrix, bbox) {
                      if (Array.isArray(matrix) && matrix.length === 6) {
                        this.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
                      }
                      if (bbox) {
                        var width = bbox[2] - bbox[0];
                        var height = bbox[3] - bbox[1];
                        var cliprect = this.svgFactory.createElement("svg:rect");
                        cliprect.setAttributeNS(null, "x", bbox[0]);
                        cliprect.setAttributeNS(null, "y", bbox[1]);
                        cliprect.setAttributeNS(null, "width", pf(width));
                        cliprect.setAttributeNS(null, "height", pf(height));
                        this.current.element = cliprect;
                        this.clip("nonzero");
                        this.endPath();
                      }
                    } }, { key: "paintFormXObjectEnd", value: function paintFormXObjectEnd() {
                    } }, { key: "_initialize", value: function _initialize(viewport) {
                      var svg = this.svgFactory.create(viewport.width, viewport.height);
                      var definitions = this.svgFactory.createElement("svg:defs");
                      svg.appendChild(definitions);
                      this.defs = definitions;
                      var rootGroup = this.svgFactory.createElement("svg:g");
                      rootGroup.setAttributeNS(null, "transform", pm(viewport.transform));
                      svg.appendChild(rootGroup);
                      this.svg = rootGroup;
                      return svg;
                    } }, { key: "_ensureClipGroup", value: function _ensureClipGroup() {
                      if (!this.current.clipGroup) {
                        var clipGroup = this.svgFactory.createElement("svg:g");
                        clipGroup.setAttributeNS(null, "clip-path", this.current.activeClipUrl);
                        this.svg.appendChild(clipGroup);
                        this.current.clipGroup = clipGroup;
                      }
                      return this.current.clipGroup;
                    } }, { key: "_ensureTransformGroup", value: function _ensureTransformGroup() {
                      if (!this.tgrp) {
                        this.tgrp = this.svgFactory.createElement("svg:g");
                        this.tgrp.setAttributeNS(null, "transform", pm(this.transformMatrix));
                        if (this.current.activeClipUrl) {
                          this._ensureClipGroup().appendChild(this.tgrp);
                        } else {
                          this.svg.appendChild(this.tgrp);
                        }
                      }
                      return this.tgrp;
                    } }]);
                    return SVGGraphics2;
                  }();
                }
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.PDFNodeStream = void 0;
                var _regenerator2 = _interopRequireDefault2(__w_pdfjs_require__2(191));
                var _util2 = __w_pdfjs_require__2(1);
                var _network_utils = __w_pdfjs_require__2(209);
                function _interopRequireDefault2(obj) {
                  return obj && obj.__esModule ? obj : { "default": obj };
                }
                function _typeof2(obj) {
                  "@babel/helpers - typeof";
                  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                    _typeof2 = function _typeof3(obj2) {
                      return typeof obj2;
                    };
                  } else {
                    _typeof2 = function _typeof3(obj2) {
                      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                    };
                  }
                  return _typeof2(obj);
                }
                function _possibleConstructorReturn(self2, call) {
                  if (call && (_typeof2(call) === "object" || typeof call === "function")) {
                    return call;
                  }
                  return _assertThisInitialized(self2);
                }
                function _assertThisInitialized(self2) {
                  if (self2 === void 0) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  }
                  return self2;
                }
                function _getPrototypeOf(o) {
                  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                    return o2.__proto__ || Object.getPrototypeOf(o2);
                  };
                  return _getPrototypeOf(o);
                }
                function _inherits(subClass, superClass) {
                  if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function");
                  }
                  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
                  if (superClass)
                    _setPrototypeOf(subClass, superClass);
                }
                function _setPrototypeOf(o, p) {
                  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                    o2.__proto__ = p2;
                    return o2;
                  };
                  return _setPrototypeOf(o, p);
                }
                function asyncGeneratorStep2(gen, resolve, reject, _next, _throw, key, arg) {
                  try {
                    var info = gen[key](arg);
                    var value = info.value;
                  } catch (error) {
                    reject(error);
                    return;
                  }
                  if (info.done) {
                    resolve(value);
                  } else {
                    Promise.resolve(value).then(_next, _throw);
                  }
                }
                function _asyncToGenerator2(fn) {
                  return function() {
                    var self2 = this, args = arguments;
                    return new Promise(function(resolve, reject) {
                      var gen = fn.apply(self2, args);
                      function _next(value) {
                        asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "next", value);
                      }
                      function _throw(err) {
                        asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "throw", err);
                      }
                      _next(void 0);
                    });
                  };
                }
                function _classCallCheck2(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _defineProperties2(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                function _createClass2(Constructor, protoProps, staticProps) {
                  if (protoProps)
                    _defineProperties2(Constructor.prototype, protoProps);
                  if (staticProps)
                    _defineProperties2(Constructor, staticProps);
                  return Constructor;
                }
                var fs = __webpack_require__(104);
                var http = __webpack_require__(3880);
                var https = __webpack_require__(6173);
                var url = __webpack_require__(6913);
                var fileUriRegex = /^file:\/\/\/[a-zA-Z]:\//;
                function parseUrl(sourceUrl) {
                  var parsedUrl = url.parse(sourceUrl);
                  if (parsedUrl.protocol === "file:" || parsedUrl.host) {
                    return parsedUrl;
                  }
                  if (/^[a-z]:[/\\]/i.test(sourceUrl)) {
                    return url.parse("file:///".concat(sourceUrl));
                  }
                  if (!parsedUrl.host) {
                    parsedUrl.protocol = "file:";
                  }
                  return parsedUrl;
                }
                var PDFNodeStream = function() {
                  function PDFNodeStream2(source) {
                    _classCallCheck2(this, PDFNodeStream2);
                    this.source = source;
                    this.url = parseUrl(source.url);
                    this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:";
                    this.isFsUrl = this.url.protocol === "file:";
                    this.httpHeaders = this.isHttp && source.httpHeaders || {};
                    this._fullRequestReader = null;
                    this._rangeRequestReaders = [];
                  }
                  _createClass2(PDFNodeStream2, [{ key: "getFullReader", value: function getFullReader() {
                    (0, _util2.assert)(!this._fullRequestReader);
                    this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this);
                    return this._fullRequestReader;
                  } }, { key: "getRangeReader", value: function getRangeReader(start, end) {
                    if (end <= this._progressiveDataLength) {
                      return null;
                    }
                    var rangeReader = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, start, end) : new PDFNodeStreamRangeReader(this, start, end);
                    this._rangeRequestReaders.push(rangeReader);
                    return rangeReader;
                  } }, { key: "cancelAllRequests", value: function cancelAllRequests(reason) {
                    if (this._fullRequestReader) {
                      this._fullRequestReader.cancel(reason);
                    }
                    var readers = this._rangeRequestReaders.slice(0);
                    readers.forEach(function(reader) {
                      reader.cancel(reason);
                    });
                  } }, { key: "_progressiveDataLength", get: function get() {
                    return this._fullRequestReader ? this._fullRequestReader._loaded : 0;
                  } }]);
                  return PDFNodeStream2;
                }();
                exports2.PDFNodeStream = PDFNodeStream;
                var BaseFullReader = function() {
                  function BaseFullReader2(stream) {
                    _classCallCheck2(this, BaseFullReader2);
                    this._url = stream.url;
                    this._done = false;
                    this._storedError = null;
                    this.onProgress = null;
                    var source = stream.source;
                    this._contentLength = source.length;
                    this._loaded = 0;
                    this._filename = null;
                    this._disableRange = source.disableRange || false;
                    this._rangeChunkSize = source.rangeChunkSize;
                    if (!this._rangeChunkSize && !this._disableRange) {
                      this._disableRange = true;
                    }
                    this._isStreamingSupported = !source.disableStream;
                    this._isRangeSupported = !source.disableRange;
                    this._readableStream = null;
                    this._readCapability = (0, _util2.createPromiseCapability)();
                    this._headersCapability = (0, _util2.createPromiseCapability)();
                  }
                  _createClass2(BaseFullReader2, [{ key: "read", value: function() {
                    var _read = _asyncToGenerator2(_regenerator2["default"].mark(function _callee2() {
                      var chunk, buffer;
                      return _regenerator2["default"].wrap(function _callee$2(_context2) {
                        while (1) {
                          switch (_context2.prev = _context2.next) {
                            case 0:
                              _context2.next = 2;
                              return this._readCapability.promise;
                            case 2:
                              if (!this._done) {
                                _context2.next = 4;
                                break;
                              }
                              return _context2.abrupt("return", { value: void 0, done: true });
                            case 4:
                              if (!this._storedError) {
                                _context2.next = 6;
                                break;
                              }
                              throw this._storedError;
                            case 6:
                              chunk = this._readableStream.read();
                              if (!(chunk === null)) {
                                _context2.next = 10;
                                break;
                              }
                              this._readCapability = (0, _util2.createPromiseCapability)();
                              return _context2.abrupt("return", this.read());
                            case 10:
                              this._loaded += chunk.length;
                              if (this.onProgress) {
                                this.onProgress({ loaded: this._loaded, total: this._contentLength });
                              }
                              buffer = new Uint8Array(chunk).buffer;
                              return _context2.abrupt("return", { value: buffer, done: false });
                            case 14:
                            case "end":
                              return _context2.stop();
                          }
                        }
                      }, _callee2, this);
                    }));
                    function read() {
                      return _read.apply(this, arguments);
                    }
                    return read;
                  }() }, { key: "cancel", value: function cancel(reason) {
                    if (!this._readableStream) {
                      this._error(reason);
                      return;
                    }
                    this._readableStream.destroy(reason);
                  } }, { key: "_error", value: function _error(reason) {
                    this._storedError = reason;
                    this._readCapability.resolve();
                  } }, { key: "_setReadableStream", value: function _setReadableStream(readableStream) {
                    var _this = this;
                    this._readableStream = readableStream;
                    readableStream.on("readable", function() {
                      _this._readCapability.resolve();
                    });
                    readableStream.on("end", function() {
                      readableStream.destroy();
                      _this._done = true;
                      _this._readCapability.resolve();
                    });
                    readableStream.on("error", function(reason) {
                      _this._error(reason);
                    });
                    if (!this._isStreamingSupported && this._isRangeSupported) {
                      this._error(new _util2.AbortException("streaming is disabled"));
                    }
                    if (this._storedError) {
                      this._readableStream.destroy(this._storedError);
                    }
                  } }, { key: "headersReady", get: function get() {
                    return this._headersCapability.promise;
                  } }, { key: "filename", get: function get() {
                    return this._filename;
                  } }, { key: "contentLength", get: function get() {
                    return this._contentLength;
                  } }, { key: "isRangeSupported", get: function get() {
                    return this._isRangeSupported;
                  } }, { key: "isStreamingSupported", get: function get() {
                    return this._isStreamingSupported;
                  } }]);
                  return BaseFullReader2;
                }();
                var BaseRangeReader = function() {
                  function BaseRangeReader2(stream) {
                    _classCallCheck2(this, BaseRangeReader2);
                    this._url = stream.url;
                    this._done = false;
                    this._storedError = null;
                    this.onProgress = null;
                    this._loaded = 0;
                    this._readableStream = null;
                    this._readCapability = (0, _util2.createPromiseCapability)();
                    var source = stream.source;
                    this._isStreamingSupported = !source.disableStream;
                  }
                  _createClass2(BaseRangeReader2, [{ key: "read", value: function() {
                    var _read2 = _asyncToGenerator2(_regenerator2["default"].mark(function _callee2() {
                      var chunk, buffer;
                      return _regenerator2["default"].wrap(function _callee2$(_context2) {
                        while (1) {
                          switch (_context2.prev = _context2.next) {
                            case 0:
                              _context2.next = 2;
                              return this._readCapability.promise;
                            case 2:
                              if (!this._done) {
                                _context2.next = 4;
                                break;
                              }
                              return _context2.abrupt("return", { value: void 0, done: true });
                            case 4:
                              if (!this._storedError) {
                                _context2.next = 6;
                                break;
                              }
                              throw this._storedError;
                            case 6:
                              chunk = this._readableStream.read();
                              if (!(chunk === null)) {
                                _context2.next = 10;
                                break;
                              }
                              this._readCapability = (0, _util2.createPromiseCapability)();
                              return _context2.abrupt("return", this.read());
                            case 10:
                              this._loaded += chunk.length;
                              if (this.onProgress) {
                                this.onProgress({ loaded: this._loaded });
                              }
                              buffer = new Uint8Array(chunk).buffer;
                              return _context2.abrupt("return", { value: buffer, done: false });
                            case 14:
                            case "end":
                              return _context2.stop();
                          }
                        }
                      }, _callee2, this);
                    }));
                    function read() {
                      return _read2.apply(this, arguments);
                    }
                    return read;
                  }() }, { key: "cancel", value: function cancel(reason) {
                    if (!this._readableStream) {
                      this._error(reason);
                      return;
                    }
                    this._readableStream.destroy(reason);
                  } }, { key: "_error", value: function _error(reason) {
                    this._storedError = reason;
                    this._readCapability.resolve();
                  } }, { key: "_setReadableStream", value: function _setReadableStream(readableStream) {
                    var _this2 = this;
                    this._readableStream = readableStream;
                    readableStream.on("readable", function() {
                      _this2._readCapability.resolve();
                    });
                    readableStream.on("end", function() {
                      readableStream.destroy();
                      _this2._done = true;
                      _this2._readCapability.resolve();
                    });
                    readableStream.on("error", function(reason) {
                      _this2._error(reason);
                    });
                    if (this._storedError) {
                      this._readableStream.destroy(this._storedError);
                    }
                  } }, { key: "isStreamingSupported", get: function get() {
                    return this._isStreamingSupported;
                  } }]);
                  return BaseRangeReader2;
                }();
                function createRequestOptions(url2, headers) {
                  return { protocol: url2.protocol, auth: url2.auth, host: url2.hostname, port: url2.port, path: url2.path, method: "GET", headers };
                }
                var PDFNodeStreamFullReader = function(_BaseFullReader) {
                  _inherits(PDFNodeStreamFullReader2, _BaseFullReader);
                  function PDFNodeStreamFullReader2(stream) {
                    var _this3;
                    _classCallCheck2(this, PDFNodeStreamFullReader2);
                    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(PDFNodeStreamFullReader2).call(this, stream));
                    var handleResponse = function handleResponse2(response) {
                      if (response.statusCode === 404) {
                        var error = new _util2.MissingPDFException('Missing PDF "'.concat(_this3._url, '".'));
                        _this3._storedError = error;
                        _this3._headersCapability.reject(error);
                        return;
                      }
                      _this3._headersCapability.resolve();
                      _this3._setReadableStream(response);
                      var getResponseHeader = function getResponseHeader2(name) {
                        return _this3._readableStream.headers[name.toLowerCase()];
                      };
                      var _validateRangeRequest = (0, _network_utils.validateRangeRequestCapabilities)({ getResponseHeader, isHttp: stream.isHttp, rangeChunkSize: _this3._rangeChunkSize, disableRange: _this3._disableRange }), allowRangeRequests = _validateRangeRequest.allowRangeRequests, suggestedLength = _validateRangeRequest.suggestedLength;
                      _this3._isRangeSupported = allowRangeRequests;
                      _this3._contentLength = suggestedLength || _this3._contentLength;
                      _this3._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
                    };
                    _this3._request = null;
                    if (_this3._url.protocol === "http:") {
                      _this3._request = http.request(createRequestOptions(_this3._url, stream.httpHeaders), handleResponse);
                    } else {
                      _this3._request = https.request(createRequestOptions(_this3._url, stream.httpHeaders), handleResponse);
                    }
                    _this3._request.on("error", function(reason) {
                      _this3._storedError = reason;
                      _this3._headersCapability.reject(reason);
                    });
                    _this3._request.end();
                    return _this3;
                  }
                  return PDFNodeStreamFullReader2;
                }(BaseFullReader);
                var PDFNodeStreamRangeReader = function(_BaseRangeReader) {
                  _inherits(PDFNodeStreamRangeReader2, _BaseRangeReader);
                  function PDFNodeStreamRangeReader2(stream, start, end) {
                    var _this4;
                    _classCallCheck2(this, PDFNodeStreamRangeReader2);
                    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(PDFNodeStreamRangeReader2).call(this, stream));
                    _this4._httpHeaders = {};
                    for (var property in stream.httpHeaders) {
                      var value = stream.httpHeaders[property];
                      if (typeof value === "undefined") {
                        continue;
                      }
                      _this4._httpHeaders[property] = value;
                    }
                    _this4._httpHeaders["Range"] = "bytes=".concat(start, "-").concat(end - 1);
                    var handleResponse = function handleResponse2(response) {
                      if (response.statusCode === 404) {
                        var error = new _util2.MissingPDFException('Missing PDF "'.concat(_this4._url, '".'));
                        _this4._storedError = error;
                        return;
                      }
                      _this4._setReadableStream(response);
                    };
                    _this4._request = null;
                    if (_this4._url.protocol === "http:") {
                      _this4._request = http.request(createRequestOptions(_this4._url, _this4._httpHeaders), handleResponse);
                    } else {
                      _this4._request = https.request(createRequestOptions(_this4._url, _this4._httpHeaders), handleResponse);
                    }
                    _this4._request.on("error", function(reason) {
                      _this4._storedError = reason;
                    });
                    _this4._request.end();
                    return _this4;
                  }
                  return PDFNodeStreamRangeReader2;
                }(BaseRangeReader);
                var PDFNodeStreamFsFullReader = function(_BaseFullReader2) {
                  _inherits(PDFNodeStreamFsFullReader2, _BaseFullReader2);
                  function PDFNodeStreamFsFullReader2(stream) {
                    var _this5;
                    _classCallCheck2(this, PDFNodeStreamFsFullReader2);
                    _this5 = _possibleConstructorReturn(this, _getPrototypeOf(PDFNodeStreamFsFullReader2).call(this, stream));
                    var path = decodeURIComponent(_this5._url.path);
                    if (fileUriRegex.test(_this5._url.href)) {
                      path = path.replace(/^\//, "");
                    }
                    fs.lstat(path, function(error, stat) {
                      if (error) {
                        if (error.code === "ENOENT") {
                          error = new _util2.MissingPDFException('Missing PDF "'.concat(path, '".'));
                        }
                        _this5._storedError = error;
                        _this5._headersCapability.reject(error);
                        return;
                      }
                      _this5._contentLength = stat.size;
                      _this5._setReadableStream(fs.createReadStream(path));
                      _this5._headersCapability.resolve();
                    });
                    return _this5;
                  }
                  return PDFNodeStreamFsFullReader2;
                }(BaseFullReader);
                var PDFNodeStreamFsRangeReader = function(_BaseRangeReader2) {
                  _inherits(PDFNodeStreamFsRangeReader2, _BaseRangeReader2);
                  function PDFNodeStreamFsRangeReader2(stream, start, end) {
                    var _this6;
                    _classCallCheck2(this, PDFNodeStreamFsRangeReader2);
                    _this6 = _possibleConstructorReturn(this, _getPrototypeOf(PDFNodeStreamFsRangeReader2).call(this, stream));
                    var path = decodeURIComponent(_this6._url.path);
                    if (fileUriRegex.test(_this6._url.href)) {
                      path = path.replace(/^\//, "");
                    }
                    _this6._setReadableStream(fs.createReadStream(path, { start, end: end - 1 }));
                    return _this6;
                  }
                  return PDFNodeStreamFsRangeReader2;
                }(BaseRangeReader);
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.createResponseStatusError = createResponseStatusError;
                exports2.extractFilenameFromHeader = extractFilenameFromHeader;
                exports2.validateRangeRequestCapabilities = validateRangeRequestCapabilities;
                exports2.validateResponseStatus = validateResponseStatus;
                var _util2 = __w_pdfjs_require__2(1);
                var _content_disposition = __w_pdfjs_require__2(210);
                function validateRangeRequestCapabilities(_ref) {
                  var getResponseHeader = _ref.getResponseHeader, isHttp = _ref.isHttp, rangeChunkSize = _ref.rangeChunkSize, disableRange = _ref.disableRange;
                  (0, _util2.assert)(rangeChunkSize > 0, "Range chunk size must be larger than zero");
                  var returnValues = { allowRangeRequests: false, suggestedLength: void 0 };
                  var length = parseInt(getResponseHeader("Content-Length"), 10);
                  if (!Number.isInteger(length)) {
                    return returnValues;
                  }
                  returnValues.suggestedLength = length;
                  if (length <= 2 * rangeChunkSize) {
                    return returnValues;
                  }
                  if (disableRange || !isHttp) {
                    return returnValues;
                  }
                  if (getResponseHeader("Accept-Ranges") !== "bytes") {
                    return returnValues;
                  }
                  var contentEncoding = getResponseHeader("Content-Encoding") || "identity";
                  if (contentEncoding !== "identity") {
                    return returnValues;
                  }
                  returnValues.allowRangeRequests = true;
                  return returnValues;
                }
                function extractFilenameFromHeader(getResponseHeader) {
                  var contentDisposition = getResponseHeader("Content-Disposition");
                  if (contentDisposition) {
                    var filename = (0, _content_disposition.getFilenameFromContentDispositionHeader)(contentDisposition);
                    if (filename.includes("%")) {
                      try {
                        filename = decodeURIComponent(filename);
                      } catch (ex) {
                      }
                    }
                    if (/\.pdf$/i.test(filename)) {
                      return filename;
                    }
                  }
                  return null;
                }
                function createResponseStatusError(status, url) {
                  if (status === 404 || status === 0 && url.startsWith("file:")) {
                    return new _util2.MissingPDFException('Missing PDF "' + url + '".');
                  }
                  return new _util2.UnexpectedResponseException("Unexpected server response (" + status + ') while retrieving PDF "' + url + '".', status);
                }
                function validateResponseStatus(status) {
                  return status === 200 || status === 206;
                }
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.getFilenameFromContentDispositionHeader = getFilenameFromContentDispositionHeader;
                function _slicedToArray2(arr, i) {
                  return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i) || _nonIterableRest2();
                }
                function _nonIterableRest2() {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
                function _iterableToArrayLimit2(arr, i) {
                  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
                    return;
                  }
                  var _arr = [];
                  var _n = true;
                  var _d = false;
                  var _e = void 0;
                  try {
                    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                      _arr.push(_s.value);
                      if (i && _arr.length === i)
                        break;
                    }
                  } catch (err) {
                    _d = true;
                    _e = err;
                  } finally {
                    try {
                      if (!_n && _i["return"] != null)
                        _i["return"]();
                    } finally {
                      if (_d)
                        throw _e;
                    }
                  }
                  return _arr;
                }
                function _arrayWithHoles2(arr) {
                  if (Array.isArray(arr))
                    return arr;
                }
                function getFilenameFromContentDispositionHeader(contentDisposition) {
                  var needsEncodingFixup = true;
                  var tmp = toParamRegExp("filename\\*", "i").exec(contentDisposition);
                  if (tmp) {
                    tmp = tmp[1];
                    var filename = rfc2616unquote(tmp);
                    filename = unescape(filename);
                    filename = rfc5987decode(filename);
                    filename = rfc2047decode(filename);
                    return fixupEncoding(filename);
                  }
                  tmp = rfc2231getparam(contentDisposition);
                  if (tmp) {
                    var _filename = rfc2047decode(tmp);
                    return fixupEncoding(_filename);
                  }
                  tmp = toParamRegExp("filename", "i").exec(contentDisposition);
                  if (tmp) {
                    tmp = tmp[1];
                    var _filename2 = rfc2616unquote(tmp);
                    _filename2 = rfc2047decode(_filename2);
                    return fixupEncoding(_filename2);
                  }
                  function toParamRegExp(attributePattern, flags) {
                    return new RegExp("(?:^|;)\\s*" + attributePattern + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', flags);
                  }
                  function textdecode(encoding, value) {
                    if (encoding) {
                      if (!/^[\x00-\xFF]+$/.test(value)) {
                        return value;
                      }
                      try {
                        var decoder = new TextDecoder(encoding, { fatal: true });
                        var bytes = Array.from(value, function(ch) {
                          return ch.charCodeAt(0) & 255;
                        });
                        value = decoder.decode(new Uint8Array(bytes));
                        needsEncodingFixup = false;
                      } catch (e) {
                        if (/^utf-?8$/i.test(encoding)) {
                          try {
                            value = decodeURIComponent(escape(value));
                            needsEncodingFixup = false;
                          } catch (err) {
                          }
                        }
                      }
                    }
                    return value;
                  }
                  function fixupEncoding(value) {
                    if (needsEncodingFixup && /[\x80-\xff]/.test(value)) {
                      value = textdecode("utf-8", value);
                      if (needsEncodingFixup) {
                        value = textdecode("iso-8859-1", value);
                      }
                    }
                    return value;
                  }
                  function rfc2231getparam(contentDisposition2) {
                    var matches = [];
                    var match;
                    var iter = toParamRegExp("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
                    while ((match = iter.exec(contentDisposition2)) !== null) {
                      var _match = match, _match2 = _slicedToArray2(_match, 4), n = _match2[1], quot = _match2[2], part = _match2[3];
                      n = parseInt(n, 10);
                      if (n in matches) {
                        if (n === 0) {
                          break;
                        }
                        continue;
                      }
                      matches[n] = [quot, part];
                    }
                    var parts = [];
                    for (var _n2 = 0; _n2 < matches.length; ++_n2) {
                      if (!(_n2 in matches)) {
                        break;
                      }
                      var _matches$_n = _slicedToArray2(matches[_n2], 2), _quot = _matches$_n[0], _part = _matches$_n[1];
                      _part = rfc2616unquote(_part);
                      if (_quot) {
                        _part = unescape(_part);
                        if (_n2 === 0) {
                          _part = rfc5987decode(_part);
                        }
                      }
                      parts.push(_part);
                    }
                    return parts.join("");
                  }
                  function rfc2616unquote(value) {
                    if (value.startsWith('"')) {
                      var parts = value.slice(1).split('\\"');
                      for (var i = 0; i < parts.length; ++i) {
                        var quotindex = parts[i].indexOf('"');
                        if (quotindex !== -1) {
                          parts[i] = parts[i].slice(0, quotindex);
                          parts.length = i + 1;
                        }
                        parts[i] = parts[i].replace(/\\(.)/g, "$1");
                      }
                      value = parts.join('"');
                    }
                    return value;
                  }
                  function rfc5987decode(extvalue) {
                    var encodingend = extvalue.indexOf("'");
                    if (encodingend === -1) {
                      return extvalue;
                    }
                    var encoding = extvalue.slice(0, encodingend);
                    var langvalue = extvalue.slice(encodingend + 1);
                    var value = langvalue.replace(/^[^']*'/, "");
                    return textdecode(encoding, value);
                  }
                  function rfc2047decode(value) {
                    if (!value.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(value)) {
                      return value;
                    }
                    return value.replace(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function(_, charset, encoding, text) {
                      if (encoding === "q" || encoding === "Q") {
                        text = text.replace(/_/g, " ");
                        text = text.replace(/=([0-9a-fA-F]{2})/g, function(_2, hex) {
                          return String.fromCharCode(parseInt(hex, 16));
                        });
                        return textdecode(charset, text);
                      }
                      try {
                        text = atob(text);
                      } catch (e) {
                      }
                      return textdecode(charset, text);
                    });
                  }
                  return "";
                }
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.PDFNetworkStream = void 0;
                var _regenerator2 = _interopRequireDefault2(__w_pdfjs_require__2(191));
                var _util2 = __w_pdfjs_require__2(1);
                var _network_utils = __w_pdfjs_require__2(209);
                function _interopRequireDefault2(obj) {
                  return obj && obj.__esModule ? obj : { default: obj };
                }
                function asyncGeneratorStep2(gen, resolve, reject, _next, _throw, key, arg) {
                  try {
                    var info = gen[key](arg);
                    var value = info.value;
                  } catch (error) {
                    reject(error);
                    return;
                  }
                  if (info.done) {
                    resolve(value);
                  } else {
                    Promise.resolve(value).then(_next, _throw);
                  }
                }
                function _asyncToGenerator2(fn) {
                  return function() {
                    var self2 = this, args = arguments;
                    return new Promise(function(resolve, reject) {
                      var gen = fn.apply(self2, args);
                      function _next(value) {
                        asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "next", value);
                      }
                      function _throw(err) {
                        asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "throw", err);
                      }
                      _next(void 0);
                    });
                  };
                }
                function _classCallCheck2(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _defineProperties2(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                function _createClass2(Constructor, protoProps, staticProps) {
                  if (protoProps)
                    _defineProperties2(Constructor.prototype, protoProps);
                  if (staticProps)
                    _defineProperties2(Constructor, staticProps);
                  return Constructor;
                }
                ;
                var OK_RESPONSE = 200;
                var PARTIAL_CONTENT_RESPONSE = 206;
                function getArrayBuffer(xhr) {
                  var data = xhr.response;
                  if (typeof data !== "string") {
                    return data;
                  }
                  var array = (0, _util2.stringToBytes)(data);
                  return array.buffer;
                }
                var NetworkManager = function() {
                  function NetworkManager2(url, args) {
                    _classCallCheck2(this, NetworkManager2);
                    this.url = url;
                    args = args || {};
                    this.isHttp = /^https?:/i.test(url);
                    this.httpHeaders = this.isHttp && args.httpHeaders || {};
                    this.withCredentials = args.withCredentials || false;
                    this.getXhr = args.getXhr || function NetworkManager_getXhr() {
                      return new XMLHttpRequest();
                    };
                    this.currXhrId = 0;
                    this.pendingRequests = /* @__PURE__ */ Object.create(null);
                  }
                  _createClass2(NetworkManager2, [{ key: "requestRange", value: function requestRange(begin, end, listeners) {
                    var args = { begin, end };
                    for (var prop in listeners) {
                      args[prop] = listeners[prop];
                    }
                    return this.request(args);
                  } }, { key: "requestFull", value: function requestFull(listeners) {
                    return this.request(listeners);
                  } }, { key: "request", value: function request(args) {
                    var xhr = this.getXhr();
                    var xhrId = this.currXhrId++;
                    var pendingRequest = this.pendingRequests[xhrId] = { xhr };
                    xhr.open("GET", this.url);
                    xhr.withCredentials = this.withCredentials;
                    for (var property in this.httpHeaders) {
                      var value = this.httpHeaders[property];
                      if (typeof value === "undefined") {
                        continue;
                      }
                      xhr.setRequestHeader(property, value);
                    }
                    if (this.isHttp && "begin" in args && "end" in args) {
                      xhr.setRequestHeader("Range", "bytes=".concat(args.begin, "-").concat(args.end - 1));
                      pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;
                    } else {
                      pendingRequest.expectedStatus = OK_RESPONSE;
                    }
                    xhr.responseType = "arraybuffer";
                    if (args.onError) {
                      xhr.onerror = function(evt) {
                        args.onError(xhr.status);
                      };
                    }
                    xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);
                    xhr.onprogress = this.onProgress.bind(this, xhrId);
                    pendingRequest.onHeadersReceived = args.onHeadersReceived;
                    pendingRequest.onDone = args.onDone;
                    pendingRequest.onError = args.onError;
                    pendingRequest.onProgress = args.onProgress;
                    xhr.send(null);
                    return xhrId;
                  } }, { key: "onProgress", value: function onProgress(xhrId, evt) {
                    var pendingRequest = this.pendingRequests[xhrId];
                    if (!pendingRequest) {
                      return;
                    }
                    if (pendingRequest.onProgress) {
                      pendingRequest.onProgress(evt);
                    }
                  } }, { key: "onStateChange", value: function onStateChange(xhrId, evt) {
                    var pendingRequest = this.pendingRequests[xhrId];
                    if (!pendingRequest) {
                      return;
                    }
                    var xhr = pendingRequest.xhr;
                    if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {
                      pendingRequest.onHeadersReceived();
                      delete pendingRequest.onHeadersReceived;
                    }
                    if (xhr.readyState !== 4) {
                      return;
                    }
                    if (!(xhrId in this.pendingRequests)) {
                      return;
                    }
                    delete this.pendingRequests[xhrId];
                    if (xhr.status === 0 && this.isHttp) {
                      if (pendingRequest.onError) {
                        pendingRequest.onError(xhr.status);
                      }
                      return;
                    }
                    var xhrStatus = xhr.status || OK_RESPONSE;
                    var ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;
                    if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {
                      if (pendingRequest.onError) {
                        pendingRequest.onError(xhr.status);
                      }
                      return;
                    }
                    var chunk = getArrayBuffer(xhr);
                    if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {
                      var rangeHeader = xhr.getResponseHeader("Content-Range");
                      var matches = /bytes (\d+)-(\d+)\/(\d+)/.exec(rangeHeader);
                      pendingRequest.onDone({ begin: parseInt(matches[1], 10), chunk });
                    } else if (chunk) {
                      pendingRequest.onDone({ begin: 0, chunk });
                    } else if (pendingRequest.onError) {
                      pendingRequest.onError(xhr.status);
                    }
                  } }, { key: "hasPendingRequests", value: function hasPendingRequests() {
                    for (var xhrId in this.pendingRequests) {
                      return true;
                    }
                    return false;
                  } }, { key: "getRequestXhr", value: function getRequestXhr(xhrId) {
                    return this.pendingRequests[xhrId].xhr;
                  } }, { key: "isPendingRequest", value: function isPendingRequest(xhrId) {
                    return xhrId in this.pendingRequests;
                  } }, { key: "abortAllRequests", value: function abortAllRequests() {
                    for (var xhrId in this.pendingRequests) {
                      this.abortRequest(xhrId | 0);
                    }
                  } }, { key: "abortRequest", value: function abortRequest(xhrId) {
                    var xhr = this.pendingRequests[xhrId].xhr;
                    delete this.pendingRequests[xhrId];
                    xhr.abort();
                  } }]);
                  return NetworkManager2;
                }();
                var PDFNetworkStream = function() {
                  function PDFNetworkStream2(source) {
                    _classCallCheck2(this, PDFNetworkStream2);
                    this._source = source;
                    this._manager = new NetworkManager(source.url, { httpHeaders: source.httpHeaders, withCredentials: source.withCredentials });
                    this._rangeChunkSize = source.rangeChunkSize;
                    this._fullRequestReader = null;
                    this._rangeRequestReaders = [];
                  }
                  _createClass2(PDFNetworkStream2, [{ key: "_onRangeRequestReaderClosed", value: function _onRangeRequestReaderClosed(reader) {
                    var i = this._rangeRequestReaders.indexOf(reader);
                    if (i >= 0) {
                      this._rangeRequestReaders.splice(i, 1);
                    }
                  } }, { key: "getFullReader", value: function getFullReader() {
                    (0, _util2.assert)(!this._fullRequestReader);
                    this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);
                    return this._fullRequestReader;
                  } }, { key: "getRangeReader", value: function getRangeReader(begin, end) {
                    var reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);
                    reader.onClosed = this._onRangeRequestReaderClosed.bind(this);
                    this._rangeRequestReaders.push(reader);
                    return reader;
                  } }, { key: "cancelAllRequests", value: function cancelAllRequests(reason) {
                    if (this._fullRequestReader) {
                      this._fullRequestReader.cancel(reason);
                    }
                    var readers = this._rangeRequestReaders.slice(0);
                    readers.forEach(function(reader) {
                      reader.cancel(reason);
                    });
                  } }]);
                  return PDFNetworkStream2;
                }();
                exports2.PDFNetworkStream = PDFNetworkStream;
                var PDFNetworkStreamFullRequestReader = function() {
                  function PDFNetworkStreamFullRequestReader2(manager, source) {
                    _classCallCheck2(this, PDFNetworkStreamFullRequestReader2);
                    this._manager = manager;
                    var args = { onHeadersReceived: this._onHeadersReceived.bind(this), onDone: this._onDone.bind(this), onError: this._onError.bind(this), onProgress: this._onProgress.bind(this) };
                    this._url = source.url;
                    this._fullRequestId = manager.requestFull(args);
                    this._headersReceivedCapability = (0, _util2.createPromiseCapability)();
                    this._disableRange = source.disableRange || false;
                    this._contentLength = source.length;
                    this._rangeChunkSize = source.rangeChunkSize;
                    if (!this._rangeChunkSize && !this._disableRange) {
                      this._disableRange = true;
                    }
                    this._isStreamingSupported = false;
                    this._isRangeSupported = false;
                    this._cachedChunks = [];
                    this._requests = [];
                    this._done = false;
                    this._storedError = void 0;
                    this._filename = null;
                    this.onProgress = null;
                  }
                  _createClass2(PDFNetworkStreamFullRequestReader2, [{ key: "_onHeadersReceived", value: function _onHeadersReceived() {
                    var fullRequestXhrId = this._fullRequestId;
                    var fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);
                    var getResponseHeader = function getResponseHeader2(name) {
                      return fullRequestXhr.getResponseHeader(name);
                    };
                    var _validateRangeRequest = (0, _network_utils.validateRangeRequestCapabilities)({ getResponseHeader, isHttp: this._manager.isHttp, rangeChunkSize: this._rangeChunkSize, disableRange: this._disableRange }), allowRangeRequests = _validateRangeRequest.allowRangeRequests, suggestedLength = _validateRangeRequest.suggestedLength;
                    if (allowRangeRequests) {
                      this._isRangeSupported = true;
                    }
                    this._contentLength = suggestedLength || this._contentLength;
                    this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
                    if (this._isRangeSupported) {
                      this._manager.abortRequest(fullRequestXhrId);
                    }
                    this._headersReceivedCapability.resolve();
                  } }, { key: "_onDone", value: function _onDone(args) {
                    if (args) {
                      if (this._requests.length > 0) {
                        var requestCapability = this._requests.shift();
                        requestCapability.resolve({ value: args.chunk, done: false });
                      } else {
                        this._cachedChunks.push(args.chunk);
                      }
                    }
                    this._done = true;
                    if (this._cachedChunks.length > 0) {
                      return;
                    }
                    this._requests.forEach(function(requestCapability2) {
                      requestCapability2.resolve({ value: void 0, done: true });
                    });
                    this._requests = [];
                  } }, { key: "_onError", value: function _onError(status) {
                    var url = this._url;
                    var exception = (0, _network_utils.createResponseStatusError)(status, url);
                    this._storedError = exception;
                    this._headersReceivedCapability.reject(exception);
                    this._requests.forEach(function(requestCapability) {
                      requestCapability.reject(exception);
                    });
                    this._requests = [];
                    this._cachedChunks = [];
                  } }, { key: "_onProgress", value: function _onProgress(data) {
                    if (this.onProgress) {
                      this.onProgress({ loaded: data.loaded, total: data.lengthComputable ? data.total : this._contentLength });
                    }
                  } }, { key: "read", value: function() {
                    var _read = _asyncToGenerator2(_regenerator2["default"].mark(function _callee2() {
                      var chunk, requestCapability;
                      return _regenerator2["default"].wrap(function _callee$2(_context2) {
                        while (1) {
                          switch (_context2.prev = _context2.next) {
                            case 0:
                              if (!this._storedError) {
                                _context2.next = 2;
                                break;
                              }
                              throw this._storedError;
                            case 2:
                              if (!(this._cachedChunks.length > 0)) {
                                _context2.next = 5;
                                break;
                              }
                              chunk = this._cachedChunks.shift();
                              return _context2.abrupt("return", { value: chunk, done: false });
                            case 5:
                              if (!this._done) {
                                _context2.next = 7;
                                break;
                              }
                              return _context2.abrupt("return", { value: void 0, done: true });
                            case 7:
                              requestCapability = (0, _util2.createPromiseCapability)();
                              this._requests.push(requestCapability);
                              return _context2.abrupt("return", requestCapability.promise);
                            case 10:
                            case "end":
                              return _context2.stop();
                          }
                        }
                      }, _callee2, this);
                    }));
                    function read() {
                      return _read.apply(this, arguments);
                    }
                    return read;
                  }() }, { key: "cancel", value: function cancel(reason) {
                    this._done = true;
                    this._headersReceivedCapability.reject(reason);
                    this._requests.forEach(function(requestCapability) {
                      requestCapability.resolve({ value: void 0, done: true });
                    });
                    this._requests = [];
                    if (this._manager.isPendingRequest(this._fullRequestId)) {
                      this._manager.abortRequest(this._fullRequestId);
                    }
                    this._fullRequestReader = null;
                  } }, { key: "filename", get: function get() {
                    return this._filename;
                  } }, { key: "isRangeSupported", get: function get() {
                    return this._isRangeSupported;
                  } }, { key: "isStreamingSupported", get: function get() {
                    return this._isStreamingSupported;
                  } }, { key: "contentLength", get: function get() {
                    return this._contentLength;
                  } }, { key: "headersReady", get: function get() {
                    return this._headersReceivedCapability.promise;
                  } }]);
                  return PDFNetworkStreamFullRequestReader2;
                }();
                var PDFNetworkStreamRangeRequestReader = function() {
                  function PDFNetworkStreamRangeRequestReader2(manager, begin, end) {
                    _classCallCheck2(this, PDFNetworkStreamRangeRequestReader2);
                    this._manager = manager;
                    var args = { onDone: this._onDone.bind(this), onProgress: this._onProgress.bind(this) };
                    this._requestId = manager.requestRange(begin, end, args);
                    this._requests = [];
                    this._queuedChunk = null;
                    this._done = false;
                    this.onProgress = null;
                    this.onClosed = null;
                  }
                  _createClass2(PDFNetworkStreamRangeRequestReader2, [{ key: "_close", value: function _close() {
                    if (this.onClosed) {
                      this.onClosed(this);
                    }
                  } }, { key: "_onDone", value: function _onDone(data) {
                    var chunk = data.chunk;
                    if (this._requests.length > 0) {
                      var requestCapability = this._requests.shift();
                      requestCapability.resolve({ value: chunk, done: false });
                    } else {
                      this._queuedChunk = chunk;
                    }
                    this._done = true;
                    this._requests.forEach(function(requestCapability2) {
                      requestCapability2.resolve({ value: void 0, done: true });
                    });
                    this._requests = [];
                    this._close();
                  } }, { key: "_onProgress", value: function _onProgress(evt) {
                    if (!this.isStreamingSupported && this.onProgress) {
                      this.onProgress({ loaded: evt.loaded });
                    }
                  } }, { key: "read", value: function() {
                    var _read2 = _asyncToGenerator2(_regenerator2["default"].mark(function _callee2() {
                      var chunk, requestCapability;
                      return _regenerator2["default"].wrap(function _callee2$(_context2) {
                        while (1) {
                          switch (_context2.prev = _context2.next) {
                            case 0:
                              if (!(this._queuedChunk !== null)) {
                                _context2.next = 4;
                                break;
                              }
                              chunk = this._queuedChunk;
                              this._queuedChunk = null;
                              return _context2.abrupt("return", { value: chunk, done: false });
                            case 4:
                              if (!this._done) {
                                _context2.next = 6;
                                break;
                              }
                              return _context2.abrupt("return", { value: void 0, done: true });
                            case 6:
                              requestCapability = (0, _util2.createPromiseCapability)();
                              this._requests.push(requestCapability);
                              return _context2.abrupt("return", requestCapability.promise);
                            case 9:
                            case "end":
                              return _context2.stop();
                          }
                        }
                      }, _callee2, this);
                    }));
                    function read() {
                      return _read2.apply(this, arguments);
                    }
                    return read;
                  }() }, { key: "cancel", value: function cancel(reason) {
                    this._done = true;
                    this._requests.forEach(function(requestCapability) {
                      requestCapability.resolve({ value: void 0, done: true });
                    });
                    this._requests = [];
                    if (this._manager.isPendingRequest(this._requestId)) {
                      this._manager.abortRequest(this._requestId);
                    }
                    this._close();
                  } }, { key: "isStreamingSupported", get: function get() {
                    return false;
                  } }]);
                  return PDFNetworkStreamRangeRequestReader2;
                }();
              }, function(module2, exports2, __w_pdfjs_require__2) {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.PDFFetchStream = void 0;
                var _regenerator2 = _interopRequireDefault2(__w_pdfjs_require__2(191));
                var _util2 = __w_pdfjs_require__2(1);
                var _network_utils = __w_pdfjs_require__2(209);
                function _interopRequireDefault2(obj) {
                  return obj && obj.__esModule ? obj : { default: obj };
                }
                function asyncGeneratorStep2(gen, resolve, reject, _next, _throw, key, arg) {
                  try {
                    var info = gen[key](arg);
                    var value = info.value;
                  } catch (error) {
                    reject(error);
                    return;
                  }
                  if (info.done) {
                    resolve(value);
                  } else {
                    Promise.resolve(value).then(_next, _throw);
                  }
                }
                function _asyncToGenerator2(fn) {
                  return function() {
                    var self2 = this, args = arguments;
                    return new Promise(function(resolve, reject) {
                      var gen = fn.apply(self2, args);
                      function _next(value) {
                        asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "next", value);
                      }
                      function _throw(err) {
                        asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "throw", err);
                      }
                      _next(void 0);
                    });
                  };
                }
                function _classCallCheck2(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _defineProperties2(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                function _createClass2(Constructor, protoProps, staticProps) {
                  if (protoProps)
                    _defineProperties2(Constructor.prototype, protoProps);
                  if (staticProps)
                    _defineProperties2(Constructor, staticProps);
                  return Constructor;
                }
                function createFetchOptions(headers, withCredentials, abortController) {
                  return { method: "GET", headers, signal: abortController && abortController.signal, mode: "cors", credentials: withCredentials ? "include" : "same-origin", redirect: "follow" };
                }
                function createHeaders(httpHeaders) {
                  var headers = new Headers();
                  for (var property in httpHeaders) {
                    var value = httpHeaders[property];
                    if (typeof value === "undefined") {
                      continue;
                    }
                    headers.append(property, value);
                  }
                  return headers;
                }
                var PDFFetchStream = function() {
                  function PDFFetchStream2(source) {
                    _classCallCheck2(this, PDFFetchStream2);
                    this.source = source;
                    this.isHttp = /^https?:/i.test(source.url);
                    this.httpHeaders = this.isHttp && source.httpHeaders || {};
                    this._fullRequestReader = null;
                    this._rangeRequestReaders = [];
                  }
                  _createClass2(PDFFetchStream2, [{ key: "getFullReader", value: function getFullReader() {
                    (0, _util2.assert)(!this._fullRequestReader);
                    this._fullRequestReader = new PDFFetchStreamReader(this);
                    return this._fullRequestReader;
                  } }, { key: "getRangeReader", value: function getRangeReader(begin, end) {
                    if (end <= this._progressiveDataLength) {
                      return null;
                    }
                    var reader = new PDFFetchStreamRangeReader(this, begin, end);
                    this._rangeRequestReaders.push(reader);
                    return reader;
                  } }, { key: "cancelAllRequests", value: function cancelAllRequests(reason) {
                    if (this._fullRequestReader) {
                      this._fullRequestReader.cancel(reason);
                    }
                    var readers = this._rangeRequestReaders.slice(0);
                    readers.forEach(function(reader) {
                      reader.cancel(reason);
                    });
                  } }, { key: "_progressiveDataLength", get: function get() {
                    return this._fullRequestReader ? this._fullRequestReader._loaded : 0;
                  } }]);
                  return PDFFetchStream2;
                }();
                exports2.PDFFetchStream = PDFFetchStream;
                var PDFFetchStreamReader = function() {
                  function PDFFetchStreamReader2(stream) {
                    var _this = this;
                    _classCallCheck2(this, PDFFetchStreamReader2);
                    this._stream = stream;
                    this._reader = null;
                    this._loaded = 0;
                    this._filename = null;
                    var source = stream.source;
                    this._withCredentials = source.withCredentials || false;
                    this._contentLength = source.length;
                    this._headersCapability = (0, _util2.createPromiseCapability)();
                    this._disableRange = source.disableRange || false;
                    this._rangeChunkSize = source.rangeChunkSize;
                    if (!this._rangeChunkSize && !this._disableRange) {
                      this._disableRange = true;
                    }
                    if (typeof AbortController !== "undefined") {
                      this._abortController = new AbortController();
                    }
                    this._isStreamingSupported = !source.disableStream;
                    this._isRangeSupported = !source.disableRange;
                    this._headers = createHeaders(this._stream.httpHeaders);
                    var url = source.url;
                    fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(function(response) {
                      if (!(0, _network_utils.validateResponseStatus)(response.status)) {
                        throw (0, _network_utils.createResponseStatusError)(response.status, url);
                      }
                      _this._reader = response.body.getReader();
                      _this._headersCapability.resolve();
                      var getResponseHeader = function getResponseHeader2(name) {
                        return response.headers.get(name);
                      };
                      var _validateRangeRequest = (0, _network_utils.validateRangeRequestCapabilities)({ getResponseHeader, isHttp: _this._stream.isHttp, rangeChunkSize: _this._rangeChunkSize, disableRange: _this._disableRange }), allowRangeRequests = _validateRangeRequest.allowRangeRequests, suggestedLength = _validateRangeRequest.suggestedLength;
                      _this._isRangeSupported = allowRangeRequests;
                      _this._contentLength = suggestedLength || _this._contentLength;
                      _this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
                      if (!_this._isStreamingSupported && _this._isRangeSupported) {
                        _this.cancel(new _util2.AbortException("Streaming is disabled."));
                      }
                    })["catch"](this._headersCapability.reject);
                    this.onProgress = null;
                  }
                  _createClass2(PDFFetchStreamReader2, [{ key: "read", value: function() {
                    var _read = _asyncToGenerator2(_regenerator2["default"].mark(function _callee2() {
                      var _ref, value, done, buffer;
                      return _regenerator2["default"].wrap(function _callee$2(_context2) {
                        while (1) {
                          switch (_context2.prev = _context2.next) {
                            case 0:
                              _context2.next = 2;
                              return this._headersCapability.promise;
                            case 2:
                              _context2.next = 4;
                              return this._reader.read();
                            case 4:
                              _ref = _context2.sent;
                              value = _ref.value;
                              done = _ref.done;
                              if (!done) {
                                _context2.next = 9;
                                break;
                              }
                              return _context2.abrupt("return", { value, done });
                            case 9:
                              this._loaded += value.byteLength;
                              if (this.onProgress) {
                                this.onProgress({ loaded: this._loaded, total: this._contentLength });
                              }
                              buffer = new Uint8Array(value).buffer;
                              return _context2.abrupt("return", { value: buffer, done: false });
                            case 13:
                            case "end":
                              return _context2.stop();
                          }
                        }
                      }, _callee2, this);
                    }));
                    function read() {
                      return _read.apply(this, arguments);
                    }
                    return read;
                  }() }, { key: "cancel", value: function cancel(reason) {
                    if (this._reader) {
                      this._reader.cancel(reason);
                    }
                    if (this._abortController) {
                      this._abortController.abort();
                    }
                  } }, { key: "headersReady", get: function get() {
                    return this._headersCapability.promise;
                  } }, { key: "filename", get: function get() {
                    return this._filename;
                  } }, { key: "contentLength", get: function get() {
                    return this._contentLength;
                  } }, { key: "isRangeSupported", get: function get() {
                    return this._isRangeSupported;
                  } }, { key: "isStreamingSupported", get: function get() {
                    return this._isStreamingSupported;
                  } }]);
                  return PDFFetchStreamReader2;
                }();
                var PDFFetchStreamRangeReader = function() {
                  function PDFFetchStreamRangeReader2(stream, begin, end) {
                    var _this2 = this;
                    _classCallCheck2(this, PDFFetchStreamRangeReader2);
                    this._stream = stream;
                    this._reader = null;
                    this._loaded = 0;
                    var source = stream.source;
                    this._withCredentials = source.withCredentials || false;
                    this._readCapability = (0, _util2.createPromiseCapability)();
                    this._isStreamingSupported = !source.disableStream;
                    if (typeof AbortController !== "undefined") {
                      this._abortController = new AbortController();
                    }
                    this._headers = createHeaders(this._stream.httpHeaders);
                    this._headers.append("Range", "bytes=".concat(begin, "-").concat(end - 1));
                    var url = source.url;
                    fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(function(response) {
                      if (!(0, _network_utils.validateResponseStatus)(response.status)) {
                        throw (0, _network_utils.createResponseStatusError)(response.status, url);
                      }
                      _this2._readCapability.resolve();
                      _this2._reader = response.body.getReader();
                    });
                    this.onProgress = null;
                  }
                  _createClass2(PDFFetchStreamRangeReader2, [{ key: "read", value: function() {
                    var _read2 = _asyncToGenerator2(_regenerator2["default"].mark(function _callee2() {
                      var _ref2, value, done, buffer;
                      return _regenerator2["default"].wrap(function _callee2$(_context2) {
                        while (1) {
                          switch (_context2.prev = _context2.next) {
                            case 0:
                              _context2.next = 2;
                              return this._readCapability.promise;
                            case 2:
                              _context2.next = 4;
                              return this._reader.read();
                            case 4:
                              _ref2 = _context2.sent;
                              value = _ref2.value;
                              done = _ref2.done;
                              if (!done) {
                                _context2.next = 9;
                                break;
                              }
                              return _context2.abrupt("return", { value, done });
                            case 9:
                              this._loaded += value.byteLength;
                              if (this.onProgress) {
                                this.onProgress({ loaded: this._loaded });
                              }
                              buffer = new Uint8Array(value).buffer;
                              return _context2.abrupt("return", { value: buffer, done: false });
                            case 13:
                            case "end":
                              return _context2.stop();
                          }
                        }
                      }, _callee2, this);
                    }));
                    function read() {
                      return _read2.apply(this, arguments);
                    }
                    return read;
                  }() }, { key: "cancel", value: function cancel(reason) {
                    if (this._reader) {
                      this._reader.cancel(reason);
                    }
                    if (this._abortController) {
                      this._abortController.abort();
                    }
                  } }, { key: "isStreamingSupported", get: function get() {
                    return this._isStreamingSupported;
                  } }]);
                  return PDFFetchStreamRangeReader2;
                }();
              }]);
            });
          },
          901: function(__unused_webpack_module2, exports2, __webpack_require__2) {
            "use strict";
            __webpack_require__2(7658);
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.AnnotationLayer = void 0;
            var _display_utils2 = __webpack_require__2(9485);
            var _util2 = __webpack_require__2(7484);
            class AnnotationElementFactory {
              static create(parameters) {
                const subtype = parameters.data.annotationType;
                switch (subtype) {
                  case _util2.AnnotationType.LINK:
                    return new LinkAnnotationElement(parameters);
                  case _util2.AnnotationType.TEXT:
                    return new TextAnnotationElement(parameters);
                  case _util2.AnnotationType.WIDGET:
                    const fieldType = parameters.data.fieldType;
                    switch (fieldType) {
                      case "Tx":
                        return new TextWidgetAnnotationElement(parameters);
                      case "Btn":
                        if (parameters.data.radioButton) {
                          return new RadioButtonWidgetAnnotationElement(parameters);
                        } else if (parameters.data.checkBox) {
                          return new CheckboxWidgetAnnotationElement(parameters);
                        }
                        return new PushButtonWidgetAnnotationElement(parameters);
                      case "Ch":
                        return new ChoiceWidgetAnnotationElement(parameters);
                    }
                    return new WidgetAnnotationElement(parameters);
                  case _util2.AnnotationType.POPUP:
                    return new PopupAnnotationElement(parameters);
                  case _util2.AnnotationType.FREETEXT:
                    return new FreeTextAnnotationElement(parameters);
                  case _util2.AnnotationType.LINE:
                    return new LineAnnotationElement(parameters);
                  case _util2.AnnotationType.SQUARE:
                    return new SquareAnnotationElement(parameters);
                  case _util2.AnnotationType.CIRCLE:
                    return new CircleAnnotationElement(parameters);
                  case _util2.AnnotationType.POLYLINE:
                    return new PolylineAnnotationElement(parameters);
                  case _util2.AnnotationType.CARET:
                    return new CaretAnnotationElement(parameters);
                  case _util2.AnnotationType.INK:
                    return new InkAnnotationElement(parameters);
                  case _util2.AnnotationType.POLYGON:
                    return new PolygonAnnotationElement(parameters);
                  case _util2.AnnotationType.HIGHLIGHT:
                    return new HighlightAnnotationElement(parameters);
                  case _util2.AnnotationType.UNDERLINE:
                    return new UnderlineAnnotationElement(parameters);
                  case _util2.AnnotationType.SQUIGGLY:
                    return new SquigglyAnnotationElement(parameters);
                  case _util2.AnnotationType.STRIKEOUT:
                    return new StrikeOutAnnotationElement(parameters);
                  case _util2.AnnotationType.STAMP:
                    return new StampAnnotationElement(parameters);
                  case _util2.AnnotationType.FILEATTACHMENT:
                    return new FileAttachmentAnnotationElement(parameters);
                  default:
                    return new AnnotationElement(parameters);
                }
              }
            }
            class AnnotationElement {
              constructor(parameters, isRenderable = false, ignoreBorder = false) {
                this.isRenderable = isRenderable;
                this.data = parameters.data;
                this.layer = parameters.layer;
                this.page = parameters.page;
                this.viewport = parameters.viewport;
                this.linkService = parameters.linkService;
                this.downloadManager = parameters.downloadManager;
                this.imageResourcesPath = parameters.imageResourcesPath;
                this.renderInteractiveForms = parameters.renderInteractiveForms;
                this.svgFactory = parameters.svgFactory;
                if (isRenderable) {
                  this.container = this._createContainer(ignoreBorder);
                }
              }
              _createContainer(ignoreBorder = false) {
                const data = this.data, page = this.page, viewport = this.viewport;
                const container = document.createElement("section");
                let width = data.rect[2] - data.rect[0];
                let height = data.rect[3] - data.rect[1];
                container.setAttribute("data-annotation-id", data.id);
                const rect = _util2.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);
                container.style.transform = `matrix(${viewport.transform.join(",")})`;
                container.style.transformOrigin = `-${rect[0]}px -${rect[1]}px`;
                if (!ignoreBorder && data.borderStyle.width > 0) {
                  container.style.borderWidth = `${data.borderStyle.width}px`;
                  if (data.borderStyle.style !== _util2.AnnotationBorderStyleType.UNDERLINE) {
                    width = width - 2 * data.borderStyle.width;
                    height = height - 2 * data.borderStyle.width;
                  }
                  const horizontalRadius = data.borderStyle.horizontalCornerRadius;
                  const verticalRadius = data.borderStyle.verticalCornerRadius;
                  if (horizontalRadius > 0 || verticalRadius > 0) {
                    const radius = `${horizontalRadius}px / ${verticalRadius}px`;
                    container.style.borderRadius = radius;
                  }
                  switch (data.borderStyle.style) {
                    case _util2.AnnotationBorderStyleType.SOLID:
                      container.style.borderStyle = "solid";
                      break;
                    case _util2.AnnotationBorderStyleType.DASHED:
                      container.style.borderStyle = "dashed";
                      break;
                    case _util2.AnnotationBorderStyleType.BEVELED:
                      (0, _util2.warn)("Unimplemented border style: beveled");
                      break;
                    case _util2.AnnotationBorderStyleType.INSET:
                      (0, _util2.warn)("Unimplemented border style: inset");
                      break;
                    case _util2.AnnotationBorderStyleType.UNDERLINE:
                      container.style.borderBottomStyle = "solid";
                      break;
                    default:
                      break;
                  }
                  if (data.color) {
                    container.style.borderColor = _util2.Util.makeCssRgb(data.color[0] | 0, data.color[1] | 0, data.color[2] | 0);
                  } else {
                    container.style.borderWidth = 0;
                  }
                }
                container.style.left = `${rect[0]}px`;
                container.style.top = `${rect[1]}px`;
                container.style.width = `${width}px`;
                container.style.height = `${height}px`;
                return container;
              }
              _createPopup(container, trigger, data) {
                if (!trigger) {
                  trigger = document.createElement("div");
                  trigger.style.height = container.style.height;
                  trigger.style.width = container.style.width;
                  container.appendChild(trigger);
                }
                const popupElement = new PopupElement({
                  container,
                  trigger,
                  color: data.color,
                  title: data.title,
                  modificationDate: data.modificationDate,
                  contents: data.contents,
                  hideWrapper: true
                });
                const popup = popupElement.render();
                popup.style.left = container.style.width;
                container.appendChild(popup);
              }
              render() {
                (0, _util2.unreachable)("Abstract method `AnnotationElement.render` called");
              }
            }
            class LinkAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                const isRenderable = !!(parameters.data.url || parameters.data.dest || parameters.data.action);
                super(parameters, isRenderable);
              }
              render() {
                this.container.className = "linkAnnotation";
                const {
                  data,
                  linkService
                } = this;
                const link = document.createElement("a");
                if (data.url) {
                  (0, _display_utils2.addLinkAttributes)(link, {
                    url: data.url,
                    target: data.newWindow ? _display_utils2.LinkTarget.BLANK : linkService.externalLinkTarget,
                    rel: linkService.externalLinkRel,
                    enabled: linkService.externalLinkEnabled
                  });
                } else if (data.action) {
                  this._bindNamedAction(link, data.action);
                } else {
                  this._bindLink(link, data.dest);
                }
                this.container.appendChild(link);
                return this.container;
              }
              _bindLink(link, destination) {
                link.href = this.linkService.getDestinationHash(destination);
                link.onclick = () => {
                  if (destination) {
                    this.linkService.navigateTo(destination);
                  }
                  return false;
                };
                if (destination) {
                  link.className = "internalLink";
                }
              }
              _bindNamedAction(link, action) {
                link.href = this.linkService.getAnchorUrl("");
                link.onclick = () => {
                  this.linkService.executeNamedAction(action);
                  return false;
                };
                link.className = "internalLink";
              }
            }
            class TextAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                super(parameters, isRenderable);
              }
              render() {
                this.container.className = "textAnnotation";
                const image = document.createElement("img");
                image.style.height = this.container.style.height;
                image.style.width = this.container.style.width;
                image.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg";
                image.alt = "[{{type}} Annotation]";
                image.dataset.l10nId = "text_annotation_type";
                image.dataset.l10nArgs = JSON.stringify({
                  type: this.data.name
                });
                if (!this.data.hasPopup) {
                  this._createPopup(this.container, image, this.data);
                }
                this.container.appendChild(image);
                return this.container;
              }
            }
            class WidgetAnnotationElement extends AnnotationElement {
              render() {
                return this.container;
              }
            }
            class TextWidgetAnnotationElement extends WidgetAnnotationElement {
              constructor(parameters) {
                const isRenderable = parameters.renderInteractiveForms || !parameters.data.hasAppearance && !!parameters.data.fieldValue;
                super(parameters, isRenderable);
              }
              render() {
                const TEXT_ALIGNMENT = ["left", "center", "right"];
                this.container.className = "textWidgetAnnotation";
                let element = null;
                if (this.renderInteractiveForms) {
                  if (this.data.multiLine) {
                    element = document.createElement("textarea");
                    element.textContent = this.data.fieldValue;
                  } else {
                    element = document.createElement("input");
                    element.type = "text";
                    element.setAttribute("value", this.data.fieldValue);
                  }
                  element.disabled = this.data.readOnly;
                  if (this.data.maxLen !== null) {
                    element.maxLength = this.data.maxLen;
                  }
                  if (this.data.comb) {
                    const fieldWidth = this.data.rect[2] - this.data.rect[0];
                    const combWidth = fieldWidth / this.data.maxLen;
                    element.classList.add("comb");
                    element.style.letterSpacing = `calc(${combWidth}px - 1ch)`;
                  }
                } else {
                  element = document.createElement("div");
                  element.textContent = this.data.fieldValue;
                  element.style.verticalAlign = "middle";
                  element.style.display = "table-cell";
                  let font = null;
                  if (this.data.fontRefName && this.page.commonObjs.has(this.data.fontRefName)) {
                    font = this.page.commonObjs.get(this.data.fontRefName);
                  }
                  this._setTextStyle(element, font);
                }
                if (this.data.textAlignment !== null) {
                  element.style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];
                }
                this.container.appendChild(element);
                return this.container;
              }
              _setTextStyle(element, font) {
                const style = element.style;
                style.fontSize = `${this.data.fontSize}px`;
                style.direction = this.data.fontDirection < 0 ? "rtl" : "ltr";
                if (!font) {
                  return;
                }
                let bold = "normal";
                if (font.black) {
                  bold = "900";
                } else if (font.bold) {
                  bold = "bold";
                }
                style.fontWeight = bold;
                style.fontStyle = font.italic ? "italic" : "normal";
                const fontFamily = font.loadedName ? `"${font.loadedName}", ` : "";
                const fallbackName = font.fallbackName || "Helvetica, sans-serif";
                style.fontFamily = fontFamily + fallbackName;
              }
            }
            class CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {
              constructor(parameters) {
                super(parameters, parameters.renderInteractiveForms);
              }
              render() {
                this.container.className = "buttonWidgetAnnotation checkBox";
                const element = document.createElement("input");
                element.disabled = this.data.readOnly;
                element.type = "checkbox";
                if (this.data.fieldValue && this.data.fieldValue !== "Off") {
                  element.setAttribute("checked", true);
                }
                this.container.appendChild(element);
                return this.container;
              }
            }
            class RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {
              constructor(parameters) {
                super(parameters, parameters.renderInteractiveForms);
              }
              render() {
                this.container.className = "buttonWidgetAnnotation radioButton";
                const element = document.createElement("input");
                element.disabled = this.data.readOnly;
                element.type = "radio";
                element.name = this.data.fieldName;
                if (this.data.fieldValue === this.data.buttonValue) {
                  element.setAttribute("checked", true);
                }
                this.container.appendChild(element);
                return this.container;
              }
            }
            class PushButtonWidgetAnnotationElement extends LinkAnnotationElement {
              render() {
                const container = super.render();
                container.className = "buttonWidgetAnnotation pushButton";
                return container;
              }
            }
            class ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {
              constructor(parameters) {
                super(parameters, parameters.renderInteractiveForms);
              }
              render() {
                this.container.className = "choiceWidgetAnnotation";
                const selectElement = document.createElement("select");
                selectElement.disabled = this.data.readOnly;
                if (!this.data.combo) {
                  selectElement.size = this.data.options.length;
                  if (this.data.multiSelect) {
                    selectElement.multiple = true;
                  }
                }
                for (const option of this.data.options) {
                  const optionElement = document.createElement("option");
                  optionElement.textContent = option.displayValue;
                  optionElement.value = option.exportValue;
                  if (this.data.fieldValue.includes(option.displayValue)) {
                    optionElement.setAttribute("selected", true);
                  }
                  selectElement.appendChild(optionElement);
                }
                this.container.appendChild(selectElement);
                return this.container;
              }
            }
            class PopupAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                const isRenderable = !!(parameters.data.title || parameters.data.contents);
                super(parameters, isRenderable);
              }
              render() {
                const IGNORE_TYPES = ["Line", "Square", "Circle", "PolyLine", "Polygon", "Ink"];
                this.container.className = "popupAnnotation";
                if (IGNORE_TYPES.includes(this.data.parentType)) {
                  return this.container;
                }
                const selector = `[data-annotation-id="${this.data.parentId}"]`;
                const parentElement = this.layer.querySelector(selector);
                if (!parentElement) {
                  return this.container;
                }
                const popup = new PopupElement({
                  container: this.container,
                  trigger: parentElement,
                  color: this.data.color,
                  title: this.data.title,
                  modificationDate: this.data.modificationDate,
                  contents: this.data.contents
                });
                const parentLeft = parseFloat(parentElement.style.left);
                const parentWidth = parseFloat(parentElement.style.width);
                this.container.style.transformOrigin = `-${parentLeft + parentWidth}px -${parentElement.style.top}`;
                this.container.style.left = `${parentLeft + parentWidth}px`;
                this.container.appendChild(popup.render());
                return this.container;
              }
            }
            class PopupElement {
              constructor(parameters) {
                this.container = parameters.container;
                this.trigger = parameters.trigger;
                this.color = parameters.color;
                this.title = parameters.title;
                this.modificationDate = parameters.modificationDate;
                this.contents = parameters.contents;
                this.hideWrapper = parameters.hideWrapper || false;
                this.pinned = false;
              }
              render() {
                const BACKGROUND_ENLIGHT = 0.7;
                const wrapper = document.createElement("div");
                wrapper.className = "popupWrapper";
                this.hideElement = this.hideWrapper ? wrapper : this.container;
                this.hideElement.setAttribute("hidden", true);
                const popup = document.createElement("div");
                popup.className = "popup";
                const color = this.color;
                if (color) {
                  const r = BACKGROUND_ENLIGHT * (255 - color[0]) + color[0];
                  const g = BACKGROUND_ENLIGHT * (255 - color[1]) + color[1];
                  const b = BACKGROUND_ENLIGHT * (255 - color[2]) + color[2];
                  popup.style.backgroundColor = _util2.Util.makeCssRgb(r | 0, g | 0, b | 0);
                }
                const title = document.createElement("h1");
                title.textContent = this.title;
                popup.appendChild(title);
                const dateObject = _display_utils2.PDFDateString.toDateObject(this.modificationDate);
                if (dateObject) {
                  const modificationDate = document.createElement("span");
                  modificationDate.textContent = "{{date}}, {{time}}";
                  modificationDate.dataset.l10nId = "annotation_date_string";
                  modificationDate.dataset.l10nArgs = JSON.stringify({
                    date: dateObject.toLocaleDateString(),
                    time: dateObject.toLocaleTimeString()
                  });
                  popup.appendChild(modificationDate);
                }
                const contents = this._formatContents(this.contents);
                popup.appendChild(contents);
                this.trigger.addEventListener("click", this._toggle.bind(this));
                this.trigger.addEventListener("mouseover", this._show.bind(this, false));
                this.trigger.addEventListener("mouseout", this._hide.bind(this, false));
                popup.addEventListener("click", this._hide.bind(this, true));
                wrapper.appendChild(popup);
                return wrapper;
              }
              _formatContents(contents) {
                const p = document.createElement("p");
                const lines = contents.split(/(?:\r\n?|\n)/);
                for (let i = 0, ii = lines.length; i < ii; ++i) {
                  const line = lines[i];
                  p.appendChild(document.createTextNode(line));
                  if (i < ii - 1) {
                    p.appendChild(document.createElement("br"));
                  }
                }
                return p;
              }
              _toggle() {
                if (this.pinned) {
                  this._hide(true);
                } else {
                  this._show(true);
                }
              }
              _show(pin = false) {
                if (pin) {
                  this.pinned = true;
                }
                if (this.hideElement.hasAttribute("hidden")) {
                  this.hideElement.removeAttribute("hidden");
                  this.container.style.zIndex += 1;
                }
              }
              _hide(unpin = true) {
                if (unpin) {
                  this.pinned = false;
                }
                if (!this.hideElement.hasAttribute("hidden") && !this.pinned) {
                  this.hideElement.setAttribute("hidden", true);
                  this.container.style.zIndex -= 1;
                }
              }
            }
            class FreeTextAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                super(parameters, isRenderable, true);
              }
              render() {
                this.container.className = "freeTextAnnotation";
                if (!this.data.hasPopup) {
                  this._createPopup(this.container, null, this.data);
                }
                return this.container;
              }
            }
            class LineAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                super(parameters, isRenderable, true);
              }
              render() {
                this.container.className = "lineAnnotation";
                const data = this.data;
                const width = data.rect[2] - data.rect[0];
                const height = data.rect[3] - data.rect[1];
                const svg = this.svgFactory.create(width, height);
                const line = this.svgFactory.createElement("svg:line");
                line.setAttribute("x1", data.rect[2] - data.lineCoordinates[0]);
                line.setAttribute("y1", data.rect[3] - data.lineCoordinates[1]);
                line.setAttribute("x2", data.rect[2] - data.lineCoordinates[2]);
                line.setAttribute("y2", data.rect[3] - data.lineCoordinates[3]);
                line.setAttribute("stroke-width", data.borderStyle.width || 1);
                line.setAttribute("stroke", "transparent");
                svg.appendChild(line);
                this.container.append(svg);
                this._createPopup(this.container, line, data);
                return this.container;
              }
            }
            class SquareAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                super(parameters, isRenderable, true);
              }
              render() {
                this.container.className = "squareAnnotation";
                const data = this.data;
                const width = data.rect[2] - data.rect[0];
                const height = data.rect[3] - data.rect[1];
                const svg = this.svgFactory.create(width, height);
                const borderWidth = data.borderStyle.width;
                const square = this.svgFactory.createElement("svg:rect");
                square.setAttribute("x", borderWidth / 2);
                square.setAttribute("y", borderWidth / 2);
                square.setAttribute("width", width - borderWidth);
                square.setAttribute("height", height - borderWidth);
                square.setAttribute("stroke-width", borderWidth || 1);
                square.setAttribute("stroke", "transparent");
                square.setAttribute("fill", "none");
                svg.appendChild(square);
                this.container.append(svg);
                this._createPopup(this.container, square, data);
                return this.container;
              }
            }
            class CircleAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                super(parameters, isRenderable, true);
              }
              render() {
                this.container.className = "circleAnnotation";
                const data = this.data;
                const width = data.rect[2] - data.rect[0];
                const height = data.rect[3] - data.rect[1];
                const svg = this.svgFactory.create(width, height);
                const borderWidth = data.borderStyle.width;
                const circle = this.svgFactory.createElement("svg:ellipse");
                circle.setAttribute("cx", width / 2);
                circle.setAttribute("cy", height / 2);
                circle.setAttribute("rx", width / 2 - borderWidth / 2);
                circle.setAttribute("ry", height / 2 - borderWidth / 2);
                circle.setAttribute("stroke-width", borderWidth || 1);
                circle.setAttribute("stroke", "transparent");
                circle.setAttribute("fill", "none");
                svg.appendChild(circle);
                this.container.append(svg);
                this._createPopup(this.container, circle, data);
                return this.container;
              }
            }
            class PolylineAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                super(parameters, isRenderable, true);
                this.containerClassName = "polylineAnnotation";
                this.svgElementName = "svg:polyline";
              }
              render() {
                this.container.className = this.containerClassName;
                const data = this.data;
                const width = data.rect[2] - data.rect[0];
                const height = data.rect[3] - data.rect[1];
                const svg = this.svgFactory.create(width, height);
                let points = [];
                for (const coordinate of data.vertices) {
                  const x = coordinate.x - data.rect[0];
                  const y = data.rect[3] - coordinate.y;
                  points.push(x + "," + y);
                }
                points = points.join(" ");
                const polyline = this.svgFactory.createElement(this.svgElementName);
                polyline.setAttribute("points", points);
                polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
                polyline.setAttribute("stroke", "transparent");
                polyline.setAttribute("fill", "none");
                svg.appendChild(polyline);
                this.container.append(svg);
                this._createPopup(this.container, polyline, data);
                return this.container;
              }
            }
            class PolygonAnnotationElement extends PolylineAnnotationElement {
              constructor(parameters) {
                super(parameters);
                this.containerClassName = "polygonAnnotation";
                this.svgElementName = "svg:polygon";
              }
            }
            class CaretAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                super(parameters, isRenderable, true);
              }
              render() {
                this.container.className = "caretAnnotation";
                if (!this.data.hasPopup) {
                  this._createPopup(this.container, null, this.data);
                }
                return this.container;
              }
            }
            class InkAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                super(parameters, isRenderable, true);
                this.containerClassName = "inkAnnotation";
                this.svgElementName = "svg:polyline";
              }
              render() {
                this.container.className = this.containerClassName;
                const data = this.data;
                const width = data.rect[2] - data.rect[0];
                const height = data.rect[3] - data.rect[1];
                const svg = this.svgFactory.create(width, height);
                for (const inkList of data.inkLists) {
                  let points = [];
                  for (const coordinate of inkList) {
                    const x = coordinate.x - data.rect[0];
                    const y = data.rect[3] - coordinate.y;
                    points.push(`${x},${y}`);
                  }
                  points = points.join(" ");
                  const polyline = this.svgFactory.createElement(this.svgElementName);
                  polyline.setAttribute("points", points);
                  polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
                  polyline.setAttribute("stroke", "transparent");
                  polyline.setAttribute("fill", "none");
                  this._createPopup(this.container, polyline, data);
                  svg.appendChild(polyline);
                }
                this.container.append(svg);
                return this.container;
              }
            }
            class HighlightAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                super(parameters, isRenderable, true);
              }
              render() {
                this.container.className = "highlightAnnotation";
                if (!this.data.hasPopup) {
                  this._createPopup(this.container, null, this.data);
                }
                return this.container;
              }
            }
            class UnderlineAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                super(parameters, isRenderable, true);
              }
              render() {
                this.container.className = "underlineAnnotation";
                if (!this.data.hasPopup) {
                  this._createPopup(this.container, null, this.data);
                }
                return this.container;
              }
            }
            class SquigglyAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                super(parameters, isRenderable, true);
              }
              render() {
                this.container.className = "squigglyAnnotation";
                if (!this.data.hasPopup) {
                  this._createPopup(this.container, null, this.data);
                }
                return this.container;
              }
            }
            class StrikeOutAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                super(parameters, isRenderable, true);
              }
              render() {
                this.container.className = "strikeoutAnnotation";
                if (!this.data.hasPopup) {
                  this._createPopup(this.container, null, this.data);
                }
                return this.container;
              }
            }
            class StampAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
                super(parameters, isRenderable, true);
              }
              render() {
                this.container.className = "stampAnnotation";
                if (!this.data.hasPopup) {
                  this._createPopup(this.container, null, this.data);
                }
                return this.container;
              }
            }
            class FileAttachmentAnnotationElement extends AnnotationElement {
              constructor(parameters) {
                super(parameters, true);
                const {
                  filename,
                  content
                } = this.data.file;
                this.filename = (0, _display_utils2.getFilenameFromUrl)(filename);
                this.content = content;
                if (this.linkService.eventBus) {
                  this.linkService.eventBus.dispatch("fileattachmentannotation", {
                    source: this,
                    id: (0, _util2.stringToPDFString)(filename),
                    filename,
                    content
                  });
                }
              }
              render() {
                this.container.className = "fileAttachmentAnnotation";
                const trigger = document.createElement("div");
                trigger.style.height = this.container.style.height;
                trigger.style.width = this.container.style.width;
                trigger.addEventListener("dblclick", this._download.bind(this));
                if (!this.data.hasPopup && (this.data.title || this.data.contents)) {
                  this._createPopup(this.container, trigger, this.data);
                }
                this.container.appendChild(trigger);
                return this.container;
              }
              _download() {
                if (!this.downloadManager) {
                  (0, _util2.warn)("Download cannot be started due to unavailable download manager");
                  return;
                }
                this.downloadManager.downloadData(this.content, this.filename, "");
              }
            }
            class AnnotationLayer {
              static render(parameters) {
                const sortedAnnotations = [], popupAnnotations = [];
                for (const data of parameters.annotations) {
                  if (!data) {
                    continue;
                  }
                  if (data.annotationType === _util2.AnnotationType.POPUP) {
                    popupAnnotations.push(data);
                    continue;
                  }
                  sortedAnnotations.push(data);
                }
                if (popupAnnotations.length) {
                  sortedAnnotations.push(...popupAnnotations);
                }
                for (const data of sortedAnnotations) {
                  const element = AnnotationElementFactory.create({
                    data,
                    layer: parameters.div,
                    page: parameters.page,
                    viewport: parameters.viewport,
                    linkService: parameters.linkService,
                    downloadManager: parameters.downloadManager,
                    imageResourcesPath: parameters.imageResourcesPath || "",
                    renderInteractiveForms: parameters.renderInteractiveForms || false,
                    svgFactory: new _display_utils2.DOMSVGFactory()
                  });
                  if (element.isRenderable) {
                    parameters.div.appendChild(element.render());
                  }
                }
              }
              static update(parameters) {
                for (const data of parameters.annotations) {
                  const element = parameters.div.querySelector(`[data-annotation-id="${data.id}"]`);
                  if (element) {
                    element.style.transform = `matrix(${parameters.viewport.transform.join(",")})`;
                  }
                }
                parameters.div.removeAttribute("hidden");
              }
            }
            exports2.AnnotationLayer = AnnotationLayer;
          },
          6738: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            __webpack_require__(3408);
            __webpack_require__(4590);
            __webpack_require__(7658);
            Object.defineProperty(exports, "__esModule", {
              value: true
            });
            exports.getDocument = getDocument;
            exports.setPDFNetworkStreamFactory = setPDFNetworkStreamFactory;
            exports.build = exports.version = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFWorker = exports.PDFDataRangeTransport = exports.LoopbackPort = void 0;
            var _util = __webpack_require__(7484);
            var _display_utils = __webpack_require__(9485);
            var _font_loader = __webpack_require__(8096);
            var _api_compatibility = __webpack_require__(3528);
            var _canvas = __webpack_require__(193);
            var _worker_options = __webpack_require__(5864);
            var _is_node = __webpack_require__(2918);
            var _message_handler = __webpack_require__(9725);
            var _metadata = __webpack_require__(5554);
            var _transport_stream = __webpack_require__(1307);
            var _webgl = __webpack_require__(4708);
            const DEFAULT_RANGE_CHUNK_SIZE = 65536;
            const RENDERING_CANCELLED_TIMEOUT = 100;
            let createPDFNetworkStream;
            function setPDFNetworkStreamFactory(pdfNetworkStreamFactory) {
              createPDFNetworkStream = pdfNetworkStreamFactory;
            }
            function getDocument(src) {
              const task = new PDFDocumentLoadingTask();
              let source;
              if (typeof src === "string") {
                source = {
                  url: src
                };
              } else if ((0, _util.isArrayBuffer)(src)) {
                source = {
                  data: src
                };
              } else if (src instanceof PDFDataRangeTransport) {
                source = {
                  range: src
                };
              } else {
                if (typeof src !== "object") {
                  throw new Error("Invalid parameter in getDocument, need either Uint8Array, string or a parameter object");
                }
                if (!src.url && !src.data && !src.range) {
                  throw new Error("Invalid parameter object: need either .data, .range or .url");
                }
                source = src;
              }
              const params = /* @__PURE__ */ Object.create(null);
              let rangeTransport = null, worker2 = null;
              for (const key in source) {
                if (key === "url" && typeof window !== "undefined") {
                  params[key] = new URL(source[key], window.location).href;
                  continue;
                } else if (key === "range") {
                  rangeTransport = source[key];
                  continue;
                } else if (key === "worker") {
                  worker2 = source[key];
                  continue;
                } else if (key === "data" && !(source[key] instanceof Uint8Array)) {
                  const pdfBytes = source[key];
                  if (typeof pdfBytes === "string") {
                    params[key] = (0, _util.stringToBytes)(pdfBytes);
                  } else if (typeof pdfBytes === "object" && pdfBytes !== null && !isNaN(pdfBytes.length)) {
                    params[key] = new Uint8Array(pdfBytes);
                  } else if ((0, _util.isArrayBuffer)(pdfBytes)) {
                    params[key] = new Uint8Array(pdfBytes);
                  } else {
                    throw new Error("Invalid PDF binary data: either typed array, string or array-like object is expected in the data property.");
                  }
                  continue;
                }
                params[key] = source[key];
              }
              params.rangeChunkSize = params.rangeChunkSize || DEFAULT_RANGE_CHUNK_SIZE;
              params.CMapReaderFactory = params.CMapReaderFactory || _display_utils.DOMCMapReaderFactory;
              params.ignoreErrors = params.stopAtErrors !== true;
              params.pdfBug = params.pdfBug === true;
              const NativeImageDecoderValues = Object.values(_util.NativeImageDecoding);
              if (params.nativeImageDecoderSupport === void 0 || !NativeImageDecoderValues.includes(params.nativeImageDecoderSupport)) {
                params.nativeImageDecoderSupport = _api_compatibility.apiCompatibilityParams.nativeImageDecoderSupport || _util.NativeImageDecoding.DECODE;
              }
              if (!Number.isInteger(params.maxImageSize)) {
                params.maxImageSize = -1;
              }
              if (typeof params.isEvalSupported !== "boolean") {
                params.isEvalSupported = true;
              }
              if (typeof params.disableFontFace !== "boolean") {
                params.disableFontFace = _api_compatibility.apiCompatibilityParams.disableFontFace || false;
              }
              if (typeof params.disableRange !== "boolean") {
                params.disableRange = false;
              }
              if (typeof params.disableStream !== "boolean") {
                params.disableStream = false;
              }
              if (typeof params.disableAutoFetch !== "boolean") {
                params.disableAutoFetch = false;
              }
              if (typeof params.disableCreateObjectURL !== "boolean") {
                params.disableCreateObjectURL = _api_compatibility.apiCompatibilityParams.disableCreateObjectURL || false;
              }
              (0, _util.setVerbosityLevel)(params.verbosity);
              if (!worker2) {
                const workerParams = {
                  verbosity: params.verbosity,
                  port: _worker_options.GlobalWorkerOptions.workerPort
                };
                worker2 = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams);
                task._worker = worker2;
              }
              const docId = task.docId;
              worker2.promise.then(function() {
                if (task.destroyed) {
                  throw new Error("Loading aborted");
                }
                return _fetchDocument(worker2, params, rangeTransport, docId).then(function(workerId) {
                  if (task.destroyed) {
                    throw new Error("Loading aborted");
                  }
                  let networkStream;
                  if (rangeTransport) {
                    networkStream = new _transport_stream.PDFDataTransportStream({
                      length: params.length,
                      initialData: params.initialData,
                      progressiveDone: params.progressiveDone,
                      disableRange: params.disableRange,
                      disableStream: params.disableStream
                    }, rangeTransport);
                  } else if (!params.data) {
                    networkStream = createPDFNetworkStream({
                      url: params.url,
                      length: params.length,
                      httpHeaders: params.httpHeaders,
                      withCredentials: params.withCredentials,
                      rangeChunkSize: params.rangeChunkSize,
                      disableRange: params.disableRange,
                      disableStream: params.disableStream
                    });
                  }
                  const messageHandler = new _message_handler.MessageHandler(docId, workerId, worker2.port);
                  messageHandler.postMessageTransfers = worker2.postMessageTransfers;
                  const transport = new WorkerTransport(messageHandler, task, networkStream, params);
                  task._transport = transport;
                  messageHandler.send("Ready", null);
                });
              }).catch(task._capability.reject);
              return task;
            }
            function _fetchDocument(worker2, source, pdfDataRangeTransport, docId) {
              if (worker2.destroyed) {
                return Promise.reject(new Error("Worker was destroyed"));
              }
              if (pdfDataRangeTransport) {
                source.length = pdfDataRangeTransport.length;
                source.initialData = pdfDataRangeTransport.initialData;
                source.progressiveDone = pdfDataRangeTransport.progressiveDone;
              }
              return worker2.messageHandler.sendWithPromise("GetDocRequest", {
                docId,
                apiVersion: "2.4.456",
                source: {
                  data: source.data,
                  url: source.url,
                  password: source.password,
                  disableAutoFetch: source.disableAutoFetch,
                  rangeChunkSize: source.rangeChunkSize,
                  length: source.length
                },
                maxImageSize: source.maxImageSize,
                disableFontFace: source.disableFontFace,
                disableCreateObjectURL: source.disableCreateObjectURL,
                postMessageTransfers: worker2.postMessageTransfers,
                docBaseUrl: source.docBaseUrl,
                nativeImageDecoderSupport: source.nativeImageDecoderSupport,
                ignoreErrors: source.ignoreErrors,
                isEvalSupported: source.isEvalSupported
              }).then(function(workerId) {
                if (worker2.destroyed) {
                  throw new Error("Worker was destroyed");
                }
                return workerId;
              });
            }
            const PDFDocumentLoadingTask = function PDFDocumentLoadingTaskClosure() {
              let nextDocumentId = 0;
              class PDFDocumentLoadingTask2 {
                constructor() {
                  this._capability = (0, _util.createPromiseCapability)();
                  this._transport = null;
                  this._worker = null;
                  this.docId = "d" + nextDocumentId++;
                  this.destroyed = false;
                  this.onPassword = null;
                  this.onProgress = null;
                  this.onUnsupportedFeature = null;
                }
                get promise() {
                  return this._capability.promise;
                }
                destroy() {
                  this.destroyed = true;
                  const transportDestroyed = !this._transport ? Promise.resolve() : this._transport.destroy();
                  return transportDestroyed.then(() => {
                    this._transport = null;
                    if (this._worker) {
                      this._worker.destroy();
                      this._worker = null;
                    }
                  });
                }
                then(onFulfilled, onRejected) {
                  throw new Error("Removed API method: PDFDocumentLoadingTask.then, use the `promise` getter instead.");
                }
              }
              return PDFDocumentLoadingTask2;
            }();
            class PDFDataRangeTransport {
              constructor(length, initialData, progressiveDone = false) {
                this.length = length;
                this.initialData = initialData;
                this.progressiveDone = progressiveDone;
                this._rangeListeners = [];
                this._progressListeners = [];
                this._progressiveReadListeners = [];
                this._progressiveDoneListeners = [];
                this._readyCapability = (0, _util.createPromiseCapability)();
              }
              addRangeListener(listener) {
                this._rangeListeners.push(listener);
              }
              addProgressListener(listener) {
                this._progressListeners.push(listener);
              }
              addProgressiveReadListener(listener) {
                this._progressiveReadListeners.push(listener);
              }
              addProgressiveDoneListener(listener) {
                this._progressiveDoneListeners.push(listener);
              }
              onDataRange(begin, chunk) {
                for (const listener of this._rangeListeners) {
                  listener(begin, chunk);
                }
              }
              onDataProgress(loaded, total) {
                this._readyCapability.promise.then(() => {
                  for (const listener of this._progressListeners) {
                    listener(loaded, total);
                  }
                });
              }
              onDataProgressiveRead(chunk) {
                this._readyCapability.promise.then(() => {
                  for (const listener of this._progressiveReadListeners) {
                    listener(chunk);
                  }
                });
              }
              onDataProgressiveDone() {
                this._readyCapability.promise.then(() => {
                  for (const listener of this._progressiveDoneListeners) {
                    listener();
                  }
                });
              }
              transportReady() {
                this._readyCapability.resolve();
              }
              requestDataRange(begin, end) {
                (0, _util.unreachable)("Abstract method PDFDataRangeTransport.requestDataRange");
              }
              abort() {
              }
            }
            exports.PDFDataRangeTransport = PDFDataRangeTransport;
            class PDFDocumentProxy {
              constructor(pdfInfo, transport) {
                this._pdfInfo = pdfInfo;
                this._transport = transport;
              }
              get numPages() {
                return this._pdfInfo.numPages;
              }
              get fingerprint() {
                return this._pdfInfo.fingerprint;
              }
              getPage(pageNumber) {
                return this._transport.getPage(pageNumber);
              }
              getPageIndex(ref) {
                return this._transport.getPageIndex(ref);
              }
              getDestinations() {
                return this._transport.getDestinations();
              }
              getDestination(id) {
                return this._transport.getDestination(id);
              }
              getPageLabels() {
                return this._transport.getPageLabels();
              }
              getPageLayout() {
                return this._transport.getPageLayout();
              }
              getPageMode() {
                return this._transport.getPageMode();
              }
              getViewerPreferences() {
                return this._transport.getViewerPreferences();
              }
              getOpenAction() {
                return this._transport.getOpenAction();
              }
              getOpenActionDestination() {
                (0, _display_utils.deprecated)("getOpenActionDestination, use getOpenAction instead.");
                return this.getOpenAction().then(function(openAction) {
                  return openAction && openAction.dest ? openAction.dest : null;
                });
              }
              getAttachments() {
                return this._transport.getAttachments();
              }
              getJavaScript() {
                return this._transport.getJavaScript();
              }
              getOutline() {
                return this._transport.getOutline();
              }
              getPermissions() {
                return this._transport.getPermissions();
              }
              getMetadata() {
                return this._transport.getMetadata();
              }
              getData() {
                return this._transport.getData();
              }
              getDownloadInfo() {
                return this._transport.downloadInfoCapability.promise;
              }
              getStats() {
                return this._transport.getStats();
              }
              cleanup() {
                return this._transport.startCleanup();
              }
              destroy() {
                return this.loadingTask.destroy();
              }
              get loadingParams() {
                return this._transport.loadingParams;
              }
              get loadingTask() {
                return this._transport.loadingTask;
              }
            }
            exports.PDFDocumentProxy = PDFDocumentProxy;
            class PDFPageProxy {
              constructor(pageIndex, pageInfo, transport, pdfBug = false) {
                this._pageIndex = pageIndex;
                this._pageInfo = pageInfo;
                this._transport = transport;
                this._stats = pdfBug ? new _display_utils.StatTimer() : null;
                this._pdfBug = pdfBug;
                this.commonObjs = transport.commonObjs;
                this.objs = new PDFObjects();
                this.cleanupAfterRender = false;
                this.pendingCleanup = false;
                this.intentStates = /* @__PURE__ */ Object.create(null);
                this.destroyed = false;
              }
              get pageNumber() {
                return this._pageIndex + 1;
              }
              get rotate() {
                return this._pageInfo.rotate;
              }
              get ref() {
                return this._pageInfo.ref;
              }
              get userUnit() {
                return this._pageInfo.userUnit;
              }
              get view() {
                return this._pageInfo.view;
              }
              getViewport({
                scale,
                rotation = this.rotate,
                offsetX = 0,
                offsetY = 0,
                dontFlip = false
              } = {}) {
                if (arguments.length > 1 || typeof arguments[0] === "number") {
                  throw new Error("PDFPageProxy.getViewport is called with obsolete arguments.");
                }
                return new _display_utils.PageViewport({
                  viewBox: this.view,
                  scale,
                  rotation,
                  offsetX,
                  offsetY,
                  dontFlip
                });
              }
              getAnnotations({
                intent = null
              } = {}) {
                if (!this.annotationsPromise || this.annotationsIntent !== intent) {
                  this.annotationsPromise = this._transport.getAnnotations(this._pageIndex, intent);
                  this.annotationsIntent = intent;
                }
                return this.annotationsPromise;
              }
              render({
                canvasContext,
                viewport,
                intent = "display",
                enableWebGL = false,
                renderInteractiveForms = false,
                transform = null,
                imageLayer = null,
                canvasFactory = null,
                background = null
              }) {
                if (this._stats) {
                  this._stats.time("Overall");
                }
                const renderingIntent = intent === "print" ? "print" : "display";
                this.pendingCleanup = false;
                if (!this.intentStates[renderingIntent]) {
                  this.intentStates[renderingIntent] = /* @__PURE__ */ Object.create(null);
                }
                const intentState = this.intentStates[renderingIntent];
                if (intentState.streamReaderCancelTimeout) {
                  clearTimeout(intentState.streamReaderCancelTimeout);
                  intentState.streamReaderCancelTimeout = null;
                }
                const canvasFactoryInstance = canvasFactory || new _display_utils.DOMCanvasFactory();
                const webGLContext = new _webgl.WebGLContext({
                  enable: enableWebGL
                });
                if (!intentState.displayReadyCapability) {
                  intentState.displayReadyCapability = (0, _util.createPromiseCapability)();
                  intentState.operatorList = {
                    fnArray: [],
                    argsArray: [],
                    lastChunk: false
                  };
                  if (this._stats) {
                    this._stats.time("Page Request");
                  }
                  this._pumpOperatorList({
                    pageIndex: this._pageIndex,
                    intent: renderingIntent,
                    renderInteractiveForms: renderInteractiveForms === true
                  });
                }
                const complete = (error) => {
                  const i = intentState.renderTasks.indexOf(internalRenderTask);
                  if (i >= 0) {
                    intentState.renderTasks.splice(i, 1);
                  }
                  if (this.cleanupAfterRender || renderingIntent === "print") {
                    this.pendingCleanup = true;
                  }
                  this._tryCleanup();
                  if (error) {
                    internalRenderTask.capability.reject(error);
                    this._abortOperatorList({
                      intentState,
                      reason: error
                    });
                  } else {
                    internalRenderTask.capability.resolve();
                  }
                  if (this._stats) {
                    this._stats.timeEnd("Rendering");
                    this._stats.timeEnd("Overall");
                  }
                };
                const internalRenderTask = new InternalRenderTask({
                  callback: complete,
                  params: {
                    canvasContext,
                    viewport,
                    transform,
                    imageLayer,
                    background
                  },
                  objs: this.objs,
                  commonObjs: this.commonObjs,
                  operatorList: intentState.operatorList,
                  pageIndex: this._pageIndex,
                  canvasFactory: canvasFactoryInstance,
                  webGLContext,
                  useRequestAnimationFrame: renderingIntent !== "print",
                  pdfBug: this._pdfBug
                });
                if (!intentState.renderTasks) {
                  intentState.renderTasks = [];
                }
                intentState.renderTasks.push(internalRenderTask);
                const renderTask = internalRenderTask.task;
                intentState.displayReadyCapability.promise.then((transparency) => {
                  if (this.pendingCleanup) {
                    complete();
                    return;
                  }
                  if (this._stats) {
                    this._stats.time("Rendering");
                  }
                  internalRenderTask.initializeGraphics(transparency);
                  internalRenderTask.operatorListChanged();
                }).catch(complete);
                return renderTask;
              }
              getOperatorList() {
                function operatorListChanged() {
                  if (intentState.operatorList.lastChunk) {
                    intentState.opListReadCapability.resolve(intentState.operatorList);
                    const i = intentState.renderTasks.indexOf(opListTask);
                    if (i >= 0) {
                      intentState.renderTasks.splice(i, 1);
                    }
                  }
                }
                const renderingIntent = "oplist";
                if (!this.intentStates[renderingIntent]) {
                  this.intentStates[renderingIntent] = /* @__PURE__ */ Object.create(null);
                }
                const intentState = this.intentStates[renderingIntent];
                let opListTask;
                if (!intentState.opListReadCapability) {
                  opListTask = {};
                  opListTask.operatorListChanged = operatorListChanged;
                  intentState.opListReadCapability = (0, _util.createPromiseCapability)();
                  intentState.renderTasks = [];
                  intentState.renderTasks.push(opListTask);
                  intentState.operatorList = {
                    fnArray: [],
                    argsArray: [],
                    lastChunk: false
                  };
                  if (this._stats) {
                    this._stats.time("Page Request");
                  }
                  this._pumpOperatorList({
                    pageIndex: this._pageIndex,
                    intent: renderingIntent
                  });
                }
                return intentState.opListReadCapability.promise;
              }
              streamTextContent({
                normalizeWhitespace = false,
                disableCombineTextItems = false
              } = {}) {
                const TEXT_CONTENT_CHUNK_SIZE = 100;
                return this._transport.messageHandler.sendWithStream("GetTextContent", {
                  pageIndex: this._pageIndex,
                  normalizeWhitespace: normalizeWhitespace === true,
                  combineTextItems: disableCombineTextItems !== true
                }, {
                  highWaterMark: TEXT_CONTENT_CHUNK_SIZE,
                  size(textContent) {
                    return textContent.items.length;
                  }
                });
              }
              getTextContent(params = {}) {
                const readableStream = this.streamTextContent(params);
                return new Promise(function(resolve, reject) {
                  function pump() {
                    reader.read().then(function({
                      value,
                      done
                    }) {
                      if (done) {
                        resolve(textContent);
                        return;
                      }
                      Object.assign(textContent.styles, value.styles);
                      textContent.items.push(...value.items);
                      pump();
                    }, reject);
                  }
                  const reader = readableStream.getReader();
                  const textContent = {
                    items: [],
                    styles: /* @__PURE__ */ Object.create(null)
                  };
                  pump();
                });
              }
              _destroy() {
                this.destroyed = true;
                this._transport.pageCache[this._pageIndex] = null;
                const waitOn = [];
                Object.keys(this.intentStates).forEach((intent) => {
                  const intentState = this.intentStates[intent];
                  this._abortOperatorList({
                    intentState,
                    reason: new Error("Page was destroyed."),
                    force: true
                  });
                  if (intent === "oplist") {
                    return;
                  }
                  intentState.renderTasks.forEach(function(renderTask) {
                    const renderCompleted = renderTask.capability.promise.catch(function() {
                    });
                    waitOn.push(renderCompleted);
                    renderTask.cancel();
                  });
                });
                this.objs.clear();
                this.annotationsPromise = null;
                this.pendingCleanup = false;
                return Promise.all(waitOn);
              }
              cleanup(resetStats = false) {
                this.pendingCleanup = true;
                return this._tryCleanup(resetStats);
              }
              _tryCleanup(resetStats = false) {
                if (!this.pendingCleanup || Object.keys(this.intentStates).some((intent) => {
                  const intentState = this.intentStates[intent];
                  return intentState.renderTasks.length !== 0 || !intentState.operatorList.lastChunk;
                })) {
                  return false;
                }
                Object.keys(this.intentStates).forEach((intent) => {
                  delete this.intentStates[intent];
                });
                this.objs.clear();
                this.annotationsPromise = null;
                if (resetStats && this._stats) {
                  this._stats = new _display_utils.StatTimer();
                }
                this.pendingCleanup = false;
                return true;
              }
              _startRenderPage(transparency, intent) {
                const intentState = this.intentStates[intent];
                if (!intentState) {
                  return;
                }
                if (this._stats) {
                  this._stats.timeEnd("Page Request");
                }
                if (intentState.displayReadyCapability) {
                  intentState.displayReadyCapability.resolve(transparency);
                }
              }
              _renderPageChunk(operatorListChunk, intentState) {
                for (let i = 0, ii = operatorListChunk.length; i < ii; i++) {
                  intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);
                  intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);
                }
                intentState.operatorList.lastChunk = operatorListChunk.lastChunk;
                for (let i = 0; i < intentState.renderTasks.length; i++) {
                  intentState.renderTasks[i].operatorListChanged();
                }
                if (operatorListChunk.lastChunk) {
                  this._tryCleanup();
                }
              }
              _pumpOperatorList(args) {
                (0, _util.assert)(args.intent, 'PDFPageProxy._pumpOperatorList: Expected "intent" argument.');
                const readableStream = this._transport.messageHandler.sendWithStream("GetOperatorList", args);
                const reader = readableStream.getReader();
                const intentState = this.intentStates[args.intent];
                intentState.streamReader = reader;
                const pump = () => {
                  reader.read().then(({
                    value,
                    done
                  }) => {
                    if (done) {
                      intentState.streamReader = null;
                      return;
                    }
                    if (this._transport.destroyed) {
                      return;
                    }
                    this._renderPageChunk(value, intentState);
                    pump();
                  }, (reason) => {
                    intentState.streamReader = null;
                    if (this._transport.destroyed) {
                      return;
                    }
                    if (intentState.operatorList) {
                      intentState.operatorList.lastChunk = true;
                      for (let i = 0; i < intentState.renderTasks.length; i++) {
                        intentState.renderTasks[i].operatorListChanged();
                      }
                      this._tryCleanup();
                    }
                    if (intentState.displayReadyCapability) {
                      intentState.displayReadyCapability.reject(reason);
                    } else if (intentState.opListReadCapability) {
                      intentState.opListReadCapability.reject(reason);
                    } else {
                      throw reason;
                    }
                  });
                };
                pump();
              }
              _abortOperatorList({
                intentState,
                reason,
                force = false
              }) {
                (0, _util.assert)(reason instanceof Error || typeof reason === "object" && reason !== null, 'PDFPageProxy._abortOperatorList: Expected "reason" argument.');
                if (!intentState.streamReader) {
                  return;
                }
                if (!force) {
                  if (intentState.renderTasks.length !== 0) {
                    return;
                  }
                  if (reason instanceof _display_utils.RenderingCancelledException) {
                    intentState.streamReaderCancelTimeout = setTimeout(() => {
                      this._abortOperatorList({
                        intentState,
                        reason,
                        force: true
                      });
                      intentState.streamReaderCancelTimeout = null;
                    }, RENDERING_CANCELLED_TIMEOUT);
                    return;
                  }
                }
                intentState.streamReader.cancel(new _util.AbortException(reason && reason.message));
                intentState.streamReader = null;
                if (this._transport.destroyed) {
                  return;
                }
                Object.keys(this.intentStates).some((intent) => {
                  if (this.intentStates[intent] === intentState) {
                    delete this.intentStates[intent];
                    return true;
                  }
                  return false;
                });
                this.cleanup();
              }
              get stats() {
                return this._stats;
              }
            }
            exports.PDFPageProxy = PDFPageProxy;
            class LoopbackPort {
              constructor(defer = true) {
                this._listeners = [];
                this._defer = defer;
                this._deferred = Promise.resolve(void 0);
              }
              postMessage(obj, transfers) {
                function cloneValue(value) {
                  if (typeof value !== "object" || value === null) {
                    return value;
                  }
                  if (cloned.has(value)) {
                    return cloned.get(value);
                  }
                  let buffer, result;
                  if ((buffer = value.buffer) && (0, _util.isArrayBuffer)(buffer)) {
                    const transferable = transfers && transfers.includes(buffer);
                    if (transferable) {
                      result = new value.constructor(buffer, value.byteOffset, value.byteLength);
                    } else {
                      result = new value.constructor(value);
                    }
                    cloned.set(value, result);
                    return result;
                  }
                  result = Array.isArray(value) ? [] : {};
                  cloned.set(value, result);
                  for (const i in value) {
                    let desc, p = value;
                    while (!(desc = Object.getOwnPropertyDescriptor(p, i))) {
                      p = Object.getPrototypeOf(p);
                    }
                    if (typeof desc.value === "undefined") {
                      continue;
                    }
                    if (typeof desc.value === "function") {
                      if (value.hasOwnProperty && value.hasOwnProperty(i)) {
                        throw new Error(`LoopbackPort.postMessage - cannot clone: ${value[i]}`);
                      }
                      continue;
                    }
                    result[i] = cloneValue(desc.value);
                  }
                  return result;
                }
                if (!this._defer) {
                  this._listeners.forEach((listener) => {
                    listener.call(this, {
                      data: obj
                    });
                  });
                  return;
                }
                const cloned = /* @__PURE__ */ new WeakMap();
                const e = {
                  data: cloneValue(obj)
                };
                this._deferred.then(() => {
                  this._listeners.forEach((listener) => {
                    listener.call(this, e);
                  });
                });
              }
              addEventListener(name, listener) {
                this._listeners.push(listener);
              }
              removeEventListener(name, listener) {
                const i = this._listeners.indexOf(listener);
                this._listeners.splice(i, 1);
              }
              terminate() {
                this._listeners.length = 0;
              }
            }
            exports.LoopbackPort = LoopbackPort;
            const PDFWorker = function PDFWorkerClosure() {
              const pdfWorkerPorts = /* @__PURE__ */ new WeakMap();
              let isWorkerDisabled = false;
              let fallbackWorkerSrc;
              let nextFakeWorkerId = 0;
              let fakeWorkerCapability;
              if (_is_node.isNodeJS && true) {
                isWorkerDisabled = true;
                fallbackWorkerSrc = "../pdf.worker.js";
              } else if (typeof document === "object" && "currentScript" in document) {
                const pdfjsFilePath2 = document.currentScript && document.currentScript.src;
                if (pdfjsFilePath2) {
                  fallbackWorkerSrc = pdfjsFilePath2.replace(/(\.(?:min\.)?js)(\?.*)?$/i, ".worker$1$2");
                }
              }
              function getWorkerSrc() {
                if (_worker_options.GlobalWorkerOptions.workerSrc) {
                  return _worker_options.GlobalWorkerOptions.workerSrc;
                }
                if (typeof fallbackWorkerSrc !== "undefined") {
                  if (!_is_node.isNodeJS) {
                    (0, _display_utils.deprecated)('No "GlobalWorkerOptions.workerSrc" specified.');
                  }
                  return fallbackWorkerSrc;
                }
                throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
              }
              function getMainThreadWorkerMessageHandler() {
                let mainWorkerMessageHandler2;
                try {
                  mainWorkerMessageHandler2 = globalThis.pdfjsWorker && globalThis.pdfjsWorker.WorkerMessageHandler;
                } catch (ex) {
                }
                return mainWorkerMessageHandler2 || null;
              }
              function setupFakeWorkerGlobal() {
                if (fakeWorkerCapability) {
                  return fakeWorkerCapability.promise;
                }
                fakeWorkerCapability = (0, _util.createPromiseCapability)();
                const loader = async function() {
                  const mainWorkerMessageHandler = getMainThreadWorkerMessageHandler();
                  if (mainWorkerMessageHandler) {
                    return mainWorkerMessageHandler;
                  }
                  if (_is_node.isNodeJS && true) {
                    const worker = eval("require")(getWorkerSrc());
                    return worker.WorkerMessageHandler;
                  }
                  await (0, _display_utils.loadScript)(getWorkerSrc());
                  return window.pdfjsWorker.WorkerMessageHandler;
                };
                loader().then(fakeWorkerCapability.resolve, fakeWorkerCapability.reject);
                return fakeWorkerCapability.promise;
              }
              function createCDNWrapper(url) {
                const wrapper = "importScripts('" + url + "');";
                return URL.createObjectURL(new Blob([wrapper]));
              }
              class PDFWorker {
                constructor({
                  name = null,
                  port = null,
                  verbosity = (0, _util.getVerbosityLevel)()
                } = {}) {
                  if (port && pdfWorkerPorts.has(port)) {
                    throw new Error("Cannot use more than one PDFWorker per port");
                  }
                  this.name = name;
                  this.destroyed = false;
                  this.postMessageTransfers = true;
                  this.verbosity = verbosity;
                  this._readyCapability = (0, _util.createPromiseCapability)();
                  this._port = null;
                  this._webWorker = null;
                  this._messageHandler = null;
                  if (port) {
                    pdfWorkerPorts.set(port, this);
                    this._initializeFromPort(port);
                    return;
                  }
                  this._initialize();
                }
                get promise() {
                  return this._readyCapability.promise;
                }
                get port() {
                  return this._port;
                }
                get messageHandler() {
                  return this._messageHandler;
                }
                _initializeFromPort(port) {
                  this._port = port;
                  this._messageHandler = new _message_handler.MessageHandler("main", "worker", port);
                  this._messageHandler.on("ready", function() {
                  });
                  this._readyCapability.resolve();
                }
                _initialize() {
                  if (typeof Worker !== "undefined" && !isWorkerDisabled && !getMainThreadWorkerMessageHandler()) {
                    let workerSrc = getWorkerSrc();
                    try {
                      if (!(0, _util.isSameOrigin)(window.location.href, workerSrc)) {
                        workerSrc = createCDNWrapper(new URL(workerSrc, window.location).href);
                      }
                      const worker2 = new Worker(workerSrc);
                      const messageHandler = new _message_handler.MessageHandler("main", "worker", worker2);
                      const terminateEarly = () => {
                        worker2.removeEventListener("error", onWorkerError);
                        messageHandler.destroy();
                        worker2.terminate();
                        if (this.destroyed) {
                          this._readyCapability.reject(new Error("Worker was destroyed"));
                        } else {
                          this._setupFakeWorker();
                        }
                      };
                      const onWorkerError = () => {
                        if (!this._webWorker) {
                          terminateEarly();
                        }
                      };
                      worker2.addEventListener("error", onWorkerError);
                      messageHandler.on("test", (data) => {
                        worker2.removeEventListener("error", onWorkerError);
                        if (this.destroyed) {
                          terminateEarly();
                          return;
                        }
                        if (data) {
                          this._messageHandler = messageHandler;
                          this._port = worker2;
                          this._webWorker = worker2;
                          if (!data.supportTransfers) {
                            this.postMessageTransfers = false;
                          }
                          this._readyCapability.resolve();
                          messageHandler.send("configure", {
                            verbosity: this.verbosity
                          });
                        } else {
                          this._setupFakeWorker();
                          messageHandler.destroy();
                          worker2.terminate();
                        }
                      });
                      messageHandler.on("ready", (data) => {
                        worker2.removeEventListener("error", onWorkerError);
                        if (this.destroyed) {
                          terminateEarly();
                          return;
                        }
                        try {
                          sendTest();
                        } catch (e) {
                          this._setupFakeWorker();
                        }
                      });
                      const sendTest = () => {
                        const testObj = new Uint8Array([this.postMessageTransfers ? 255 : 0]);
                        try {
                          messageHandler.send("test", testObj, [testObj.buffer]);
                        } catch (ex) {
                          (0, _util.warn)("Cannot use postMessage transfers.");
                          testObj[0] = 0;
                          messageHandler.send("test", testObj);
                        }
                      };
                      sendTest();
                      return;
                    } catch (e) {
                      (0, _util.info)("The worker has been disabled.");
                    }
                  }
                  this._setupFakeWorker();
                }
                _setupFakeWorker() {
                  if (!isWorkerDisabled) {
                    (0, _util.warn)("Setting up fake worker.");
                    isWorkerDisabled = true;
                  }
                  setupFakeWorkerGlobal().then((WorkerMessageHandler) => {
                    if (this.destroyed) {
                      this._readyCapability.reject(new Error("Worker was destroyed"));
                      return;
                    }
                    const port = new LoopbackPort();
                    this._port = port;
                    const id = "fake" + nextFakeWorkerId++;
                    const workerHandler = new _message_handler.MessageHandler(id + "_worker", id, port);
                    WorkerMessageHandler.setup(workerHandler, port);
                    const messageHandler = new _message_handler.MessageHandler(id, id + "_worker", port);
                    this._messageHandler = messageHandler;
                    this._readyCapability.resolve();
                    messageHandler.send("configure", {
                      verbosity: this.verbosity
                    });
                  }).catch((reason) => {
                    this._readyCapability.reject(new Error(`Setting up fake worker failed: "${reason.message}".`));
                  });
                }
                destroy() {
                  this.destroyed = true;
                  if (this._webWorker) {
                    this._webWorker.terminate();
                    this._webWorker = null;
                  }
                  pdfWorkerPorts.delete(this._port);
                  this._port = null;
                  if (this._messageHandler) {
                    this._messageHandler.destroy();
                    this._messageHandler = null;
                  }
                }
                static fromPort(params) {
                  if (!params || !params.port) {
                    throw new Error("PDFWorker.fromPort - invalid method signature.");
                  }
                  if (pdfWorkerPorts.has(params.port)) {
                    return pdfWorkerPorts.get(params.port);
                  }
                  return new PDFWorker(params);
                }
                static getWorkerSrc() {
                  return getWorkerSrc();
                }
              }
              return PDFWorker;
            }();
            exports.PDFWorker = PDFWorker;
            class WorkerTransport {
              constructor(messageHandler, loadingTask, networkStream, params) {
                this.messageHandler = messageHandler;
                this.loadingTask = loadingTask;
                this.commonObjs = new PDFObjects();
                this.fontLoader = new _font_loader.FontLoader({
                  docId: loadingTask.docId,
                  onUnsupportedFeature: this._onUnsupportedFeature.bind(this)
                });
                this._params = params;
                this.CMapReaderFactory = new params.CMapReaderFactory({
                  baseUrl: params.cMapUrl,
                  isCompressed: params.cMapPacked
                });
                this.destroyed = false;
                this.destroyCapability = null;
                this._passwordCapability = null;
                this._networkStream = networkStream;
                this._fullReader = null;
                this._lastProgress = null;
                this.pageCache = [];
                this.pagePromises = [];
                this.downloadInfoCapability = (0, _util.createPromiseCapability)();
                this.setupMessageHandler();
              }
              destroy() {
                if (this.destroyCapability) {
                  return this.destroyCapability.promise;
                }
                this.destroyed = true;
                this.destroyCapability = (0, _util.createPromiseCapability)();
                if (this._passwordCapability) {
                  this._passwordCapability.reject(new Error("Worker was destroyed during onPassword callback"));
                }
                const waitOn = [];
                this.pageCache.forEach(function(page) {
                  if (page) {
                    waitOn.push(page._destroy());
                  }
                });
                this.pageCache.length = 0;
                this.pagePromises.length = 0;
                const terminated = this.messageHandler.sendWithPromise("Terminate", null);
                waitOn.push(terminated);
                Promise.all(waitOn).then(() => {
                  this.fontLoader.clear();
                  if (this._networkStream) {
                    this._networkStream.cancelAllRequests(new _util.AbortException("Worker was terminated."));
                  }
                  if (this.messageHandler) {
                    this.messageHandler.destroy();
                    this.messageHandler = null;
                  }
                  this.destroyCapability.resolve();
                }, this.destroyCapability.reject);
                return this.destroyCapability.promise;
              }
              setupMessageHandler() {
                const {
                  messageHandler,
                  loadingTask
                } = this;
                messageHandler.on("GetReader", (data, sink) => {
                  (0, _util.assert)(this._networkStream);
                  this._fullReader = this._networkStream.getFullReader();
                  this._fullReader.onProgress = (evt) => {
                    this._lastProgress = {
                      loaded: evt.loaded,
                      total: evt.total
                    };
                  };
                  sink.onPull = () => {
                    this._fullReader.read().then(function({
                      value,
                      done
                    }) {
                      if (done) {
                        sink.close();
                        return;
                      }
                      (0, _util.assert)((0, _util.isArrayBuffer)(value));
                      sink.enqueue(new Uint8Array(value), 1, [value]);
                    }).catch((reason) => {
                      sink.error(reason);
                    });
                  };
                  sink.onCancel = (reason) => {
                    this._fullReader.cancel(reason);
                  };
                });
                messageHandler.on("ReaderHeadersReady", (data) => {
                  const headersCapability = (0, _util.createPromiseCapability)();
                  const fullReader = this._fullReader;
                  fullReader.headersReady.then(() => {
                    if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {
                      if (this._lastProgress && loadingTask.onProgress) {
                        loadingTask.onProgress(this._lastProgress);
                      }
                      fullReader.onProgress = (evt) => {
                        if (loadingTask.onProgress) {
                          loadingTask.onProgress({
                            loaded: evt.loaded,
                            total: evt.total
                          });
                        }
                      };
                    }
                    headersCapability.resolve({
                      isStreamingSupported: fullReader.isStreamingSupported,
                      isRangeSupported: fullReader.isRangeSupported,
                      contentLength: fullReader.contentLength
                    });
                  }, headersCapability.reject);
                  return headersCapability.promise;
                });
                messageHandler.on("GetRangeReader", (data, sink) => {
                  (0, _util.assert)(this._networkStream);
                  const rangeReader = this._networkStream.getRangeReader(data.begin, data.end);
                  if (!rangeReader) {
                    sink.close();
                    return;
                  }
                  sink.onPull = () => {
                    rangeReader.read().then(function({
                      value,
                      done
                    }) {
                      if (done) {
                        sink.close();
                        return;
                      }
                      (0, _util.assert)((0, _util.isArrayBuffer)(value));
                      sink.enqueue(new Uint8Array(value), 1, [value]);
                    }).catch((reason) => {
                      sink.error(reason);
                    });
                  };
                  sink.onCancel = (reason) => {
                    rangeReader.cancel(reason);
                  };
                });
                messageHandler.on("GetDoc", ({
                  pdfInfo
                }) => {
                  this._numPages = pdfInfo.numPages;
                  loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));
                });
                messageHandler.on("DocException", function(ex) {
                  let reason;
                  switch (ex.name) {
                    case "PasswordException":
                      reason = new _util.PasswordException(ex.message, ex.code);
                      break;
                    case "InvalidPDFException":
                      reason = new _util.InvalidPDFException(ex.message);
                      break;
                    case "MissingPDFException":
                      reason = new _util.MissingPDFException(ex.message);
                      break;
                    case "UnexpectedResponseException":
                      reason = new _util.UnexpectedResponseException(ex.message, ex.status);
                      break;
                    case "UnknownErrorException":
                      reason = new _util.UnknownErrorException(ex.message, ex.details);
                      break;
                  }
                  loadingTask._capability.reject(reason);
                });
                messageHandler.on("PasswordRequest", (exception) => {
                  this._passwordCapability = (0, _util.createPromiseCapability)();
                  if (loadingTask.onPassword) {
                    const updatePassword = (password) => {
                      this._passwordCapability.resolve({
                        password
                      });
                    };
                    try {
                      loadingTask.onPassword(updatePassword, exception.code);
                    } catch (ex) {
                      this._passwordCapability.reject(ex);
                    }
                  } else {
                    this._passwordCapability.reject(new _util.PasswordException(exception.message, exception.code));
                  }
                  return this._passwordCapability.promise;
                });
                messageHandler.on("DataLoaded", (data) => {
                  if (loadingTask.onProgress) {
                    loadingTask.onProgress({
                      loaded: data.length,
                      total: data.length
                    });
                  }
                  this.downloadInfoCapability.resolve(data);
                });
                messageHandler.on("StartRenderPage", (data) => {
                  if (this.destroyed) {
                    return;
                  }
                  const page = this.pageCache[data.pageIndex];
                  page._startRenderPage(data.transparency, data.intent);
                });
                messageHandler.on("commonobj", (data) => {
                  if (this.destroyed) {
                    return;
                  }
                  const [id, type, exportedData] = data;
                  if (this.commonObjs.has(id)) {
                    return;
                  }
                  switch (type) {
                    case "Font":
                      const params = this._params;
                      if ("error" in exportedData) {
                        const exportedError = exportedData.error;
                        (0, _util.warn)(`Error during font loading: ${exportedError}`);
                        this.commonObjs.resolve(id, exportedError);
                        break;
                      }
                      let fontRegistry = null;
                      if (params.pdfBug && globalThis.FontInspector && globalThis.FontInspector.enabled) {
                        fontRegistry = {
                          registerFont(font2, url) {
                            globalThis.FontInspector.fontAdded(font2, url);
                          }
                        };
                      }
                      const font = new _font_loader.FontFaceObject(exportedData, {
                        isEvalSupported: params.isEvalSupported,
                        disableFontFace: params.disableFontFace,
                        ignoreErrors: params.ignoreErrors,
                        onUnsupportedFeature: this._onUnsupportedFeature.bind(this),
                        fontRegistry
                      });
                      this.fontLoader.bind(font).then(() => {
                        this.commonObjs.resolve(id, font);
                      }, (reason) => {
                        messageHandler.sendWithPromise("FontFallback", {
                          id
                        }).finally(() => {
                          this.commonObjs.resolve(id, font);
                        });
                      });
                      break;
                    case "FontPath":
                    case "FontType3Res":
                      this.commonObjs.resolve(id, exportedData);
                      break;
                    default:
                      throw new Error(`Got unknown common object type ${type}`);
                  }
                });
                messageHandler.on("obj", (data) => {
                  if (this.destroyed) {
                    return void 0;
                  }
                  const [id, pageIndex, type, imageData] = data;
                  const pageProxy = this.pageCache[pageIndex];
                  if (pageProxy.objs.has(id)) {
                    return void 0;
                  }
                  switch (type) {
                    case "JpegStream":
                      return new Promise((resolve, reject) => {
                        const img = new Image();
                        img.onload = function() {
                          resolve(img);
                        };
                        img.onerror = function() {
                          reject(new Error("Error during JPEG image loading"));
                          (0, _display_utils.releaseImageResources)(img);
                        };
                        img.src = imageData;
                      }).then((img) => {
                        pageProxy.objs.resolve(id, img);
                      });
                    case "Image":
                      pageProxy.objs.resolve(id, imageData);
                      const MAX_IMAGE_SIZE_TO_STORE = 8e6;
                      if (imageData && "data" in imageData && imageData.data.length > MAX_IMAGE_SIZE_TO_STORE) {
                        pageProxy.cleanupAfterRender = true;
                      }
                      break;
                    default:
                      throw new Error(`Got unknown object type ${type}`);
                  }
                  return void 0;
                });
                messageHandler.on("DocProgress", (data) => {
                  if (this.destroyed) {
                    return;
                  }
                  if (loadingTask.onProgress) {
                    loadingTask.onProgress({
                      loaded: data.loaded,
                      total: data.total
                    });
                  }
                });
                messageHandler.on("UnsupportedFeature", this._onUnsupportedFeature.bind(this));
                messageHandler.on("JpegDecode", (data) => {
                  if (this.destroyed) {
                    return Promise.reject(new Error("Worker was destroyed"));
                  }
                  if (typeof document === "undefined") {
                    return Promise.reject(new Error('"document" is not defined.'));
                  }
                  const [imageUrl, components] = data;
                  if (components !== 3 && components !== 1) {
                    return Promise.reject(new Error("Only 3 components or 1 component can be returned"));
                  }
                  return new Promise(function(resolve, reject) {
                    const img = new Image();
                    img.onload = function() {
                      const {
                        width,
                        height
                      } = img;
                      const size = width * height;
                      const rgbaLength = size * 4;
                      const buf = new Uint8ClampedArray(size * components);
                      let tmpCanvas = document.createElement("canvas");
                      tmpCanvas.width = width;
                      tmpCanvas.height = height;
                      let tmpCtx = tmpCanvas.getContext("2d");
                      tmpCtx.drawImage(img, 0, 0);
                      const data2 = tmpCtx.getImageData(0, 0, width, height).data;
                      if (components === 3) {
                        for (let i = 0, j = 0; i < rgbaLength; i += 4, j += 3) {
                          buf[j] = data2[i];
                          buf[j + 1] = data2[i + 1];
                          buf[j + 2] = data2[i + 2];
                        }
                      } else if (components === 1) {
                        for (let i = 0, j = 0; i < rgbaLength; i += 4, j++) {
                          buf[j] = data2[i];
                        }
                      }
                      resolve({
                        data: buf,
                        width,
                        height
                      });
                      (0, _display_utils.releaseImageResources)(img);
                      tmpCanvas.width = 0;
                      tmpCanvas.height = 0;
                      tmpCanvas = null;
                      tmpCtx = null;
                    };
                    img.onerror = function() {
                      reject(new Error("JpegDecode failed to load image"));
                      (0, _display_utils.releaseImageResources)(img);
                    };
                    img.src = imageUrl;
                  });
                });
                messageHandler.on("FetchBuiltInCMap", (data, sink) => {
                  if (this.destroyed) {
                    sink.error(new Error("Worker was destroyed"));
                    return;
                  }
                  let fetched = false;
                  sink.onPull = () => {
                    if (fetched) {
                      sink.close();
                      return;
                    }
                    fetched = true;
                    this.CMapReaderFactory.fetch(data).then(function(builtInCMap) {
                      sink.enqueue(builtInCMap, 1, [builtInCMap.cMapData.buffer]);
                    }).catch(function(reason) {
                      sink.error(reason);
                    });
                  };
                });
              }
              _onUnsupportedFeature({
                featureId
              }) {
                if (this.destroyed) {
                  return;
                }
                if (this.loadingTask.onUnsupportedFeature) {
                  this.loadingTask.onUnsupportedFeature(featureId);
                }
              }
              getData() {
                return this.messageHandler.sendWithPromise("GetData", null);
              }
              getPage(pageNumber) {
                if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {
                  return Promise.reject(new Error("Invalid page request"));
                }
                const pageIndex = pageNumber - 1;
                if (pageIndex in this.pagePromises) {
                  return this.pagePromises[pageIndex];
                }
                const promise = this.messageHandler.sendWithPromise("GetPage", {
                  pageIndex
                }).then((pageInfo) => {
                  if (this.destroyed) {
                    throw new Error("Transport destroyed");
                  }
                  const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.pdfBug);
                  this.pageCache[pageIndex] = page;
                  return page;
                });
                this.pagePromises[pageIndex] = promise;
                return promise;
              }
              getPageIndex(ref) {
                return this.messageHandler.sendWithPromise("GetPageIndex", {
                  ref
                }).catch(function(reason) {
                  return Promise.reject(new Error(reason));
                });
              }
              getAnnotations(pageIndex, intent) {
                return this.messageHandler.sendWithPromise("GetAnnotations", {
                  pageIndex,
                  intent
                });
              }
              getDestinations() {
                return this.messageHandler.sendWithPromise("GetDestinations", null);
              }
              getDestination(id) {
                if (typeof id !== "string") {
                  return Promise.reject(new Error("Invalid destination request."));
                }
                return this.messageHandler.sendWithPromise("GetDestination", {
                  id
                });
              }
              getPageLabels() {
                return this.messageHandler.sendWithPromise("GetPageLabels", null);
              }
              getPageLayout() {
                return this.messageHandler.sendWithPromise("GetPageLayout", null);
              }
              getPageMode() {
                return this.messageHandler.sendWithPromise("GetPageMode", null);
              }
              getViewerPreferences() {
                return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
              }
              getOpenAction() {
                return this.messageHandler.sendWithPromise("GetOpenAction", null);
              }
              getAttachments() {
                return this.messageHandler.sendWithPromise("GetAttachments", null);
              }
              getJavaScript() {
                return this.messageHandler.sendWithPromise("GetJavaScript", null);
              }
              getOutline() {
                return this.messageHandler.sendWithPromise("GetOutline", null);
              }
              getPermissions() {
                return this.messageHandler.sendWithPromise("GetPermissions", null);
              }
              getMetadata() {
                return this.messageHandler.sendWithPromise("GetMetadata", null).then((results) => {
                  return {
                    info: results[0],
                    metadata: results[1] ? new _metadata.Metadata(results[1]) : null,
                    contentDispositionFilename: this._fullReader ? this._fullReader.filename : null
                  };
                });
              }
              getStats() {
                return this.messageHandler.sendWithPromise("GetStats", null);
              }
              startCleanup() {
                return this.messageHandler.sendWithPromise("Cleanup", null).then(() => {
                  for (let i = 0, ii = this.pageCache.length; i < ii; i++) {
                    const page = this.pageCache[i];
                    if (page) {
                      const cleanupSuccessful = page.cleanup();
                      if (!cleanupSuccessful) {
                        throw new Error(`startCleanup: Page ${i + 1} is currently rendering.`);
                      }
                    }
                  }
                  this.commonObjs.clear();
                  this.fontLoader.clear();
                });
              }
              get loadingParams() {
                const params = this._params;
                return (0, _util.shadow)(this, "loadingParams", {
                  disableAutoFetch: params.disableAutoFetch,
                  disableCreateObjectURL: params.disableCreateObjectURL,
                  disableFontFace: params.disableFontFace,
                  nativeImageDecoderSupport: params.nativeImageDecoderSupport
                });
              }
            }
            class PDFObjects {
              constructor() {
                this._objs = /* @__PURE__ */ Object.create(null);
              }
              _ensureObj(objId) {
                if (this._objs[objId]) {
                  return this._objs[objId];
                }
                return this._objs[objId] = {
                  capability: (0, _util.createPromiseCapability)(),
                  data: null,
                  resolved: false
                };
              }
              get(objId, callback = null) {
                if (callback) {
                  this._ensureObj(objId).capability.promise.then(callback);
                  return null;
                }
                const obj = this._objs[objId];
                if (!obj || !obj.resolved) {
                  throw new Error(`Requesting object that isn't resolved yet ${objId}.`);
                }
                return obj.data;
              }
              has(objId) {
                const obj = this._objs[objId];
                return obj ? obj.resolved : false;
              }
              resolve(objId, data) {
                const obj = this._ensureObj(objId);
                obj.resolved = true;
                obj.data = data;
                obj.capability.resolve(data);
              }
              clear() {
                for (const objId in this._objs) {
                  const {
                    data
                  } = this._objs[objId];
                  if (typeof Image !== "undefined" && data instanceof Image) {
                    (0, _display_utils.releaseImageResources)(data);
                  }
                }
                this._objs = /* @__PURE__ */ Object.create(null);
              }
            }
            class RenderTask {
              constructor(internalRenderTask) {
                this._internalRenderTask = internalRenderTask;
                this.onContinue = null;
              }
              get promise() {
                return this._internalRenderTask.capability.promise;
              }
              cancel() {
                this._internalRenderTask.cancel();
              }
              then(onFulfilled, onRejected) {
                throw new Error("Removed API method: RenderTask.then, use the `promise` getter instead.");
              }
            }
            const InternalRenderTask = function InternalRenderTaskClosure() {
              const canvasInRendering = /* @__PURE__ */ new WeakSet();
              class InternalRenderTask2 {
                constructor({
                  callback,
                  params,
                  objs,
                  commonObjs,
                  operatorList,
                  pageIndex,
                  canvasFactory,
                  webGLContext,
                  useRequestAnimationFrame = false,
                  pdfBug = false
                }) {
                  this.callback = callback;
                  this.params = params;
                  this.objs = objs;
                  this.commonObjs = commonObjs;
                  this.operatorListIdx = null;
                  this.operatorList = operatorList;
                  this._pageIndex = pageIndex;
                  this.canvasFactory = canvasFactory;
                  this.webGLContext = webGLContext;
                  this._pdfBug = pdfBug;
                  this.running = false;
                  this.graphicsReadyCallback = null;
                  this.graphicsReady = false;
                  this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== "undefined";
                  this.cancelled = false;
                  this.capability = (0, _util.createPromiseCapability)();
                  this.task = new RenderTask(this);
                  this._continueBound = this._continue.bind(this);
                  this._scheduleNextBound = this._scheduleNext.bind(this);
                  this._nextBound = this._next.bind(this);
                  this._canvas = params.canvasContext.canvas;
                }
                initializeGraphics(transparency = false) {
                  if (this.cancelled) {
                    return;
                  }
                  if (this._canvas) {
                    if (canvasInRendering.has(this._canvas)) {
                      throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");
                    }
                    canvasInRendering.add(this._canvas);
                  }
                  if (this._pdfBug && globalThis.StepperManager && globalThis.StepperManager.enabled) {
                    this.stepper = globalThis.StepperManager.create(this._pageIndex);
                    this.stepper.init(this.operatorList);
                    this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();
                  }
                  const {
                    canvasContext,
                    viewport,
                    transform,
                    imageLayer,
                    background
                  } = this.params;
                  this.gfx = new _canvas.CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, this.webGLContext, imageLayer);
                  this.gfx.beginDrawing({
                    transform,
                    viewport,
                    transparency,
                    background
                  });
                  this.operatorListIdx = 0;
                  this.graphicsReady = true;
                  if (this.graphicsReadyCallback) {
                    this.graphicsReadyCallback();
                  }
                }
                cancel(error = null) {
                  this.running = false;
                  this.cancelled = true;
                  if (this.gfx) {
                    this.gfx.endDrawing();
                  }
                  if (this._canvas) {
                    canvasInRendering.delete(this._canvas);
                  }
                  this.callback(error || new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, "canvas"));
                }
                operatorListChanged() {
                  if (!this.graphicsReady) {
                    if (!this.graphicsReadyCallback) {
                      this.graphicsReadyCallback = this._continueBound;
                    }
                    return;
                  }
                  if (this.stepper) {
                    this.stepper.updateOperatorList(this.operatorList);
                  }
                  if (this.running) {
                    return;
                  }
                  this._continue();
                }
                _continue() {
                  this.running = true;
                  if (this.cancelled) {
                    return;
                  }
                  if (this.task.onContinue) {
                    this.task.onContinue(this._scheduleNextBound);
                  } else {
                    this._scheduleNext();
                  }
                }
                _scheduleNext() {
                  if (this._useRequestAnimationFrame) {
                    window.requestAnimationFrame(() => {
                      this._nextBound().catch(this.cancel.bind(this));
                    });
                  } else {
                    Promise.resolve().then(this._nextBound).catch(this.cancel.bind(this));
                  }
                }
                async _next() {
                  if (this.cancelled) {
                    return;
                  }
                  this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);
                  if (this.operatorListIdx === this.operatorList.argsArray.length) {
                    this.running = false;
                    if (this.operatorList.lastChunk) {
                      this.gfx.endDrawing();
                      if (this._canvas) {
                        canvasInRendering.delete(this._canvas);
                      }
                      this.callback();
                    }
                  }
                }
              }
              return InternalRenderTask2;
            }();
            const version = "2.4.456";
            exports.version = version;
            const build = "228a591c";
            exports.build = build;
          },
          3528: function(__unused_webpack_module2, exports2, __webpack_require__2) {
            "use strict";
            const compatibilityParams = /* @__PURE__ */ Object.create(null);
            {
              const {
                isNodeJS
              } = __webpack_require__2(2918);
              const userAgent = typeof navigator !== "undefined" && navigator.userAgent || "";
              const isIE = /Trident/.test(userAgent);
              const isIOSChrome = /CriOS/.test(userAgent);
              (function checkOnBlobSupport() {
                if (isIE || isIOSChrome) {
                  compatibilityParams.disableCreateObjectURL = true;
                }
              })();
              (function checkFontFaceAndImage() {
                if (isNodeJS) {
                  compatibilityParams.disableFontFace = true;
                  compatibilityParams.nativeImageDecoderSupport = "none";
                }
              })();
            }
            exports2.apiCompatibilityParams = Object.freeze(compatibilityParams);
          },
          193: function(__unused_webpack_module2, exports2, __webpack_require__2) {
            "use strict";
            __webpack_require__2(7658);
            __webpack_require__2(3408);
            __webpack_require__2(4590);
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.CanvasGraphics = void 0;
            var _util2 = __webpack_require__2(7484);
            var _pattern_helper = __webpack_require__2(9299);
            var MIN_FONT_SIZE = 16;
            var MAX_FONT_SIZE = 100;
            var MAX_GROUP_SIZE = 4096;
            var MIN_WIDTH_FACTOR = 0.65;
            var COMPILE_TYPE3_GLYPHS = true;
            var MAX_SIZE_TO_COMPILE = 1e3;
            var FULL_CHUNK_HEIGHT = 16;
            function addContextCurrentTransform(ctx) {
              if (!ctx.mozCurrentTransform) {
                ctx._originalSave = ctx.save;
                ctx._originalRestore = ctx.restore;
                ctx._originalRotate = ctx.rotate;
                ctx._originalScale = ctx.scale;
                ctx._originalTranslate = ctx.translate;
                ctx._originalTransform = ctx.transform;
                ctx._originalSetTransform = ctx.setTransform;
                ctx._transformMatrix = ctx._transformMatrix || [1, 0, 0, 1, 0, 0];
                ctx._transformStack = [];
                Object.defineProperty(ctx, "mozCurrentTransform", {
                  get: function getCurrentTransform() {
                    return this._transformMatrix;
                  }
                });
                Object.defineProperty(ctx, "mozCurrentTransformInverse", {
                  get: function getCurrentTransformInverse() {
                    var m = this._transformMatrix;
                    var a = m[0], b = m[1], c = m[2], d = m[3], e = m[4], f = m[5];
                    var ad_bc = a * d - b * c;
                    var bc_ad = b * c - a * d;
                    return [d / ad_bc, b / bc_ad, c / bc_ad, a / ad_bc, (d * e - c * f) / bc_ad, (b * e - a * f) / ad_bc];
                  }
                });
                ctx.save = function ctxSave() {
                  var old = this._transformMatrix;
                  this._transformStack.push(old);
                  this._transformMatrix = old.slice(0, 6);
                  this._originalSave();
                };
                ctx.restore = function ctxRestore() {
                  var prev = this._transformStack.pop();
                  if (prev) {
                    this._transformMatrix = prev;
                    this._originalRestore();
                  }
                };
                ctx.translate = function ctxTranslate(x, y) {
                  var m = this._transformMatrix;
                  m[4] = m[0] * x + m[2] * y + m[4];
                  m[5] = m[1] * x + m[3] * y + m[5];
                  this._originalTranslate(x, y);
                };
                ctx.scale = function ctxScale(x, y) {
                  var m = this._transformMatrix;
                  m[0] = m[0] * x;
                  m[1] = m[1] * x;
                  m[2] = m[2] * y;
                  m[3] = m[3] * y;
                  this._originalScale(x, y);
                };
                ctx.transform = function ctxTransform(a, b, c, d, e, f) {
                  var m = this._transformMatrix;
                  this._transformMatrix = [m[0] * a + m[2] * b, m[1] * a + m[3] * b, m[0] * c + m[2] * d, m[1] * c + m[3] * d, m[0] * e + m[2] * f + m[4], m[1] * e + m[3] * f + m[5]];
                  ctx._originalTransform(a, b, c, d, e, f);
                };
                ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {
                  this._transformMatrix = [a, b, c, d, e, f];
                  ctx._originalSetTransform(a, b, c, d, e, f);
                };
                ctx.rotate = function ctxRotate(angle) {
                  var cosValue = Math.cos(angle);
                  var sinValue = Math.sin(angle);
                  var m = this._transformMatrix;
                  this._transformMatrix = [m[0] * cosValue + m[2] * sinValue, m[1] * cosValue + m[3] * sinValue, m[0] * -sinValue + m[2] * cosValue, m[1] * -sinValue + m[3] * cosValue, m[4], m[5]];
                  this._originalRotate(angle);
                };
              }
            }
            var CachedCanvases = function CachedCanvasesClosure() {
              function CachedCanvases2(canvasFactory) {
                this.canvasFactory = canvasFactory;
                this.cache = /* @__PURE__ */ Object.create(null);
              }
              CachedCanvases2.prototype = {
                getCanvas: function CachedCanvases_getCanvas(id, width, height, trackTransform) {
                  var canvasEntry;
                  if (this.cache[id] !== void 0) {
                    canvasEntry = this.cache[id];
                    this.canvasFactory.reset(canvasEntry, width, height);
                    canvasEntry.context.setTransform(1, 0, 0, 1, 0, 0);
                  } else {
                    canvasEntry = this.canvasFactory.create(width, height);
                    this.cache[id] = canvasEntry;
                  }
                  if (trackTransform) {
                    addContextCurrentTransform(canvasEntry.context);
                  }
                  return canvasEntry;
                },
                clear() {
                  for (var id in this.cache) {
                    var canvasEntry = this.cache[id];
                    this.canvasFactory.destroy(canvasEntry);
                    delete this.cache[id];
                  }
                }
              };
              return CachedCanvases2;
            }();
            function compileType3Glyph(imgData) {
              var POINT_TO_PROCESS_LIMIT = 1e3;
              var width = imgData.width, height = imgData.height;
              var i, j, j0, width1 = width + 1;
              var points = new Uint8Array(width1 * (height + 1));
              var POINT_TYPES = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]);
              var lineSize = width + 7 & ~7, data0 = imgData.data;
              var data = new Uint8Array(lineSize * height), pos = 0, ii;
              for (i = 0, ii = data0.length; i < ii; i++) {
                var mask = 128, elem = data0[i];
                while (mask > 0) {
                  data[pos++] = elem & mask ? 0 : 255;
                  mask >>= 1;
                }
              }
              var count = 0;
              pos = 0;
              if (data[pos] !== 0) {
                points[0] = 1;
                ++count;
              }
              for (j = 1; j < width; j++) {
                if (data[pos] !== data[pos + 1]) {
                  points[j] = data[pos] ? 2 : 1;
                  ++count;
                }
                pos++;
              }
              if (data[pos] !== 0) {
                points[j] = 2;
                ++count;
              }
              for (i = 1; i < height; i++) {
                pos = i * lineSize;
                j0 = i * width1;
                if (data[pos - lineSize] !== data[pos]) {
                  points[j0] = data[pos] ? 1 : 8;
                  ++count;
                }
                var sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);
                for (j = 1; j < width; j++) {
                  sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);
                  if (POINT_TYPES[sum]) {
                    points[j0 + j] = POINT_TYPES[sum];
                    ++count;
                  }
                  pos++;
                }
                if (data[pos - lineSize] !== data[pos]) {
                  points[j0 + j] = data[pos] ? 2 : 4;
                  ++count;
                }
                if (count > POINT_TO_PROCESS_LIMIT) {
                  return null;
                }
              }
              pos = lineSize * (height - 1);
              j0 = i * width1;
              if (data[pos] !== 0) {
                points[j0] = 8;
                ++count;
              }
              for (j = 1; j < width; j++) {
                if (data[pos] !== data[pos + 1]) {
                  points[j0 + j] = data[pos] ? 4 : 8;
                  ++count;
                }
                pos++;
              }
              if (data[pos] !== 0) {
                points[j0 + j] = 4;
                ++count;
              }
              if (count > POINT_TO_PROCESS_LIMIT) {
                return null;
              }
              var steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);
              var outlines = [];
              for (i = 0; count && i <= height; i++) {
                var p = i * width1;
                var end = p + width;
                while (p < end && !points[p]) {
                  p++;
                }
                if (p === end) {
                  continue;
                }
                var coords = [p % width1, i];
                var type = points[p], p0 = p, pp;
                do {
                  var step = steps[type];
                  do {
                    p += step;
                  } while (!points[p]);
                  pp = points[p];
                  if (pp !== 5 && pp !== 10) {
                    type = pp;
                    points[p] = 0;
                  } else {
                    type = pp & 51 * type >> 4;
                    points[p] &= type >> 2 | type << 2;
                  }
                  coords.push(p % width1);
                  coords.push(p / width1 | 0);
                  if (!points[p]) {
                    --count;
                  }
                } while (p0 !== p);
                outlines.push(coords);
                --i;
              }
              var drawOutline = function(c) {
                c.save();
                c.scale(1 / width, -1 / height);
                c.translate(0, -height);
                c.beginPath();
                for (var i2 = 0, ii2 = outlines.length; i2 < ii2; i2++) {
                  var o = outlines[i2];
                  c.moveTo(o[0], o[1]);
                  for (var j2 = 2, jj = o.length; j2 < jj; j2 += 2) {
                    c.lineTo(o[j2], o[j2 + 1]);
                  }
                }
                c.fill();
                c.beginPath();
                c.restore();
              };
              return drawOutline;
            }
            var CanvasExtraState = function CanvasExtraStateClosure() {
              function CanvasExtraState2() {
                this.alphaIsShape = false;
                this.fontSize = 0;
                this.fontSizeScale = 1;
                this.textMatrix = _util2.IDENTITY_MATRIX;
                this.textMatrixScale = 1;
                this.fontMatrix = _util2.FONT_IDENTITY_MATRIX;
                this.leading = 0;
                this.x = 0;
                this.y = 0;
                this.lineX = 0;
                this.lineY = 0;
                this.charSpacing = 0;
                this.wordSpacing = 0;
                this.textHScale = 1;
                this.textRenderingMode = _util2.TextRenderingMode.FILL;
                this.textRise = 0;
                this.fillColor = "#000000";
                this.strokeColor = "#000000";
                this.patternFill = false;
                this.fillAlpha = 1;
                this.strokeAlpha = 1;
                this.lineWidth = 1;
                this.activeSMask = null;
                this.resumeSMaskCtx = null;
              }
              CanvasExtraState2.prototype = {
                clone: function CanvasExtraState_clone() {
                  return Object.create(this);
                },
                setCurrentPoint: function CanvasExtraState_setCurrentPoint(x, y) {
                  this.x = x;
                  this.y = y;
                }
              };
              return CanvasExtraState2;
            }();
            var CanvasGraphics = function CanvasGraphicsClosure() {
              var EXECUTION_TIME = 15;
              var EXECUTION_STEPS = 10;
              function CanvasGraphics2(canvasCtx, commonObjs, objs, canvasFactory, webGLContext, imageLayer) {
                this.ctx = canvasCtx;
                this.current = new CanvasExtraState();
                this.stateStack = [];
                this.pendingClip = null;
                this.pendingEOFill = false;
                this.res = null;
                this.xobjs = null;
                this.commonObjs = commonObjs;
                this.objs = objs;
                this.canvasFactory = canvasFactory;
                this.webGLContext = webGLContext;
                this.imageLayer = imageLayer;
                this.groupStack = [];
                this.processingType3 = null;
                this.baseTransform = null;
                this.baseTransformStack = [];
                this.groupLevel = 0;
                this.smaskStack = [];
                this.smaskCounter = 0;
                this.tempSMask = null;
                this.cachedCanvases = new CachedCanvases(this.canvasFactory);
                if (canvasCtx) {
                  addContextCurrentTransform(canvasCtx);
                }
                this._cachedGetSinglePixelWidth = null;
              }
              function putBinaryImageData(ctx, imgData) {
                if (typeof ImageData !== "undefined" && imgData instanceof ImageData) {
                  ctx.putImageData(imgData, 0, 0);
                  return;
                }
                var height = imgData.height, width = imgData.width;
                var partialChunkHeight = height % FULL_CHUNK_HEIGHT;
                var fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
                var totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
                var chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
                var srcPos = 0, destPos;
                var src = imgData.data;
                var dest = chunkImgData.data;
                var i, j, thisChunkHeight, elemsInThisChunk;
                if (imgData.kind === _util2.ImageKind.GRAYSCALE_1BPP) {
                  var srcLength = src.byteLength;
                  var dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);
                  var dest32DataLength = dest32.length;
                  var fullSrcDiff = width + 7 >> 3;
                  var white = 4294967295;
                  var black = _util2.IsLittleEndianCached.value ? 4278190080 : 255;
                  for (i = 0; i < totalChunks; i++) {
                    thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
                    destPos = 0;
                    for (j = 0; j < thisChunkHeight; j++) {
                      var srcDiff = srcLength - srcPos;
                      var k = 0;
                      var kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;
                      var kEndUnrolled = kEnd & ~7;
                      var mask = 0;
                      var srcByte = 0;
                      for (; k < kEndUnrolled; k += 8) {
                        srcByte = src[srcPos++];
                        dest32[destPos++] = srcByte & 128 ? white : black;
                        dest32[destPos++] = srcByte & 64 ? white : black;
                        dest32[destPos++] = srcByte & 32 ? white : black;
                        dest32[destPos++] = srcByte & 16 ? white : black;
                        dest32[destPos++] = srcByte & 8 ? white : black;
                        dest32[destPos++] = srcByte & 4 ? white : black;
                        dest32[destPos++] = srcByte & 2 ? white : black;
                        dest32[destPos++] = srcByte & 1 ? white : black;
                      }
                      for (; k < kEnd; k++) {
                        if (mask === 0) {
                          srcByte = src[srcPos++];
                          mask = 128;
                        }
                        dest32[destPos++] = srcByte & mask ? white : black;
                        mask >>= 1;
                      }
                    }
                    while (destPos < dest32DataLength) {
                      dest32[destPos++] = 0;
                    }
                    ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
                  }
                } else if (imgData.kind === _util2.ImageKind.RGBA_32BPP) {
                  j = 0;
                  elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;
                  for (i = 0; i < fullChunks; i++) {
                    dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
                    srcPos += elemsInThisChunk;
                    ctx.putImageData(chunkImgData, 0, j);
                    j += FULL_CHUNK_HEIGHT;
                  }
                  if (i < totalChunks) {
                    elemsInThisChunk = width * partialChunkHeight * 4;
                    dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
                    ctx.putImageData(chunkImgData, 0, j);
                  }
                } else if (imgData.kind === _util2.ImageKind.RGB_24BPP) {
                  thisChunkHeight = FULL_CHUNK_HEIGHT;
                  elemsInThisChunk = width * thisChunkHeight;
                  for (i = 0; i < totalChunks; i++) {
                    if (i >= fullChunks) {
                      thisChunkHeight = partialChunkHeight;
                      elemsInThisChunk = width * thisChunkHeight;
                    }
                    destPos = 0;
                    for (j = elemsInThisChunk; j--; ) {
                      dest[destPos++] = src[srcPos++];
                      dest[destPos++] = src[srcPos++];
                      dest[destPos++] = src[srcPos++];
                      dest[destPos++] = 255;
                    }
                    ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
                  }
                } else {
                  throw new Error(`bad image kind: ${imgData.kind}`);
                }
              }
              function putBinaryImageMask(ctx, imgData) {
                var height = imgData.height, width = imgData.width;
                var partialChunkHeight = height % FULL_CHUNK_HEIGHT;
                var fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
                var totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
                var chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
                var srcPos = 0;
                var src = imgData.data;
                var dest = chunkImgData.data;
                for (var i = 0; i < totalChunks; i++) {
                  var thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
                  var destPos = 3;
                  for (var j = 0; j < thisChunkHeight; j++) {
                    var mask = 0;
                    for (var k = 0; k < width; k++) {
                      if (!mask) {
                        var elem = src[srcPos++];
                        mask = 128;
                      }
                      dest[destPos] = elem & mask ? 0 : 255;
                      destPos += 4;
                      mask >>= 1;
                    }
                  }
                  ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
                }
              }
              function copyCtxState(sourceCtx, destCtx) {
                var properties = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font"];
                for (var i = 0, ii = properties.length; i < ii; i++) {
                  var property = properties[i];
                  if (sourceCtx[property] !== void 0) {
                    destCtx[property] = sourceCtx[property];
                  }
                }
                if (sourceCtx.setLineDash !== void 0) {
                  destCtx.setLineDash(sourceCtx.getLineDash());
                  destCtx.lineDashOffset = sourceCtx.lineDashOffset;
                }
              }
              function resetCtxToDefault(ctx) {
                ctx.strokeStyle = "#000000";
                ctx.fillStyle = "#000000";
                ctx.fillRule = "nonzero";
                ctx.globalAlpha = 1;
                ctx.lineWidth = 1;
                ctx.lineCap = "butt";
                ctx.lineJoin = "miter";
                ctx.miterLimit = 10;
                ctx.globalCompositeOperation = "source-over";
                ctx.font = "10px sans-serif";
                if (ctx.setLineDash !== void 0) {
                  ctx.setLineDash([]);
                  ctx.lineDashOffset = 0;
                }
              }
              function composeSMaskBackdrop(bytes, r0, g0, b0) {
                var length = bytes.length;
                for (var i = 3; i < length; i += 4) {
                  var alpha = bytes[i];
                  if (alpha === 0) {
                    bytes[i - 3] = r0;
                    bytes[i - 2] = g0;
                    bytes[i - 1] = b0;
                  } else if (alpha < 255) {
                    var alpha_ = 255 - alpha;
                    bytes[i - 3] = bytes[i - 3] * alpha + r0 * alpha_ >> 8;
                    bytes[i - 2] = bytes[i - 2] * alpha + g0 * alpha_ >> 8;
                    bytes[i - 1] = bytes[i - 1] * alpha + b0 * alpha_ >> 8;
                  }
                }
              }
              function composeSMaskAlpha(maskData, layerData, transferMap) {
                var length = maskData.length;
                var scale = 1 / 255;
                for (var i = 3; i < length; i += 4) {
                  var alpha = transferMap ? transferMap[maskData[i]] : maskData[i];
                  layerData[i] = layerData[i] * alpha * scale | 0;
                }
              }
              function composeSMaskLuminosity(maskData, layerData, transferMap) {
                var length = maskData.length;
                for (var i = 3; i < length; i += 4) {
                  var y = maskData[i - 3] * 77 + maskData[i - 2] * 152 + maskData[i - 1] * 28;
                  layerData[i] = transferMap ? layerData[i] * transferMap[y >> 8] >> 8 : layerData[i] * y >> 16;
                }
              }
              function genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap) {
                var hasBackdrop = !!backdrop;
                var r0 = hasBackdrop ? backdrop[0] : 0;
                var g0 = hasBackdrop ? backdrop[1] : 0;
                var b0 = hasBackdrop ? backdrop[2] : 0;
                var composeFn;
                if (subtype === "Luminosity") {
                  composeFn = composeSMaskLuminosity;
                } else {
                  composeFn = composeSMaskAlpha;
                }
                var PIXELS_TO_PROCESS = 1048576;
                var chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width));
                for (var row = 0; row < height; row += chunkSize) {
                  var chunkHeight = Math.min(chunkSize, height - row);
                  var maskData = maskCtx.getImageData(0, row, width, chunkHeight);
                  var layerData = layerCtx.getImageData(0, row, width, chunkHeight);
                  if (hasBackdrop) {
                    composeSMaskBackdrop(maskData.data, r0, g0, b0);
                  }
                  composeFn(maskData.data, layerData.data, transferMap);
                  maskCtx.putImageData(layerData, 0, row);
                }
              }
              function composeSMask(ctx, smask, layerCtx, webGLContext) {
                var mask = smask.canvas;
                var maskCtx = smask.context;
                ctx.setTransform(smask.scaleX, 0, 0, smask.scaleY, smask.offsetX, smask.offsetY);
                var backdrop = smask.backdrop || null;
                if (!smask.transferMap && webGLContext.isEnabled) {
                  const composed = webGLContext.composeSMask({
                    layer: layerCtx.canvas,
                    mask,
                    properties: {
                      subtype: smask.subtype,
                      backdrop
                    }
                  });
                  ctx.setTransform(1, 0, 0, 1, 0, 0);
                  ctx.drawImage(composed, smask.offsetX, smask.offsetY);
                  return;
                }
                genericComposeSMask(maskCtx, layerCtx, mask.width, mask.height, smask.subtype, backdrop, smask.transferMap);
                ctx.drawImage(mask, 0, 0);
              }
              var LINE_CAP_STYLES = ["butt", "round", "square"];
              var LINE_JOIN_STYLES = ["miter", "round", "bevel"];
              var NORMAL_CLIP = {};
              var EO_CLIP = {};
              CanvasGraphics2.prototype = {
                beginDrawing({
                  transform,
                  viewport,
                  transparency = false,
                  background = null
                }) {
                  var width = this.ctx.canvas.width;
                  var height = this.ctx.canvas.height;
                  this.ctx.save();
                  this.ctx.fillStyle = background || "rgb(255, 255, 255)";
                  this.ctx.fillRect(0, 0, width, height);
                  this.ctx.restore();
                  if (transparency) {
                    var transparentCanvas = this.cachedCanvases.getCanvas("transparent", width, height, true);
                    this.compositeCtx = this.ctx;
                    this.transparentCanvas = transparentCanvas.canvas;
                    this.ctx = transparentCanvas.context;
                    this.ctx.save();
                    this.ctx.transform.apply(this.ctx, this.compositeCtx.mozCurrentTransform);
                  }
                  this.ctx.save();
                  resetCtxToDefault(this.ctx);
                  if (transform) {
                    this.ctx.transform.apply(this.ctx, transform);
                  }
                  this.ctx.transform.apply(this.ctx, viewport.transform);
                  this.baseTransform = this.ctx.mozCurrentTransform.slice();
                  if (this.imageLayer) {
                    this.imageLayer.beginLayout();
                  }
                },
                executeOperatorList: function CanvasGraphics_executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {
                  var argsArray = operatorList.argsArray;
                  var fnArray = operatorList.fnArray;
                  var i = executionStartIdx || 0;
                  var argsArrayLen = argsArray.length;
                  if (argsArrayLen === i) {
                    return i;
                  }
                  var chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === "function";
                  var endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;
                  var steps = 0;
                  var commonObjs = this.commonObjs;
                  var objs = this.objs;
                  var fnId;
                  while (true) {
                    if (stepper !== void 0 && i === stepper.nextBreakPoint) {
                      stepper.breakIt(i, continueCallback);
                      return i;
                    }
                    fnId = fnArray[i];
                    if (fnId !== _util2.OPS.dependency) {
                      this[fnId].apply(this, argsArray[i]);
                    } else {
                      for (const depObjId of argsArray[i]) {
                        const objsPool = depObjId.startsWith("g_") ? commonObjs : objs;
                        if (!objsPool.has(depObjId)) {
                          objsPool.get(depObjId, continueCallback);
                          return i;
                        }
                      }
                    }
                    i++;
                    if (i === argsArrayLen) {
                      return i;
                    }
                    if (chunkOperations && ++steps > EXECUTION_STEPS) {
                      if (Date.now() > endTime) {
                        continueCallback();
                        return i;
                      }
                      steps = 0;
                    }
                  }
                },
                endDrawing: function CanvasGraphics_endDrawing() {
                  if (this.current.activeSMask !== null) {
                    this.endSMaskGroup();
                  }
                  this.ctx.restore();
                  if (this.transparentCanvas) {
                    this.ctx = this.compositeCtx;
                    this.ctx.save();
                    this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                    this.ctx.drawImage(this.transparentCanvas, 0, 0);
                    this.ctx.restore();
                    this.transparentCanvas = null;
                  }
                  this.cachedCanvases.clear();
                  this.webGLContext.clear();
                  if (this.imageLayer) {
                    this.imageLayer.endLayout();
                  }
                },
                setLineWidth: function CanvasGraphics_setLineWidth(width) {
                  this.current.lineWidth = width;
                  this.ctx.lineWidth = width;
                },
                setLineCap: function CanvasGraphics_setLineCap(style) {
                  this.ctx.lineCap = LINE_CAP_STYLES[style];
                },
                setLineJoin: function CanvasGraphics_setLineJoin(style) {
                  this.ctx.lineJoin = LINE_JOIN_STYLES[style];
                },
                setMiterLimit: function CanvasGraphics_setMiterLimit(limit) {
                  this.ctx.miterLimit = limit;
                },
                setDash: function CanvasGraphics_setDash(dashArray, dashPhase) {
                  var ctx = this.ctx;
                  if (ctx.setLineDash !== void 0) {
                    ctx.setLineDash(dashArray);
                    ctx.lineDashOffset = dashPhase;
                  }
                },
                setRenderingIntent(intent) {
                },
                setFlatness(flatness) {
                },
                setGState: function CanvasGraphics_setGState(states) {
                  for (var i = 0, ii = states.length; i < ii; i++) {
                    var state = states[i];
                    var key = state[0];
                    var value = state[1];
                    switch (key) {
                      case "LW":
                        this.setLineWidth(value);
                        break;
                      case "LC":
                        this.setLineCap(value);
                        break;
                      case "LJ":
                        this.setLineJoin(value);
                        break;
                      case "ML":
                        this.setMiterLimit(value);
                        break;
                      case "D":
                        this.setDash(value[0], value[1]);
                        break;
                      case "RI":
                        this.setRenderingIntent(value);
                        break;
                      case "FL":
                        this.setFlatness(value);
                        break;
                      case "Font":
                        this.setFont(value[0], value[1]);
                        break;
                      case "CA":
                        this.current.strokeAlpha = state[1];
                        break;
                      case "ca":
                        this.current.fillAlpha = state[1];
                        this.ctx.globalAlpha = state[1];
                        break;
                      case "BM":
                        this.ctx.globalCompositeOperation = value;
                        break;
                      case "SMask":
                        if (this.current.activeSMask) {
                          if (this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1].activeSMask === this.current.activeSMask) {
                            this.suspendSMaskGroup();
                          } else {
                            this.endSMaskGroup();
                          }
                        }
                        this.current.activeSMask = value ? this.tempSMask : null;
                        if (this.current.activeSMask) {
                          this.beginSMaskGroup();
                        }
                        this.tempSMask = null;
                        break;
                    }
                  }
                },
                beginSMaskGroup: function CanvasGraphics_beginSMaskGroup() {
                  var activeSMask = this.current.activeSMask;
                  var drawnWidth = activeSMask.canvas.width;
                  var drawnHeight = activeSMask.canvas.height;
                  var cacheId = "smaskGroupAt" + this.groupLevel;
                  var scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);
                  var currentCtx = this.ctx;
                  var currentTransform = currentCtx.mozCurrentTransform;
                  this.ctx.save();
                  var groupCtx = scratchCanvas.context;
                  groupCtx.scale(1 / activeSMask.scaleX, 1 / activeSMask.scaleY);
                  groupCtx.translate(-activeSMask.offsetX, -activeSMask.offsetY);
                  groupCtx.transform.apply(groupCtx, currentTransform);
                  activeSMask.startTransformInverse = groupCtx.mozCurrentTransformInverse;
                  copyCtxState(currentCtx, groupCtx);
                  this.ctx = groupCtx;
                  this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
                  this.groupStack.push(currentCtx);
                  this.groupLevel++;
                },
                suspendSMaskGroup: function CanvasGraphics_endSMaskGroup() {
                  var groupCtx = this.ctx;
                  this.groupLevel--;
                  this.ctx = this.groupStack.pop();
                  composeSMask(this.ctx, this.current.activeSMask, groupCtx, this.webGLContext);
                  this.ctx.restore();
                  this.ctx.save();
                  copyCtxState(groupCtx, this.ctx);
                  this.current.resumeSMaskCtx = groupCtx;
                  var deltaTransform = _util2.Util.transform(this.current.activeSMask.startTransformInverse, groupCtx.mozCurrentTransform);
                  this.ctx.transform.apply(this.ctx, deltaTransform);
                  groupCtx.save();
                  groupCtx.setTransform(1, 0, 0, 1, 0, 0);
                  groupCtx.clearRect(0, 0, groupCtx.canvas.width, groupCtx.canvas.height);
                  groupCtx.restore();
                },
                resumeSMaskGroup: function CanvasGraphics_endSMaskGroup() {
                  var groupCtx = this.current.resumeSMaskCtx;
                  var currentCtx = this.ctx;
                  this.ctx = groupCtx;
                  this.groupStack.push(currentCtx);
                  this.groupLevel++;
                },
                endSMaskGroup: function CanvasGraphics_endSMaskGroup() {
                  var groupCtx = this.ctx;
                  this.groupLevel--;
                  this.ctx = this.groupStack.pop();
                  composeSMask(this.ctx, this.current.activeSMask, groupCtx, this.webGLContext);
                  this.ctx.restore();
                  copyCtxState(groupCtx, this.ctx);
                  var deltaTransform = _util2.Util.transform(this.current.activeSMask.startTransformInverse, groupCtx.mozCurrentTransform);
                  this.ctx.transform.apply(this.ctx, deltaTransform);
                },
                save: function CanvasGraphics_save() {
                  this.ctx.save();
                  var old = this.current;
                  this.stateStack.push(old);
                  this.current = old.clone();
                  this.current.resumeSMaskCtx = null;
                },
                restore: function CanvasGraphics_restore() {
                  if (this.current.resumeSMaskCtx) {
                    this.resumeSMaskGroup();
                  }
                  if (this.current.activeSMask !== null && (this.stateStack.length === 0 || this.stateStack[this.stateStack.length - 1].activeSMask !== this.current.activeSMask)) {
                    this.endSMaskGroup();
                  }
                  if (this.stateStack.length !== 0) {
                    this.current = this.stateStack.pop();
                    this.ctx.restore();
                    this.pendingClip = null;
                    this._cachedGetSinglePixelWidth = null;
                  }
                },
                transform: function CanvasGraphics_transform(a, b, c, d, e, f) {
                  this.ctx.transform(a, b, c, d, e, f);
                  this._cachedGetSinglePixelWidth = null;
                },
                constructPath: function CanvasGraphics_constructPath(ops, args) {
                  var ctx = this.ctx;
                  var current = this.current;
                  var x = current.x, y = current.y;
                  for (var i = 0, j = 0, ii = ops.length; i < ii; i++) {
                    switch (ops[i] | 0) {
                      case _util2.OPS.rectangle:
                        x = args[j++];
                        y = args[j++];
                        var width = args[j++];
                        var height = args[j++];
                        if (width === 0) {
                          width = this.getSinglePixelWidth();
                        }
                        if (height === 0) {
                          height = this.getSinglePixelWidth();
                        }
                        var xw = x + width;
                        var yh = y + height;
                        this.ctx.moveTo(x, y);
                        this.ctx.lineTo(xw, y);
                        this.ctx.lineTo(xw, yh);
                        this.ctx.lineTo(x, yh);
                        this.ctx.lineTo(x, y);
                        this.ctx.closePath();
                        break;
                      case _util2.OPS.moveTo:
                        x = args[j++];
                        y = args[j++];
                        ctx.moveTo(x, y);
                        break;
                      case _util2.OPS.lineTo:
                        x = args[j++];
                        y = args[j++];
                        ctx.lineTo(x, y);
                        break;
                      case _util2.OPS.curveTo:
                        x = args[j + 4];
                        y = args[j + 5];
                        ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y);
                        j += 6;
                        break;
                      case _util2.OPS.curveTo2:
                        ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);
                        x = args[j + 2];
                        y = args[j + 3];
                        j += 4;
                        break;
                      case _util2.OPS.curveTo3:
                        x = args[j + 2];
                        y = args[j + 3];
                        ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);
                        j += 4;
                        break;
                      case _util2.OPS.closePath:
                        ctx.closePath();
                        break;
                    }
                  }
                  current.setCurrentPoint(x, y);
                },
                closePath: function CanvasGraphics_closePath() {
                  this.ctx.closePath();
                },
                stroke: function CanvasGraphics_stroke(consumePath) {
                  consumePath = typeof consumePath !== "undefined" ? consumePath : true;
                  var ctx = this.ctx;
                  var strokeColor = this.current.strokeColor;
                  ctx.globalAlpha = this.current.strokeAlpha;
                  if (strokeColor && strokeColor.hasOwnProperty("type") && strokeColor.type === "Pattern") {
                    ctx.save();
                    const transform = ctx.mozCurrentTransform;
                    const scale = _util2.Util.singularValueDecompose2dScale(transform)[0];
                    ctx.strokeStyle = strokeColor.getPattern(ctx, this);
                    ctx.lineWidth = Math.max(this.getSinglePixelWidth() * MIN_WIDTH_FACTOR, this.current.lineWidth * scale);
                    ctx.stroke();
                    ctx.restore();
                  } else {
                    ctx.lineWidth = Math.max(this.getSinglePixelWidth() * MIN_WIDTH_FACTOR, this.current.lineWidth);
                    ctx.stroke();
                  }
                  if (consumePath) {
                    this.consumePath();
                  }
                  ctx.globalAlpha = this.current.fillAlpha;
                },
                closeStroke: function CanvasGraphics_closeStroke() {
                  this.closePath();
                  this.stroke();
                },
                fill: function CanvasGraphics_fill(consumePath) {
                  consumePath = typeof consumePath !== "undefined" ? consumePath : true;
                  var ctx = this.ctx;
                  var fillColor = this.current.fillColor;
                  var isPatternFill = this.current.patternFill;
                  var needRestore = false;
                  if (isPatternFill) {
                    ctx.save();
                    if (this.baseTransform) {
                      ctx.setTransform.apply(ctx, this.baseTransform);
                    }
                    ctx.fillStyle = fillColor.getPattern(ctx, this);
                    needRestore = true;
                  }
                  if (this.pendingEOFill) {
                    ctx.fill("evenodd");
                    this.pendingEOFill = false;
                  } else {
                    ctx.fill();
                  }
                  if (needRestore) {
                    ctx.restore();
                  }
                  if (consumePath) {
                    this.consumePath();
                  }
                },
                eoFill: function CanvasGraphics_eoFill() {
                  this.pendingEOFill = true;
                  this.fill();
                },
                fillStroke: function CanvasGraphics_fillStroke() {
                  this.fill(false);
                  this.stroke(false);
                  this.consumePath();
                },
                eoFillStroke: function CanvasGraphics_eoFillStroke() {
                  this.pendingEOFill = true;
                  this.fillStroke();
                },
                closeFillStroke: function CanvasGraphics_closeFillStroke() {
                  this.closePath();
                  this.fillStroke();
                },
                closeEOFillStroke: function CanvasGraphics_closeEOFillStroke() {
                  this.pendingEOFill = true;
                  this.closePath();
                  this.fillStroke();
                },
                endPath: function CanvasGraphics_endPath() {
                  this.consumePath();
                },
                clip: function CanvasGraphics_clip() {
                  this.pendingClip = NORMAL_CLIP;
                },
                eoClip: function CanvasGraphics_eoClip() {
                  this.pendingClip = EO_CLIP;
                },
                beginText: function CanvasGraphics_beginText() {
                  this.current.textMatrix = _util2.IDENTITY_MATRIX;
                  this.current.textMatrixScale = 1;
                  this.current.x = this.current.lineX = 0;
                  this.current.y = this.current.lineY = 0;
                },
                endText: function CanvasGraphics_endText() {
                  var paths = this.pendingTextPaths;
                  var ctx = this.ctx;
                  if (paths === void 0) {
                    ctx.beginPath();
                    return;
                  }
                  ctx.save();
                  ctx.beginPath();
                  for (var i = 0; i < paths.length; i++) {
                    var path = paths[i];
                    ctx.setTransform.apply(ctx, path.transform);
                    ctx.translate(path.x, path.y);
                    path.addToPath(ctx, path.fontSize);
                  }
                  ctx.restore();
                  ctx.clip();
                  ctx.beginPath();
                  delete this.pendingTextPaths;
                },
                setCharSpacing: function CanvasGraphics_setCharSpacing(spacing) {
                  this.current.charSpacing = spacing;
                },
                setWordSpacing: function CanvasGraphics_setWordSpacing(spacing) {
                  this.current.wordSpacing = spacing;
                },
                setHScale: function CanvasGraphics_setHScale(scale) {
                  this.current.textHScale = scale / 100;
                },
                setLeading: function CanvasGraphics_setLeading(leading) {
                  this.current.leading = -leading;
                },
                setFont: function CanvasGraphics_setFont(fontRefName, size) {
                  var fontObj = this.commonObjs.get(fontRefName);
                  var current = this.current;
                  if (!fontObj) {
                    throw new Error(`Can't find font for ${fontRefName}`);
                  }
                  current.fontMatrix = fontObj.fontMatrix ? fontObj.fontMatrix : _util2.FONT_IDENTITY_MATRIX;
                  if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {
                    (0, _util2.warn)("Invalid font matrix for font " + fontRefName);
                  }
                  if (size < 0) {
                    size = -size;
                    current.fontDirection = -1;
                  } else {
                    current.fontDirection = 1;
                  }
                  this.current.font = fontObj;
                  this.current.fontSize = size;
                  if (fontObj.isType3Font) {
                    return;
                  }
                  var name = fontObj.loadedName || "sans-serif";
                  let bold = "normal";
                  if (fontObj.black) {
                    bold = "900";
                  } else if (fontObj.bold) {
                    bold = "bold";
                  }
                  var italic = fontObj.italic ? "italic" : "normal";
                  var typeface = `"${name}", ${fontObj.fallbackName}`;
                  let browserFontSize = size;
                  if (size < MIN_FONT_SIZE) {
                    browserFontSize = MIN_FONT_SIZE;
                  } else if (size > MAX_FONT_SIZE) {
                    browserFontSize = MAX_FONT_SIZE;
                  }
                  this.current.fontSizeScale = size / browserFontSize;
                  this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;
                },
                setTextRenderingMode: function CanvasGraphics_setTextRenderingMode(mode) {
                  this.current.textRenderingMode = mode;
                },
                setTextRise: function CanvasGraphics_setTextRise(rise) {
                  this.current.textRise = rise;
                },
                moveText: function CanvasGraphics_moveText(x, y) {
                  this.current.x = this.current.lineX += x;
                  this.current.y = this.current.lineY += y;
                },
                setLeadingMoveText: function CanvasGraphics_setLeadingMoveText(x, y) {
                  this.setLeading(-y);
                  this.moveText(x, y);
                },
                setTextMatrix: function CanvasGraphics_setTextMatrix(a, b, c, d, e, f) {
                  this.current.textMatrix = [a, b, c, d, e, f];
                  this.current.textMatrixScale = Math.sqrt(a * a + b * b);
                  this.current.x = this.current.lineX = 0;
                  this.current.y = this.current.lineY = 0;
                },
                nextLine: function CanvasGraphics_nextLine() {
                  this.moveText(0, this.current.leading);
                },
                paintChar(character, x, y, patternTransform) {
                  var ctx = this.ctx;
                  var current = this.current;
                  var font = current.font;
                  var textRenderingMode = current.textRenderingMode;
                  var fontSize = current.fontSize / current.fontSizeScale;
                  var fillStrokeMode = textRenderingMode & _util2.TextRenderingMode.FILL_STROKE_MASK;
                  var isAddToPathSet = !!(textRenderingMode & _util2.TextRenderingMode.ADD_TO_PATH_FLAG);
                  const patternFill = current.patternFill && font.data;
                  var addToPath;
                  if (font.disableFontFace || isAddToPathSet || patternFill) {
                    addToPath = font.getPathGenerator(this.commonObjs, character);
                  }
                  if (font.disableFontFace || patternFill) {
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.beginPath();
                    addToPath(ctx, fontSize);
                    if (patternTransform) {
                      ctx.setTransform.apply(ctx, patternTransform);
                    }
                    if (fillStrokeMode === _util2.TextRenderingMode.FILL || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      ctx.fill();
                    }
                    if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      ctx.stroke();
                    }
                    ctx.restore();
                  } else {
                    if (fillStrokeMode === _util2.TextRenderingMode.FILL || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      ctx.fillText(character, x, y);
                    }
                    if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      ctx.strokeText(character, x, y);
                    }
                  }
                  if (isAddToPathSet) {
                    var paths = this.pendingTextPaths || (this.pendingTextPaths = []);
                    paths.push({
                      transform: ctx.mozCurrentTransform,
                      x,
                      y,
                      fontSize,
                      addToPath
                    });
                  }
                },
                get isFontSubpixelAAEnabled() {
                  const {
                    context: ctx
                  } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
                  ctx.scale(1.5, 1);
                  ctx.fillText("I", 0, 10);
                  var data = ctx.getImageData(0, 0, 10, 10).data;
                  var enabled = false;
                  for (var i = 3; i < data.length; i += 4) {
                    if (data[i] > 0 && data[i] < 255) {
                      enabled = true;
                      break;
                    }
                  }
                  return (0, _util2.shadow)(this, "isFontSubpixelAAEnabled", enabled);
                },
                showText: function CanvasGraphics_showText(glyphs) {
                  var current = this.current;
                  var font = current.font;
                  if (font.isType3Font) {
                    return this.showType3Text(glyphs);
                  }
                  var fontSize = current.fontSize;
                  if (fontSize === 0) {
                    return void 0;
                  }
                  var ctx = this.ctx;
                  var fontSizeScale = current.fontSizeScale;
                  var charSpacing = current.charSpacing;
                  var wordSpacing = current.wordSpacing;
                  var fontDirection = current.fontDirection;
                  var textHScale = current.textHScale * fontDirection;
                  var glyphsLength = glyphs.length;
                  var vertical = font.vertical;
                  var spacingDir = vertical ? 1 : -1;
                  var defaultVMetrics = font.defaultVMetrics;
                  var widthAdvanceScale = fontSize * current.fontMatrix[0];
                  var simpleFillText = current.textRenderingMode === _util2.TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;
                  ctx.save();
                  let patternTransform;
                  if (current.patternFill) {
                    ctx.save();
                    const pattern = current.fillColor.getPattern(ctx, this);
                    patternTransform = ctx.mozCurrentTransform;
                    ctx.restore();
                    ctx.fillStyle = pattern;
                  }
                  ctx.transform.apply(ctx, current.textMatrix);
                  ctx.translate(current.x, current.y + current.textRise);
                  if (fontDirection > 0) {
                    ctx.scale(textHScale, -1);
                  } else {
                    ctx.scale(textHScale, 1);
                  }
                  var lineWidth = current.lineWidth;
                  var scale = current.textMatrixScale;
                  if (scale === 0 || lineWidth === 0) {
                    var fillStrokeMode = current.textRenderingMode & _util2.TextRenderingMode.FILL_STROKE_MASK;
                    if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      this._cachedGetSinglePixelWidth = null;
                      lineWidth = this.getSinglePixelWidth() * MIN_WIDTH_FACTOR;
                    }
                  } else {
                    lineWidth /= scale;
                  }
                  if (fontSizeScale !== 1) {
                    ctx.scale(fontSizeScale, fontSizeScale);
                    lineWidth /= fontSizeScale;
                  }
                  ctx.lineWidth = lineWidth;
                  var x = 0, i;
                  for (i = 0; i < glyphsLength; ++i) {
                    var glyph = glyphs[i];
                    if ((0, _util2.isNum)(glyph)) {
                      x += spacingDir * glyph * fontSize / 1e3;
                      continue;
                    }
                    var restoreNeeded = false;
                    var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                    var character = glyph.fontChar;
                    var accent = glyph.accent;
                    var scaledX, scaledY, scaledAccentX, scaledAccentY;
                    var width = glyph.width;
                    if (vertical) {
                      var vmetric, vx, vy;
                      vmetric = glyph.vmetric || defaultVMetrics;
                      vx = glyph.vmetric ? vmetric[1] : width * 0.5;
                      vx = -vx * widthAdvanceScale;
                      vy = vmetric[2] * widthAdvanceScale;
                      width = vmetric ? -vmetric[0] : width;
                      scaledX = vx / fontSizeScale;
                      scaledY = (x + vy) / fontSizeScale;
                    } else {
                      scaledX = x / fontSizeScale;
                      scaledY = 0;
                    }
                    if (font.remeasure && width > 0) {
                      var measuredWidth = ctx.measureText(character).width * 1e3 / fontSize * fontSizeScale;
                      if (width < measuredWidth && this.isFontSubpixelAAEnabled) {
                        var characterScaleX = width / measuredWidth;
                        restoreNeeded = true;
                        ctx.save();
                        ctx.scale(characterScaleX, 1);
                        scaledX /= characterScaleX;
                      } else if (width !== measuredWidth) {
                        scaledX += (width - measuredWidth) / 2e3 * fontSize / fontSizeScale;
                      }
                    }
                    if (glyph.isInFont || font.missingFile) {
                      if (simpleFillText && !accent) {
                        ctx.fillText(character, scaledX, scaledY);
                      } else {
                        this.paintChar(character, scaledX, scaledY, patternTransform);
                        if (accent) {
                          scaledAccentX = scaledX + accent.offset.x / fontSizeScale;
                          scaledAccentY = scaledY - accent.offset.y / fontSizeScale;
                          this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternTransform);
                        }
                      }
                    }
                    var charWidth;
                    if (vertical) {
                      charWidth = width * widthAdvanceScale - spacing * fontDirection;
                    } else {
                      charWidth = width * widthAdvanceScale + spacing * fontDirection;
                    }
                    x += charWidth;
                    if (restoreNeeded) {
                      ctx.restore();
                    }
                  }
                  if (vertical) {
                    current.y -= x;
                  } else {
                    current.x += x * textHScale;
                  }
                  ctx.restore();
                },
                showType3Text: function CanvasGraphics_showType3Text(glyphs) {
                  var ctx = this.ctx;
                  var current = this.current;
                  var font = current.font;
                  var fontSize = current.fontSize;
                  var fontDirection = current.fontDirection;
                  var spacingDir = font.vertical ? 1 : -1;
                  var charSpacing = current.charSpacing;
                  var wordSpacing = current.wordSpacing;
                  var textHScale = current.textHScale * fontDirection;
                  var fontMatrix = current.fontMatrix || _util2.FONT_IDENTITY_MATRIX;
                  var glyphsLength = glyphs.length;
                  var isTextInvisible = current.textRenderingMode === _util2.TextRenderingMode.INVISIBLE;
                  var i, glyph, width, spacingLength;
                  if (isTextInvisible || fontSize === 0) {
                    return;
                  }
                  this._cachedGetSinglePixelWidth = null;
                  ctx.save();
                  ctx.transform.apply(ctx, current.textMatrix);
                  ctx.translate(current.x, current.y);
                  ctx.scale(textHScale, fontDirection);
                  for (i = 0; i < glyphsLength; ++i) {
                    glyph = glyphs[i];
                    if ((0, _util2.isNum)(glyph)) {
                      spacingLength = spacingDir * glyph * fontSize / 1e3;
                      this.ctx.translate(spacingLength, 0);
                      current.x += spacingLength * textHScale;
                      continue;
                    }
                    var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                    var operatorList = font.charProcOperatorList[glyph.operatorListId];
                    if (!operatorList) {
                      (0, _util2.warn)(`Type3 character "${glyph.operatorListId}" is not available.`);
                      continue;
                    }
                    this.processingType3 = glyph;
                    this.save();
                    ctx.scale(fontSize, fontSize);
                    ctx.transform.apply(ctx, fontMatrix);
                    this.executeOperatorList(operatorList);
                    this.restore();
                    var transformed = _util2.Util.applyTransform([glyph.width, 0], fontMatrix);
                    width = transformed[0] * fontSize + spacing;
                    ctx.translate(width, 0);
                    current.x += width * textHScale;
                  }
                  ctx.restore();
                  this.processingType3 = null;
                },
                setCharWidth: function CanvasGraphics_setCharWidth(xWidth, yWidth) {
                },
                setCharWidthAndBounds: function CanvasGraphics_setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {
                  this.ctx.rect(llx, lly, urx - llx, ury - lly);
                  this.clip();
                  this.endPath();
                },
                getColorN_Pattern: function CanvasGraphics_getColorN_Pattern(IR) {
                  var pattern;
                  if (IR[0] === "TilingPattern") {
                    var color = IR[1];
                    var baseTransform = this.baseTransform || this.ctx.mozCurrentTransform.slice();
                    var canvasGraphicsFactory = {
                      createCanvasGraphics: (ctx) => {
                        return new CanvasGraphics2(ctx, this.commonObjs, this.objs, this.canvasFactory, this.webGLContext);
                      }
                    };
                    pattern = new _pattern_helper.TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);
                  } else {
                    pattern = (0, _pattern_helper.getShadingPatternFromIR)(IR);
                  }
                  return pattern;
                },
                setStrokeColorN: function CanvasGraphics_setStrokeColorN() {
                  this.current.strokeColor = this.getColorN_Pattern(arguments);
                },
                setFillColorN: function CanvasGraphics_setFillColorN() {
                  this.current.fillColor = this.getColorN_Pattern(arguments);
                  this.current.patternFill = true;
                },
                setStrokeRGBColor: function CanvasGraphics_setStrokeRGBColor(r, g, b) {
                  var color = _util2.Util.makeCssRgb(r, g, b);
                  this.ctx.strokeStyle = color;
                  this.current.strokeColor = color;
                },
                setFillRGBColor: function CanvasGraphics_setFillRGBColor(r, g, b) {
                  var color = _util2.Util.makeCssRgb(r, g, b);
                  this.ctx.fillStyle = color;
                  this.current.fillColor = color;
                  this.current.patternFill = false;
                },
                shadingFill: function CanvasGraphics_shadingFill(patternIR) {
                  var ctx = this.ctx;
                  this.save();
                  var pattern = (0, _pattern_helper.getShadingPatternFromIR)(patternIR);
                  ctx.fillStyle = pattern.getPattern(ctx, this, true);
                  var inv = ctx.mozCurrentTransformInverse;
                  if (inv) {
                    var canvas = ctx.canvas;
                    var width = canvas.width;
                    var height = canvas.height;
                    var bl = _util2.Util.applyTransform([0, 0], inv);
                    var br = _util2.Util.applyTransform([0, height], inv);
                    var ul = _util2.Util.applyTransform([width, 0], inv);
                    var ur = _util2.Util.applyTransform([width, height], inv);
                    var x0 = Math.min(bl[0], br[0], ul[0], ur[0]);
                    var y0 = Math.min(bl[1], br[1], ul[1], ur[1]);
                    var x1 = Math.max(bl[0], br[0], ul[0], ur[0]);
                    var y1 = Math.max(bl[1], br[1], ul[1], ur[1]);
                    this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);
                  } else {
                    this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
                  }
                  this.restore();
                },
                beginInlineImage: function CanvasGraphics_beginInlineImage() {
                  (0, _util2.unreachable)("Should not call beginInlineImage");
                },
                beginImageData: function CanvasGraphics_beginImageData() {
                  (0, _util2.unreachable)("Should not call beginImageData");
                },
                paintFormXObjectBegin: function CanvasGraphics_paintFormXObjectBegin(matrix, bbox) {
                  this.save();
                  this.baseTransformStack.push(this.baseTransform);
                  if (Array.isArray(matrix) && matrix.length === 6) {
                    this.transform.apply(this, matrix);
                  }
                  this.baseTransform = this.ctx.mozCurrentTransform;
                  if (bbox) {
                    var width = bbox[2] - bbox[0];
                    var height = bbox[3] - bbox[1];
                    this.ctx.rect(bbox[0], bbox[1], width, height);
                    this.clip();
                    this.endPath();
                  }
                },
                paintFormXObjectEnd: function CanvasGraphics_paintFormXObjectEnd() {
                  this.restore();
                  this.baseTransform = this.baseTransformStack.pop();
                },
                beginGroup: function CanvasGraphics_beginGroup(group) {
                  this.save();
                  var currentCtx = this.ctx;
                  if (!group.isolated) {
                    (0, _util2.info)("TODO: Support non-isolated groups.");
                  }
                  if (group.knockout) {
                    (0, _util2.warn)("Knockout groups not supported.");
                  }
                  var currentTransform = currentCtx.mozCurrentTransform;
                  if (group.matrix) {
                    currentCtx.transform.apply(currentCtx, group.matrix);
                  }
                  if (!group.bbox) {
                    throw new Error("Bounding box is required.");
                  }
                  var bounds = _util2.Util.getAxialAlignedBoundingBox(group.bbox, currentCtx.mozCurrentTransform);
                  var canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];
                  bounds = _util2.Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];
                  var offsetX = Math.floor(bounds[0]);
                  var offsetY = Math.floor(bounds[1]);
                  var drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);
                  var drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);
                  var scaleX = 1, scaleY = 1;
                  if (drawnWidth > MAX_GROUP_SIZE) {
                    scaleX = drawnWidth / MAX_GROUP_SIZE;
                    drawnWidth = MAX_GROUP_SIZE;
                  }
                  if (drawnHeight > MAX_GROUP_SIZE) {
                    scaleY = drawnHeight / MAX_GROUP_SIZE;
                    drawnHeight = MAX_GROUP_SIZE;
                  }
                  var cacheId = "groupAt" + this.groupLevel;
                  if (group.smask) {
                    cacheId += "_smask_" + this.smaskCounter++ % 2;
                  }
                  var scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);
                  var groupCtx = scratchCanvas.context;
                  groupCtx.scale(1 / scaleX, 1 / scaleY);
                  groupCtx.translate(-offsetX, -offsetY);
                  groupCtx.transform.apply(groupCtx, currentTransform);
                  if (group.smask) {
                    this.smaskStack.push({
                      canvas: scratchCanvas.canvas,
                      context: groupCtx,
                      offsetX,
                      offsetY,
                      scaleX,
                      scaleY,
                      subtype: group.smask.subtype,
                      backdrop: group.smask.backdrop,
                      transferMap: group.smask.transferMap || null,
                      startTransformInverse: null
                    });
                  } else {
                    currentCtx.setTransform(1, 0, 0, 1, 0, 0);
                    currentCtx.translate(offsetX, offsetY);
                    currentCtx.scale(scaleX, scaleY);
                  }
                  copyCtxState(currentCtx, groupCtx);
                  this.ctx = groupCtx;
                  this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
                  this.groupStack.push(currentCtx);
                  this.groupLevel++;
                  this.current.activeSMask = null;
                },
                endGroup: function CanvasGraphics_endGroup(group) {
                  this.groupLevel--;
                  var groupCtx = this.ctx;
                  this.ctx = this.groupStack.pop();
                  if (this.ctx.imageSmoothingEnabled !== void 0) {
                    this.ctx.imageSmoothingEnabled = false;
                  } else {
                    this.ctx.mozImageSmoothingEnabled = false;
                  }
                  if (group.smask) {
                    this.tempSMask = this.smaskStack.pop();
                  } else {
                    this.ctx.drawImage(groupCtx.canvas, 0, 0);
                  }
                  this.restore();
                },
                beginAnnotations: function CanvasGraphics_beginAnnotations() {
                  this.save();
                  if (this.baseTransform) {
                    this.ctx.setTransform.apply(this.ctx, this.baseTransform);
                  }
                },
                endAnnotations: function CanvasGraphics_endAnnotations() {
                  this.restore();
                },
                beginAnnotation: function CanvasGraphics_beginAnnotation(rect, transform, matrix) {
                  this.save();
                  resetCtxToDefault(this.ctx);
                  this.current = new CanvasExtraState();
                  if (Array.isArray(rect) && rect.length === 4) {
                    var width = rect[2] - rect[0];
                    var height = rect[3] - rect[1];
                    this.ctx.rect(rect[0], rect[1], width, height);
                    this.clip();
                    this.endPath();
                  }
                  this.transform.apply(this, transform);
                  this.transform.apply(this, matrix);
                },
                endAnnotation: function CanvasGraphics_endAnnotation() {
                  this.restore();
                },
                paintJpegXObject: function CanvasGraphics_paintJpegXObject(objId, w, h) {
                  const domImage = this.processingType3 ? this.commonObjs.get(objId) : this.objs.get(objId);
                  if (!domImage) {
                    (0, _util2.warn)("Dependent image isn't ready yet");
                    return;
                  }
                  this.save();
                  var ctx = this.ctx;
                  ctx.scale(1 / w, -1 / h);
                  ctx.drawImage(domImage, 0, 0, domImage.width, domImage.height, 0, -h, w, h);
                  if (this.imageLayer) {
                    var currentTransform = ctx.mozCurrentTransformInverse;
                    var position = this.getCanvasPosition(0, 0);
                    this.imageLayer.appendImage({
                      objId,
                      left: position[0],
                      top: position[1],
                      width: w / currentTransform[0],
                      height: h / currentTransform[3]
                    });
                  }
                  this.restore();
                },
                paintImageMaskXObject: function CanvasGraphics_paintImageMaskXObject(img) {
                  var ctx = this.ctx;
                  var width = img.width, height = img.height;
                  var fillColor = this.current.fillColor;
                  var isPatternFill = this.current.patternFill;
                  var glyph = this.processingType3;
                  if (COMPILE_TYPE3_GLYPHS && glyph && glyph.compiled === void 0) {
                    if (width <= MAX_SIZE_TO_COMPILE && height <= MAX_SIZE_TO_COMPILE) {
                      glyph.compiled = compileType3Glyph({
                        data: img.data,
                        width,
                        height
                      });
                    } else {
                      glyph.compiled = null;
                    }
                  }
                  if (glyph && glyph.compiled) {
                    glyph.compiled(ctx);
                    return;
                  }
                  var maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
                  var maskCtx = maskCanvas.context;
                  maskCtx.save();
                  putBinaryImageMask(maskCtx, img);
                  maskCtx.globalCompositeOperation = "source-in";
                  maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;
                  maskCtx.fillRect(0, 0, width, height);
                  maskCtx.restore();
                  this.paintInlineImageXObject(maskCanvas.canvas);
                },
                paintImageMaskXObjectRepeat: function CanvasGraphics_paintImageMaskXObjectRepeat(imgData, scaleX, scaleY, positions) {
                  var width = imgData.width;
                  var height = imgData.height;
                  var fillColor = this.current.fillColor;
                  var isPatternFill = this.current.patternFill;
                  var maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
                  var maskCtx = maskCanvas.context;
                  maskCtx.save();
                  putBinaryImageMask(maskCtx, imgData);
                  maskCtx.globalCompositeOperation = "source-in";
                  maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;
                  maskCtx.fillRect(0, 0, width, height);
                  maskCtx.restore();
                  var ctx = this.ctx;
                  for (var i = 0, ii = positions.length; i < ii; i += 2) {
                    ctx.save();
                    ctx.transform(scaleX, 0, 0, scaleY, positions[i], positions[i + 1]);
                    ctx.scale(1, -1);
                    ctx.drawImage(maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);
                    ctx.restore();
                  }
                },
                paintImageMaskXObjectGroup: function CanvasGraphics_paintImageMaskXObjectGroup(images) {
                  var ctx = this.ctx;
                  var fillColor = this.current.fillColor;
                  var isPatternFill = this.current.patternFill;
                  for (var i = 0, ii = images.length; i < ii; i++) {
                    var image = images[i];
                    var width = image.width, height = image.height;
                    var maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
                    var maskCtx = maskCanvas.context;
                    maskCtx.save();
                    putBinaryImageMask(maskCtx, image);
                    maskCtx.globalCompositeOperation = "source-in";
                    maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;
                    maskCtx.fillRect(0, 0, width, height);
                    maskCtx.restore();
                    ctx.save();
                    ctx.transform.apply(ctx, image.transform);
                    ctx.scale(1, -1);
                    ctx.drawImage(maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);
                    ctx.restore();
                  }
                },
                paintImageXObject: function CanvasGraphics_paintImageXObject(objId) {
                  const imgData = this.processingType3 ? this.commonObjs.get(objId) : this.objs.get(objId);
                  if (!imgData) {
                    (0, _util2.warn)("Dependent image isn't ready yet");
                    return;
                  }
                  this.paintInlineImageXObject(imgData);
                },
                paintImageXObjectRepeat: function CanvasGraphics_paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {
                  const imgData = this.processingType3 ? this.commonObjs.get(objId) : this.objs.get(objId);
                  if (!imgData) {
                    (0, _util2.warn)("Dependent image isn't ready yet");
                    return;
                  }
                  var width = imgData.width;
                  var height = imgData.height;
                  var map = [];
                  for (var i = 0, ii = positions.length; i < ii; i += 2) {
                    map.push({
                      transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],
                      x: 0,
                      y: 0,
                      w: width,
                      h: height
                    });
                  }
                  this.paintInlineImageXObjectGroup(imgData, map);
                },
                paintInlineImageXObject: function CanvasGraphics_paintInlineImageXObject(imgData) {
                  var width = imgData.width;
                  var height = imgData.height;
                  var ctx = this.ctx;
                  this.save();
                  ctx.scale(1 / width, -1 / height);
                  var currentTransform = ctx.mozCurrentTransformInverse;
                  var a = currentTransform[0], b = currentTransform[1];
                  var widthScale = Math.max(Math.sqrt(a * a + b * b), 1);
                  var c = currentTransform[2], d = currentTransform[3];
                  var heightScale = Math.max(Math.sqrt(c * c + d * d), 1);
                  var imgToPaint, tmpCanvas;
                  if (typeof HTMLElement === "function" && imgData instanceof HTMLElement || !imgData.data) {
                    imgToPaint = imgData;
                  } else {
                    tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", width, height);
                    var tmpCtx = tmpCanvas.context;
                    putBinaryImageData(tmpCtx, imgData);
                    imgToPaint = tmpCanvas.canvas;
                  }
                  var paintWidth = width, paintHeight = height;
                  var tmpCanvasId = "prescale1";
                  while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {
                    var newWidth = paintWidth, newHeight = paintHeight;
                    if (widthScale > 2 && paintWidth > 1) {
                      newWidth = Math.ceil(paintWidth / 2);
                      widthScale /= paintWidth / newWidth;
                    }
                    if (heightScale > 2 && paintHeight > 1) {
                      newHeight = Math.ceil(paintHeight / 2);
                      heightScale /= paintHeight / newHeight;
                    }
                    tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);
                    tmpCtx = tmpCanvas.context;
                    tmpCtx.clearRect(0, 0, newWidth, newHeight);
                    tmpCtx.drawImage(imgToPaint, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);
                    imgToPaint = tmpCanvas.canvas;
                    paintWidth = newWidth;
                    paintHeight = newHeight;
                    tmpCanvasId = tmpCanvasId === "prescale1" ? "prescale2" : "prescale1";
                  }
                  ctx.drawImage(imgToPaint, 0, 0, paintWidth, paintHeight, 0, -height, width, height);
                  if (this.imageLayer) {
                    var position = this.getCanvasPosition(0, -height);
                    this.imageLayer.appendImage({
                      imgData,
                      left: position[0],
                      top: position[1],
                      width: width / currentTransform[0],
                      height: height / currentTransform[3]
                    });
                  }
                  this.restore();
                },
                paintInlineImageXObjectGroup: function CanvasGraphics_paintInlineImageXObjectGroup(imgData, map) {
                  var ctx = this.ctx;
                  var w = imgData.width;
                  var h = imgData.height;
                  var tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", w, h);
                  var tmpCtx = tmpCanvas.context;
                  putBinaryImageData(tmpCtx, imgData);
                  for (var i = 0, ii = map.length; i < ii; i++) {
                    var entry = map[i];
                    ctx.save();
                    ctx.transform.apply(ctx, entry.transform);
                    ctx.scale(1, -1);
                    ctx.drawImage(tmpCanvas.canvas, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);
                    if (this.imageLayer) {
                      var position = this.getCanvasPosition(entry.x, entry.y);
                      this.imageLayer.appendImage({
                        imgData,
                        left: position[0],
                        top: position[1],
                        width: w,
                        height: h
                      });
                    }
                    ctx.restore();
                  }
                },
                paintSolidColorImageMask: function CanvasGraphics_paintSolidColorImageMask() {
                  this.ctx.fillRect(0, 0, 1, 1);
                },
                paintXObject: function CanvasGraphics_paintXObject() {
                  (0, _util2.warn)("Unsupported 'paintXObject' command.");
                },
                markPoint: function CanvasGraphics_markPoint(tag) {
                },
                markPointProps: function CanvasGraphics_markPointProps(tag, properties) {
                },
                beginMarkedContent: function CanvasGraphics_beginMarkedContent(tag) {
                },
                beginMarkedContentProps: function CanvasGraphics_beginMarkedContentProps(tag, properties) {
                },
                endMarkedContent: function CanvasGraphics_endMarkedContent() {
                },
                beginCompat: function CanvasGraphics_beginCompat() {
                },
                endCompat: function CanvasGraphics_endCompat() {
                },
                consumePath: function CanvasGraphics_consumePath() {
                  var ctx = this.ctx;
                  if (this.pendingClip) {
                    if (this.pendingClip === EO_CLIP) {
                      ctx.clip("evenodd");
                    } else {
                      ctx.clip();
                    }
                    this.pendingClip = null;
                  }
                  ctx.beginPath();
                },
                getSinglePixelWidth(scale) {
                  if (this._cachedGetSinglePixelWidth === null) {
                    const inverse = this.ctx.mozCurrentTransformInverse;
                    this._cachedGetSinglePixelWidth = Math.sqrt(Math.max(inverse[0] * inverse[0] + inverse[1] * inverse[1], inverse[2] * inverse[2] + inverse[3] * inverse[3]));
                  }
                  return this._cachedGetSinglePixelWidth;
                },
                getCanvasPosition: function CanvasGraphics_getCanvasPosition(x, y) {
                  var transform = this.ctx.mozCurrentTransform;
                  return [transform[0] * x + transform[2] * y + transform[4], transform[1] * x + transform[3] * y + transform[5]];
                }
              };
              for (var op in _util2.OPS) {
                CanvasGraphics2.prototype[_util2.OPS[op]] = CanvasGraphics2.prototype[op];
              }
              return CanvasGraphics2;
            }();
            exports2.CanvasGraphics = CanvasGraphics;
          },
          9074: function(__unused_webpack_module2, exports2, __webpack_require__2) {
            "use strict";
            __webpack_require__2(3408);
            __webpack_require__2(4590);
            __webpack_require__2(7658);
            __webpack_require__2(2801);
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.getFilenameFromContentDispositionHeader = getFilenameFromContentDispositionHeader;
            function getFilenameFromContentDispositionHeader(contentDisposition) {
              let needsEncodingFixup = true;
              let tmp = toParamRegExp("filename\\*", "i").exec(contentDisposition);
              if (tmp) {
                tmp = tmp[1];
                let filename = rfc2616unquote(tmp);
                filename = unescape(filename);
                filename = rfc5987decode(filename);
                filename = rfc2047decode(filename);
                return fixupEncoding(filename);
              }
              tmp = rfc2231getparam(contentDisposition);
              if (tmp) {
                const filename = rfc2047decode(tmp);
                return fixupEncoding(filename);
              }
              tmp = toParamRegExp("filename", "i").exec(contentDisposition);
              if (tmp) {
                tmp = tmp[1];
                let filename = rfc2616unquote(tmp);
                filename = rfc2047decode(filename);
                return fixupEncoding(filename);
              }
              function toParamRegExp(attributePattern, flags) {
                return new RegExp("(?:^|;)\\s*" + attributePattern + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', flags);
              }
              function textdecode(encoding, value) {
                if (encoding) {
                  if (!/^[\x00-\xFF]+$/.test(value)) {
                    return value;
                  }
                  try {
                    const decoder = new TextDecoder(encoding, {
                      fatal: true
                    });
                    const bytes = Array.from(value, function(ch) {
                      return ch.charCodeAt(0) & 255;
                    });
                    value = decoder.decode(new Uint8Array(bytes));
                    needsEncodingFixup = false;
                  } catch (e) {
                    if (/^utf-?8$/i.test(encoding)) {
                      try {
                        value = decodeURIComponent(escape(value));
                        needsEncodingFixup = false;
                      } catch (err) {
                      }
                    }
                  }
                }
                return value;
              }
              function fixupEncoding(value) {
                if (needsEncodingFixup && /[\x80-\xff]/.test(value)) {
                  value = textdecode("utf-8", value);
                  if (needsEncodingFixup) {
                    value = textdecode("iso-8859-1", value);
                  }
                }
                return value;
              }
              function rfc2231getparam(contentDisposition2) {
                const matches = [];
                let match;
                const iter = toParamRegExp("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
                while ((match = iter.exec(contentDisposition2)) !== null) {
                  let [, n, quot, part] = match;
                  n = parseInt(n, 10);
                  if (n in matches) {
                    if (n === 0) {
                      break;
                    }
                    continue;
                  }
                  matches[n] = [quot, part];
                }
                const parts = [];
                for (let n = 0; n < matches.length; ++n) {
                  if (!(n in matches)) {
                    break;
                  }
                  let [quot, part] = matches[n];
                  part = rfc2616unquote(part);
                  if (quot) {
                    part = unescape(part);
                    if (n === 0) {
                      part = rfc5987decode(part);
                    }
                  }
                  parts.push(part);
                }
                return parts.join("");
              }
              function rfc2616unquote(value) {
                if (value.startsWith('"')) {
                  const parts = value.slice(1).split('\\"');
                  for (let i = 0; i < parts.length; ++i) {
                    const quotindex = parts[i].indexOf('"');
                    if (quotindex !== -1) {
                      parts[i] = parts[i].slice(0, quotindex);
                      parts.length = i + 1;
                    }
                    parts[i] = parts[i].replace(/\\(.)/g, "$1");
                  }
                  value = parts.join('"');
                }
                return value;
              }
              function rfc5987decode(extvalue) {
                const encodingend = extvalue.indexOf("'");
                if (encodingend === -1) {
                  return extvalue;
                }
                const encoding = extvalue.slice(0, encodingend);
                const langvalue = extvalue.slice(encodingend + 1);
                const value = langvalue.replace(/^[^']*'/, "");
                return textdecode(encoding, value);
              }
              function rfc2047decode(value) {
                if (!value.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(value)) {
                  return value;
                }
                return value.replace(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function(_, charset, encoding, text) {
                  if (encoding === "q" || encoding === "Q") {
                    text = text.replace(/_/g, " ");
                    text = text.replace(/=([0-9a-fA-F]{2})/g, function(_2, hex) {
                      return String.fromCharCode(parseInt(hex, 16));
                    });
                    return textdecode(charset, text);
                  }
                  try {
                    text = atob(text);
                  } catch (e) {
                  }
                  return textdecode(charset, text);
                });
              }
              return "";
            }
          },
          9485: function(__unused_webpack_module2, exports2, __webpack_require__2) {
            "use strict";
            __webpack_require__2(3408);
            __webpack_require__2(4590);
            __webpack_require__2(7658);
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.addLinkAttributes = addLinkAttributes;
            exports2.getFilenameFromUrl = getFilenameFromUrl;
            exports2.isFetchSupported = isFetchSupported;
            exports2.isValidFetchUrl = isValidFetchUrl;
            exports2.loadScript = loadScript;
            exports2.deprecated = deprecated;
            exports2.releaseImageResources = releaseImageResources;
            exports2.PDFDateString = exports2.StatTimer = exports2.DOMSVGFactory = exports2.DOMCMapReaderFactory = exports2.DOMCanvasFactory = exports2.DEFAULT_LINK_REL = exports2.LinkTarget = exports2.RenderingCancelledException = exports2.PageViewport = void 0;
            var _util2 = __webpack_require__2(7484);
            const DEFAULT_LINK_REL = "noopener noreferrer nofollow";
            exports2.DEFAULT_LINK_REL = DEFAULT_LINK_REL;
            const SVG_NS = "http://www.w3.org/2000/svg";
            class DOMCanvasFactory {
              create(width, height) {
                if (width <= 0 || height <= 0) {
                  throw new Error("Invalid canvas size");
                }
                const canvas = document.createElement("canvas");
                const context = canvas.getContext("2d");
                canvas.width = width;
                canvas.height = height;
                return {
                  canvas,
                  context
                };
              }
              reset(canvasAndContext, width, height) {
                if (!canvasAndContext.canvas) {
                  throw new Error("Canvas is not specified");
                }
                if (width <= 0 || height <= 0) {
                  throw new Error("Invalid canvas size");
                }
                canvasAndContext.canvas.width = width;
                canvasAndContext.canvas.height = height;
              }
              destroy(canvasAndContext) {
                if (!canvasAndContext.canvas) {
                  throw new Error("Canvas is not specified");
                }
                canvasAndContext.canvas.width = 0;
                canvasAndContext.canvas.height = 0;
                canvasAndContext.canvas = null;
                canvasAndContext.context = null;
              }
            }
            exports2.DOMCanvasFactory = DOMCanvasFactory;
            class DOMCMapReaderFactory {
              constructor({
                baseUrl = null,
                isCompressed = false
              }) {
                this.baseUrl = baseUrl;
                this.isCompressed = isCompressed;
              }
              async fetch({
                name
              }) {
                if (!this.baseUrl) {
                  throw new Error('The CMap "baseUrl" parameter must be specified, ensure that the "cMapUrl" and "cMapPacked" API parameters are provided.');
                }
                if (!name) {
                  throw new Error("CMap name must be specified.");
                }
                const url = this.baseUrl + name + (this.isCompressed ? ".bcmap" : "");
                const compressionType = this.isCompressed ? _util2.CMapCompressionType.BINARY : _util2.CMapCompressionType.NONE;
                if (isFetchSupported() && isValidFetchUrl(url, document.baseURI)) {
                  return fetch(url).then(async (response) => {
                    if (!response.ok) {
                      throw new Error(response.statusText);
                    }
                    let cMapData;
                    if (this.isCompressed) {
                      cMapData = new Uint8Array(await response.arrayBuffer());
                    } else {
                      cMapData = (0, _util2.stringToBytes)(await response.text());
                    }
                    return {
                      cMapData,
                      compressionType
                    };
                  }).catch((reason) => {
                    throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${url}`);
                  });
                }
                return new Promise((resolve, reject) => {
                  const request = new XMLHttpRequest();
                  request.open("GET", url, true);
                  if (this.isCompressed) {
                    request.responseType = "arraybuffer";
                  }
                  request.onreadystatechange = () => {
                    if (request.readyState !== XMLHttpRequest.DONE) {
                      return;
                    }
                    if (request.status === 200 || request.status === 0) {
                      let cMapData;
                      if (this.isCompressed && request.response) {
                        cMapData = new Uint8Array(request.response);
                      } else if (!this.isCompressed && request.responseText) {
                        cMapData = (0, _util2.stringToBytes)(request.responseText);
                      }
                      if (cMapData) {
                        resolve({
                          cMapData,
                          compressionType
                        });
                        return;
                      }
                    }
                    reject(new Error(request.statusText));
                  };
                  request.send(null);
                }).catch((reason) => {
                  throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${url}`);
                });
              }
            }
            exports2.DOMCMapReaderFactory = DOMCMapReaderFactory;
            class DOMSVGFactory {
              create(width, height) {
                (0, _util2.assert)(width > 0 && height > 0, "Invalid SVG dimensions");
                const svg = document.createElementNS(SVG_NS, "svg:svg");
                svg.setAttribute("version", "1.1");
                svg.setAttribute("width", width + "px");
                svg.setAttribute("height", height + "px");
                svg.setAttribute("preserveAspectRatio", "none");
                svg.setAttribute("viewBox", "0 0 " + width + " " + height);
                return svg;
              }
              createElement(type) {
                (0, _util2.assert)(typeof type === "string", "Invalid SVG element type");
                return document.createElementNS(SVG_NS, type);
              }
            }
            exports2.DOMSVGFactory = DOMSVGFactory;
            class PageViewport {
              constructor({
                viewBox,
                scale,
                rotation,
                offsetX = 0,
                offsetY = 0,
                dontFlip = false
              }) {
                this.viewBox = viewBox;
                this.scale = scale;
                this.rotation = rotation;
                this.offsetX = offsetX;
                this.offsetY = offsetY;
                const centerX = (viewBox[2] + viewBox[0]) / 2;
                const centerY = (viewBox[3] + viewBox[1]) / 2;
                let rotateA, rotateB, rotateC, rotateD;
                rotation = rotation % 360;
                rotation = rotation < 0 ? rotation + 360 : rotation;
                switch (rotation) {
                  case 180:
                    rotateA = -1;
                    rotateB = 0;
                    rotateC = 0;
                    rotateD = 1;
                    break;
                  case 90:
                    rotateA = 0;
                    rotateB = 1;
                    rotateC = 1;
                    rotateD = 0;
                    break;
                  case 270:
                    rotateA = 0;
                    rotateB = -1;
                    rotateC = -1;
                    rotateD = 0;
                    break;
                  default:
                    rotateA = 1;
                    rotateB = 0;
                    rotateC = 0;
                    rotateD = -1;
                    break;
                }
                if (dontFlip) {
                  rotateC = -rotateC;
                  rotateD = -rotateD;
                }
                let offsetCanvasX, offsetCanvasY;
                let width, height;
                if (rotateA === 0) {
                  offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;
                  offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;
                  width = Math.abs(viewBox[3] - viewBox[1]) * scale;
                  height = Math.abs(viewBox[2] - viewBox[0]) * scale;
                } else {
                  offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;
                  offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;
                  width = Math.abs(viewBox[2] - viewBox[0]) * scale;
                  height = Math.abs(viewBox[3] - viewBox[1]) * scale;
                }
                this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];
                this.width = width;
                this.height = height;
              }
              clone({
                scale = this.scale,
                rotation = this.rotation,
                offsetX = this.offsetX,
                offsetY = this.offsetY,
                dontFlip = false
              } = {}) {
                return new PageViewport({
                  viewBox: this.viewBox.slice(),
                  scale,
                  rotation,
                  offsetX,
                  offsetY,
                  dontFlip
                });
              }
              convertToViewportPoint(x, y) {
                return _util2.Util.applyTransform([x, y], this.transform);
              }
              convertToViewportRectangle(rect) {
                const topLeft = _util2.Util.applyTransform([rect[0], rect[1]], this.transform);
                const bottomRight = _util2.Util.applyTransform([rect[2], rect[3]], this.transform);
                return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]];
              }
              convertToPdfPoint(x, y) {
                return _util2.Util.applyInverseTransform([x, y], this.transform);
              }
            }
            exports2.PageViewport = PageViewport;
            class RenderingCancelledException extends _util2.BaseException {
              constructor(msg, type) {
                super(msg);
                this.type = type;
              }
            }
            exports2.RenderingCancelledException = RenderingCancelledException;
            const LinkTarget = {
              NONE: 0,
              SELF: 1,
              BLANK: 2,
              PARENT: 3,
              TOP: 4
            };
            exports2.LinkTarget = LinkTarget;
            function addLinkAttributes(link, {
              url,
              target,
              rel,
              enabled = true
            } = {}) {
              (0, _util2.assert)(url && typeof url === "string", 'addLinkAttributes: A valid "url" parameter must provided.');
              const urlNullRemoved = (0, _util2.removeNullCharacters)(url);
              if (enabled) {
                link.href = link.title = urlNullRemoved;
              } else {
                link.href = "";
                link.title = `Disabled: ${urlNullRemoved}`;
                link.onclick = () => {
                  return false;
                };
              }
              let targetStr = "";
              switch (target) {
                case LinkTarget.NONE:
                  break;
                case LinkTarget.SELF:
                  targetStr = "_self";
                  break;
                case LinkTarget.BLANK:
                  targetStr = "_blank";
                  break;
                case LinkTarget.PARENT:
                  targetStr = "_parent";
                  break;
                case LinkTarget.TOP:
                  targetStr = "_top";
                  break;
              }
              link.target = targetStr;
              link.rel = typeof rel === "string" ? rel : DEFAULT_LINK_REL;
            }
            function getFilenameFromUrl(url) {
              const anchor = url.indexOf("#");
              const query = url.indexOf("?");
              const end = Math.min(anchor > 0 ? anchor : url.length, query > 0 ? query : url.length);
              return url.substring(url.lastIndexOf("/", end) + 1, end);
            }
            class StatTimer {
              constructor() {
                this.started = /* @__PURE__ */ Object.create(null);
                this.times = [];
              }
              time(name) {
                if (name in this.started) {
                  (0, _util2.warn)(`Timer is already running for ${name}`);
                }
                this.started[name] = Date.now();
              }
              timeEnd(name) {
                if (!(name in this.started)) {
                  (0, _util2.warn)(`Timer has not been started for ${name}`);
                }
                this.times.push({
                  name,
                  start: this.started[name],
                  end: Date.now()
                });
                delete this.started[name];
              }
              toString() {
                const outBuf = [];
                let longest = 0;
                for (const time of this.times) {
                  const name = time.name;
                  if (name.length > longest) {
                    longest = name.length;
                  }
                }
                for (const time of this.times) {
                  const duration = time.end - time.start;
                  outBuf.push(`${time.name.padEnd(longest)} ${duration}ms
`);
                }
                return outBuf.join("");
              }
            }
            exports2.StatTimer = StatTimer;
            function isFetchSupported() {
              return typeof fetch !== "undefined" && typeof Response !== "undefined" && "body" in Response.prototype && typeof ReadableStream !== "undefined";
            }
            function isValidFetchUrl(url, baseUrl) {
              try {
                const {
                  protocol
                } = baseUrl ? new URL(url, baseUrl) : new URL(url);
                return protocol === "http:" || protocol === "https:";
              } catch (ex) {
                return false;
              }
            }
            function loadScript(src) {
              return new Promise((resolve, reject) => {
                const script = document.createElement("script");
                script.src = src;
                script.onload = resolve;
                script.onerror = function() {
                  reject(new Error(`Cannot load script at: ${script.src}`));
                };
                (document.head || document.documentElement).appendChild(script);
              });
            }
            function deprecated(details) {
              console.log("Deprecated API usage: " + details);
            }
            function releaseImageResources(img) {
              (0, _util2.assert)(img instanceof Image, "Invalid `img` parameter.");
              const url = img.src;
              if (typeof url === "string" && url.startsWith("blob:") && URL.revokeObjectURL) {
                URL.revokeObjectURL(url);
              }
              img.removeAttribute("src");
            }
            let pdfDateStringRegex;
            class PDFDateString {
              static toDateObject(input) {
                if (!input || !(0, _util2.isString)(input)) {
                  return null;
                }
                if (!pdfDateStringRegex) {
                  pdfDateStringRegex = new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?");
                }
                const matches = pdfDateStringRegex.exec(input);
                if (!matches) {
                  return null;
                }
                const year = parseInt(matches[1], 10);
                let month = parseInt(matches[2], 10);
                month = month >= 1 && month <= 12 ? month - 1 : 0;
                let day = parseInt(matches[3], 10);
                day = day >= 1 && day <= 31 ? day : 1;
                let hour = parseInt(matches[4], 10);
                hour = hour >= 0 && hour <= 23 ? hour : 0;
                let minute = parseInt(matches[5], 10);
                minute = minute >= 0 && minute <= 59 ? minute : 0;
                let second = parseInt(matches[6], 10);
                second = second >= 0 && second <= 59 ? second : 0;
                const universalTimeRelation = matches[7] || "Z";
                let offsetHour = parseInt(matches[8], 10);
                offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;
                let offsetMinute = parseInt(matches[9], 10) || 0;
                offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;
                if (universalTimeRelation === "-") {
                  hour += offsetHour;
                  minute += offsetMinute;
                } else if (universalTimeRelation === "+") {
                  hour -= offsetHour;
                  minute -= offsetMinute;
                }
                return new Date(Date.UTC(year, month, day, hour, minute, second));
              }
            }
            exports2.PDFDateString = PDFDateString;
          },
          6445: function(__unused_webpack_module2, exports2, __webpack_require__2) {
            "use strict";
            var __webpack_unused_export__;
            __webpack_require__2(7658);
            __webpack_require__2(3408);
            __webpack_require__2(4590);
            __webpack_unused_export__ = {
              value: true
            };
            exports2.r = void 0;
            var _util2 = __webpack_require__2(7484);
            var _network_utils = __webpack_require__2(330);
            function createFetchOptions(headers, withCredentials, abortController) {
              return {
                method: "GET",
                headers,
                signal: abortController && abortController.signal,
                mode: "cors",
                credentials: withCredentials ? "include" : "same-origin",
                redirect: "follow"
              };
            }
            function createHeaders(httpHeaders) {
              const headers = new Headers();
              for (const property in httpHeaders) {
                const value = httpHeaders[property];
                if (typeof value === "undefined") {
                  continue;
                }
                headers.append(property, value);
              }
              return headers;
            }
            class PDFFetchStream {
              constructor(source) {
                this.source = source;
                this.isHttp = /^https?:/i.test(source.url);
                this.httpHeaders = this.isHttp && source.httpHeaders || {};
                this._fullRequestReader = null;
                this._rangeRequestReaders = [];
              }
              get _progressiveDataLength() {
                return this._fullRequestReader ? this._fullRequestReader._loaded : 0;
              }
              getFullReader() {
                (0, _util2.assert)(!this._fullRequestReader);
                this._fullRequestReader = new PDFFetchStreamReader(this);
                return this._fullRequestReader;
              }
              getRangeReader(begin, end) {
                if (end <= this._progressiveDataLength) {
                  return null;
                }
                const reader = new PDFFetchStreamRangeReader(this, begin, end);
                this._rangeRequestReaders.push(reader);
                return reader;
              }
              cancelAllRequests(reason) {
                if (this._fullRequestReader) {
                  this._fullRequestReader.cancel(reason);
                }
                const readers = this._rangeRequestReaders.slice(0);
                readers.forEach(function(reader) {
                  reader.cancel(reason);
                });
              }
            }
            exports2.r = PDFFetchStream;
            class PDFFetchStreamReader {
              constructor(stream) {
                this._stream = stream;
                this._reader = null;
                this._loaded = 0;
                this._filename = null;
                const source = stream.source;
                this._withCredentials = source.withCredentials || false;
                this._contentLength = source.length;
                this._headersCapability = (0, _util2.createPromiseCapability)();
                this._disableRange = source.disableRange || false;
                this._rangeChunkSize = source.rangeChunkSize;
                if (!this._rangeChunkSize && !this._disableRange) {
                  this._disableRange = true;
                }
                if (typeof AbortController !== "undefined") {
                  this._abortController = new AbortController();
                }
                this._isStreamingSupported = !source.disableStream;
                this._isRangeSupported = !source.disableRange;
                this._headers = createHeaders(this._stream.httpHeaders);
                const url = source.url;
                fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then((response) => {
                  if (!(0, _network_utils.validateResponseStatus)(response.status)) {
                    throw (0, _network_utils.createResponseStatusError)(response.status, url);
                  }
                  this._reader = response.body.getReader();
                  this._headersCapability.resolve();
                  const getResponseHeader = (name) => {
                    return response.headers.get(name);
                  };
                  const {
                    allowRangeRequests,
                    suggestedLength
                  } = (0, _network_utils.validateRangeRequestCapabilities)({
                    getResponseHeader,
                    isHttp: this._stream.isHttp,
                    rangeChunkSize: this._rangeChunkSize,
                    disableRange: this._disableRange
                  });
                  this._isRangeSupported = allowRangeRequests;
                  this._contentLength = suggestedLength || this._contentLength;
                  this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
                  if (!this._isStreamingSupported && this._isRangeSupported) {
                    this.cancel(new _util2.AbortException("Streaming is disabled."));
                  }
                }).catch(this._headersCapability.reject);
                this.onProgress = null;
              }
              get headersReady() {
                return this._headersCapability.promise;
              }
              get filename() {
                return this._filename;
              }
              get contentLength() {
                return this._contentLength;
              }
              get isRangeSupported() {
                return this._isRangeSupported;
              }
              get isStreamingSupported() {
                return this._isStreamingSupported;
              }
              async read() {
                await this._headersCapability.promise;
                const {
                  value,
                  done
                } = await this._reader.read();
                if (done) {
                  return {
                    value,
                    done
                  };
                }
                this._loaded += value.byteLength;
                if (this.onProgress) {
                  this.onProgress({
                    loaded: this._loaded,
                    total: this._contentLength
                  });
                }
                const buffer = new Uint8Array(value).buffer;
                return {
                  value: buffer,
                  done: false
                };
              }
              cancel(reason) {
                if (this._reader) {
                  this._reader.cancel(reason);
                }
                if (this._abortController) {
                  this._abortController.abort();
                }
              }
            }
            class PDFFetchStreamRangeReader {
              constructor(stream, begin, end) {
                this._stream = stream;
                this._reader = null;
                this._loaded = 0;
                const source = stream.source;
                this._withCredentials = source.withCredentials || false;
                this._readCapability = (0, _util2.createPromiseCapability)();
                this._isStreamingSupported = !source.disableStream;
                if (typeof AbortController !== "undefined") {
                  this._abortController = new AbortController();
                }
                this._headers = createHeaders(this._stream.httpHeaders);
                this._headers.append("Range", `bytes=${begin}-${end - 1}`);
                const url = source.url;
                fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then((response) => {
                  if (!(0, _network_utils.validateResponseStatus)(response.status)) {
                    throw (0, _network_utils.createResponseStatusError)(response.status, url);
                  }
                  this._readCapability.resolve();
                  this._reader = response.body.getReader();
                });
                this.onProgress = null;
              }
              get isStreamingSupported() {
                return this._isStreamingSupported;
              }
              async read() {
                await this._readCapability.promise;
                const {
                  value,
                  done
                } = await this._reader.read();
                if (done) {
                  return {
                    value,
                    done
                  };
                }
                this._loaded += value.byteLength;
                if (this.onProgress) {
                  this.onProgress({
                    loaded: this._loaded
                  });
                }
                const buffer = new Uint8Array(value).buffer;
                return {
                  value: buffer,
                  done: false
                };
              }
              cancel(reason) {
                if (this._reader) {
                  this._reader.cancel(reason);
                }
                if (this._abortController) {
                  this._abortController.abort();
                }
              }
            }
          },
          8096: function(__unused_webpack_module2, exports2, __webpack_require__2) {
            "use strict";
            __webpack_require__2(7658);
            __webpack_require__2(2801);
            __webpack_require__2(3408);
            __webpack_require__2(4590);
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.FontLoader = exports2.FontFaceObject = void 0;
            var _util2 = __webpack_require__2(7484);
            class BaseFontLoader {
              constructor({
                docId,
                onUnsupportedFeature
              }) {
                if (this.constructor === BaseFontLoader) {
                  (0, _util2.unreachable)("Cannot initialize BaseFontLoader.");
                }
                this.docId = docId;
                this._onUnsupportedFeature = onUnsupportedFeature;
                this.nativeFontFaces = [];
                this.styleElement = null;
              }
              addNativeFontFace(nativeFontFace) {
                this.nativeFontFaces.push(nativeFontFace);
                document.fonts.add(nativeFontFace);
              }
              insertRule(rule) {
                let styleElement = this.styleElement;
                if (!styleElement) {
                  styleElement = this.styleElement = document.createElement("style");
                  styleElement.id = `PDFJS_FONT_STYLE_TAG_${this.docId}`;
                  document.documentElement.getElementsByTagName("head")[0].appendChild(styleElement);
                }
                const styleSheet = styleElement.sheet;
                styleSheet.insertRule(rule, styleSheet.cssRules.length);
              }
              clear() {
                this.nativeFontFaces.forEach(function(nativeFontFace) {
                  document.fonts.delete(nativeFontFace);
                });
                this.nativeFontFaces.length = 0;
                if (this.styleElement) {
                  this.styleElement.remove();
                  this.styleElement = null;
                }
              }
              async bind(font) {
                if (font.attached || font.missingFile) {
                  return;
                }
                font.attached = true;
                if (this.isFontLoadingAPISupported) {
                  const nativeFontFace = font.createNativeFontFace();
                  if (nativeFontFace) {
                    this.addNativeFontFace(nativeFontFace);
                    try {
                      await nativeFontFace.loaded;
                    } catch (ex) {
                      this._onUnsupportedFeature({
                        featureId: _util2.UNSUPPORTED_FEATURES.font
                      });
                      (0, _util2.warn)(`Failed to load font '${nativeFontFace.family}': '${ex}'.`);
                      font.disableFontFace = true;
                      throw ex;
                    }
                  }
                  return;
                }
                const rule = font.createFontFaceRule();
                if (rule) {
                  this.insertRule(rule);
                  if (this.isSyncFontLoadingSupported) {
                    return;
                  }
                  await new Promise((resolve) => {
                    const request = this._queueLoadingCallback(resolve);
                    this._prepareFontLoadEvent([rule], [font], request);
                  });
                }
              }
              _queueLoadingCallback(callback) {
                (0, _util2.unreachable)("Abstract method `_queueLoadingCallback`.");
              }
              get isFontLoadingAPISupported() {
                const supported = typeof document !== "undefined" && !!document.fonts;
                return (0, _util2.shadow)(this, "isFontLoadingAPISupported", supported);
              }
              get isSyncFontLoadingSupported() {
                (0, _util2.unreachable)("Abstract method `isSyncFontLoadingSupported`.");
              }
              get _loadTestFont() {
                (0, _util2.unreachable)("Abstract method `_loadTestFont`.");
              }
              _prepareFontLoadEvent(rules, fontsToLoad, request) {
                (0, _util2.unreachable)("Abstract method `_prepareFontLoadEvent`.");
              }
            }
            let FontLoader;
            exports2.FontLoader = FontLoader;
            {
              exports2.FontLoader = FontLoader = class GenericFontLoader extends BaseFontLoader {
                constructor(docId) {
                  super(docId);
                  this.loadingContext = {
                    requests: [],
                    nextRequestId: 0
                  };
                  this.loadTestFontId = 0;
                }
                get isSyncFontLoadingSupported() {
                  let supported = false;
                  if (typeof navigator === "undefined") {
                    supported = true;
                  } else {
                    const m = /Mozilla\/5.0.*?rv:(\d+).*? Gecko/.exec(navigator.userAgent);
                    if (m && m[1] >= 14) {
                      supported = true;
                    }
                  }
                  return (0, _util2.shadow)(this, "isSyncFontLoadingSupported", supported);
                }
                _queueLoadingCallback(callback) {
                  function completeRequest() {
                    (0, _util2.assert)(!request.done, "completeRequest() cannot be called twice.");
                    request.done = true;
                    while (context.requests.length > 0 && context.requests[0].done) {
                      const otherRequest = context.requests.shift();
                      setTimeout(otherRequest.callback, 0);
                    }
                  }
                  const context = this.loadingContext;
                  const request = {
                    id: `pdfjs-font-loading-${context.nextRequestId++}`,
                    done: false,
                    complete: completeRequest,
                    callback
                  };
                  context.requests.push(request);
                  return request;
                }
                get _loadTestFont() {
                  const getLoadTestFont = function() {
                    return atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
                  };
                  return (0, _util2.shadow)(this, "_loadTestFont", getLoadTestFont());
                }
                _prepareFontLoadEvent(rules, fonts, request) {
                  function int32(data2, offset) {
                    return data2.charCodeAt(offset) << 24 | data2.charCodeAt(offset + 1) << 16 | data2.charCodeAt(offset + 2) << 8 | data2.charCodeAt(offset + 3) & 255;
                  }
                  function spliceString(s, offset, remove, insert) {
                    const chunk1 = s.substring(0, offset);
                    const chunk2 = s.substring(offset + remove);
                    return chunk1 + insert + chunk2;
                  }
                  let i, ii;
                  const canvas = document.createElement("canvas");
                  canvas.width = 1;
                  canvas.height = 1;
                  const ctx = canvas.getContext("2d");
                  let called = 0;
                  function isFontReady(name, callback) {
                    called++;
                    if (called > 30) {
                      (0, _util2.warn)("Load test font never loaded.");
                      callback();
                      return;
                    }
                    ctx.font = "30px " + name;
                    ctx.fillText(".", 0, 20);
                    const imageData = ctx.getImageData(0, 0, 1, 1);
                    if (imageData.data[3] > 0) {
                      callback();
                      return;
                    }
                    setTimeout(isFontReady.bind(null, name, callback));
                  }
                  const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`;
                  let data = this._loadTestFont;
                  const COMMENT_OFFSET = 976;
                  data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);
                  const CFF_CHECKSUM_OFFSET = 16;
                  const XXXX_VALUE = 1482184792;
                  let checksum = int32(data, CFF_CHECKSUM_OFFSET);
                  for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {
                    checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;
                  }
                  if (i < loadTestFontId.length) {
                    checksum = checksum - XXXX_VALUE + int32(loadTestFontId + "XXX", i) | 0;
                  }
                  data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, (0, _util2.string32)(checksum));
                  const url = `url(data:font/opentype;base64,${btoa(data)});`;
                  const rule = `@font-face {font-family:"${loadTestFontId}";src:${url}}`;
                  this.insertRule(rule);
                  const names = [];
                  for (i = 0, ii = fonts.length; i < ii; i++) {
                    names.push(fonts[i].loadedName);
                  }
                  names.push(loadTestFontId);
                  const div = document.createElement("div");
                  div.style.visibility = "hidden";
                  div.style.width = div.style.height = "10px";
                  div.style.position = "absolute";
                  div.style.top = div.style.left = "0px";
                  for (i = 0, ii = names.length; i < ii; ++i) {
                    const span = document.createElement("span");
                    span.textContent = "Hi";
                    span.style.fontFamily = names[i];
                    div.appendChild(span);
                  }
                  document.body.appendChild(div);
                  isFontReady(loadTestFontId, function() {
                    document.body.removeChild(div);
                    request.complete();
                  });
                }
              };
            }
            class FontFaceObject {
              constructor(translatedData, {
                isEvalSupported = true,
                disableFontFace = false,
                ignoreErrors = false,
                onUnsupportedFeature = null,
                fontRegistry = null
              }) {
                this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
                for (const i in translatedData) {
                  this[i] = translatedData[i];
                }
                this.isEvalSupported = isEvalSupported !== false;
                this.disableFontFace = disableFontFace === true;
                this.ignoreErrors = ignoreErrors === true;
                this._onUnsupportedFeature = onUnsupportedFeature;
                this.fontRegistry = fontRegistry;
              }
              createNativeFontFace() {
                if (!this.data || this.disableFontFace) {
                  return null;
                }
                const nativeFontFace = new FontFace(this.loadedName, this.data, {});
                if (this.fontRegistry) {
                  this.fontRegistry.registerFont(this);
                }
                return nativeFontFace;
              }
              createFontFaceRule() {
                if (!this.data || this.disableFontFace) {
                  return null;
                }
                const data = (0, _util2.bytesToString)(new Uint8Array(this.data));
                const url = `url(data:${this.mimetype};base64,${btoa(data)});`;
                const rule = `@font-face {font-family:"${this.loadedName}";src:${url}}`;
                if (this.fontRegistry) {
                  this.fontRegistry.registerFont(this, url);
                }
                return rule;
              }
              getPathGenerator(objs, character) {
                if (this.compiledGlyphs[character] !== void 0) {
                  return this.compiledGlyphs[character];
                }
                let cmds, current;
                try {
                  cmds = objs.get(this.loadedName + "_path_" + character);
                } catch (ex) {
                  if (!this.ignoreErrors) {
                    throw ex;
                  }
                  if (this._onUnsupportedFeature) {
                    this._onUnsupportedFeature({
                      featureId: _util2.UNSUPPORTED_FEATURES.font
                    });
                  }
                  (0, _util2.warn)(`getPathGenerator - ignoring character: "${ex}".`);
                  return this.compiledGlyphs[character] = function(c, size) {
                  };
                }
                if (this.isEvalSupported && _util2.IsEvalSupportedCached.value) {
                  let args, js = "";
                  for (let i = 0, ii = cmds.length; i < ii; i++) {
                    current = cmds[i];
                    if (current.args !== void 0) {
                      args = current.args.join(",");
                    } else {
                      args = "";
                    }
                    js += "c." + current.cmd + "(" + args + ");\n";
                  }
                  return this.compiledGlyphs[character] = new Function("c", "size", js);
                }
                return this.compiledGlyphs[character] = function(c, size) {
                  for (let i = 0, ii = cmds.length; i < ii; i++) {
                    current = cmds[i];
                    if (current.cmd === "scale") {
                      current.args = [size, -size];
                    }
                    c[current.cmd].apply(c, current.args);
                  }
                };
              }
            }
            exports2.FontFaceObject = FontFaceObject;
          },
          5554: function(__unused_webpack_module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.Metadata = void 0;
            var _util2 = __webpack_require__2(7484);
            var _xml_parser = __webpack_require__2(8635);
            class Metadata {
              constructor(data) {
                (0, _util2.assert)(typeof data === "string", "Metadata: input is not a string");
                data = this._repair(data);
                const parser = new _xml_parser.SimpleXMLParser();
                const xmlDocument = parser.parseFromString(data);
                this._metadataMap = /* @__PURE__ */ new Map();
                if (xmlDocument) {
                  this._parse(xmlDocument);
                }
              }
              _repair(data) {
                return data.replace(/^[^<]+/, "").replace(/>\\376\\377([^<]+)/g, function(all, codes) {
                  const bytes = codes.replace(/\\([0-3])([0-7])([0-7])/g, function(code, d1, d2, d3) {
                    return String.fromCharCode(d1 * 64 + d2 * 8 + d3 * 1);
                  }).replace(/&(amp|apos|gt|lt|quot);/g, function(str, name) {
                    switch (name) {
                      case "amp":
                        return "&";
                      case "apos":
                        return "'";
                      case "gt":
                        return ">";
                      case "lt":
                        return "<";
                      case "quot":
                        return '"';
                    }
                    throw new Error(`_repair: ${name} isn't defined.`);
                  });
                  let chars = "";
                  for (let i = 0, ii = bytes.length; i < ii; i += 2) {
                    const code = bytes.charCodeAt(i) * 256 + bytes.charCodeAt(i + 1);
                    if (code >= 32 && code < 127 && code !== 60 && code !== 62 && code !== 38) {
                      chars += String.fromCharCode(code);
                    } else {
                      chars += "&#x" + (65536 + code).toString(16).substring(1) + ";";
                    }
                  }
                  return ">" + chars;
                });
              }
              _parse(xmlDocument) {
                let rdf = xmlDocument.documentElement;
                if (rdf.nodeName.toLowerCase() !== "rdf:rdf") {
                  rdf = rdf.firstChild;
                  while (rdf && rdf.nodeName.toLowerCase() !== "rdf:rdf") {
                    rdf = rdf.nextSibling;
                  }
                }
                const nodeName = rdf ? rdf.nodeName.toLowerCase() : null;
                if (!rdf || nodeName !== "rdf:rdf" || !rdf.hasChildNodes()) {
                  return;
                }
                const children = rdf.childNodes;
                for (let i = 0, ii = children.length; i < ii; i++) {
                  const desc = children[i];
                  if (desc.nodeName.toLowerCase() !== "rdf:description") {
                    continue;
                  }
                  for (let j = 0, jj = desc.childNodes.length; j < jj; j++) {
                    if (desc.childNodes[j].nodeName.toLowerCase() !== "#text") {
                      const entry = desc.childNodes[j];
                      const name = entry.nodeName.toLowerCase();
                      this._metadataMap.set(name, entry.textContent.trim());
                    }
                  }
                }
              }
              get(name) {
                return this._metadataMap.has(name) ? this._metadataMap.get(name) : null;
              }
              getAll() {
                const obj = /* @__PURE__ */ Object.create(null);
                for (const [key, value] of this._metadataMap) {
                  obj[key] = value;
                }
                return obj;
              }
              has(name) {
                return this._metadataMap.has(name);
              }
            }
            exports2.Metadata = Metadata;
          },
          962: function(__unused_webpack_module2, exports2, __webpack_require__2) {
            "use strict";
            var __webpack_unused_export__;
            __webpack_require__2(7658);
            __webpack_unused_export__ = {
              value: true
            };
            exports2.V = void 0;
            var _util2 = __webpack_require__2(7484);
            var _network_utils = __webpack_require__2(330);
            ;
            const OK_RESPONSE = 200;
            const PARTIAL_CONTENT_RESPONSE = 206;
            function getArrayBuffer(xhr) {
              const data = xhr.response;
              if (typeof data !== "string") {
                return data;
              }
              const array = (0, _util2.stringToBytes)(data);
              return array.buffer;
            }
            class NetworkManager {
              constructor(url, args) {
                this.url = url;
                args = args || {};
                this.isHttp = /^https?:/i.test(url);
                this.httpHeaders = this.isHttp && args.httpHeaders || {};
                this.withCredentials = args.withCredentials || false;
                this.getXhr = args.getXhr || function NetworkManager_getXhr() {
                  return new XMLHttpRequest();
                };
                this.currXhrId = 0;
                this.pendingRequests = /* @__PURE__ */ Object.create(null);
              }
              requestRange(begin, end, listeners) {
                const args = {
                  begin,
                  end
                };
                for (const prop in listeners) {
                  args[prop] = listeners[prop];
                }
                return this.request(args);
              }
              requestFull(listeners) {
                return this.request(listeners);
              }
              request(args) {
                const xhr = this.getXhr();
                const xhrId = this.currXhrId++;
                const pendingRequest = this.pendingRequests[xhrId] = {
                  xhr
                };
                xhr.open("GET", this.url);
                xhr.withCredentials = this.withCredentials;
                for (const property in this.httpHeaders) {
                  const value = this.httpHeaders[property];
                  if (typeof value === "undefined") {
                    continue;
                  }
                  xhr.setRequestHeader(property, value);
                }
                if (this.isHttp && "begin" in args && "end" in args) {
                  xhr.setRequestHeader("Range", `bytes=${args.begin}-${args.end - 1}`);
                  pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;
                } else {
                  pendingRequest.expectedStatus = OK_RESPONSE;
                }
                xhr.responseType = "arraybuffer";
                if (args.onError) {
                  xhr.onerror = function(evt) {
                    args.onError(xhr.status);
                  };
                }
                xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);
                xhr.onprogress = this.onProgress.bind(this, xhrId);
                pendingRequest.onHeadersReceived = args.onHeadersReceived;
                pendingRequest.onDone = args.onDone;
                pendingRequest.onError = args.onError;
                pendingRequest.onProgress = args.onProgress;
                xhr.send(null);
                return xhrId;
              }
              onProgress(xhrId, evt) {
                const pendingRequest = this.pendingRequests[xhrId];
                if (!pendingRequest) {
                  return;
                }
                if (pendingRequest.onProgress) {
                  pendingRequest.onProgress(evt);
                }
              }
              onStateChange(xhrId, evt) {
                const pendingRequest = this.pendingRequests[xhrId];
                if (!pendingRequest) {
                  return;
                }
                const xhr = pendingRequest.xhr;
                if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {
                  pendingRequest.onHeadersReceived();
                  delete pendingRequest.onHeadersReceived;
                }
                if (xhr.readyState !== 4) {
                  return;
                }
                if (!(xhrId in this.pendingRequests)) {
                  return;
                }
                delete this.pendingRequests[xhrId];
                if (xhr.status === 0 && this.isHttp) {
                  if (pendingRequest.onError) {
                    pendingRequest.onError(xhr.status);
                  }
                  return;
                }
                const xhrStatus = xhr.status || OK_RESPONSE;
                const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;
                if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {
                  if (pendingRequest.onError) {
                    pendingRequest.onError(xhr.status);
                  }
                  return;
                }
                const chunk = getArrayBuffer(xhr);
                if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {
                  const rangeHeader = xhr.getResponseHeader("Content-Range");
                  const matches = /bytes (\d+)-(\d+)\/(\d+)/.exec(rangeHeader);
                  pendingRequest.onDone({
                    begin: parseInt(matches[1], 10),
                    chunk
                  });
                } else if (chunk) {
                  pendingRequest.onDone({
                    begin: 0,
                    chunk
                  });
                } else if (pendingRequest.onError) {
                  pendingRequest.onError(xhr.status);
                }
              }
              hasPendingRequests() {
                for (const xhrId in this.pendingRequests) {
                  return true;
                }
                return false;
              }
              getRequestXhr(xhrId) {
                return this.pendingRequests[xhrId].xhr;
              }
              isPendingRequest(xhrId) {
                return xhrId in this.pendingRequests;
              }
              abortAllRequests() {
                for (const xhrId in this.pendingRequests) {
                  this.abortRequest(xhrId | 0);
                }
              }
              abortRequest(xhrId) {
                const xhr = this.pendingRequests[xhrId].xhr;
                delete this.pendingRequests[xhrId];
                xhr.abort();
              }
            }
            class PDFNetworkStream {
              constructor(source) {
                this._source = source;
                this._manager = new NetworkManager(source.url, {
                  httpHeaders: source.httpHeaders,
                  withCredentials: source.withCredentials
                });
                this._rangeChunkSize = source.rangeChunkSize;
                this._fullRequestReader = null;
                this._rangeRequestReaders = [];
              }
              _onRangeRequestReaderClosed(reader) {
                const i = this._rangeRequestReaders.indexOf(reader);
                if (i >= 0) {
                  this._rangeRequestReaders.splice(i, 1);
                }
              }
              getFullReader() {
                (0, _util2.assert)(!this._fullRequestReader);
                this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);
                return this._fullRequestReader;
              }
              getRangeReader(begin, end) {
                const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);
                reader.onClosed = this._onRangeRequestReaderClosed.bind(this);
                this._rangeRequestReaders.push(reader);
                return reader;
              }
              cancelAllRequests(reason) {
                if (this._fullRequestReader) {
                  this._fullRequestReader.cancel(reason);
                }
                const readers = this._rangeRequestReaders.slice(0);
                readers.forEach(function(reader) {
                  reader.cancel(reason);
                });
              }
            }
            exports2.V = PDFNetworkStream;
            class PDFNetworkStreamFullRequestReader {
              constructor(manager, source) {
                this._manager = manager;
                const args = {
                  onHeadersReceived: this._onHeadersReceived.bind(this),
                  onDone: this._onDone.bind(this),
                  onError: this._onError.bind(this),
                  onProgress: this._onProgress.bind(this)
                };
                this._url = source.url;
                this._fullRequestId = manager.requestFull(args);
                this._headersReceivedCapability = (0, _util2.createPromiseCapability)();
                this._disableRange = source.disableRange || false;
                this._contentLength = source.length;
                this._rangeChunkSize = source.rangeChunkSize;
                if (!this._rangeChunkSize && !this._disableRange) {
                  this._disableRange = true;
                }
                this._isStreamingSupported = false;
                this._isRangeSupported = false;
                this._cachedChunks = [];
                this._requests = [];
                this._done = false;
                this._storedError = void 0;
                this._filename = null;
                this.onProgress = null;
              }
              _onHeadersReceived() {
                const fullRequestXhrId = this._fullRequestId;
                const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);
                const getResponseHeader = (name) => {
                  return fullRequestXhr.getResponseHeader(name);
                };
                const {
                  allowRangeRequests,
                  suggestedLength
                } = (0, _network_utils.validateRangeRequestCapabilities)({
                  getResponseHeader,
                  isHttp: this._manager.isHttp,
                  rangeChunkSize: this._rangeChunkSize,
                  disableRange: this._disableRange
                });
                if (allowRangeRequests) {
                  this._isRangeSupported = true;
                }
                this._contentLength = suggestedLength || this._contentLength;
                this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
                if (this._isRangeSupported) {
                  this._manager.abortRequest(fullRequestXhrId);
                }
                this._headersReceivedCapability.resolve();
              }
              _onDone(args) {
                if (args) {
                  if (this._requests.length > 0) {
                    const requestCapability = this._requests.shift();
                    requestCapability.resolve({
                      value: args.chunk,
                      done: false
                    });
                  } else {
                    this._cachedChunks.push(args.chunk);
                  }
                }
                this._done = true;
                if (this._cachedChunks.length > 0) {
                  return;
                }
                this._requests.forEach(function(requestCapability) {
                  requestCapability.resolve({
                    value: void 0,
                    done: true
                  });
                });
                this._requests = [];
              }
              _onError(status) {
                const url = this._url;
                const exception = (0, _network_utils.createResponseStatusError)(status, url);
                this._storedError = exception;
                this._headersReceivedCapability.reject(exception);
                this._requests.forEach(function(requestCapability) {
                  requestCapability.reject(exception);
                });
                this._requests = [];
                this._cachedChunks = [];
              }
              _onProgress(data) {
                if (this.onProgress) {
                  this.onProgress({
                    loaded: data.loaded,
                    total: data.lengthComputable ? data.total : this._contentLength
                  });
                }
              }
              get filename() {
                return this._filename;
              }
              get isRangeSupported() {
                return this._isRangeSupported;
              }
              get isStreamingSupported() {
                return this._isStreamingSupported;
              }
              get contentLength() {
                return this._contentLength;
              }
              get headersReady() {
                return this._headersReceivedCapability.promise;
              }
              async read() {
                if (this._storedError) {
                  throw this._storedError;
                }
                if (this._cachedChunks.length > 0) {
                  const chunk = this._cachedChunks.shift();
                  return {
                    value: chunk,
                    done: false
                  };
                }
                if (this._done) {
                  return {
                    value: void 0,
                    done: true
                  };
                }
                const requestCapability = (0, _util2.createPromiseCapability)();
                this._requests.push(requestCapability);
                return requestCapability.promise;
              }
              cancel(reason) {
                this._done = true;
                this._headersReceivedCapability.reject(reason);
                this._requests.forEach(function(requestCapability) {
                  requestCapability.resolve({
                    value: void 0,
                    done: true
                  });
                });
                this._requests = [];
                if (this._manager.isPendingRequest(this._fullRequestId)) {
                  this._manager.abortRequest(this._fullRequestId);
                }
                this._fullRequestReader = null;
              }
            }
            class PDFNetworkStreamRangeRequestReader {
              constructor(manager, begin, end) {
                this._manager = manager;
                const args = {
                  onDone: this._onDone.bind(this),
                  onProgress: this._onProgress.bind(this)
                };
                this._requestId = manager.requestRange(begin, end, args);
                this._requests = [];
                this._queuedChunk = null;
                this._done = false;
                this.onProgress = null;
                this.onClosed = null;
              }
              _close() {
                if (this.onClosed) {
                  this.onClosed(this);
                }
              }
              _onDone(data) {
                const chunk = data.chunk;
                if (this._requests.length > 0) {
                  const requestCapability = this._requests.shift();
                  requestCapability.resolve({
                    value: chunk,
                    done: false
                  });
                } else {
                  this._queuedChunk = chunk;
                }
                this._done = true;
                this._requests.forEach(function(requestCapability) {
                  requestCapability.resolve({
                    value: void 0,
                    done: true
                  });
                });
                this._requests = [];
                this._close();
              }
              _onProgress(evt) {
                if (!this.isStreamingSupported && this.onProgress) {
                  this.onProgress({
                    loaded: evt.loaded
                  });
                }
              }
              get isStreamingSupported() {
                return false;
              }
              async read() {
                if (this._queuedChunk !== null) {
                  const chunk = this._queuedChunk;
                  this._queuedChunk = null;
                  return {
                    value: chunk,
                    done: false
                  };
                }
                if (this._done) {
                  return {
                    value: void 0,
                    done: true
                  };
                }
                const requestCapability = (0, _util2.createPromiseCapability)();
                this._requests.push(requestCapability);
                return requestCapability.promise;
              }
              cancel(reason) {
                this._done = true;
                this._requests.forEach(function(requestCapability) {
                  requestCapability.resolve({
                    value: void 0,
                    done: true
                  });
                });
                this._requests = [];
                if (this._manager.isPendingRequest(this._requestId)) {
                  this._manager.abortRequest(this._requestId);
                }
                this._close();
              }
            }
          },
          330: function(__unused_webpack_module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.createResponseStatusError = createResponseStatusError;
            exports2.extractFilenameFromHeader = extractFilenameFromHeader;
            exports2.validateRangeRequestCapabilities = validateRangeRequestCapabilities;
            exports2.validateResponseStatus = validateResponseStatus;
            var _util2 = __webpack_require__2(7484);
            var _content_disposition = __webpack_require__2(9074);
            function validateRangeRequestCapabilities({
              getResponseHeader,
              isHttp,
              rangeChunkSize,
              disableRange
            }) {
              (0, _util2.assert)(rangeChunkSize > 0, "Range chunk size must be larger than zero");
              const returnValues = {
                allowRangeRequests: false,
                suggestedLength: void 0
              };
              const length = parseInt(getResponseHeader("Content-Length"), 10);
              if (!Number.isInteger(length)) {
                return returnValues;
              }
              returnValues.suggestedLength = length;
              if (length <= 2 * rangeChunkSize) {
                return returnValues;
              }
              if (disableRange || !isHttp) {
                return returnValues;
              }
              if (getResponseHeader("Accept-Ranges") !== "bytes") {
                return returnValues;
              }
              const contentEncoding = getResponseHeader("Content-Encoding") || "identity";
              if (contentEncoding !== "identity") {
                return returnValues;
              }
              returnValues.allowRangeRequests = true;
              return returnValues;
            }
            function extractFilenameFromHeader(getResponseHeader) {
              const contentDisposition = getResponseHeader("Content-Disposition");
              if (contentDisposition) {
                let filename = (0, _content_disposition.getFilenameFromContentDispositionHeader)(contentDisposition);
                if (filename.includes("%")) {
                  try {
                    filename = decodeURIComponent(filename);
                  } catch (ex) {
                  }
                }
                if (/\.pdf$/i.test(filename)) {
                  return filename;
                }
              }
              return null;
            }
            function createResponseStatusError(status, url) {
              if (status === 404 || status === 0 && url.startsWith("file:")) {
                return new _util2.MissingPDFException('Missing PDF "' + url + '".');
              }
              return new _util2.UnexpectedResponseException("Unexpected server response (" + status + ') while retrieving PDF "' + url + '".', status);
            }
            function validateResponseStatus(status) {
              return status === 200 || status === 206;
            }
          },
          5156: function(__unused_webpack_module2, exports2, __webpack_require__2) {
            "use strict";
            var __webpack_unused_export__;
            __webpack_require__2(7658);
            __webpack_require__2(3408);
            __webpack_require__2(4590);
            __webpack_unused_export__ = {
              value: true
            };
            exports2.b = void 0;
            var _util2 = __webpack_require__2(7484);
            var _network_utils = __webpack_require__2(330);
            const fs = __webpack_require__2(9365);
            const http = __webpack_require__2(9635);
            const https = __webpack_require__2(4579);
            const url = __webpack_require__2(9510);
            const fileUriRegex = /^file:\/\/\/[a-zA-Z]:\//;
            function parseUrl(sourceUrl) {
              const parsedUrl = url.parse(sourceUrl);
              if (parsedUrl.protocol === "file:" || parsedUrl.host) {
                return parsedUrl;
              }
              if (/^[a-z]:[/\\]/i.test(sourceUrl)) {
                return url.parse(`file:///${sourceUrl}`);
              }
              if (!parsedUrl.host) {
                parsedUrl.protocol = "file:";
              }
              return parsedUrl;
            }
            class PDFNodeStream {
              constructor(source) {
                this.source = source;
                this.url = parseUrl(source.url);
                this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:";
                this.isFsUrl = this.url.protocol === "file:";
                this.httpHeaders = this.isHttp && source.httpHeaders || {};
                this._fullRequestReader = null;
                this._rangeRequestReaders = [];
              }
              get _progressiveDataLength() {
                return this._fullRequestReader ? this._fullRequestReader._loaded : 0;
              }
              getFullReader() {
                (0, _util2.assert)(!this._fullRequestReader);
                this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this);
                return this._fullRequestReader;
              }
              getRangeReader(start, end) {
                if (end <= this._progressiveDataLength) {
                  return null;
                }
                const rangeReader = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, start, end) : new PDFNodeStreamRangeReader(this, start, end);
                this._rangeRequestReaders.push(rangeReader);
                return rangeReader;
              }
              cancelAllRequests(reason) {
                if (this._fullRequestReader) {
                  this._fullRequestReader.cancel(reason);
                }
                const readers = this._rangeRequestReaders.slice(0);
                readers.forEach(function(reader) {
                  reader.cancel(reason);
                });
              }
            }
            exports2.b = PDFNodeStream;
            class BaseFullReader {
              constructor(stream) {
                this._url = stream.url;
                this._done = false;
                this._storedError = null;
                this.onProgress = null;
                const source = stream.source;
                this._contentLength = source.length;
                this._loaded = 0;
                this._filename = null;
                this._disableRange = source.disableRange || false;
                this._rangeChunkSize = source.rangeChunkSize;
                if (!this._rangeChunkSize && !this._disableRange) {
                  this._disableRange = true;
                }
                this._isStreamingSupported = !source.disableStream;
                this._isRangeSupported = !source.disableRange;
                this._readableStream = null;
                this._readCapability = (0, _util2.createPromiseCapability)();
                this._headersCapability = (0, _util2.createPromiseCapability)();
              }
              get headersReady() {
                return this._headersCapability.promise;
              }
              get filename() {
                return this._filename;
              }
              get contentLength() {
                return this._contentLength;
              }
              get isRangeSupported() {
                return this._isRangeSupported;
              }
              get isStreamingSupported() {
                return this._isStreamingSupported;
              }
              async read() {
                await this._readCapability.promise;
                if (this._done) {
                  return {
                    value: void 0,
                    done: true
                  };
                }
                if (this._storedError) {
                  throw this._storedError;
                }
                const chunk = this._readableStream.read();
                if (chunk === null) {
                  this._readCapability = (0, _util2.createPromiseCapability)();
                  return this.read();
                }
                this._loaded += chunk.length;
                if (this.onProgress) {
                  this.onProgress({
                    loaded: this._loaded,
                    total: this._contentLength
                  });
                }
                const buffer = new Uint8Array(chunk).buffer;
                return {
                  value: buffer,
                  done: false
                };
              }
              cancel(reason) {
                if (!this._readableStream) {
                  this._error(reason);
                  return;
                }
                this._readableStream.destroy(reason);
              }
              _error(reason) {
                this._storedError = reason;
                this._readCapability.resolve();
              }
              _setReadableStream(readableStream) {
                this._readableStream = readableStream;
                readableStream.on("readable", () => {
                  this._readCapability.resolve();
                });
                readableStream.on("end", () => {
                  readableStream.destroy();
                  this._done = true;
                  this._readCapability.resolve();
                });
                readableStream.on("error", (reason) => {
                  this._error(reason);
                });
                if (!this._isStreamingSupported && this._isRangeSupported) {
                  this._error(new _util2.AbortException("streaming is disabled"));
                }
                if (this._storedError) {
                  this._readableStream.destroy(this._storedError);
                }
              }
            }
            class BaseRangeReader {
              constructor(stream) {
                this._url = stream.url;
                this._done = false;
                this._storedError = null;
                this.onProgress = null;
                this._loaded = 0;
                this._readableStream = null;
                this._readCapability = (0, _util2.createPromiseCapability)();
                const source = stream.source;
                this._isStreamingSupported = !source.disableStream;
              }
              get isStreamingSupported() {
                return this._isStreamingSupported;
              }
              async read() {
                await this._readCapability.promise;
                if (this._done) {
                  return {
                    value: void 0,
                    done: true
                  };
                }
                if (this._storedError) {
                  throw this._storedError;
                }
                const chunk = this._readableStream.read();
                if (chunk === null) {
                  this._readCapability = (0, _util2.createPromiseCapability)();
                  return this.read();
                }
                this._loaded += chunk.length;
                if (this.onProgress) {
                  this.onProgress({
                    loaded: this._loaded
                  });
                }
                const buffer = new Uint8Array(chunk).buffer;
                return {
                  value: buffer,
                  done: false
                };
              }
              cancel(reason) {
                if (!this._readableStream) {
                  this._error(reason);
                  return;
                }
                this._readableStream.destroy(reason);
              }
              _error(reason) {
                this._storedError = reason;
                this._readCapability.resolve();
              }
              _setReadableStream(readableStream) {
                this._readableStream = readableStream;
                readableStream.on("readable", () => {
                  this._readCapability.resolve();
                });
                readableStream.on("end", () => {
                  readableStream.destroy();
                  this._done = true;
                  this._readCapability.resolve();
                });
                readableStream.on("error", (reason) => {
                  this._error(reason);
                });
                if (this._storedError) {
                  this._readableStream.destroy(this._storedError);
                }
              }
            }
            function createRequestOptions(url2, headers) {
              return {
                protocol: url2.protocol,
                auth: url2.auth,
                host: url2.hostname,
                port: url2.port,
                path: url2.path,
                method: "GET",
                headers
              };
            }
            class PDFNodeStreamFullReader extends BaseFullReader {
              constructor(stream) {
                super(stream);
                const handleResponse = (response) => {
                  if (response.statusCode === 404) {
                    const error = new _util2.MissingPDFException(`Missing PDF "${this._url}".`);
                    this._storedError = error;
                    this._headersCapability.reject(error);
                    return;
                  }
                  this._headersCapability.resolve();
                  this._setReadableStream(response);
                  const getResponseHeader = (name) => {
                    return this._readableStream.headers[name.toLowerCase()];
                  };
                  const {
                    allowRangeRequests,
                    suggestedLength
                  } = (0, _network_utils.validateRangeRequestCapabilities)({
                    getResponseHeader,
                    isHttp: stream.isHttp,
                    rangeChunkSize: this._rangeChunkSize,
                    disableRange: this._disableRange
                  });
                  this._isRangeSupported = allowRangeRequests;
                  this._contentLength = suggestedLength || this._contentLength;
                  this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
                };
                this._request = null;
                if (this._url.protocol === "http:") {
                  this._request = http.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);
                } else {
                  this._request = https.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);
                }
                this._request.on("error", (reason) => {
                  this._storedError = reason;
                  this._headersCapability.reject(reason);
                });
                this._request.end();
              }
            }
            class PDFNodeStreamRangeReader extends BaseRangeReader {
              constructor(stream, start, end) {
                super(stream);
                this._httpHeaders = {};
                for (const property in stream.httpHeaders) {
                  const value = stream.httpHeaders[property];
                  if (typeof value === "undefined") {
                    continue;
                  }
                  this._httpHeaders[property] = value;
                }
                this._httpHeaders["Range"] = `bytes=${start}-${end - 1}`;
                const handleResponse = (response) => {
                  if (response.statusCode === 404) {
                    const error = new _util2.MissingPDFException(`Missing PDF "${this._url}".`);
                    this._storedError = error;
                    return;
                  }
                  this._setReadableStream(response);
                };
                this._request = null;
                if (this._url.protocol === "http:") {
                  this._request = http.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);
                } else {
                  this._request = https.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);
                }
                this._request.on("error", (reason) => {
                  this._storedError = reason;
                });
                this._request.end();
              }
            }
            class PDFNodeStreamFsFullReader extends BaseFullReader {
              constructor(stream) {
                super(stream);
                let path = decodeURIComponent(this._url.path);
                if (fileUriRegex.test(this._url.href)) {
                  path = path.replace(/^\//, "");
                }
                fs.lstat(path, (error, stat) => {
                  if (error) {
                    if (error.code === "ENOENT") {
                      error = new _util2.MissingPDFException(`Missing PDF "${path}".`);
                    }
                    this._storedError = error;
                    this._headersCapability.reject(error);
                    return;
                  }
                  this._contentLength = stat.size;
                  this._setReadableStream(fs.createReadStream(path));
                  this._headersCapability.resolve();
                });
              }
            }
            class PDFNodeStreamFsRangeReader extends BaseRangeReader {
              constructor(stream, start, end) {
                super(stream);
                let path = decodeURIComponent(this._url.path);
                if (fileUriRegex.test(this._url.href)) {
                  path = path.replace(/^\//, "");
                }
                this._setReadableStream(fs.createReadStream(path, {
                  start,
                  end: end - 1
                }));
              }
            }
          },
          9299: function(__unused_webpack_module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.getShadingPatternFromIR = getShadingPatternFromIR;
            exports2.TilingPattern = void 0;
            var _util2 = __webpack_require__2(7484);
            var ShadingIRs = {};
            function applyBoundingBox(ctx, bbox) {
              if (!bbox || typeof Path2D === "undefined") {
                return;
              }
              const width = bbox[2] - bbox[0];
              const height = bbox[3] - bbox[1];
              const region = new Path2D();
              region.rect(bbox[0], bbox[1], width, height);
              ctx.clip(region);
            }
            ShadingIRs.RadialAxial = {
              fromIR: function RadialAxial_fromIR(raw) {
                var type = raw[1];
                var bbox = raw[2];
                var colorStops = raw[3];
                var p0 = raw[4];
                var p1 = raw[5];
                var r0 = raw[6];
                var r1 = raw[7];
                return {
                  type: "Pattern",
                  getPattern: function RadialAxial_getPattern(ctx) {
                    applyBoundingBox(ctx, bbox);
                    var grad;
                    if (type === "axial") {
                      grad = ctx.createLinearGradient(p0[0], p0[1], p1[0], p1[1]);
                    } else if (type === "radial") {
                      grad = ctx.createRadialGradient(p0[0], p0[1], r0, p1[0], p1[1], r1);
                    }
                    for (var i = 0, ii = colorStops.length; i < ii; ++i) {
                      var c = colorStops[i];
                      grad.addColorStop(c[0], c[1]);
                    }
                    return grad;
                  }
                };
              }
            };
            var createMeshCanvas = function createMeshCanvasClosure() {
              function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {
                var coords = context.coords, colors = context.colors;
                var bytes = data.data, rowSize = data.width * 4;
                var tmp;
                if (coords[p1 + 1] > coords[p2 + 1]) {
                  tmp = p1;
                  p1 = p2;
                  p2 = tmp;
                  tmp = c1;
                  c1 = c2;
                  c2 = tmp;
                }
                if (coords[p2 + 1] > coords[p3 + 1]) {
                  tmp = p2;
                  p2 = p3;
                  p3 = tmp;
                  tmp = c2;
                  c2 = c3;
                  c3 = tmp;
                }
                if (coords[p1 + 1] > coords[p2 + 1]) {
                  tmp = p1;
                  p1 = p2;
                  p2 = tmp;
                  tmp = c1;
                  c1 = c2;
                  c2 = tmp;
                }
                var x1 = (coords[p1] + context.offsetX) * context.scaleX;
                var y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;
                var x2 = (coords[p2] + context.offsetX) * context.scaleX;
                var y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;
                var x3 = (coords[p3] + context.offsetX) * context.scaleX;
                var y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;
                if (y1 >= y3) {
                  return;
                }
                var c1r = colors[c1], c1g = colors[c1 + 1], c1b = colors[c1 + 2];
                var c2r = colors[c2], c2g = colors[c2 + 1], c2b = colors[c2 + 2];
                var c3r = colors[c3], c3g = colors[c3 + 1], c3b = colors[c3 + 2];
                var minY = Math.round(y1), maxY = Math.round(y3);
                var xa, car, cag, cab;
                var xb, cbr, cbg, cbb;
                for (var y = minY; y <= maxY; y++) {
                  if (y < y2) {
                    let k2;
                    if (y < y1) {
                      k2 = 0;
                    } else if (y1 === y2) {
                      k2 = 1;
                    } else {
                      k2 = (y1 - y) / (y1 - y2);
                    }
                    xa = x1 - (x1 - x2) * k2;
                    car = c1r - (c1r - c2r) * k2;
                    cag = c1g - (c1g - c2g) * k2;
                    cab = c1b - (c1b - c2b) * k2;
                  } else {
                    let k2;
                    if (y > y3) {
                      k2 = 1;
                    } else if (y2 === y3) {
                      k2 = 0;
                    } else {
                      k2 = (y2 - y) / (y2 - y3);
                    }
                    xa = x2 - (x2 - x3) * k2;
                    car = c2r - (c2r - c3r) * k2;
                    cag = c2g - (c2g - c3g) * k2;
                    cab = c2b - (c2b - c3b) * k2;
                  }
                  let k;
                  if (y < y1) {
                    k = 0;
                  } else if (y > y3) {
                    k = 1;
                  } else {
                    k = (y1 - y) / (y1 - y3);
                  }
                  xb = x1 - (x1 - x3) * k;
                  cbr = c1r - (c1r - c3r) * k;
                  cbg = c1g - (c1g - c3g) * k;
                  cbb = c1b - (c1b - c3b) * k;
                  var x1_ = Math.round(Math.min(xa, xb));
                  var x2_ = Math.round(Math.max(xa, xb));
                  var j = rowSize * y + x1_ * 4;
                  for (var x = x1_; x <= x2_; x++) {
                    let k2 = (xa - x) / (xa - xb);
                    if (k2 < 0) {
                      k2 = 0;
                    } else if (k2 > 1) {
                      k2 = 1;
                    }
                    bytes[j++] = car - (car - cbr) * k2 | 0;
                    bytes[j++] = cag - (cag - cbg) * k2 | 0;
                    bytes[j++] = cab - (cab - cbb) * k2 | 0;
                    bytes[j++] = 255;
                  }
                }
              }
              function drawFigure(data, figure, context) {
                var ps = figure.coords;
                var cs = figure.colors;
                var i, ii;
                switch (figure.type) {
                  case "lattice":
                    var verticesPerRow = figure.verticesPerRow;
                    var rows = Math.floor(ps.length / verticesPerRow) - 1;
                    var cols = verticesPerRow - 1;
                    for (i = 0; i < rows; i++) {
                      var q = i * verticesPerRow;
                      for (var j = 0; j < cols; j++, q++) {
                        drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);
                        drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);
                      }
                    }
                    break;
                  case "triangles":
                    for (i = 0, ii = ps.length; i < ii; i += 3) {
                      drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);
                    }
                    break;
                  default:
                    throw new Error("illegal figure");
                }
              }
              function createMeshCanvas2(bounds, combinesScale, coords, colors, figures, backgroundColor, cachedCanvases, webGLContext) {
                var EXPECTED_SCALE = 1.1;
                var MAX_PATTERN_SIZE = 3e3;
                var BORDER_SIZE = 2;
                var offsetX = Math.floor(bounds[0]);
                var offsetY = Math.floor(bounds[1]);
                var boundsWidth = Math.ceil(bounds[2]) - offsetX;
                var boundsHeight = Math.ceil(bounds[3]) - offsetY;
                var width = Math.min(Math.ceil(Math.abs(boundsWidth * combinesScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
                var height = Math.min(Math.ceil(Math.abs(boundsHeight * combinesScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
                var scaleX = boundsWidth / width;
                var scaleY = boundsHeight / height;
                var context = {
                  coords,
                  colors,
                  offsetX: -offsetX,
                  offsetY: -offsetY,
                  scaleX: 1 / scaleX,
                  scaleY: 1 / scaleY
                };
                var paddedWidth = width + BORDER_SIZE * 2;
                var paddedHeight = height + BORDER_SIZE * 2;
                var canvas, tmpCanvas, i, ii;
                if (webGLContext.isEnabled) {
                  canvas = webGLContext.drawFigures({
                    width,
                    height,
                    backgroundColor,
                    figures,
                    context
                  });
                  tmpCanvas = cachedCanvases.getCanvas("mesh", paddedWidth, paddedHeight, false);
                  tmpCanvas.context.drawImage(canvas, BORDER_SIZE, BORDER_SIZE);
                  canvas = tmpCanvas.canvas;
                } else {
                  tmpCanvas = cachedCanvases.getCanvas("mesh", paddedWidth, paddedHeight, false);
                  var tmpCtx = tmpCanvas.context;
                  var data = tmpCtx.createImageData(width, height);
                  if (backgroundColor) {
                    var bytes = data.data;
                    for (i = 0, ii = bytes.length; i < ii; i += 4) {
                      bytes[i] = backgroundColor[0];
                      bytes[i + 1] = backgroundColor[1];
                      bytes[i + 2] = backgroundColor[2];
                      bytes[i + 3] = 255;
                    }
                  }
                  for (i = 0; i < figures.length; i++) {
                    drawFigure(data, figures[i], context);
                  }
                  tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);
                  canvas = tmpCanvas.canvas;
                }
                return {
                  canvas,
                  offsetX: offsetX - BORDER_SIZE * scaleX,
                  offsetY: offsetY - BORDER_SIZE * scaleY,
                  scaleX,
                  scaleY
                };
              }
              return createMeshCanvas2;
            }();
            ShadingIRs.Mesh = {
              fromIR: function Mesh_fromIR(raw) {
                var coords = raw[2];
                var colors = raw[3];
                var figures = raw[4];
                var bounds = raw[5];
                var matrix = raw[6];
                var bbox = raw[7];
                var background = raw[8];
                return {
                  type: "Pattern",
                  getPattern: function Mesh_getPattern(ctx, owner, shadingFill) {
                    applyBoundingBox(ctx, bbox);
                    var scale;
                    if (shadingFill) {
                      scale = _util2.Util.singularValueDecompose2dScale(ctx.mozCurrentTransform);
                    } else {
                      scale = _util2.Util.singularValueDecompose2dScale(owner.baseTransform);
                      if (matrix) {
                        var matrixScale = _util2.Util.singularValueDecompose2dScale(matrix);
                        scale = [scale[0] * matrixScale[0], scale[1] * matrixScale[1]];
                      }
                    }
                    var temporaryPatternCanvas = createMeshCanvas(bounds, scale, coords, colors, figures, shadingFill ? null : background, owner.cachedCanvases, owner.webGLContext);
                    if (!shadingFill) {
                      ctx.setTransform.apply(ctx, owner.baseTransform);
                      if (matrix) {
                        ctx.transform.apply(ctx, matrix);
                      }
                    }
                    ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
                    ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);
                    return ctx.createPattern(temporaryPatternCanvas.canvas, "no-repeat");
                  }
                };
              }
            };
            ShadingIRs.Dummy = {
              fromIR: function Dummy_fromIR() {
                return {
                  type: "Pattern",
                  getPattern: function Dummy_fromIR_getPattern() {
                    return "hotpink";
                  }
                };
              }
            };
            function getShadingPatternFromIR(raw) {
              var shadingIR = ShadingIRs[raw[0]];
              if (!shadingIR) {
                throw new Error(`Unknown IR type: ${raw[0]}`);
              }
              return shadingIR.fromIR(raw);
            }
            var TilingPattern = function TilingPatternClosure() {
              var PaintType = {
                COLORED: 1,
                UNCOLORED: 2
              };
              var MAX_PATTERN_SIZE = 3e3;
              function TilingPattern2(IR, color, ctx, canvasGraphicsFactory, baseTransform) {
                this.operatorList = IR[2];
                this.matrix = IR[3] || [1, 0, 0, 1, 0, 0];
                this.bbox = IR[4];
                this.xstep = IR[5];
                this.ystep = IR[6];
                this.paintType = IR[7];
                this.tilingType = IR[8];
                this.color = color;
                this.canvasGraphicsFactory = canvasGraphicsFactory;
                this.baseTransform = baseTransform;
                this.type = "Pattern";
                this.ctx = ctx;
              }
              TilingPattern2.prototype = {
                createPatternCanvas: function TilinPattern_createPatternCanvas(owner) {
                  var operatorList = this.operatorList;
                  var bbox = this.bbox;
                  var xstep = this.xstep;
                  var ystep = this.ystep;
                  var paintType = this.paintType;
                  var tilingType = this.tilingType;
                  var color = this.color;
                  var canvasGraphicsFactory = this.canvasGraphicsFactory;
                  (0, _util2.info)("TilingType: " + tilingType);
                  var x0 = bbox[0], y0 = bbox[1], x1 = bbox[2], y1 = bbox[3];
                  var matrixScale = _util2.Util.singularValueDecompose2dScale(this.matrix);
                  var curMatrixScale = _util2.Util.singularValueDecompose2dScale(this.baseTransform);
                  var combinedScale = [matrixScale[0] * curMatrixScale[0], matrixScale[1] * curMatrixScale[1]];
                  var dimx = this.getSizeAndScale(xstep, this.ctx.canvas.width, combinedScale[0]);
                  var dimy = this.getSizeAndScale(ystep, this.ctx.canvas.height, combinedScale[1]);
                  var tmpCanvas = owner.cachedCanvases.getCanvas("pattern", dimx.size, dimy.size, true);
                  var tmpCtx = tmpCanvas.context;
                  var graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);
                  graphics.groupLevel = owner.groupLevel;
                  this.setFillAndStrokeStyleToContext(graphics, paintType, color);
                  graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0);
                  graphics.transform(1, 0, 0, 1, -x0, -y0);
                  this.clipBbox(graphics, bbox, x0, y0, x1, y1);
                  graphics.executeOperatorList(operatorList);
                  this.ctx.transform(1, 0, 0, 1, x0, y0);
                  this.ctx.scale(1 / dimx.scale, 1 / dimy.scale);
                  return tmpCanvas.canvas;
                },
                getSizeAndScale: function TilingPattern_getSizeAndScale(step, realOutputSize, scale) {
                  step = Math.abs(step);
                  var maxSize = Math.max(MAX_PATTERN_SIZE, realOutputSize);
                  var size = Math.ceil(step * scale);
                  if (size >= maxSize) {
                    size = maxSize;
                  } else {
                    scale = size / step;
                  }
                  return {
                    scale,
                    size
                  };
                },
                clipBbox: function clipBbox(graphics, bbox, x0, y0, x1, y1) {
                  if (Array.isArray(bbox) && bbox.length === 4) {
                    var bboxWidth = x1 - x0;
                    var bboxHeight = y1 - y0;
                    graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);
                    graphics.clip();
                    graphics.endPath();
                  }
                },
                setFillAndStrokeStyleToContext: function setFillAndStrokeStyleToContext(graphics, paintType, color) {
                  const context = graphics.ctx, current = graphics.current;
                  switch (paintType) {
                    case PaintType.COLORED:
                      var ctx = this.ctx;
                      context.fillStyle = ctx.fillStyle;
                      context.strokeStyle = ctx.strokeStyle;
                      current.fillColor = ctx.fillStyle;
                      current.strokeColor = ctx.strokeStyle;
                      break;
                    case PaintType.UNCOLORED:
                      var cssColor = _util2.Util.makeCssRgb(color[0], color[1], color[2]);
                      context.fillStyle = cssColor;
                      context.strokeStyle = cssColor;
                      current.fillColor = cssColor;
                      current.strokeColor = cssColor;
                      break;
                    default:
                      throw new _util2.FormatError(`Unsupported paint type: ${paintType}`);
                  }
                },
                getPattern: function TilingPattern_getPattern(ctx, owner) {
                  ctx = this.ctx;
                  ctx.setTransform.apply(ctx, this.baseTransform);
                  ctx.transform.apply(ctx, this.matrix);
                  var temporaryPatternCanvas = this.createPatternCanvas(owner);
                  return ctx.createPattern(temporaryPatternCanvas, "repeat");
                }
              };
              return TilingPattern2;
            }();
            exports2.TilingPattern = TilingPattern;
          },
          8002: function(__unused_webpack_module2, exports2, __webpack_require__2) {
            "use strict";
            __webpack_require__2(3408);
            __webpack_require__2(4590);
            __webpack_require__2(7658);
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.SVGGraphics = void 0;
            var _util2 = __webpack_require__2(7484);
            var _display_utils2 = __webpack_require__2(9485);
            var _is_node2 = __webpack_require__2(2918);
            let SVGGraphics = function() {
              throw new Error("Not implemented: SVGGraphics");
            };
            exports2.SVGGraphics = SVGGraphics;
            {
              let opListToTree = function(opList) {
                let opTree = [];
                const tmp = [];
                for (const opListElement of opList) {
                  if (opListElement.fn === "save") {
                    opTree.push({
                      fnId: 92,
                      fn: "group",
                      items: []
                    });
                    tmp.push(opTree);
                    opTree = opTree[opTree.length - 1].items;
                    continue;
                  }
                  if (opListElement.fn === "restore") {
                    opTree = tmp.pop();
                  } else {
                    opTree.push(opListElement);
                  }
                }
                return opTree;
              }, pf = function(value) {
                if (Number.isInteger(value)) {
                  return value.toString();
                }
                const s = value.toFixed(10);
                let i = s.length - 1;
                if (s[i] !== "0") {
                  return s;
                }
                do {
                  i--;
                } while (s[i] === "0");
                return s.substring(0, s[i] === "." ? i : i + 1);
              }, pm = function(m) {
                if (m[4] === 0 && m[5] === 0) {
                  if (m[1] === 0 && m[2] === 0) {
                    if (m[0] === 1 && m[3] === 1) {
                      return "";
                    }
                    return `scale(${pf(m[0])} ${pf(m[3])})`;
                  }
                  if (m[0] === m[3] && m[1] === -m[2]) {
                    const a = Math.acos(m[0]) * 180 / Math.PI;
                    return `rotate(${pf(a)})`;
                  }
                } else {
                  if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1) {
                    return `translate(${pf(m[4])} ${pf(m[5])})`;
                  }
                }
                return `matrix(${pf(m[0])} ${pf(m[1])} ${pf(m[2])} ${pf(m[3])} ${pf(m[4])} ${pf(m[5])})`;
              };
              const SVG_DEFAULTS = {
                fontStyle: "normal",
                fontWeight: "normal",
                fillColor: "#000000"
              };
              const XML_NS = "http://www.w3.org/XML/1998/namespace";
              const XLINK_NS = "http://www.w3.org/1999/xlink";
              const LINE_CAP_STYLES = ["butt", "round", "square"];
              const LINE_JOIN_STYLES = ["miter", "round", "bevel"];
              const convertImgDataToPng = function() {
                const PNG_HEADER = new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10]);
                const CHUNK_WRAPPER_SIZE = 12;
                const crcTable = new Int32Array(256);
                for (let i = 0; i < 256; i++) {
                  let c = i;
                  for (let h = 0; h < 8; h++) {
                    if (c & 1) {
                      c = 3988292384 ^ c >> 1 & 2147483647;
                    } else {
                      c = c >> 1 & 2147483647;
                    }
                  }
                  crcTable[i] = c;
                }
                function crc32(data, start, end) {
                  let crc = -1;
                  for (let i = start; i < end; i++) {
                    const a = (crc ^ data[i]) & 255;
                    const b = crcTable[a];
                    crc = crc >>> 8 ^ b;
                  }
                  return crc ^ -1;
                }
                function writePngChunk(type, body, data, offset) {
                  let p = offset;
                  const len = body.length;
                  data[p] = len >> 24 & 255;
                  data[p + 1] = len >> 16 & 255;
                  data[p + 2] = len >> 8 & 255;
                  data[p + 3] = len & 255;
                  p += 4;
                  data[p] = type.charCodeAt(0) & 255;
                  data[p + 1] = type.charCodeAt(1) & 255;
                  data[p + 2] = type.charCodeAt(2) & 255;
                  data[p + 3] = type.charCodeAt(3) & 255;
                  p += 4;
                  data.set(body, p);
                  p += body.length;
                  const crc = crc32(data, offset + 4, p);
                  data[p] = crc >> 24 & 255;
                  data[p + 1] = crc >> 16 & 255;
                  data[p + 2] = crc >> 8 & 255;
                  data[p + 3] = crc & 255;
                }
                function adler32(data, start, end) {
                  let a = 1;
                  let b = 0;
                  for (let i = start; i < end; ++i) {
                    a = (a + (data[i] & 255)) % 65521;
                    b = (b + a) % 65521;
                  }
                  return b << 16 | a;
                }
                function deflateSync(literals) {
                  if (!_is_node2.isNodeJS) {
                    return deflateSyncUncompressed(literals);
                  }
                  try {
                    let input;
                    if (parseInt(process.versions.node) >= 8) {
                      input = literals;
                    } else {
                      input = Buffer.from(literals);
                    }
                    const output = __webpack_require__2(8498).deflateSync(input, {
                      level: 9
                    });
                    return output instanceof Uint8Array ? output : new Uint8Array(output);
                  } catch (e) {
                    (0, _util2.warn)("Not compressing PNG because zlib.deflateSync is unavailable: " + e);
                  }
                  return deflateSyncUncompressed(literals);
                }
                function deflateSyncUncompressed(literals) {
                  let len = literals.length;
                  const maxBlockLength = 65535;
                  const deflateBlocks = Math.ceil(len / maxBlockLength);
                  const idat = new Uint8Array(2 + len + deflateBlocks * 5 + 4);
                  let pi = 0;
                  idat[pi++] = 120;
                  idat[pi++] = 156;
                  let pos = 0;
                  while (len > maxBlockLength) {
                    idat[pi++] = 0;
                    idat[pi++] = 255;
                    idat[pi++] = 255;
                    idat[pi++] = 0;
                    idat[pi++] = 0;
                    idat.set(literals.subarray(pos, pos + maxBlockLength), pi);
                    pi += maxBlockLength;
                    pos += maxBlockLength;
                    len -= maxBlockLength;
                  }
                  idat[pi++] = 1;
                  idat[pi++] = len & 255;
                  idat[pi++] = len >> 8 & 255;
                  idat[pi++] = ~len & 65535 & 255;
                  idat[pi++] = (~len & 65535) >> 8 & 255;
                  idat.set(literals.subarray(pos), pi);
                  pi += literals.length - pos;
                  const adler = adler32(literals, 0, literals.length);
                  idat[pi++] = adler >> 24 & 255;
                  idat[pi++] = adler >> 16 & 255;
                  idat[pi++] = adler >> 8 & 255;
                  idat[pi++] = adler & 255;
                  return idat;
                }
                function encode(imgData, kind, forceDataSchema, isMask) {
                  const width = imgData.width;
                  const height = imgData.height;
                  let bitDepth, colorType, lineSize;
                  const bytes = imgData.data;
                  switch (kind) {
                    case _util2.ImageKind.GRAYSCALE_1BPP:
                      colorType = 0;
                      bitDepth = 1;
                      lineSize = width + 7 >> 3;
                      break;
                    case _util2.ImageKind.RGB_24BPP:
                      colorType = 2;
                      bitDepth = 8;
                      lineSize = width * 3;
                      break;
                    case _util2.ImageKind.RGBA_32BPP:
                      colorType = 6;
                      bitDepth = 8;
                      lineSize = width * 4;
                      break;
                    default:
                      throw new Error("invalid format");
                  }
                  const literals = new Uint8Array((1 + lineSize) * height);
                  let offsetLiterals = 0, offsetBytes = 0;
                  for (let y = 0; y < height; ++y) {
                    literals[offsetLiterals++] = 0;
                    literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize), offsetLiterals);
                    offsetBytes += lineSize;
                    offsetLiterals += lineSize;
                  }
                  if (kind === _util2.ImageKind.GRAYSCALE_1BPP && isMask) {
                    offsetLiterals = 0;
                    for (let y = 0; y < height; y++) {
                      offsetLiterals++;
                      for (let i = 0; i < lineSize; i++) {
                        literals[offsetLiterals++] ^= 255;
                      }
                    }
                  }
                  const ihdr = new Uint8Array([width >> 24 & 255, width >> 16 & 255, width >> 8 & 255, width & 255, height >> 24 & 255, height >> 16 & 255, height >> 8 & 255, height & 255, bitDepth, colorType, 0, 0, 0]);
                  const idat = deflateSync(literals);
                  const pngLength = PNG_HEADER.length + CHUNK_WRAPPER_SIZE * 3 + ihdr.length + idat.length;
                  const data = new Uint8Array(pngLength);
                  let offset = 0;
                  data.set(PNG_HEADER, offset);
                  offset += PNG_HEADER.length;
                  writePngChunk("IHDR", ihdr, data, offset);
                  offset += CHUNK_WRAPPER_SIZE + ihdr.length;
                  writePngChunk("IDATA", idat, data, offset);
                  offset += CHUNK_WRAPPER_SIZE + idat.length;
                  writePngChunk("IEND", new Uint8Array(0), data, offset);
                  return (0, _util2.createObjectURL)(data, "image/png", forceDataSchema);
                }
                return function convertImgDataToPng2(imgData, forceDataSchema, isMask) {
                  const kind = imgData.kind === void 0 ? _util2.ImageKind.GRAYSCALE_1BPP : imgData.kind;
                  return encode(imgData, kind, forceDataSchema, isMask);
                };
              }();
              class SVGExtraState {
                constructor() {
                  this.fontSizeScale = 1;
                  this.fontWeight = SVG_DEFAULTS.fontWeight;
                  this.fontSize = 0;
                  this.textMatrix = _util2.IDENTITY_MATRIX;
                  this.fontMatrix = _util2.FONT_IDENTITY_MATRIX;
                  this.leading = 0;
                  this.textRenderingMode = _util2.TextRenderingMode.FILL;
                  this.textMatrixScale = 1;
                  this.x = 0;
                  this.y = 0;
                  this.lineX = 0;
                  this.lineY = 0;
                  this.charSpacing = 0;
                  this.wordSpacing = 0;
                  this.textHScale = 1;
                  this.textRise = 0;
                  this.fillColor = SVG_DEFAULTS.fillColor;
                  this.strokeColor = "#000000";
                  this.fillAlpha = 1;
                  this.strokeAlpha = 1;
                  this.lineWidth = 1;
                  this.lineJoin = "";
                  this.lineCap = "";
                  this.miterLimit = 0;
                  this.dashArray = [];
                  this.dashPhase = 0;
                  this.dependencies = [];
                  this.activeClipUrl = null;
                  this.clipGroup = null;
                  this.maskId = "";
                }
                clone() {
                  return Object.create(this);
                }
                setCurrentPoint(x, y) {
                  this.x = x;
                  this.y = y;
                }
              }
              let clipCount = 0;
              let maskCount = 0;
              let shadingCount = 0;
              exports2.SVGGraphics = SVGGraphics = class SVGGraphics {
                constructor(commonObjs, objs, forceDataSchema) {
                  this.svgFactory = new _display_utils2.DOMSVGFactory();
                  this.current = new SVGExtraState();
                  this.transformMatrix = _util2.IDENTITY_MATRIX;
                  this.transformStack = [];
                  this.extraStack = [];
                  this.commonObjs = commonObjs;
                  this.objs = objs;
                  this.pendingClip = null;
                  this.pendingEOFill = false;
                  this.embedFonts = false;
                  this.embeddedFonts = /* @__PURE__ */ Object.create(null);
                  this.cssStyle = null;
                  this.forceDataSchema = !!forceDataSchema;
                  this._operatorIdMapping = [];
                  for (const op in _util2.OPS) {
                    this._operatorIdMapping[_util2.OPS[op]] = op;
                  }
                }
                save() {
                  this.transformStack.push(this.transformMatrix);
                  const old = this.current;
                  this.extraStack.push(old);
                  this.current = old.clone();
                }
                restore() {
                  this.transformMatrix = this.transformStack.pop();
                  this.current = this.extraStack.pop();
                  this.pendingClip = null;
                  this.tgrp = null;
                }
                group(items) {
                  this.save();
                  this.executeOpTree(items);
                  this.restore();
                }
                loadDependencies(operatorList) {
                  const fnArray = operatorList.fnArray;
                  const argsArray = operatorList.argsArray;
                  for (let i = 0, ii = fnArray.length; i < ii; i++) {
                    if (fnArray[i] !== _util2.OPS.dependency) {
                      continue;
                    }
                    for (const obj of argsArray[i]) {
                      const objsPool = obj.startsWith("g_") ? this.commonObjs : this.objs;
                      const promise = new Promise((resolve) => {
                        objsPool.get(obj, resolve);
                      });
                      this.current.dependencies.push(promise);
                    }
                  }
                  return Promise.all(this.current.dependencies);
                }
                transform(a, b, c, d, e, f) {
                  const transformMatrix = [a, b, c, d, e, f];
                  this.transformMatrix = _util2.Util.transform(this.transformMatrix, transformMatrix);
                  this.tgrp = null;
                }
                getSVG(operatorList, viewport) {
                  this.viewport = viewport;
                  const svgElement = this._initialize(viewport);
                  return this.loadDependencies(operatorList).then(() => {
                    this.transformMatrix = _util2.IDENTITY_MATRIX;
                    this.executeOpTree(this.convertOpList(operatorList));
                    return svgElement;
                  });
                }
                convertOpList(operatorList) {
                  const operatorIdMapping = this._operatorIdMapping;
                  const argsArray = operatorList.argsArray;
                  const fnArray = operatorList.fnArray;
                  const opList = [];
                  for (let i = 0, ii = fnArray.length; i < ii; i++) {
                    const fnId = fnArray[i];
                    opList.push({
                      fnId,
                      fn: operatorIdMapping[fnId],
                      args: argsArray[i]
                    });
                  }
                  return opListToTree(opList);
                }
                executeOpTree(opTree) {
                  for (const opTreeElement of opTree) {
                    const fn = opTreeElement.fn;
                    const fnId = opTreeElement.fnId;
                    const args = opTreeElement.args;
                    switch (fnId | 0) {
                      case _util2.OPS.beginText:
                        this.beginText();
                        break;
                      case _util2.OPS.dependency:
                        break;
                      case _util2.OPS.setLeading:
                        this.setLeading(args);
                        break;
                      case _util2.OPS.setLeadingMoveText:
                        this.setLeadingMoveText(args[0], args[1]);
                        break;
                      case _util2.OPS.setFont:
                        this.setFont(args);
                        break;
                      case _util2.OPS.showText:
                        this.showText(args[0]);
                        break;
                      case _util2.OPS.showSpacedText:
                        this.showText(args[0]);
                        break;
                      case _util2.OPS.endText:
                        this.endText();
                        break;
                      case _util2.OPS.moveText:
                        this.moveText(args[0], args[1]);
                        break;
                      case _util2.OPS.setCharSpacing:
                        this.setCharSpacing(args[0]);
                        break;
                      case _util2.OPS.setWordSpacing:
                        this.setWordSpacing(args[0]);
                        break;
                      case _util2.OPS.setHScale:
                        this.setHScale(args[0]);
                        break;
                      case _util2.OPS.setTextMatrix:
                        this.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
                        break;
                      case _util2.OPS.setTextRise:
                        this.setTextRise(args[0]);
                        break;
                      case _util2.OPS.setTextRenderingMode:
                        this.setTextRenderingMode(args[0]);
                        break;
                      case _util2.OPS.setLineWidth:
                        this.setLineWidth(args[0]);
                        break;
                      case _util2.OPS.setLineJoin:
                        this.setLineJoin(args[0]);
                        break;
                      case _util2.OPS.setLineCap:
                        this.setLineCap(args[0]);
                        break;
                      case _util2.OPS.setMiterLimit:
                        this.setMiterLimit(args[0]);
                        break;
                      case _util2.OPS.setFillRGBColor:
                        this.setFillRGBColor(args[0], args[1], args[2]);
                        break;
                      case _util2.OPS.setStrokeRGBColor:
                        this.setStrokeRGBColor(args[0], args[1], args[2]);
                        break;
                      case _util2.OPS.setStrokeColorN:
                        this.setStrokeColorN(args);
                        break;
                      case _util2.OPS.setFillColorN:
                        this.setFillColorN(args);
                        break;
                      case _util2.OPS.shadingFill:
                        this.shadingFill(args[0]);
                        break;
                      case _util2.OPS.setDash:
                        this.setDash(args[0], args[1]);
                        break;
                      case _util2.OPS.setRenderingIntent:
                        this.setRenderingIntent(args[0]);
                        break;
                      case _util2.OPS.setFlatness:
                        this.setFlatness(args[0]);
                        break;
                      case _util2.OPS.setGState:
                        this.setGState(args[0]);
                        break;
                      case _util2.OPS.fill:
                        this.fill();
                        break;
                      case _util2.OPS.eoFill:
                        this.eoFill();
                        break;
                      case _util2.OPS.stroke:
                        this.stroke();
                        break;
                      case _util2.OPS.fillStroke:
                        this.fillStroke();
                        break;
                      case _util2.OPS.eoFillStroke:
                        this.eoFillStroke();
                        break;
                      case _util2.OPS.clip:
                        this.clip("nonzero");
                        break;
                      case _util2.OPS.eoClip:
                        this.clip("evenodd");
                        break;
                      case _util2.OPS.paintSolidColorImageMask:
                        this.paintSolidColorImageMask();
                        break;
                      case _util2.OPS.paintJpegXObject:
                        this.paintJpegXObject(args[0], args[1], args[2]);
                        break;
                      case _util2.OPS.paintImageXObject:
                        this.paintImageXObject(args[0]);
                        break;
                      case _util2.OPS.paintInlineImageXObject:
                        this.paintInlineImageXObject(args[0]);
                        break;
                      case _util2.OPS.paintImageMaskXObject:
                        this.paintImageMaskXObject(args[0]);
                        break;
                      case _util2.OPS.paintFormXObjectBegin:
                        this.paintFormXObjectBegin(args[0], args[1]);
                        break;
                      case _util2.OPS.paintFormXObjectEnd:
                        this.paintFormXObjectEnd();
                        break;
                      case _util2.OPS.closePath:
                        this.closePath();
                        break;
                      case _util2.OPS.closeStroke:
                        this.closeStroke();
                        break;
                      case _util2.OPS.closeFillStroke:
                        this.closeFillStroke();
                        break;
                      case _util2.OPS.closeEOFillStroke:
                        this.closeEOFillStroke();
                        break;
                      case _util2.OPS.nextLine:
                        this.nextLine();
                        break;
                      case _util2.OPS.transform:
                        this.transform(args[0], args[1], args[2], args[3], args[4], args[5]);
                        break;
                      case _util2.OPS.constructPath:
                        this.constructPath(args[0], args[1]);
                        break;
                      case _util2.OPS.endPath:
                        this.endPath();
                        break;
                      case 92:
                        this.group(opTreeElement.items);
                        break;
                      default:
                        (0, _util2.warn)(`Unimplemented operator ${fn}`);
                        break;
                    }
                  }
                }
                setWordSpacing(wordSpacing) {
                  this.current.wordSpacing = wordSpacing;
                }
                setCharSpacing(charSpacing) {
                  this.current.charSpacing = charSpacing;
                }
                nextLine() {
                  this.moveText(0, this.current.leading);
                }
                setTextMatrix(a, b, c, d, e, f) {
                  const current = this.current;
                  current.textMatrix = current.lineMatrix = [a, b, c, d, e, f];
                  current.textMatrixScale = Math.sqrt(a * a + b * b);
                  current.x = current.lineX = 0;
                  current.y = current.lineY = 0;
                  current.xcoords = [];
                  current.tspan = this.svgFactory.createElement("svg:tspan");
                  current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
                  current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);
                  current.tspan.setAttributeNS(null, "y", pf(-current.y));
                  current.txtElement = this.svgFactory.createElement("svg:text");
                  current.txtElement.appendChild(current.tspan);
                }
                beginText() {
                  const current = this.current;
                  current.x = current.lineX = 0;
                  current.y = current.lineY = 0;
                  current.textMatrix = _util2.IDENTITY_MATRIX;
                  current.lineMatrix = _util2.IDENTITY_MATRIX;
                  current.textMatrixScale = 1;
                  current.tspan = this.svgFactory.createElement("svg:tspan");
                  current.txtElement = this.svgFactory.createElement("svg:text");
                  current.txtgrp = this.svgFactory.createElement("svg:g");
                  current.xcoords = [];
                }
                moveText(x, y) {
                  const current = this.current;
                  current.x = current.lineX += x;
                  current.y = current.lineY += y;
                  current.xcoords = [];
                  current.tspan = this.svgFactory.createElement("svg:tspan");
                  current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
                  current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);
                  current.tspan.setAttributeNS(null, "y", pf(-current.y));
                }
                showText(glyphs) {
                  const current = this.current;
                  const font = current.font;
                  const fontSize = current.fontSize;
                  if (fontSize === 0) {
                    return;
                  }
                  const charSpacing = current.charSpacing;
                  const wordSpacing = current.wordSpacing;
                  const fontDirection = current.fontDirection;
                  const textHScale = current.textHScale * fontDirection;
                  const vertical = font.vertical;
                  const widthAdvanceScale = fontSize * current.fontMatrix[0];
                  let x = 0;
                  for (const glyph of glyphs) {
                    if (glyph === null) {
                      x += fontDirection * wordSpacing;
                      continue;
                    } else if ((0, _util2.isNum)(glyph)) {
                      x += -glyph * fontSize * 1e-3;
                      continue;
                    }
                    const width = glyph.width;
                    const character = glyph.fontChar;
                    const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                    const charWidth = width * widthAdvanceScale + spacing * fontDirection;
                    if (!glyph.isInFont && !font.missingFile) {
                      x += charWidth;
                      continue;
                    }
                    current.xcoords.push(current.x + x);
                    current.tspan.textContent += character;
                    x += charWidth;
                  }
                  if (vertical) {
                    current.y -= x * textHScale;
                  } else {
                    current.x += x * textHScale;
                  }
                  current.tspan.setAttributeNS(null, "x", current.xcoords.map(pf).join(" "));
                  current.tspan.setAttributeNS(null, "y", pf(-current.y));
                  current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
                  current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);
                  if (current.fontStyle !== SVG_DEFAULTS.fontStyle) {
                    current.tspan.setAttributeNS(null, "font-style", current.fontStyle);
                  }
                  if (current.fontWeight !== SVG_DEFAULTS.fontWeight) {
                    current.tspan.setAttributeNS(null, "font-weight", current.fontWeight);
                  }
                  const fillStrokeMode = current.textRenderingMode & _util2.TextRenderingMode.FILL_STROKE_MASK;
                  if (fillStrokeMode === _util2.TextRenderingMode.FILL || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                    if (current.fillColor !== SVG_DEFAULTS.fillColor) {
                      current.tspan.setAttributeNS(null, "fill", current.fillColor);
                    }
                    if (current.fillAlpha < 1) {
                      current.tspan.setAttributeNS(null, "fill-opacity", current.fillAlpha);
                    }
                  } else if (current.textRenderingMode === _util2.TextRenderingMode.ADD_TO_PATH) {
                    current.tspan.setAttributeNS(null, "fill", "transparent");
                  } else {
                    current.tspan.setAttributeNS(null, "fill", "none");
                  }
                  if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                    const lineWidthScale = 1 / (current.textMatrixScale || 1);
                    this._setStrokeAttributes(current.tspan, lineWidthScale);
                  }
                  let textMatrix = current.textMatrix;
                  if (current.textRise !== 0) {
                    textMatrix = textMatrix.slice();
                    textMatrix[5] += current.textRise;
                  }
                  current.txtElement.setAttributeNS(null, "transform", `${pm(textMatrix)} scale(${pf(textHScale)}, -1)`);
                  current.txtElement.setAttributeNS(XML_NS, "xml:space", "preserve");
                  current.txtElement.appendChild(current.tspan);
                  current.txtgrp.appendChild(current.txtElement);
                  this._ensureTransformGroup().appendChild(current.txtElement);
                }
                setLeadingMoveText(x, y) {
                  this.setLeading(-y);
                  this.moveText(x, y);
                }
                addFontStyle(fontObj) {
                  if (!this.cssStyle) {
                    this.cssStyle = this.svgFactory.createElement("svg:style");
                    this.cssStyle.setAttributeNS(null, "type", "text/css");
                    this.defs.appendChild(this.cssStyle);
                  }
                  const url = (0, _util2.createObjectURL)(fontObj.data, fontObj.mimetype, this.forceDataSchema);
                  this.cssStyle.textContent += `@font-face { font-family: "${fontObj.loadedName}"; src: url(${url}); }
`;
                }
                setFont(details) {
                  const current = this.current;
                  const fontObj = this.commonObjs.get(details[0]);
                  let size = details[1];
                  current.font = fontObj;
                  if (this.embedFonts && fontObj.data && !this.embeddedFonts[fontObj.loadedName]) {
                    this.addFontStyle(fontObj);
                    this.embeddedFonts[fontObj.loadedName] = fontObj;
                  }
                  current.fontMatrix = fontObj.fontMatrix ? fontObj.fontMatrix : _util2.FONT_IDENTITY_MATRIX;
                  let bold = "normal";
                  if (fontObj.black) {
                    bold = "900";
                  } else if (fontObj.bold) {
                    bold = "bold";
                  }
                  const italic = fontObj.italic ? "italic" : "normal";
                  if (size < 0) {
                    size = -size;
                    current.fontDirection = -1;
                  } else {
                    current.fontDirection = 1;
                  }
                  current.fontSize = size;
                  current.fontFamily = fontObj.loadedName;
                  current.fontWeight = bold;
                  current.fontStyle = italic;
                  current.tspan = this.svgFactory.createElement("svg:tspan");
                  current.tspan.setAttributeNS(null, "y", pf(-current.y));
                  current.xcoords = [];
                }
                endText() {
                  const current = this.current;
                  if (current.textRenderingMode & _util2.TextRenderingMode.ADD_TO_PATH_FLAG && current.txtElement && current.txtElement.hasChildNodes()) {
                    current.element = current.txtElement;
                    this.clip("nonzero");
                    this.endPath();
                  }
                }
                setLineWidth(width) {
                  if (width > 0) {
                    this.current.lineWidth = width;
                  }
                }
                setLineCap(style) {
                  this.current.lineCap = LINE_CAP_STYLES[style];
                }
                setLineJoin(style) {
                  this.current.lineJoin = LINE_JOIN_STYLES[style];
                }
                setMiterLimit(limit) {
                  this.current.miterLimit = limit;
                }
                setStrokeAlpha(strokeAlpha) {
                  this.current.strokeAlpha = strokeAlpha;
                }
                setStrokeRGBColor(r, g, b) {
                  this.current.strokeColor = _util2.Util.makeCssRgb(r, g, b);
                }
                setFillAlpha(fillAlpha) {
                  this.current.fillAlpha = fillAlpha;
                }
                setFillRGBColor(r, g, b) {
                  this.current.fillColor = _util2.Util.makeCssRgb(r, g, b);
                  this.current.tspan = this.svgFactory.createElement("svg:tspan");
                  this.current.xcoords = [];
                }
                setStrokeColorN(args) {
                  this.current.strokeColor = this._makeColorN_Pattern(args);
                }
                setFillColorN(args) {
                  this.current.fillColor = this._makeColorN_Pattern(args);
                }
                shadingFill(args) {
                  const width = this.viewport.width;
                  const height = this.viewport.height;
                  const inv = _util2.Util.inverseTransform(this.transformMatrix);
                  const bl = _util2.Util.applyTransform([0, 0], inv);
                  const br = _util2.Util.applyTransform([0, height], inv);
                  const ul = _util2.Util.applyTransform([width, 0], inv);
                  const ur = _util2.Util.applyTransform([width, height], inv);
                  const x0 = Math.min(bl[0], br[0], ul[0], ur[0]);
                  const y0 = Math.min(bl[1], br[1], ul[1], ur[1]);
                  const x1 = Math.max(bl[0], br[0], ul[0], ur[0]);
                  const y1 = Math.max(bl[1], br[1], ul[1], ur[1]);
                  const rect = this.svgFactory.createElement("svg:rect");
                  rect.setAttributeNS(null, "x", x0);
                  rect.setAttributeNS(null, "y", y0);
                  rect.setAttributeNS(null, "width", x1 - x0);
                  rect.setAttributeNS(null, "height", y1 - y0);
                  rect.setAttributeNS(null, "fill", this._makeShadingPattern(args));
                  this._ensureTransformGroup().appendChild(rect);
                }
                _makeColorN_Pattern(args) {
                  if (args[0] === "TilingPattern") {
                    return this._makeTilingPattern(args);
                  }
                  return this._makeShadingPattern(args);
                }
                _makeTilingPattern(args) {
                  const color = args[1];
                  const operatorList = args[2];
                  const matrix = args[3] || _util2.IDENTITY_MATRIX;
                  const [x0, y0, x1, y1] = args[4];
                  const xstep = args[5];
                  const ystep = args[6];
                  const paintType = args[7];
                  const tilingId = `shading${shadingCount++}`;
                  const [tx0, ty0] = _util2.Util.applyTransform([x0, y0], matrix);
                  const [tx1, ty1] = _util2.Util.applyTransform([x1, y1], matrix);
                  const [xscale, yscale] = _util2.Util.singularValueDecompose2dScale(matrix);
                  const txstep = xstep * xscale;
                  const tystep = ystep * yscale;
                  const tiling = this.svgFactory.createElement("svg:pattern");
                  tiling.setAttributeNS(null, "id", tilingId);
                  tiling.setAttributeNS(null, "patternUnits", "userSpaceOnUse");
                  tiling.setAttributeNS(null, "width", txstep);
                  tiling.setAttributeNS(null, "height", tystep);
                  tiling.setAttributeNS(null, "x", `${tx0}`);
                  tiling.setAttributeNS(null, "y", `${ty0}`);
                  const svg = this.svg;
                  const transformMatrix = this.transformMatrix;
                  const fillColor = this.current.fillColor;
                  const strokeColor = this.current.strokeColor;
                  const bbox = this.svgFactory.create(tx1 - tx0, ty1 - ty0);
                  this.svg = bbox;
                  this.transformMatrix = matrix;
                  if (paintType === 2) {
                    const cssColor = _util2.Util.makeCssRgb(...color);
                    this.current.fillColor = cssColor;
                    this.current.strokeColor = cssColor;
                  }
                  this.executeOpTree(this.convertOpList(operatorList));
                  this.svg = svg;
                  this.transformMatrix = transformMatrix;
                  this.current.fillColor = fillColor;
                  this.current.strokeColor = strokeColor;
                  tiling.appendChild(bbox.childNodes[0]);
                  this.defs.appendChild(tiling);
                  return `url(#${tilingId})`;
                }
                _makeShadingPattern(args) {
                  switch (args[0]) {
                    case "RadialAxial":
                      const shadingId = `shading${shadingCount++}`;
                      const colorStops = args[3];
                      let gradient;
                      switch (args[1]) {
                        case "axial":
                          const point0 = args[4];
                          const point1 = args[5];
                          gradient = this.svgFactory.createElement("svg:linearGradient");
                          gradient.setAttributeNS(null, "id", shadingId);
                          gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
                          gradient.setAttributeNS(null, "x1", point0[0]);
                          gradient.setAttributeNS(null, "y1", point0[1]);
                          gradient.setAttributeNS(null, "x2", point1[0]);
                          gradient.setAttributeNS(null, "y2", point1[1]);
                          break;
                        case "radial":
                          const focalPoint = args[4];
                          const circlePoint = args[5];
                          const focalRadius = args[6];
                          const circleRadius = args[7];
                          gradient = this.svgFactory.createElement("svg:radialGradient");
                          gradient.setAttributeNS(null, "id", shadingId);
                          gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
                          gradient.setAttributeNS(null, "cx", circlePoint[0]);
                          gradient.setAttributeNS(null, "cy", circlePoint[1]);
                          gradient.setAttributeNS(null, "r", circleRadius);
                          gradient.setAttributeNS(null, "fx", focalPoint[0]);
                          gradient.setAttributeNS(null, "fy", focalPoint[1]);
                          gradient.setAttributeNS(null, "fr", focalRadius);
                          break;
                        default:
                          throw new Error(`Unknown RadialAxial type: ${args[1]}`);
                      }
                      for (const colorStop of colorStops) {
                        const stop = this.svgFactory.createElement("svg:stop");
                        stop.setAttributeNS(null, "offset", colorStop[0]);
                        stop.setAttributeNS(null, "stop-color", colorStop[1]);
                        gradient.appendChild(stop);
                      }
                      this.defs.appendChild(gradient);
                      return `url(#${shadingId})`;
                    case "Mesh":
                      (0, _util2.warn)("Unimplemented pattern Mesh");
                      return null;
                    case "Dummy":
                      return "hotpink";
                    default:
                      throw new Error(`Unknown IR type: ${args[0]}`);
                  }
                }
                setDash(dashArray, dashPhase) {
                  this.current.dashArray = dashArray;
                  this.current.dashPhase = dashPhase;
                }
                constructPath(ops, args) {
                  const current = this.current;
                  let x = current.x, y = current.y;
                  let d = [];
                  let j = 0;
                  for (const op of ops) {
                    switch (op | 0) {
                      case _util2.OPS.rectangle:
                        x = args[j++];
                        y = args[j++];
                        const width = args[j++];
                        const height = args[j++];
                        const xw = x + width;
                        const yh = y + height;
                        d.push("M", pf(x), pf(y), "L", pf(xw), pf(y), "L", pf(xw), pf(yh), "L", pf(x), pf(yh), "Z");
                        break;
                      case _util2.OPS.moveTo:
                        x = args[j++];
                        y = args[j++];
                        d.push("M", pf(x), pf(y));
                        break;
                      case _util2.OPS.lineTo:
                        x = args[j++];
                        y = args[j++];
                        d.push("L", pf(x), pf(y));
                        break;
                      case _util2.OPS.curveTo:
                        x = args[j + 4];
                        y = args[j + 5];
                        d.push("C", pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]), pf(x), pf(y));
                        j += 6;
                        break;
                      case _util2.OPS.curveTo2:
                        d.push("C", pf(x), pf(y), pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]));
                        x = args[j + 2];
                        y = args[j + 3];
                        j += 4;
                        break;
                      case _util2.OPS.curveTo3:
                        x = args[j + 2];
                        y = args[j + 3];
                        d.push("C", pf(args[j]), pf(args[j + 1]), pf(x), pf(y), pf(x), pf(y));
                        j += 4;
                        break;
                      case _util2.OPS.closePath:
                        d.push("Z");
                        break;
                    }
                  }
                  d = d.join(" ");
                  if (current.path && ops.length > 0 && ops[0] !== _util2.OPS.rectangle && ops[0] !== _util2.OPS.moveTo) {
                    d = current.path.getAttributeNS(null, "d") + d;
                  } else {
                    current.path = this.svgFactory.createElement("svg:path");
                    this._ensureTransformGroup().appendChild(current.path);
                  }
                  current.path.setAttributeNS(null, "d", d);
                  current.path.setAttributeNS(null, "fill", "none");
                  current.element = current.path;
                  current.setCurrentPoint(x, y);
                }
                endPath() {
                  const current = this.current;
                  current.path = null;
                  if (!this.pendingClip) {
                    return;
                  }
                  if (!current.element) {
                    this.pendingClip = null;
                    return;
                  }
                  const clipId = `clippath${clipCount++}`;
                  const clipPath = this.svgFactory.createElement("svg:clipPath");
                  clipPath.setAttributeNS(null, "id", clipId);
                  clipPath.setAttributeNS(null, "transform", pm(this.transformMatrix));
                  const clipElement = current.element.cloneNode(true);
                  if (this.pendingClip === "evenodd") {
                    clipElement.setAttributeNS(null, "clip-rule", "evenodd");
                  } else {
                    clipElement.setAttributeNS(null, "clip-rule", "nonzero");
                  }
                  this.pendingClip = null;
                  clipPath.appendChild(clipElement);
                  this.defs.appendChild(clipPath);
                  if (current.activeClipUrl) {
                    current.clipGroup = null;
                    this.extraStack.forEach(function(prev) {
                      prev.clipGroup = null;
                    });
                    clipPath.setAttributeNS(null, "clip-path", current.activeClipUrl);
                  }
                  current.activeClipUrl = `url(#${clipId})`;
                  this.tgrp = null;
                }
                clip(type) {
                  this.pendingClip = type;
                }
                closePath() {
                  const current = this.current;
                  if (current.path) {
                    const d = `${current.path.getAttributeNS(null, "d")}Z`;
                    current.path.setAttributeNS(null, "d", d);
                  }
                }
                setLeading(leading) {
                  this.current.leading = -leading;
                }
                setTextRise(textRise) {
                  this.current.textRise = textRise;
                }
                setTextRenderingMode(textRenderingMode) {
                  this.current.textRenderingMode = textRenderingMode;
                }
                setHScale(scale) {
                  this.current.textHScale = scale / 100;
                }
                setRenderingIntent(intent) {
                }
                setFlatness(flatness) {
                }
                setGState(states) {
                  for (const [key, value] of states) {
                    switch (key) {
                      case "LW":
                        this.setLineWidth(value);
                        break;
                      case "LC":
                        this.setLineCap(value);
                        break;
                      case "LJ":
                        this.setLineJoin(value);
                        break;
                      case "ML":
                        this.setMiterLimit(value);
                        break;
                      case "D":
                        this.setDash(value[0], value[1]);
                        break;
                      case "RI":
                        this.setRenderingIntent(value);
                        break;
                      case "FL":
                        this.setFlatness(value);
                        break;
                      case "Font":
                        this.setFont(value);
                        break;
                      case "CA":
                        this.setStrokeAlpha(value);
                        break;
                      case "ca":
                        this.setFillAlpha(value);
                        break;
                      default:
                        (0, _util2.warn)(`Unimplemented graphic state operator ${key}`);
                        break;
                    }
                  }
                }
                fill() {
                  const current = this.current;
                  if (current.element) {
                    current.element.setAttributeNS(null, "fill", current.fillColor);
                    current.element.setAttributeNS(null, "fill-opacity", current.fillAlpha);
                    this.endPath();
                  }
                }
                stroke() {
                  const current = this.current;
                  if (current.element) {
                    this._setStrokeAttributes(current.element);
                    current.element.setAttributeNS(null, "fill", "none");
                    this.endPath();
                  }
                }
                _setStrokeAttributes(element, lineWidthScale = 1) {
                  const current = this.current;
                  let dashArray = current.dashArray;
                  if (lineWidthScale !== 1 && dashArray.length > 0) {
                    dashArray = dashArray.map(function(value) {
                      return lineWidthScale * value;
                    });
                  }
                  element.setAttributeNS(null, "stroke", current.strokeColor);
                  element.setAttributeNS(null, "stroke-opacity", current.strokeAlpha);
                  element.setAttributeNS(null, "stroke-miterlimit", pf(current.miterLimit));
                  element.setAttributeNS(null, "stroke-linecap", current.lineCap);
                  element.setAttributeNS(null, "stroke-linejoin", current.lineJoin);
                  element.setAttributeNS(null, "stroke-width", pf(lineWidthScale * current.lineWidth) + "px");
                  element.setAttributeNS(null, "stroke-dasharray", dashArray.map(pf).join(" "));
                  element.setAttributeNS(null, "stroke-dashoffset", pf(lineWidthScale * current.dashPhase) + "px");
                }
                eoFill() {
                  if (this.current.element) {
                    this.current.element.setAttributeNS(null, "fill-rule", "evenodd");
                  }
                  this.fill();
                }
                fillStroke() {
                  this.stroke();
                  this.fill();
                }
                eoFillStroke() {
                  if (this.current.element) {
                    this.current.element.setAttributeNS(null, "fill-rule", "evenodd");
                  }
                  this.fillStroke();
                }
                closeStroke() {
                  this.closePath();
                  this.stroke();
                }
                closeFillStroke() {
                  this.closePath();
                  this.fillStroke();
                }
                closeEOFillStroke() {
                  this.closePath();
                  this.eoFillStroke();
                }
                paintSolidColorImageMask() {
                  const rect = this.svgFactory.createElement("svg:rect");
                  rect.setAttributeNS(null, "x", "0");
                  rect.setAttributeNS(null, "y", "0");
                  rect.setAttributeNS(null, "width", "1px");
                  rect.setAttributeNS(null, "height", "1px");
                  rect.setAttributeNS(null, "fill", this.current.fillColor);
                  this._ensureTransformGroup().appendChild(rect);
                }
                paintJpegXObject(objId, w, h) {
                  const imgObj = this.objs.get(objId);
                  const imgEl = this.svgFactory.createElement("svg:image");
                  imgEl.setAttributeNS(XLINK_NS, "xlink:href", imgObj.src);
                  imgEl.setAttributeNS(null, "width", pf(w));
                  imgEl.setAttributeNS(null, "height", pf(h));
                  imgEl.setAttributeNS(null, "x", "0");
                  imgEl.setAttributeNS(null, "y", pf(-h));
                  imgEl.setAttributeNS(null, "transform", `scale(${pf(1 / w)} ${pf(-1 / h)})`);
                  this._ensureTransformGroup().appendChild(imgEl);
                }
                paintImageXObject(objId) {
                  const imgData = this.objs.get(objId);
                  if (!imgData) {
                    (0, _util2.warn)(`Dependent image with object ID ${objId} is not ready yet`);
                    return;
                  }
                  this.paintInlineImageXObject(imgData);
                }
                paintInlineImageXObject(imgData, mask) {
                  const width = imgData.width;
                  const height = imgData.height;
                  const imgSrc = convertImgDataToPng(imgData, this.forceDataSchema, !!mask);
                  const cliprect = this.svgFactory.createElement("svg:rect");
                  cliprect.setAttributeNS(null, "x", "0");
                  cliprect.setAttributeNS(null, "y", "0");
                  cliprect.setAttributeNS(null, "width", pf(width));
                  cliprect.setAttributeNS(null, "height", pf(height));
                  this.current.element = cliprect;
                  this.clip("nonzero");
                  const imgEl = this.svgFactory.createElement("svg:image");
                  imgEl.setAttributeNS(XLINK_NS, "xlink:href", imgSrc);
                  imgEl.setAttributeNS(null, "x", "0");
                  imgEl.setAttributeNS(null, "y", pf(-height));
                  imgEl.setAttributeNS(null, "width", pf(width) + "px");
                  imgEl.setAttributeNS(null, "height", pf(height) + "px");
                  imgEl.setAttributeNS(null, "transform", `scale(${pf(1 / width)} ${pf(-1 / height)})`);
                  if (mask) {
                    mask.appendChild(imgEl);
                  } else {
                    this._ensureTransformGroup().appendChild(imgEl);
                  }
                }
                paintImageMaskXObject(imgData) {
                  const current = this.current;
                  const width = imgData.width;
                  const height = imgData.height;
                  const fillColor = current.fillColor;
                  current.maskId = `mask${maskCount++}`;
                  const mask = this.svgFactory.createElement("svg:mask");
                  mask.setAttributeNS(null, "id", current.maskId);
                  const rect = this.svgFactory.createElement("svg:rect");
                  rect.setAttributeNS(null, "x", "0");
                  rect.setAttributeNS(null, "y", "0");
                  rect.setAttributeNS(null, "width", pf(width));
                  rect.setAttributeNS(null, "height", pf(height));
                  rect.setAttributeNS(null, "fill", fillColor);
                  rect.setAttributeNS(null, "mask", `url(#${current.maskId})`);
                  this.defs.appendChild(mask);
                  this._ensureTransformGroup().appendChild(rect);
                  this.paintInlineImageXObject(imgData, mask);
                }
                paintFormXObjectBegin(matrix, bbox) {
                  if (Array.isArray(matrix) && matrix.length === 6) {
                    this.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
                  }
                  if (bbox) {
                    const width = bbox[2] - bbox[0];
                    const height = bbox[3] - bbox[1];
                    const cliprect = this.svgFactory.createElement("svg:rect");
                    cliprect.setAttributeNS(null, "x", bbox[0]);
                    cliprect.setAttributeNS(null, "y", bbox[1]);
                    cliprect.setAttributeNS(null, "width", pf(width));
                    cliprect.setAttributeNS(null, "height", pf(height));
                    this.current.element = cliprect;
                    this.clip("nonzero");
                    this.endPath();
                  }
                }
                paintFormXObjectEnd() {
                }
                _initialize(viewport) {
                  const svg = this.svgFactory.create(viewport.width, viewport.height);
                  const definitions = this.svgFactory.createElement("svg:defs");
                  svg.appendChild(definitions);
                  this.defs = definitions;
                  const rootGroup = this.svgFactory.createElement("svg:g");
                  rootGroup.setAttributeNS(null, "transform", pm(viewport.transform));
                  svg.appendChild(rootGroup);
                  this.svg = rootGroup;
                  return svg;
                }
                _ensureClipGroup() {
                  if (!this.current.clipGroup) {
                    const clipGroup = this.svgFactory.createElement("svg:g");
                    clipGroup.setAttributeNS(null, "clip-path", this.current.activeClipUrl);
                    this.svg.appendChild(clipGroup);
                    this.current.clipGroup = clipGroup;
                  }
                  return this.current.clipGroup;
                }
                _ensureTransformGroup() {
                  if (!this.tgrp) {
                    this.tgrp = this.svgFactory.createElement("svg:g");
                    this.tgrp.setAttributeNS(null, "transform", pm(this.transformMatrix));
                    if (this.current.activeClipUrl) {
                      this._ensureClipGroup().appendChild(this.tgrp);
                    } else {
                      this.svg.appendChild(this.tgrp);
                    }
                  }
                  return this.tgrp;
                }
              };
            }
          },
          2245: function(__unused_webpack_module2, exports2, __webpack_require__2) {
            "use strict";
            __webpack_require__2(7658);
            __webpack_require__2(3408);
            __webpack_require__2(4590);
            __webpack_require__2(541);
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.renderTextLayer = void 0;
            var _util2 = __webpack_require__2(7484);
            var renderTextLayer = function renderTextLayerClosure() {
              var MAX_TEXT_DIVS_TO_RENDER = 1e5;
              var NonWhitespaceRegexp = /\S/;
              function isAllWhitespace(str) {
                return !NonWhitespaceRegexp.test(str);
              }
              function appendText(task, geom, styles) {
                var textDiv = document.createElement("span");
                var textDivProperties = {
                  angle: 0,
                  canvasWidth: 0,
                  isWhitespace: false,
                  originalTransform: null,
                  paddingBottom: 0,
                  paddingLeft: 0,
                  paddingRight: 0,
                  paddingTop: 0,
                  scale: 1
                };
                task._textDivs.push(textDiv);
                if (isAllWhitespace(geom.str)) {
                  textDivProperties.isWhitespace = true;
                  task._textDivProperties.set(textDiv, textDivProperties);
                  return;
                }
                var tx = _util2.Util.transform(task._viewport.transform, geom.transform);
                var angle = Math.atan2(tx[1], tx[0]);
                var style = styles[geom.fontName];
                if (style.vertical) {
                  angle += Math.PI / 2;
                }
                var fontHeight = Math.sqrt(tx[2] * tx[2] + tx[3] * tx[3]);
                var fontAscent = fontHeight;
                if (style.ascent) {
                  fontAscent = style.ascent * fontAscent;
                } else if (style.descent) {
                  fontAscent = (1 + style.descent) * fontAscent;
                }
                let left, top;
                if (angle === 0) {
                  left = tx[4];
                  top = tx[5] - fontAscent;
                } else {
                  left = tx[4] + fontAscent * Math.sin(angle);
                  top = tx[5] - fontAscent * Math.cos(angle);
                }
                textDiv.style.left = `${left}px`;
                textDiv.style.top = `${top}px`;
                textDiv.style.fontSize = `${fontHeight}px`;
                textDiv.style.fontFamily = style.fontFamily;
                textDiv.textContent = geom.str;
                if (task._fontInspectorEnabled) {
                  textDiv.dataset.fontName = geom.fontName;
                }
                if (angle !== 0) {
                  textDivProperties.angle = angle * (180 / Math.PI);
                }
                if (geom.str.length > 1) {
                  if (style.vertical) {
                    textDivProperties.canvasWidth = geom.height * task._viewport.scale;
                  } else {
                    textDivProperties.canvasWidth = geom.width * task._viewport.scale;
                  }
                }
                task._textDivProperties.set(textDiv, textDivProperties);
                if (task._textContentStream) {
                  task._layoutText(textDiv);
                }
                if (task._enhanceTextSelection) {
                  var angleCos = 1, angleSin = 0;
                  if (angle !== 0) {
                    angleCos = Math.cos(angle);
                    angleSin = Math.sin(angle);
                  }
                  var divWidth = (style.vertical ? geom.height : geom.width) * task._viewport.scale;
                  var divHeight = fontHeight;
                  var m, b;
                  if (angle !== 0) {
                    m = [angleCos, angleSin, -angleSin, angleCos, left, top];
                    b = _util2.Util.getAxialAlignedBoundingBox([0, 0, divWidth, divHeight], m);
                  } else {
                    b = [left, top, left + divWidth, top + divHeight];
                  }
                  task._bounds.push({
                    left: b[0],
                    top: b[1],
                    right: b[2],
                    bottom: b[3],
                    div: textDiv,
                    size: [divWidth, divHeight],
                    m
                  });
                }
              }
              function render(task) {
                if (task._canceled) {
                  return;
                }
                var textDivs = task._textDivs;
                var capability = task._capability;
                var textDivsLength = textDivs.length;
                if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) {
                  task._renderingDone = true;
                  capability.resolve();
                  return;
                }
                if (!task._textContentStream) {
                  for (var i = 0; i < textDivsLength; i++) {
                    task._layoutText(textDivs[i]);
                  }
                }
                task._renderingDone = true;
                capability.resolve();
              }
              function expand(task) {
                var bounds = task._bounds;
                var viewport = task._viewport;
                var expanded = expandBounds(viewport.width, viewport.height, bounds);
                for (var i = 0; i < expanded.length; i++) {
                  var div = bounds[i].div;
                  var divProperties = task._textDivProperties.get(div);
                  if (divProperties.angle === 0) {
                    divProperties.paddingLeft = bounds[i].left - expanded[i].left;
                    divProperties.paddingTop = bounds[i].top - expanded[i].top;
                    divProperties.paddingRight = expanded[i].right - bounds[i].right;
                    divProperties.paddingBottom = expanded[i].bottom - bounds[i].bottom;
                    task._textDivProperties.set(div, divProperties);
                    continue;
                  }
                  var e = expanded[i], b = bounds[i];
                  var m = b.m, c = m[0], s = m[1];
                  var points = [[0, 0], [0, b.size[1]], [b.size[0], 0], b.size];
                  var ts = new Float64Array(64);
                  points.forEach(function(p, i2) {
                    var t = _util2.Util.applyTransform(p, m);
                    ts[i2 + 0] = c && (e.left - t[0]) / c;
                    ts[i2 + 4] = s && (e.top - t[1]) / s;
                    ts[i2 + 8] = c && (e.right - t[0]) / c;
                    ts[i2 + 12] = s && (e.bottom - t[1]) / s;
                    ts[i2 + 16] = s && (e.left - t[0]) / -s;
                    ts[i2 + 20] = c && (e.top - t[1]) / c;
                    ts[i2 + 24] = s && (e.right - t[0]) / -s;
                    ts[i2 + 28] = c && (e.bottom - t[1]) / c;
                    ts[i2 + 32] = c && (e.left - t[0]) / -c;
                    ts[i2 + 36] = s && (e.top - t[1]) / -s;
                    ts[i2 + 40] = c && (e.right - t[0]) / -c;
                    ts[i2 + 44] = s && (e.bottom - t[1]) / -s;
                    ts[i2 + 48] = s && (e.left - t[0]) / s;
                    ts[i2 + 52] = c && (e.top - t[1]) / -c;
                    ts[i2 + 56] = s && (e.right - t[0]) / s;
                    ts[i2 + 60] = c && (e.bottom - t[1]) / -c;
                  });
                  var findPositiveMin = function(ts2, offset, count) {
                    var result = 0;
                    for (var i2 = 0; i2 < count; i2++) {
                      var t = ts2[offset++];
                      if (t > 0) {
                        result = result ? Math.min(t, result) : t;
                      }
                    }
                    return result;
                  };
                  var boxScale = 1 + Math.min(Math.abs(c), Math.abs(s));
                  divProperties.paddingLeft = findPositiveMin(ts, 32, 16) / boxScale;
                  divProperties.paddingTop = findPositiveMin(ts, 48, 16) / boxScale;
                  divProperties.paddingRight = findPositiveMin(ts, 0, 16) / boxScale;
                  divProperties.paddingBottom = findPositiveMin(ts, 16, 16) / boxScale;
                  task._textDivProperties.set(div, divProperties);
                }
              }
              function expandBounds(width, height, boxes) {
                var bounds = boxes.map(function(box, i) {
                  return {
                    x1: box.left,
                    y1: box.top,
                    x2: box.right,
                    y2: box.bottom,
                    index: i,
                    x1New: void 0,
                    x2New: void 0
                  };
                });
                expandBoundsLTR(width, bounds);
                var expanded = new Array(boxes.length);
                bounds.forEach(function(b) {
                  var i = b.index;
                  expanded[i] = {
                    left: b.x1New,
                    top: 0,
                    right: b.x2New,
                    bottom: 0
                  };
                });
                boxes.map(function(box, i) {
                  var e = expanded[i], b = bounds[i];
                  b.x1 = box.top;
                  b.y1 = width - e.right;
                  b.x2 = box.bottom;
                  b.y2 = width - e.left;
                  b.index = i;
                  b.x1New = void 0;
                  b.x2New = void 0;
                });
                expandBoundsLTR(height, bounds);
                bounds.forEach(function(b) {
                  var i = b.index;
                  expanded[i].top = b.x1New;
                  expanded[i].bottom = b.x2New;
                });
                return expanded;
              }
              function expandBoundsLTR(width, bounds) {
                bounds.sort(function(a, b) {
                  return a.x1 - b.x1 || a.index - b.index;
                });
                var fakeBoundary = {
                  x1: -Infinity,
                  y1: -Infinity,
                  x2: 0,
                  y2: Infinity,
                  index: -1,
                  x1New: 0,
                  x2New: 0
                };
                var horizon = [{
                  start: -Infinity,
                  end: Infinity,
                  boundary: fakeBoundary
                }];
                bounds.forEach(function(boundary) {
                  var i = 0;
                  while (i < horizon.length && horizon[i].end <= boundary.y1) {
                    i++;
                  }
                  var j = horizon.length - 1;
                  while (j >= 0 && horizon[j].start >= boundary.y2) {
                    j--;
                  }
                  var horizonPart, affectedBoundary;
                  var q, k, maxXNew = -Infinity;
                  for (q = i; q <= j; q++) {
                    horizonPart = horizon[q];
                    affectedBoundary = horizonPart.boundary;
                    var xNew;
                    if (affectedBoundary.x2 > boundary.x1) {
                      xNew = affectedBoundary.index > boundary.index ? affectedBoundary.x1New : boundary.x1;
                    } else if (affectedBoundary.x2New === void 0) {
                      xNew = (affectedBoundary.x2 + boundary.x1) / 2;
                    } else {
                      xNew = affectedBoundary.x2New;
                    }
                    if (xNew > maxXNew) {
                      maxXNew = xNew;
                    }
                  }
                  boundary.x1New = maxXNew;
                  for (q = i; q <= j; q++) {
                    horizonPart = horizon[q];
                    affectedBoundary = horizonPart.boundary;
                    if (affectedBoundary.x2New === void 0) {
                      if (affectedBoundary.x2 > boundary.x1) {
                        if (affectedBoundary.index > boundary.index) {
                          affectedBoundary.x2New = affectedBoundary.x2;
                        }
                      } else {
                        affectedBoundary.x2New = maxXNew;
                      }
                    } else if (affectedBoundary.x2New > maxXNew) {
                      affectedBoundary.x2New = Math.max(maxXNew, affectedBoundary.x2);
                    }
                  }
                  var changedHorizon = [], lastBoundary = null;
                  for (q = i; q <= j; q++) {
                    horizonPart = horizon[q];
                    affectedBoundary = horizonPart.boundary;
                    var useBoundary = affectedBoundary.x2 > boundary.x2 ? affectedBoundary : boundary;
                    if (lastBoundary === useBoundary) {
                      changedHorizon[changedHorizon.length - 1].end = horizonPart.end;
                    } else {
                      changedHorizon.push({
                        start: horizonPart.start,
                        end: horizonPart.end,
                        boundary: useBoundary
                      });
                      lastBoundary = useBoundary;
                    }
                  }
                  if (horizon[i].start < boundary.y1) {
                    changedHorizon[0].start = boundary.y1;
                    changedHorizon.unshift({
                      start: horizon[i].start,
                      end: boundary.y1,
                      boundary: horizon[i].boundary
                    });
                  }
                  if (boundary.y2 < horizon[j].end) {
                    changedHorizon[changedHorizon.length - 1].end = boundary.y2;
                    changedHorizon.push({
                      start: boundary.y2,
                      end: horizon[j].end,
                      boundary: horizon[j].boundary
                    });
                  }
                  for (q = i; q <= j; q++) {
                    horizonPart = horizon[q];
                    affectedBoundary = horizonPart.boundary;
                    if (affectedBoundary.x2New !== void 0) {
                      continue;
                    }
                    var used = false;
                    for (k = i - 1; !used && k >= 0 && horizon[k].start >= affectedBoundary.y1; k--) {
                      used = horizon[k].boundary === affectedBoundary;
                    }
                    for (k = j + 1; !used && k < horizon.length && horizon[k].end <= affectedBoundary.y2; k++) {
                      used = horizon[k].boundary === affectedBoundary;
                    }
                    for (k = 0; !used && k < changedHorizon.length; k++) {
                      used = changedHorizon[k].boundary === affectedBoundary;
                    }
                    if (!used) {
                      affectedBoundary.x2New = maxXNew;
                    }
                  }
                  Array.prototype.splice.apply(horizon, [i, j - i + 1].concat(changedHorizon));
                });
                horizon.forEach(function(horizonPart) {
                  var affectedBoundary = horizonPart.boundary;
                  if (affectedBoundary.x2New === void 0) {
                    affectedBoundary.x2New = Math.max(width, affectedBoundary.x2);
                  }
                });
              }
              function TextLayerRenderTask({
                textContent,
                textContentStream,
                container,
                viewport,
                textDivs,
                textContentItemsStr,
                enhanceTextSelection
              }) {
                this._textContent = textContent;
                this._textContentStream = textContentStream;
                this._container = container;
                this._viewport = viewport;
                this._textDivs = textDivs || [];
                this._textContentItemsStr = textContentItemsStr || [];
                this._enhanceTextSelection = !!enhanceTextSelection;
                this._fontInspectorEnabled = !!(globalThis.FontInspector && globalThis.FontInspector.enabled);
                this._reader = null;
                this._layoutTextLastFontSize = null;
                this._layoutTextLastFontFamily = null;
                this._layoutTextCtx = null;
                this._textDivProperties = /* @__PURE__ */ new WeakMap();
                this._renderingDone = false;
                this._canceled = false;
                this._capability = (0, _util2.createPromiseCapability)();
                this._renderTimer = null;
                this._bounds = [];
                this._capability.promise.finally(() => {
                  if (this._layoutTextCtx) {
                    this._layoutTextCtx.canvas.width = 0;
                    this._layoutTextCtx.canvas.height = 0;
                    this._layoutTextCtx = null;
                  }
                }).catch(() => {
                });
              }
              TextLayerRenderTask.prototype = {
                get promise() {
                  return this._capability.promise;
                },
                cancel: function TextLayer_cancel() {
                  this._canceled = true;
                  if (this._reader) {
                    this._reader.cancel(new _util2.AbortException("TextLayer task cancelled."));
                    this._reader = null;
                  }
                  if (this._renderTimer !== null) {
                    clearTimeout(this._renderTimer);
                    this._renderTimer = null;
                  }
                  this._capability.reject(new Error("TextLayer task cancelled."));
                },
                _processItems(items, styleCache) {
                  for (let i = 0, len = items.length; i < len; i++) {
                    this._textContentItemsStr.push(items[i].str);
                    appendText(this, items[i], styleCache);
                  }
                },
                _layoutText(textDiv) {
                  const textDivProperties = this._textDivProperties.get(textDiv);
                  if (textDivProperties.isWhitespace) {
                    return;
                  }
                  let transform = "";
                  if (textDivProperties.canvasWidth !== 0) {
                    const {
                      fontSize,
                      fontFamily
                    } = textDiv.style;
                    if (fontSize !== this._layoutTextLastFontSize || fontFamily !== this._layoutTextLastFontFamily) {
                      this._layoutTextCtx.font = `${fontSize} ${fontFamily}`;
                      this._layoutTextLastFontSize = fontSize;
                      this._layoutTextLastFontFamily = fontFamily;
                    }
                    const {
                      width
                    } = this._layoutTextCtx.measureText(textDiv.textContent);
                    if (width > 0) {
                      textDivProperties.scale = textDivProperties.canvasWidth / width;
                      transform = `scaleX(${textDivProperties.scale})`;
                    }
                  }
                  if (textDivProperties.angle !== 0) {
                    transform = `rotate(${textDivProperties.angle}deg) ${transform}`;
                  }
                  if (transform.length > 0) {
                    if (this._enhanceTextSelection) {
                      textDivProperties.originalTransform = transform;
                    }
                    textDiv.style.transform = transform;
                  }
                  this._textDivProperties.set(textDiv, textDivProperties);
                  this._container.appendChild(textDiv);
                },
                _render: function TextLayer_render(timeout) {
                  const capability = (0, _util2.createPromiseCapability)();
                  let styleCache = /* @__PURE__ */ Object.create(null);
                  const canvas = document.createElement("canvas");
                  canvas.mozOpaque = true;
                  this._layoutTextCtx = canvas.getContext("2d", {
                    alpha: false
                  });
                  if (this._textContent) {
                    const textItems = this._textContent.items;
                    const textStyles = this._textContent.styles;
                    this._processItems(textItems, textStyles);
                    capability.resolve();
                  } else if (this._textContentStream) {
                    const pump = () => {
                      this._reader.read().then(({
                        value,
                        done
                      }) => {
                        if (done) {
                          capability.resolve();
                          return;
                        }
                        Object.assign(styleCache, value.styles);
                        this._processItems(value.items, styleCache);
                        pump();
                      }, capability.reject);
                    };
                    this._reader = this._textContentStream.getReader();
                    pump();
                  } else {
                    throw new Error('Neither "textContent" nor "textContentStream" parameters specified.');
                  }
                  capability.promise.then(() => {
                    styleCache = null;
                    if (!timeout) {
                      render(this);
                    } else {
                      this._renderTimer = setTimeout(() => {
                        render(this);
                        this._renderTimer = null;
                      }, timeout);
                    }
                  }, this._capability.reject);
                },
                expandTextDivs: function TextLayer_expandTextDivs(expandDivs) {
                  if (!this._enhanceTextSelection || !this._renderingDone) {
                    return;
                  }
                  if (this._bounds !== null) {
                    expand(this);
                    this._bounds = null;
                  }
                  const transformBuf = [], paddingBuf = [];
                  for (var i = 0, ii = this._textDivs.length; i < ii; i++) {
                    const div = this._textDivs[i];
                    const divProps = this._textDivProperties.get(div);
                    if (divProps.isWhitespace) {
                      continue;
                    }
                    if (expandDivs) {
                      transformBuf.length = 0;
                      paddingBuf.length = 0;
                      if (divProps.originalTransform) {
                        transformBuf.push(divProps.originalTransform);
                      }
                      if (divProps.paddingTop > 0) {
                        paddingBuf.push(`${divProps.paddingTop}px`);
                        transformBuf.push(`translateY(${-divProps.paddingTop}px)`);
                      } else {
                        paddingBuf.push(0);
                      }
                      if (divProps.paddingRight > 0) {
                        paddingBuf.push(`${divProps.paddingRight / divProps.scale}px`);
                      } else {
                        paddingBuf.push(0);
                      }
                      if (divProps.paddingBottom > 0) {
                        paddingBuf.push(`${divProps.paddingBottom}px`);
                      } else {
                        paddingBuf.push(0);
                      }
                      if (divProps.paddingLeft > 0) {
                        paddingBuf.push(`${divProps.paddingLeft / divProps.scale}px`);
                        transformBuf.push(`translateX(${-divProps.paddingLeft / divProps.scale}px)`);
                      } else {
                        paddingBuf.push(0);
                      }
                      div.style.padding = paddingBuf.join(" ");
                      if (transformBuf.length) {
                        div.style.transform = transformBuf.join(" ");
                      }
                    } else {
                      div.style.padding = null;
                      div.style.transform = divProps.originalTransform;
                    }
                  }
                }
              };
              function renderTextLayer2(renderParameters) {
                var task = new TextLayerRenderTask({
                  textContent: renderParameters.textContent,
                  textContentStream: renderParameters.textContentStream,
                  container: renderParameters.container,
                  viewport: renderParameters.viewport,
                  textDivs: renderParameters.textDivs,
                  textContentItemsStr: renderParameters.textContentItemsStr,
                  enhanceTextSelection: renderParameters.enhanceTextSelection
                });
                task._render(renderParameters.timeout);
                return task;
              }
              return renderTextLayer2;
            }();
            exports2.renderTextLayer = renderTextLayer;
          },
          1307: function(__unused_webpack_module2, exports2, __webpack_require__2) {
            "use strict";
            __webpack_require__2(3408);
            __webpack_require__2(4590);
            __webpack_require__2(7658);
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.PDFDataTransportStream = void 0;
            var _util2 = __webpack_require__2(7484);
            class PDFDataTransportStream {
              constructor(params, pdfDataRangeTransport) {
                (0, _util2.assert)(pdfDataRangeTransport);
                this._queuedChunks = [];
                this._progressiveDone = params.progressiveDone || false;
                const initialData = params.initialData;
                if (initialData && initialData.length > 0) {
                  const buffer = new Uint8Array(initialData).buffer;
                  this._queuedChunks.push(buffer);
                }
                this._pdfDataRangeTransport = pdfDataRangeTransport;
                this._isStreamingSupported = !params.disableStream;
                this._isRangeSupported = !params.disableRange;
                this._contentLength = params.length;
                this._fullRequestReader = null;
                this._rangeReaders = [];
                this._pdfDataRangeTransport.addRangeListener((begin, chunk) => {
                  this._onReceiveData({
                    begin,
                    chunk
                  });
                });
                this._pdfDataRangeTransport.addProgressListener((loaded, total) => {
                  this._onProgress({
                    loaded,
                    total
                  });
                });
                this._pdfDataRangeTransport.addProgressiveReadListener((chunk) => {
                  this._onReceiveData({
                    chunk
                  });
                });
                this._pdfDataRangeTransport.addProgressiveDoneListener(() => {
                  this._onProgressiveDone();
                });
                this._pdfDataRangeTransport.transportReady();
              }
              _onReceiveData(args) {
                const buffer = new Uint8Array(args.chunk).buffer;
                if (args.begin === void 0) {
                  if (this._fullRequestReader) {
                    this._fullRequestReader._enqueue(buffer);
                  } else {
                    this._queuedChunks.push(buffer);
                  }
                } else {
                  const found = this._rangeReaders.some(function(rangeReader) {
                    if (rangeReader._begin !== args.begin) {
                      return false;
                    }
                    rangeReader._enqueue(buffer);
                    return true;
                  });
                  (0, _util2.assert)(found);
                }
              }
              get _progressiveDataLength() {
                return this._fullRequestReader ? this._fullRequestReader._loaded : 0;
              }
              _onProgress(evt) {
                if (evt.total === void 0) {
                  const firstReader = this._rangeReaders[0];
                  if (firstReader && firstReader.onProgress) {
                    firstReader.onProgress({
                      loaded: evt.loaded
                    });
                  }
                } else {
                  const fullReader = this._fullRequestReader;
                  if (fullReader && fullReader.onProgress) {
                    fullReader.onProgress({
                      loaded: evt.loaded,
                      total: evt.total
                    });
                  }
                }
              }
              _onProgressiveDone() {
                if (this._fullRequestReader) {
                  this._fullRequestReader.progressiveDone();
                }
                this._progressiveDone = true;
              }
              _removeRangeReader(reader) {
                const i = this._rangeReaders.indexOf(reader);
                if (i >= 0) {
                  this._rangeReaders.splice(i, 1);
                }
              }
              getFullReader() {
                (0, _util2.assert)(!this._fullRequestReader);
                const queuedChunks = this._queuedChunks;
                this._queuedChunks = null;
                return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone);
              }
              getRangeReader(begin, end) {
                if (end <= this._progressiveDataLength) {
                  return null;
                }
                const reader = new PDFDataTransportStreamRangeReader(this, begin, end);
                this._pdfDataRangeTransport.requestDataRange(begin, end);
                this._rangeReaders.push(reader);
                return reader;
              }
              cancelAllRequests(reason) {
                if (this._fullRequestReader) {
                  this._fullRequestReader.cancel(reason);
                }
                const readers = this._rangeReaders.slice(0);
                readers.forEach(function(rangeReader) {
                  rangeReader.cancel(reason);
                });
                this._pdfDataRangeTransport.abort();
              }
            }
            exports2.PDFDataTransportStream = PDFDataTransportStream;
            class PDFDataTransportStreamReader {
              constructor(stream, queuedChunks, progressiveDone = false) {
                this._stream = stream;
                this._done = progressiveDone || false;
                this._filename = null;
                this._queuedChunks = queuedChunks || [];
                this._loaded = 0;
                for (const chunk of this._queuedChunks) {
                  this._loaded += chunk.byteLength;
                }
                this._requests = [];
                this._headersReady = Promise.resolve();
                stream._fullRequestReader = this;
                this.onProgress = null;
              }
              _enqueue(chunk) {
                if (this._done) {
                  return;
                }
                if (this._requests.length > 0) {
                  const requestCapability = this._requests.shift();
                  requestCapability.resolve({
                    value: chunk,
                    done: false
                  });
                } else {
                  this._queuedChunks.push(chunk);
                }
                this._loaded += chunk.byteLength;
              }
              get headersReady() {
                return this._headersReady;
              }
              get filename() {
                return this._filename;
              }
              get isRangeSupported() {
                return this._stream._isRangeSupported;
              }
              get isStreamingSupported() {
                return this._stream._isStreamingSupported;
              }
              get contentLength() {
                return this._stream._contentLength;
              }
              async read() {
                if (this._queuedChunks.length > 0) {
                  const chunk = this._queuedChunks.shift();
                  return {
                    value: chunk,
                    done: false
                  };
                }
                if (this._done) {
                  return {
                    value: void 0,
                    done: true
                  };
                }
                const requestCapability = (0, _util2.createPromiseCapability)();
                this._requests.push(requestCapability);
                return requestCapability.promise;
              }
              cancel(reason) {
                this._done = true;
                this._requests.forEach(function(requestCapability) {
                  requestCapability.resolve({
                    value: void 0,
                    done: true
                  });
                });
                this._requests = [];
              }
              progressiveDone() {
                if (this._done) {
                  return;
                }
                this._done = true;
              }
            }
            class PDFDataTransportStreamRangeReader {
              constructor(stream, begin, end) {
                this._stream = stream;
                this._begin = begin;
                this._end = end;
                this._queuedChunk = null;
                this._requests = [];
                this._done = false;
                this.onProgress = null;
              }
              _enqueue(chunk) {
                if (this._done) {
                  return;
                }
                if (this._requests.length === 0) {
                  this._queuedChunk = chunk;
                } else {
                  const requestsCapability = this._requests.shift();
                  requestsCapability.resolve({
                    value: chunk,
                    done: false
                  });
                  this._requests.forEach(function(requestCapability) {
                    requestCapability.resolve({
                      value: void 0,
                      done: true
                    });
                  });
                  this._requests = [];
                }
                this._done = true;
                this._stream._removeRangeReader(this);
              }
              get isStreamingSupported() {
                return false;
              }
              async read() {
                if (this._queuedChunk) {
                  const chunk = this._queuedChunk;
                  this._queuedChunk = null;
                  return {
                    value: chunk,
                    done: false
                  };
                }
                if (this._done) {
                  return {
                    value: void 0,
                    done: true
                  };
                }
                const requestCapability = (0, _util2.createPromiseCapability)();
                this._requests.push(requestCapability);
                return requestCapability.promise;
              }
              cancel(reason) {
                this._done = true;
                this._requests.forEach(function(requestCapability) {
                  requestCapability.resolve({
                    value: void 0,
                    done: true
                  });
                });
                this._requests = [];
                this._stream._removeRangeReader(this);
              }
            }
          },
          4708: function(__unused_webpack_module2, exports2, __webpack_require__2) {
            "use strict";
            __webpack_require__2(3408);
            __webpack_require__2(4590);
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.WebGLContext = void 0;
            var _util2 = __webpack_require__2(7484);
            class WebGLContext {
              constructor({
                enable = false
              }) {
                this._enabled = enable === true;
              }
              get isEnabled() {
                let enabled = this._enabled;
                if (enabled) {
                  enabled = WebGLUtils.tryInitGL();
                }
                return (0, _util2.shadow)(this, "isEnabled", enabled);
              }
              composeSMask({
                layer,
                mask,
                properties
              }) {
                return WebGLUtils.composeSMask(layer, mask, properties);
              }
              drawFigures({
                width,
                height,
                backgroundColor,
                figures,
                context
              }) {
                return WebGLUtils.drawFigures(width, height, backgroundColor, figures, context);
              }
              clear() {
                WebGLUtils.cleanup();
              }
            }
            exports2.WebGLContext = WebGLContext;
            var WebGLUtils = function WebGLUtilsClosure() {
              function loadShader(gl, code, shaderType) {
                var shader = gl.createShader(shaderType);
                gl.shaderSource(shader, code);
                gl.compileShader(shader);
                var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
                if (!compiled) {
                  var errorMsg = gl.getShaderInfoLog(shader);
                  throw new Error("Error during shader compilation: " + errorMsg);
                }
                return shader;
              }
              function createVertexShader(gl, code) {
                return loadShader(gl, code, gl.VERTEX_SHADER);
              }
              function createFragmentShader(gl, code) {
                return loadShader(gl, code, gl.FRAGMENT_SHADER);
              }
              function createProgram(gl, shaders) {
                var program = gl.createProgram();
                for (var i = 0, ii = shaders.length; i < ii; ++i) {
                  gl.attachShader(program, shaders[i]);
                }
                gl.linkProgram(program);
                var linked = gl.getProgramParameter(program, gl.LINK_STATUS);
                if (!linked) {
                  var errorMsg = gl.getProgramInfoLog(program);
                  throw new Error("Error during program linking: " + errorMsg);
                }
                return program;
              }
              function createTexture(gl, image, textureId) {
                gl.activeTexture(textureId);
                var texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
                return texture;
              }
              var currentGL, currentCanvas;
              function generateGL() {
                if (currentGL) {
                  return;
                }
                currentCanvas = document.createElement("canvas");
                currentGL = currentCanvas.getContext("webgl", {
                  premultipliedalpha: false
                });
              }
              var smaskVertexShaderCode = "  attribute vec2 a_position;                                      attribute vec2 a_texCoord;                                                                                                      uniform vec2 u_resolution;                                                                                                      varying vec2 v_texCoord;                                                                                                        void main() {                                                     vec2 clipSpace = (a_position / u_resolution) * 2.0 - 1.0;       gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);                                                                              v_texCoord = a_texCoord;                                      }                                                             ";
              var smaskFragmentShaderCode = "  precision mediump float;                                                                                                        uniform vec4 u_backdrop;                                        uniform int u_subtype;                                          uniform sampler2D u_image;                                      uniform sampler2D u_mask;                                                                                                       varying vec2 v_texCoord;                                                                                                        void main() {                                                     vec4 imageColor = texture2D(u_image, v_texCoord);               vec4 maskColor = texture2D(u_mask, v_texCoord);                 if (u_backdrop.a > 0.0) {                                         maskColor.rgb = maskColor.rgb * maskColor.a +                                   u_backdrop.rgb * (1.0 - maskColor.a);         }                                                               float lum;                                                      if (u_subtype == 0) {                                             lum = maskColor.a;                                            } else {                                                          lum = maskColor.r * 0.3 + maskColor.g * 0.59 +                        maskColor.b * 0.11;                                     }                                                               imageColor.a *= lum;                                            imageColor.rgb *= imageColor.a;                                 gl_FragColor = imageColor;                                    }                                                             ";
              var smaskCache = null;
              function initSmaskGL() {
                var canvas, gl;
                generateGL();
                canvas = currentCanvas;
                currentCanvas = null;
                gl = currentGL;
                currentGL = null;
                var vertexShader = createVertexShader(gl, smaskVertexShaderCode);
                var fragmentShader = createFragmentShader(gl, smaskFragmentShaderCode);
                var program = createProgram(gl, [vertexShader, fragmentShader]);
                gl.useProgram(program);
                var cache = {};
                cache.gl = gl;
                cache.canvas = canvas;
                cache.resolutionLocation = gl.getUniformLocation(program, "u_resolution");
                cache.positionLocation = gl.getAttribLocation(program, "a_position");
                cache.backdropLocation = gl.getUniformLocation(program, "u_backdrop");
                cache.subtypeLocation = gl.getUniformLocation(program, "u_subtype");
                var texCoordLocation = gl.getAttribLocation(program, "a_texCoord");
                var texLayerLocation = gl.getUniformLocation(program, "u_image");
                var texMaskLocation = gl.getUniformLocation(program, "u_mask");
                var texCoordBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1]), gl.STATIC_DRAW);
                gl.enableVertexAttribArray(texCoordLocation);
                gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);
                gl.uniform1i(texLayerLocation, 0);
                gl.uniform1i(texMaskLocation, 1);
                smaskCache = cache;
              }
              function composeSMask(layer, mask, properties) {
                var width = layer.width, height = layer.height;
                if (!smaskCache) {
                  initSmaskGL();
                }
                var cache = smaskCache, canvas = cache.canvas, gl = cache.gl;
                canvas.width = width;
                canvas.height = height;
                gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
                gl.uniform2f(cache.resolutionLocation, width, height);
                if (properties.backdrop) {
                  gl.uniform4f(cache.resolutionLocation, properties.backdrop[0], properties.backdrop[1], properties.backdrop[2], 1);
                } else {
                  gl.uniform4f(cache.resolutionLocation, 0, 0, 0, 0);
                }
                gl.uniform1i(cache.subtypeLocation, properties.subtype === "Luminosity" ? 1 : 0);
                var texture = createTexture(gl, layer, gl.TEXTURE0);
                var maskTexture = createTexture(gl, mask, gl.TEXTURE1);
                var buffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, width, 0, 0, height, 0, height, width, 0, width, height]), gl.STATIC_DRAW);
                gl.enableVertexAttribArray(cache.positionLocation);
                gl.vertexAttribPointer(cache.positionLocation, 2, gl.FLOAT, false, 0, 0);
                gl.clearColor(0, 0, 0, 0);
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                gl.flush();
                gl.deleteTexture(texture);
                gl.deleteTexture(maskTexture);
                gl.deleteBuffer(buffer);
                return canvas;
              }
              var figuresVertexShaderCode = "  attribute vec2 a_position;                                      attribute vec3 a_color;                                                                                                         uniform vec2 u_resolution;                                      uniform vec2 u_scale;                                           uniform vec2 u_offset;                                                                                                          varying vec4 v_color;                                                                                                           void main() {                                                     vec2 position = (a_position + u_offset) * u_scale;              vec2 clipSpace = (position / u_resolution) * 2.0 - 1.0;         gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);                                                                              v_color = vec4(a_color / 255.0, 1.0);                         }                                                             ";
              var figuresFragmentShaderCode = "  precision mediump float;                                                                                                        varying vec4 v_color;                                                                                                           void main() {                                                     gl_FragColor = v_color;                                       }                                                             ";
              var figuresCache = null;
              function initFiguresGL() {
                var canvas, gl;
                generateGL();
                canvas = currentCanvas;
                currentCanvas = null;
                gl = currentGL;
                currentGL = null;
                var vertexShader = createVertexShader(gl, figuresVertexShaderCode);
                var fragmentShader = createFragmentShader(gl, figuresFragmentShaderCode);
                var program = createProgram(gl, [vertexShader, fragmentShader]);
                gl.useProgram(program);
                var cache = {};
                cache.gl = gl;
                cache.canvas = canvas;
                cache.resolutionLocation = gl.getUniformLocation(program, "u_resolution");
                cache.scaleLocation = gl.getUniformLocation(program, "u_scale");
                cache.offsetLocation = gl.getUniformLocation(program, "u_offset");
                cache.positionLocation = gl.getAttribLocation(program, "a_position");
                cache.colorLocation = gl.getAttribLocation(program, "a_color");
                figuresCache = cache;
              }
              function drawFigures(width, height, backgroundColor, figures, context) {
                if (!figuresCache) {
                  initFiguresGL();
                }
                var cache = figuresCache, canvas = cache.canvas, gl = cache.gl;
                canvas.width = width;
                canvas.height = height;
                gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
                gl.uniform2f(cache.resolutionLocation, width, height);
                var count = 0;
                var i, ii, rows;
                for (i = 0, ii = figures.length; i < ii; i++) {
                  switch (figures[i].type) {
                    case "lattice":
                      rows = figures[i].coords.length / figures[i].verticesPerRow | 0;
                      count += (rows - 1) * (figures[i].verticesPerRow - 1) * 6;
                      break;
                    case "triangles":
                      count += figures[i].coords.length;
                      break;
                  }
                }
                var coords = new Float32Array(count * 2);
                var colors = new Uint8Array(count * 3);
                var coordsMap = context.coords, colorsMap = context.colors;
                var pIndex = 0, cIndex = 0;
                for (i = 0, ii = figures.length; i < ii; i++) {
                  var figure = figures[i], ps = figure.coords, cs = figure.colors;
                  switch (figure.type) {
                    case "lattice":
                      var cols = figure.verticesPerRow;
                      rows = ps.length / cols | 0;
                      for (var row = 1; row < rows; row++) {
                        var offset = row * cols + 1;
                        for (var col = 1; col < cols; col++, offset++) {
                          coords[pIndex] = coordsMap[ps[offset - cols - 1]];
                          coords[pIndex + 1] = coordsMap[ps[offset - cols - 1] + 1];
                          coords[pIndex + 2] = coordsMap[ps[offset - cols]];
                          coords[pIndex + 3] = coordsMap[ps[offset - cols] + 1];
                          coords[pIndex + 4] = coordsMap[ps[offset - 1]];
                          coords[pIndex + 5] = coordsMap[ps[offset - 1] + 1];
                          colors[cIndex] = colorsMap[cs[offset - cols - 1]];
                          colors[cIndex + 1] = colorsMap[cs[offset - cols - 1] + 1];
                          colors[cIndex + 2] = colorsMap[cs[offset - cols - 1] + 2];
                          colors[cIndex + 3] = colorsMap[cs[offset - cols]];
                          colors[cIndex + 4] = colorsMap[cs[offset - cols] + 1];
                          colors[cIndex + 5] = colorsMap[cs[offset - cols] + 2];
                          colors[cIndex + 6] = colorsMap[cs[offset - 1]];
                          colors[cIndex + 7] = colorsMap[cs[offset - 1] + 1];
                          colors[cIndex + 8] = colorsMap[cs[offset - 1] + 2];
                          coords[pIndex + 6] = coords[pIndex + 2];
                          coords[pIndex + 7] = coords[pIndex + 3];
                          coords[pIndex + 8] = coords[pIndex + 4];
                          coords[pIndex + 9] = coords[pIndex + 5];
                          coords[pIndex + 10] = coordsMap[ps[offset]];
                          coords[pIndex + 11] = coordsMap[ps[offset] + 1];
                          colors[cIndex + 9] = colors[cIndex + 3];
                          colors[cIndex + 10] = colors[cIndex + 4];
                          colors[cIndex + 11] = colors[cIndex + 5];
                          colors[cIndex + 12] = colors[cIndex + 6];
                          colors[cIndex + 13] = colors[cIndex + 7];
                          colors[cIndex + 14] = colors[cIndex + 8];
                          colors[cIndex + 15] = colorsMap[cs[offset]];
                          colors[cIndex + 16] = colorsMap[cs[offset] + 1];
                          colors[cIndex + 17] = colorsMap[cs[offset] + 2];
                          pIndex += 12;
                          cIndex += 18;
                        }
                      }
                      break;
                    case "triangles":
                      for (var j = 0, jj = ps.length; j < jj; j++) {
                        coords[pIndex] = coordsMap[ps[j]];
                        coords[pIndex + 1] = coordsMap[ps[j] + 1];
                        colors[cIndex] = colorsMap[cs[j]];
                        colors[cIndex + 1] = colorsMap[cs[j] + 1];
                        colors[cIndex + 2] = colorsMap[cs[j] + 2];
                        pIndex += 2;
                        cIndex += 3;
                      }
                      break;
                  }
                }
                if (backgroundColor) {
                  gl.clearColor(backgroundColor[0] / 255, backgroundColor[1] / 255, backgroundColor[2] / 255, 1);
                } else {
                  gl.clearColor(0, 0, 0, 0);
                }
                gl.clear(gl.COLOR_BUFFER_BIT);
                var coordsBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, coordsBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, coords, gl.STATIC_DRAW);
                gl.enableVertexAttribArray(cache.positionLocation);
                gl.vertexAttribPointer(cache.positionLocation, 2, gl.FLOAT, false, 0, 0);
                var colorsBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, colorsBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
                gl.enableVertexAttribArray(cache.colorLocation);
                gl.vertexAttribPointer(cache.colorLocation, 3, gl.UNSIGNED_BYTE, false, 0, 0);
                gl.uniform2f(cache.scaleLocation, context.scaleX, context.scaleY);
                gl.uniform2f(cache.offsetLocation, context.offsetX, context.offsetY);
                gl.drawArrays(gl.TRIANGLES, 0, count);
                gl.flush();
                gl.deleteBuffer(coordsBuffer);
                gl.deleteBuffer(colorsBuffer);
                return canvas;
              }
              return {
                tryInitGL() {
                  try {
                    generateGL();
                    return !!currentGL;
                  } catch (ex) {
                  }
                  return false;
                },
                composeSMask,
                drawFigures,
                cleanup() {
                  if (smaskCache && smaskCache.canvas) {
                    smaskCache.canvas.width = 0;
                    smaskCache.canvas.height = 0;
                  }
                  if (figuresCache && figuresCache.canvas) {
                    figuresCache.canvas.width = 0;
                    figuresCache.canvas.height = 0;
                  }
                  smaskCache = null;
                  figuresCache = null;
                }
              };
            }();
          },
          5864: function(__unused_webpack_module2, exports2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.GlobalWorkerOptions = void 0;
            const GlobalWorkerOptions = /* @__PURE__ */ Object.create(null);
            exports2.GlobalWorkerOptions = GlobalWorkerOptions;
            GlobalWorkerOptions.workerPort = GlobalWorkerOptions.workerPort === void 0 ? null : GlobalWorkerOptions.workerPort;
            GlobalWorkerOptions.workerSrc = GlobalWorkerOptions.workerSrc === void 0 ? "" : GlobalWorkerOptions.workerSrc;
          },
          8635: function(__unused_webpack_module2, exports2, __webpack_require__2) {
            "use strict";
            __webpack_require__2(7658);
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.SimpleXMLParser = void 0;
            const XMLParserErrorCode = {
              NoError: 0,
              EndOfDocument: -1,
              UnterminatedCdat: -2,
              UnterminatedXmlDeclaration: -3,
              UnterminatedDoctypeDeclaration: -4,
              UnterminatedComment: -5,
              MalformedElement: -6,
              OutOfMemory: -7,
              UnterminatedAttributeValue: -8,
              UnterminatedElement: -9,
              ElementNeverBegun: -10
            };
            function isWhitespace(s, index) {
              const ch = s[index];
              return ch === " " || ch === "\n" || ch === "\r" || ch === "	";
            }
            function isWhitespaceString(s) {
              for (let i = 0, ii = s.length; i < ii; i++) {
                if (!isWhitespace(s, i)) {
                  return false;
                }
              }
              return true;
            }
            class XMLParserBase {
              _resolveEntities(s) {
                return s.replace(/&([^;]+);/g, (all, entity) => {
                  if (entity.substring(0, 2) === "#x") {
                    return String.fromCharCode(parseInt(entity.substring(2), 16));
                  } else if (entity.substring(0, 1) === "#") {
                    return String.fromCharCode(parseInt(entity.substring(1), 10));
                  }
                  switch (entity) {
                    case "lt":
                      return "<";
                    case "gt":
                      return ">";
                    case "amp":
                      return "&";
                    case "quot":
                      return '"';
                  }
                  return this.onResolveEntity(entity);
                });
              }
              _parseContent(s, start) {
                const attributes = [];
                let pos = start;
                function skipWs() {
                  while (pos < s.length && isWhitespace(s, pos)) {
                    ++pos;
                  }
                }
                while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== ">" && s[pos] !== "/") {
                  ++pos;
                }
                const name = s.substring(start, pos);
                skipWs();
                while (pos < s.length && s[pos] !== ">" && s[pos] !== "/" && s[pos] !== "?") {
                  skipWs();
                  let attrName = "", attrValue = "";
                  while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== "=") {
                    attrName += s[pos];
                    ++pos;
                  }
                  skipWs();
                  if (s[pos] !== "=") {
                    return null;
                  }
                  ++pos;
                  skipWs();
                  const attrEndChar = s[pos];
                  if (attrEndChar !== '"' && attrEndChar !== "'") {
                    return null;
                  }
                  const attrEndIndex = s.indexOf(attrEndChar, ++pos);
                  if (attrEndIndex < 0) {
                    return null;
                  }
                  attrValue = s.substring(pos, attrEndIndex);
                  attributes.push({
                    name: attrName,
                    value: this._resolveEntities(attrValue)
                  });
                  pos = attrEndIndex + 1;
                  skipWs();
                }
                return {
                  name,
                  attributes,
                  parsed: pos - start
                };
              }
              _parseProcessingInstruction(s, start) {
                let pos = start;
                function skipWs() {
                  while (pos < s.length && isWhitespace(s, pos)) {
                    ++pos;
                  }
                }
                while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== ">" && s[pos] !== "/") {
                  ++pos;
                }
                const name = s.substring(start, pos);
                skipWs();
                const attrStart = pos;
                while (pos < s.length && (s[pos] !== "?" || s[pos + 1] !== ">")) {
                  ++pos;
                }
                const value = s.substring(attrStart, pos);
                return {
                  name,
                  value,
                  parsed: pos - start
                };
              }
              parseXml(s) {
                let i = 0;
                while (i < s.length) {
                  const ch = s[i];
                  let j = i;
                  if (ch === "<") {
                    ++j;
                    const ch2 = s[j];
                    let q;
                    switch (ch2) {
                      case "/":
                        ++j;
                        q = s.indexOf(">", j);
                        if (q < 0) {
                          this.onError(XMLParserErrorCode.UnterminatedElement);
                          return;
                        }
                        this.onEndElement(s.substring(j, q));
                        j = q + 1;
                        break;
                      case "?":
                        ++j;
                        const pi = this._parseProcessingInstruction(s, j);
                        if (s.substring(j + pi.parsed, j + pi.parsed + 2) !== "?>") {
                          this.onError(XMLParserErrorCode.UnterminatedXmlDeclaration);
                          return;
                        }
                        this.onPi(pi.name, pi.value);
                        j += pi.parsed + 2;
                        break;
                      case "!":
                        if (s.substring(j + 1, j + 3) === "--") {
                          q = s.indexOf("-->", j + 3);
                          if (q < 0) {
                            this.onError(XMLParserErrorCode.UnterminatedComment);
                            return;
                          }
                          this.onComment(s.substring(j + 3, q));
                          j = q + 3;
                        } else if (s.substring(j + 1, j + 8) === "[CDATA[") {
                          q = s.indexOf("]]>", j + 8);
                          if (q < 0) {
                            this.onError(XMLParserErrorCode.UnterminatedCdat);
                            return;
                          }
                          this.onCdata(s.substring(j + 8, q));
                          j = q + 3;
                        } else if (s.substring(j + 1, j + 8) === "DOCTYPE") {
                          const q2 = s.indexOf("[", j + 8);
                          let complexDoctype = false;
                          q = s.indexOf(">", j + 8);
                          if (q < 0) {
                            this.onError(XMLParserErrorCode.UnterminatedDoctypeDeclaration);
                            return;
                          }
                          if (q2 > 0 && q > q2) {
                            q = s.indexOf("]>", j + 8);
                            if (q < 0) {
                              this.onError(XMLParserErrorCode.UnterminatedDoctypeDeclaration);
                              return;
                            }
                            complexDoctype = true;
                          }
                          const doctypeContent = s.substring(j + 8, q + (complexDoctype ? 1 : 0));
                          this.onDoctype(doctypeContent);
                          j = q + (complexDoctype ? 2 : 1);
                        } else {
                          this.onError(XMLParserErrorCode.MalformedElement);
                          return;
                        }
                        break;
                      default:
                        const content = this._parseContent(s, j);
                        if (content === null) {
                          this.onError(XMLParserErrorCode.MalformedElement);
                          return;
                        }
                        let isClosed = false;
                        if (s.substring(j + content.parsed, j + content.parsed + 2) === "/>") {
                          isClosed = true;
                        } else if (s.substring(j + content.parsed, j + content.parsed + 1) !== ">") {
                          this.onError(XMLParserErrorCode.UnterminatedElement);
                          return;
                        }
                        this.onBeginElement(content.name, content.attributes, isClosed);
                        j += content.parsed + (isClosed ? 2 : 1);
                        break;
                    }
                  } else {
                    while (j < s.length && s[j] !== "<") {
                      j++;
                    }
                    const text = s.substring(i, j);
                    this.onText(this._resolveEntities(text));
                  }
                  i = j;
                }
              }
              onResolveEntity(name) {
                return `&${name};`;
              }
              onPi(name, value) {
              }
              onComment(text) {
              }
              onCdata(text) {
              }
              onDoctype(doctypeContent) {
              }
              onText(text) {
              }
              onBeginElement(name, attributes, isEmpty) {
              }
              onEndElement(name) {
              }
              onError(code) {
              }
            }
            class SimpleDOMNode {
              constructor(nodeName, nodeValue) {
                this.nodeName = nodeName;
                this.nodeValue = nodeValue;
                Object.defineProperty(this, "parentNode", {
                  value: null,
                  writable: true
                });
              }
              get firstChild() {
                return this.childNodes && this.childNodes[0];
              }
              get nextSibling() {
                const childNodes = this.parentNode.childNodes;
                if (!childNodes) {
                  return void 0;
                }
                const index = childNodes.indexOf(this);
                if (index === -1) {
                  return void 0;
                }
                return childNodes[index + 1];
              }
              get textContent() {
                if (!this.childNodes) {
                  return this.nodeValue || "";
                }
                return this.childNodes.map(function(child) {
                  return child.textContent;
                }).join("");
              }
              hasChildNodes() {
                return this.childNodes && this.childNodes.length > 0;
              }
            }
            class SimpleXMLParser extends XMLParserBase {
              constructor() {
                super();
                this._currentFragment = null;
                this._stack = null;
                this._errorCode = XMLParserErrorCode.NoError;
              }
              parseFromString(data) {
                this._currentFragment = [];
                this._stack = [];
                this._errorCode = XMLParserErrorCode.NoError;
                this.parseXml(data);
                if (this._errorCode !== XMLParserErrorCode.NoError) {
                  return void 0;
                }
                const [documentElement] = this._currentFragment;
                if (!documentElement) {
                  return void 0;
                }
                return {
                  documentElement
                };
              }
              onResolveEntity(name) {
                switch (name) {
                  case "apos":
                    return "'";
                }
                return super.onResolveEntity(name);
              }
              onText(text) {
                if (isWhitespaceString(text)) {
                  return;
                }
                const node = new SimpleDOMNode("#text", text);
                this._currentFragment.push(node);
              }
              onCdata(text) {
                const node = new SimpleDOMNode("#text", text);
                this._currentFragment.push(node);
              }
              onBeginElement(name, attributes, isEmpty) {
                const node = new SimpleDOMNode(name);
                node.childNodes = [];
                this._currentFragment.push(node);
                if (isEmpty) {
                  return;
                }
                this._stack.push(this._currentFragment);
                this._currentFragment = node.childNodes;
              }
              onEndElement(name) {
                this._currentFragment = this._stack.pop() || [];
                const lastElement = this._currentFragment[this._currentFragment.length - 1];
                if (!lastElement) {
                  return;
                }
                for (let i = 0, ii = lastElement.childNodes.length; i < ii; i++) {
                  lastElement.childNodes[i].parentNode = lastElement;
                }
              }
              onError(code) {
                this._errorCode = code;
              }
            }
            exports2.SimpleXMLParser = SimpleXMLParser;
          },
          9490: function() {
            "use strict";
            document.webL10n = function(window2, document2, undefined2) {
              var gL10nData = {};
              var gTextData = "";
              var gTextProp = "textContent";
              var gLanguage = "";
              var gMacros = {};
              var gReadyState = "loading";
              var gAsyncResourceLoading = true;
              function getL10nResourceLinks() {
                return document2.querySelectorAll('link[type="application/l10n"]');
              }
              function getL10nDictionary() {
                var script = document2.querySelector('script[type="application/l10n"]');
                return script ? JSON.parse(script.innerHTML) : null;
              }
              function getTranslatableChildren(element) {
                return element ? element.querySelectorAll("*[data-l10n-id]") : [];
              }
              function getL10nAttributes(element) {
                if (!element)
                  return {};
                var l10nId = element.getAttribute("data-l10n-id");
                var l10nArgs = element.getAttribute("data-l10n-args");
                var args = {};
                if (l10nArgs) {
                  try {
                    args = JSON.parse(l10nArgs);
                  } catch (e) {
                    console.warn("could not parse arguments for #" + l10nId);
                  }
                }
                return {
                  id: l10nId,
                  args
                };
              }
              function xhrLoadText(url, onSuccess, onFailure) {
                onSuccess = onSuccess || function _onSuccess(data) {
                };
                onFailure = onFailure || function _onFailure() {
                };
                var xhr = new XMLHttpRequest();
                xhr.open("GET", url, gAsyncResourceLoading);
                if (xhr.overrideMimeType) {
                  xhr.overrideMimeType("text/plain; charset=utf-8");
                }
                xhr.onreadystatechange = function() {
                  if (xhr.readyState == 4) {
                    if (xhr.status == 200 || xhr.status === 0) {
                      onSuccess(xhr.responseText);
                    } else {
                      onFailure();
                    }
                  }
                };
                xhr.onerror = onFailure;
                xhr.ontimeout = onFailure;
                try {
                  xhr.send(null);
                } catch (e) {
                  onFailure();
                }
              }
              function parseResource(href, lang, successCallback, failureCallback) {
                var baseURL = href.replace(/[^\/]*$/, "") || "./";
                function evalString(text) {
                  if (text.lastIndexOf("\\") < 0)
                    return text;
                  return text.replace(/\\\\/g, "\\").replace(/\\n/g, "\n").replace(/\\r/g, "\r").replace(/\\t/g, "	").replace(/\\b/g, "\b").replace(/\\f/g, "\f").replace(/\\{/g, "{").replace(/\\}/g, "}").replace(/\\"/g, '"').replace(/\\'/g, "'");
                }
                function parseProperties(text, parsedPropertiesCallback) {
                  var dictionary = {};
                  var reBlank = /^\s*|\s*$/;
                  var reComment = /^\s*#|^\s*$/;
                  var reSection = /^\s*\[(.*)\]\s*$/;
                  var reImport = /^\s*@import\s+url\((.*)\)\s*$/i;
                  var reSplit = /^([^=\s]*)\s*=\s*(.+)$/;
                  function parseRawLines(rawText, extendedSyntax, parsedRawLinesCallback) {
                    var entries = rawText.replace(reBlank, "").split(/[\r\n]+/);
                    var currentLang = "*";
                    var genericLang = lang.split("-", 1)[0];
                    var skipLang = false;
                    var match = "";
                    function nextEntry() {
                      while (true) {
                        if (!entries.length) {
                          parsedRawLinesCallback();
                          return;
                        }
                        var line = entries.shift();
                        if (reComment.test(line))
                          continue;
                        if (extendedSyntax) {
                          match = reSection.exec(line);
                          if (match) {
                            currentLang = match[1].toLowerCase();
                            skipLang = currentLang !== "*" && currentLang !== lang && currentLang !== genericLang;
                            continue;
                          } else if (skipLang) {
                            continue;
                          }
                          match = reImport.exec(line);
                          if (match) {
                            loadImport(baseURL + match[1], nextEntry);
                            return;
                          }
                        }
                        var tmp = line.match(reSplit);
                        if (tmp && tmp.length == 3) {
                          dictionary[tmp[1]] = evalString(tmp[2]);
                        }
                      }
                    }
                    nextEntry();
                  }
                  function loadImport(url, callback) {
                    xhrLoadText(url, function(content) {
                      parseRawLines(content, false, callback);
                    }, function() {
                      console.warn(url + " not found.");
                      callback();
                    });
                  }
                  parseRawLines(text, true, function() {
                    parsedPropertiesCallback(dictionary);
                  });
                }
                xhrLoadText(href, function(response) {
                  gTextData += response;
                  parseProperties(response, function(data) {
                    for (var key in data) {
                      var id, prop, index = key.lastIndexOf(".");
                      if (index > 0) {
                        id = key.substring(0, index);
                        prop = key.substring(index + 1);
                      } else {
                        id = key;
                        prop = gTextProp;
                      }
                      if (!gL10nData[id]) {
                        gL10nData[id] = {};
                      }
                      gL10nData[id][prop] = data[key];
                    }
                    if (successCallback) {
                      successCallback();
                    }
                  });
                }, failureCallback);
              }
              function loadLocale(lang, callback) {
                if (lang) {
                  lang = lang.toLowerCase();
                }
                callback = callback || function _callback() {
                };
                clear();
                gLanguage = lang;
                var langLinks = getL10nResourceLinks();
                var langCount = langLinks.length;
                if (langCount === 0) {
                  var dict = getL10nDictionary();
                  if (dict && dict.locales && dict.default_locale) {
                    console.log("using the embedded JSON directory, early way out");
                    gL10nData = dict.locales[lang];
                    if (!gL10nData) {
                      var defaultLocale = dict.default_locale.toLowerCase();
                      for (var anyCaseLang in dict.locales) {
                        anyCaseLang = anyCaseLang.toLowerCase();
                        if (anyCaseLang === lang) {
                          gL10nData = dict.locales[lang];
                          break;
                        } else if (anyCaseLang === defaultLocale) {
                          gL10nData = dict.locales[defaultLocale];
                        }
                      }
                    }
                    callback();
                  } else {
                    console.log("no resource to load, early way out");
                  }
                  gReadyState = "complete";
                  return;
                }
                var onResourceLoaded = null;
                var gResourceCount = 0;
                onResourceLoaded = function() {
                  gResourceCount++;
                  if (gResourceCount >= langCount) {
                    callback();
                    gReadyState = "complete";
                  }
                };
                function L10nResourceLink(link) {
                  var href = link.href;
                  this.load = function(lang2, callback2) {
                    parseResource(href, lang2, callback2, function() {
                      console.warn(href + " not found.");
                      console.warn('"' + lang2 + '" resource not found');
                      gLanguage = "";
                      callback2();
                    });
                  };
                }
                for (var i = 0; i < langCount; i++) {
                  var resource = new L10nResourceLink(langLinks[i]);
                  resource.load(lang, onResourceLoaded);
                }
              }
              function clear() {
                gL10nData = {};
                gTextData = "";
                gLanguage = "";
              }
              function getPluralRules(lang) {
                var locales2rules = {
                  "af": 3,
                  "ak": 4,
                  "am": 4,
                  "ar": 1,
                  "asa": 3,
                  "az": 0,
                  "be": 11,
                  "bem": 3,
                  "bez": 3,
                  "bg": 3,
                  "bh": 4,
                  "bm": 0,
                  "bn": 3,
                  "bo": 0,
                  "br": 20,
                  "brx": 3,
                  "bs": 11,
                  "ca": 3,
                  "cgg": 3,
                  "chr": 3,
                  "cs": 12,
                  "cy": 17,
                  "da": 3,
                  "de": 3,
                  "dv": 3,
                  "dz": 0,
                  "ee": 3,
                  "el": 3,
                  "en": 3,
                  "eo": 3,
                  "es": 3,
                  "et": 3,
                  "eu": 3,
                  "fa": 0,
                  "ff": 5,
                  "fi": 3,
                  "fil": 4,
                  "fo": 3,
                  "fr": 5,
                  "fur": 3,
                  "fy": 3,
                  "ga": 8,
                  "gd": 24,
                  "gl": 3,
                  "gsw": 3,
                  "gu": 3,
                  "guw": 4,
                  "gv": 23,
                  "ha": 3,
                  "haw": 3,
                  "he": 2,
                  "hi": 4,
                  "hr": 11,
                  "hu": 0,
                  "id": 0,
                  "ig": 0,
                  "ii": 0,
                  "is": 3,
                  "it": 3,
                  "iu": 7,
                  "ja": 0,
                  "jmc": 3,
                  "jv": 0,
                  "ka": 0,
                  "kab": 5,
                  "kaj": 3,
                  "kcg": 3,
                  "kde": 0,
                  "kea": 0,
                  "kk": 3,
                  "kl": 3,
                  "km": 0,
                  "kn": 0,
                  "ko": 0,
                  "ksb": 3,
                  "ksh": 21,
                  "ku": 3,
                  "kw": 7,
                  "lag": 18,
                  "lb": 3,
                  "lg": 3,
                  "ln": 4,
                  "lo": 0,
                  "lt": 10,
                  "lv": 6,
                  "mas": 3,
                  "mg": 4,
                  "mk": 16,
                  "ml": 3,
                  "mn": 3,
                  "mo": 9,
                  "mr": 3,
                  "ms": 0,
                  "mt": 15,
                  "my": 0,
                  "nah": 3,
                  "naq": 7,
                  "nb": 3,
                  "nd": 3,
                  "ne": 3,
                  "nl": 3,
                  "nn": 3,
                  "no": 3,
                  "nr": 3,
                  "nso": 4,
                  "ny": 3,
                  "nyn": 3,
                  "om": 3,
                  "or": 3,
                  "pa": 3,
                  "pap": 3,
                  "pl": 13,
                  "ps": 3,
                  "pt": 3,
                  "rm": 3,
                  "ro": 9,
                  "rof": 3,
                  "ru": 11,
                  "rwk": 3,
                  "sah": 0,
                  "saq": 3,
                  "se": 7,
                  "seh": 3,
                  "ses": 0,
                  "sg": 0,
                  "sh": 11,
                  "shi": 19,
                  "sk": 12,
                  "sl": 14,
                  "sma": 7,
                  "smi": 7,
                  "smj": 7,
                  "smn": 7,
                  "sms": 7,
                  "sn": 3,
                  "so": 3,
                  "sq": 3,
                  "sr": 11,
                  "ss": 3,
                  "ssy": 3,
                  "st": 3,
                  "sv": 3,
                  "sw": 3,
                  "syr": 3,
                  "ta": 3,
                  "te": 3,
                  "teo": 3,
                  "th": 0,
                  "ti": 4,
                  "tig": 3,
                  "tk": 3,
                  "tl": 4,
                  "tn": 3,
                  "to": 0,
                  "tr": 0,
                  "ts": 3,
                  "tzm": 22,
                  "uk": 11,
                  "ur": 3,
                  "ve": 3,
                  "vi": 0,
                  "vun": 3,
                  "wa": 4,
                  "wae": 3,
                  "wo": 0,
                  "xh": 3,
                  "xog": 3,
                  "yo": 0,
                  "zh": 0,
                  "zu": 3
                };
                function isIn(n, list) {
                  return list.indexOf(n) !== -1;
                }
                function isBetween(n, start, end) {
                  return start <= n && n <= end;
                }
                var pluralRules = {
                  "0": function(n) {
                    return "other";
                  },
                  "1": function(n) {
                    if (isBetween(n % 100, 3, 10))
                      return "few";
                    if (n === 0)
                      return "zero";
                    if (isBetween(n % 100, 11, 99))
                      return "many";
                    if (n == 2)
                      return "two";
                    if (n == 1)
                      return "one";
                    return "other";
                  },
                  "2": function(n) {
                    if (n !== 0 && n % 10 === 0)
                      return "many";
                    if (n == 2)
                      return "two";
                    if (n == 1)
                      return "one";
                    return "other";
                  },
                  "3": function(n) {
                    if (n == 1)
                      return "one";
                    return "other";
                  },
                  "4": function(n) {
                    if (isBetween(n, 0, 1))
                      return "one";
                    return "other";
                  },
                  "5": function(n) {
                    if (isBetween(n, 0, 2) && n != 2)
                      return "one";
                    return "other";
                  },
                  "6": function(n) {
                    if (n === 0)
                      return "zero";
                    if (n % 10 == 1 && n % 100 != 11)
                      return "one";
                    return "other";
                  },
                  "7": function(n) {
                    if (n == 2)
                      return "two";
                    if (n == 1)
                      return "one";
                    return "other";
                  },
                  "8": function(n) {
                    if (isBetween(n, 3, 6))
                      return "few";
                    if (isBetween(n, 7, 10))
                      return "many";
                    if (n == 2)
                      return "two";
                    if (n == 1)
                      return "one";
                    return "other";
                  },
                  "9": function(n) {
                    if (n === 0 || n != 1 && isBetween(n % 100, 1, 19))
                      return "few";
                    if (n == 1)
                      return "one";
                    return "other";
                  },
                  "10": function(n) {
                    if (isBetween(n % 10, 2, 9) && !isBetween(n % 100, 11, 19))
                      return "few";
                    if (n % 10 == 1 && !isBetween(n % 100, 11, 19))
                      return "one";
                    return "other";
                  },
                  "11": function(n) {
                    if (isBetween(n % 10, 2, 4) && !isBetween(n % 100, 12, 14))
                      return "few";
                    if (n % 10 === 0 || isBetween(n % 10, 5, 9) || isBetween(n % 100, 11, 14))
                      return "many";
                    if (n % 10 == 1 && n % 100 != 11)
                      return "one";
                    return "other";
                  },
                  "12": function(n) {
                    if (isBetween(n, 2, 4))
                      return "few";
                    if (n == 1)
                      return "one";
                    return "other";
                  },
                  "13": function(n) {
                    if (isBetween(n % 10, 2, 4) && !isBetween(n % 100, 12, 14))
                      return "few";
                    if (n != 1 && isBetween(n % 10, 0, 1) || isBetween(n % 10, 5, 9) || isBetween(n % 100, 12, 14))
                      return "many";
                    if (n == 1)
                      return "one";
                    return "other";
                  },
                  "14": function(n) {
                    if (isBetween(n % 100, 3, 4))
                      return "few";
                    if (n % 100 == 2)
                      return "two";
                    if (n % 100 == 1)
                      return "one";
                    return "other";
                  },
                  "15": function(n) {
                    if (n === 0 || isBetween(n % 100, 2, 10))
                      return "few";
                    if (isBetween(n % 100, 11, 19))
                      return "many";
                    if (n == 1)
                      return "one";
                    return "other";
                  },
                  "16": function(n) {
                    if (n % 10 == 1 && n != 11)
                      return "one";
                    return "other";
                  },
                  "17": function(n) {
                    if (n == 3)
                      return "few";
                    if (n === 0)
                      return "zero";
                    if (n == 6)
                      return "many";
                    if (n == 2)
                      return "two";
                    if (n == 1)
                      return "one";
                    return "other";
                  },
                  "18": function(n) {
                    if (n === 0)
                      return "zero";
                    if (isBetween(n, 0, 2) && n !== 0 && n != 2)
                      return "one";
                    return "other";
                  },
                  "19": function(n) {
                    if (isBetween(n, 2, 10))
                      return "few";
                    if (isBetween(n, 0, 1))
                      return "one";
                    return "other";
                  },
                  "20": function(n) {
                    if ((isBetween(n % 10, 3, 4) || n % 10 == 9) && !(isBetween(n % 100, 10, 19) || isBetween(n % 100, 70, 79) || isBetween(n % 100, 90, 99)))
                      return "few";
                    if (n % 1e6 === 0 && n !== 0)
                      return "many";
                    if (n % 10 == 2 && !isIn(n % 100, [12, 72, 92]))
                      return "two";
                    if (n % 10 == 1 && !isIn(n % 100, [11, 71, 91]))
                      return "one";
                    return "other";
                  },
                  "21": function(n) {
                    if (n === 0)
                      return "zero";
                    if (n == 1)
                      return "one";
                    return "other";
                  },
                  "22": function(n) {
                    if (isBetween(n, 0, 1) || isBetween(n, 11, 99))
                      return "one";
                    return "other";
                  },
                  "23": function(n) {
                    if (isBetween(n % 10, 1, 2) || n % 20 === 0)
                      return "one";
                    return "other";
                  },
                  "24": function(n) {
                    if (isBetween(n, 3, 10) || isBetween(n, 13, 19))
                      return "few";
                    if (isIn(n, [2, 12]))
                      return "two";
                    if (isIn(n, [1, 11]))
                      return "one";
                    return "other";
                  }
                };
                var index = locales2rules[lang.replace(/-.*$/, "")];
                if (!(index in pluralRules)) {
                  console.warn("plural form unknown for [" + lang + "]");
                  return function() {
                    return "other";
                  };
                }
                return pluralRules[index];
              }
              gMacros.plural = function(str, param, key, prop) {
                var n = parseFloat(param);
                if (isNaN(n))
                  return str;
                if (prop != gTextProp)
                  return str;
                if (!gMacros._pluralRules) {
                  gMacros._pluralRules = getPluralRules(gLanguage);
                }
                var index = "[" + gMacros._pluralRules(n) + "]";
                if (n === 0 && key + "[zero]" in gL10nData) {
                  str = gL10nData[key + "[zero]"][prop];
                } else if (n == 1 && key + "[one]" in gL10nData) {
                  str = gL10nData[key + "[one]"][prop];
                } else if (n == 2 && key + "[two]" in gL10nData) {
                  str = gL10nData[key + "[two]"][prop];
                } else if (key + index in gL10nData) {
                  str = gL10nData[key + index][prop];
                } else if (key + "[other]" in gL10nData) {
                  str = gL10nData[key + "[other]"][prop];
                }
                return str;
              };
              function getL10nData(key, args, fallback) {
                var data = gL10nData[key];
                if (!data) {
                  console.warn("#" + key + " is undefined.");
                  if (!fallback) {
                    return null;
                  }
                  data = fallback;
                }
                var rv = {};
                for (var prop in data) {
                  var str = data[prop];
                  str = substIndexes(str, args, key, prop);
                  str = substArguments(str, args, key);
                  rv[prop] = str;
                }
                return rv;
              }
              function substIndexes(str, args, key, prop) {
                var reIndex = /\{\[\s*([a-zA-Z]+)\(([a-zA-Z]+)\)\s*\]\}/;
                var reMatch = reIndex.exec(str);
                if (!reMatch || !reMatch.length)
                  return str;
                var macroName = reMatch[1];
                var paramName = reMatch[2];
                var param;
                if (args && paramName in args) {
                  param = args[paramName];
                } else if (paramName in gL10nData) {
                  param = gL10nData[paramName];
                }
                if (macroName in gMacros) {
                  var macro = gMacros[macroName];
                  str = macro(str, param, key, prop);
                }
                return str;
              }
              function substArguments(str, args, key) {
                var reArgs = /\{\{\s*(.+?)\s*\}\}/g;
                return str.replace(reArgs, function(matched_text, arg) {
                  if (args && arg in args) {
                    return args[arg];
                  }
                  if (arg in gL10nData) {
                    return gL10nData[arg];
                  }
                  console.log("argument {{" + arg + "}} for #" + key + " is undefined.");
                  return matched_text;
                });
              }
              function translateElement(element) {
                var l10n = getL10nAttributes(element);
                if (!l10n.id)
                  return;
                var data = getL10nData(l10n.id, l10n.args);
                if (!data) {
                  console.warn("#" + l10n.id + " is undefined.");
                  return;
                }
                if (data[gTextProp]) {
                  if (getChildElementCount(element) === 0) {
                    element[gTextProp] = data[gTextProp];
                  } else {
                    var children = element.childNodes;
                    var found = false;
                    for (var i = 0, l = children.length; i < l; i++) {
                      if (children[i].nodeType === 3 && /\S/.test(children[i].nodeValue)) {
                        if (found) {
                          children[i].nodeValue = "";
                        } else {
                          children[i].nodeValue = data[gTextProp];
                          found = true;
                        }
                      }
                    }
                    if (!found) {
                      var textNode = document2.createTextNode(data[gTextProp]);
                      element.insertBefore(textNode, element.firstChild);
                    }
                  }
                  delete data[gTextProp];
                }
                for (var k in data) {
                  element[k] = data[k];
                }
              }
              function getChildElementCount(element) {
                if (element.children) {
                  return element.children.length;
                }
                if (typeof element.childElementCount !== "undefined") {
                  return element.childElementCount;
                }
                var count = 0;
                for (var i = 0; i < element.childNodes.length; i++) {
                  count += element.nodeType === 1 ? 1 : 0;
                }
                return count;
              }
              function translateFragment(element) {
                element = element || document2.documentElement;
                var children = getTranslatableChildren(element);
                var elementCount = children.length;
                for (var i = 0; i < elementCount; i++) {
                  translateElement(children[i]);
                }
                translateElement(element);
              }
              return {
                get: function(key, args, fallbackString) {
                  var index = key.lastIndexOf(".");
                  var prop = gTextProp;
                  if (index > 0) {
                    prop = key.substring(index + 1);
                    key = key.substring(0, index);
                  }
                  var fallback;
                  if (fallbackString) {
                    fallback = {};
                    fallback[prop] = fallbackString;
                  }
                  var data = getL10nData(key, args, fallback);
                  if (data && prop in data) {
                    return data[prop];
                  }
                  return "{{" + key + "}}";
                },
                getData: function() {
                  return gL10nData;
                },
                getText: function() {
                  return gTextData;
                },
                getLanguage: function() {
                  return gLanguage;
                },
                setLanguage: function(lang, callback) {
                  loadLocale(lang, function() {
                    if (callback)
                      callback();
                  });
                },
                getDirection: function() {
                  var rtlList = ["ar", "he", "fa", "ps", "ur"];
                  var shortCode = gLanguage.split("-", 1)[0];
                  return rtlList.indexOf(shortCode) >= 0 ? "rtl" : "ltr";
                },
                translate: translateFragment,
                getReadyState: function() {
                  return gReadyState;
                },
                ready: function(callback) {
                  if (!callback) {
                    return;
                  } else if (gReadyState == "complete" || gReadyState == "interactive") {
                    window2.setTimeout(function() {
                      callback();
                    });
                  } else if (document2.addEventListener) {
                    document2.addEventListener("localized", function once() {
                      document2.removeEventListener("localized", once);
                      callback();
                    });
                  }
                }
              };
            }(window, document);
          },
          3941: function(__unused_webpack_module2, exports2, __webpack_require__2) {
            "use strict";
            var pdfjsVersion = "2.4.456";
            var pdfjsBuild = "228a591c";
            var pdfjsSharedUtil = __webpack_require__2(7484);
            var pdfjsDisplayAPI = __webpack_require__2(6738);
            var pdfjsDisplayTextLayer = __webpack_require__2(2245);
            var pdfjsDisplayAnnotationLayer = __webpack_require__2(901);
            var pdfjsDisplayDisplayUtils = __webpack_require__2(9485);
            var pdfjsDisplaySVG = __webpack_require__2(8002);
            const pdfjsDisplayWorkerOptions = __webpack_require__2(5864);
            const pdfjsDisplayAPICompatibility = __webpack_require__2(3528);
            {
              const {
                isNodeJS
              } = __webpack_require__2(2918);
              if (isNodeJS) {
                const PDFNodeStream = __webpack_require__2(5156).b;
                pdfjsDisplayAPI.setPDFNetworkStreamFactory((params) => {
                  return new PDFNodeStream(params);
                });
              } else {
                const PDFNetworkStream = __webpack_require__2(962).V;
                let PDFFetchStream;
                if (pdfjsDisplayDisplayUtils.isFetchSupported()) {
                  PDFFetchStream = __webpack_require__2(6445).r;
                }
                pdfjsDisplayAPI.setPDFNetworkStreamFactory((params) => {
                  if (PDFFetchStream && pdfjsDisplayDisplayUtils.isValidFetchUrl(params.url)) {
                    return new PDFFetchStream(params);
                  }
                  return new PDFNetworkStream(params);
                });
              }
            }
            exports2.build = pdfjsDisplayAPI.build;
            exports2.version = pdfjsDisplayAPI.version;
            exports2.getDocument = pdfjsDisplayAPI.getDocument;
            exports2.LoopbackPort = pdfjsDisplayAPI.LoopbackPort;
            exports2.PDFDataRangeTransport = pdfjsDisplayAPI.PDFDataRangeTransport;
            exports2.PDFWorker = pdfjsDisplayAPI.PDFWorker;
            exports2.renderTextLayer = pdfjsDisplayTextLayer.renderTextLayer;
            exports2.AnnotationLayer = pdfjsDisplayAnnotationLayer.AnnotationLayer;
            exports2.createPromiseCapability = pdfjsSharedUtil.createPromiseCapability;
            exports2.PasswordResponses = pdfjsSharedUtil.PasswordResponses;
            exports2.InvalidPDFException = pdfjsSharedUtil.InvalidPDFException;
            exports2.MissingPDFException = pdfjsSharedUtil.MissingPDFException;
            exports2.SVGGraphics = pdfjsDisplaySVG.SVGGraphics;
            exports2.NativeImageDecoding = pdfjsSharedUtil.NativeImageDecoding;
            exports2.CMapCompressionType = pdfjsSharedUtil.CMapCompressionType;
            exports2.PermissionFlag = pdfjsSharedUtil.PermissionFlag;
            exports2.UnexpectedResponseException = pdfjsSharedUtil.UnexpectedResponseException;
            exports2.OPS = pdfjsSharedUtil.OPS;
            exports2.VerbosityLevel = pdfjsSharedUtil.VerbosityLevel;
            exports2.UNSUPPORTED_FEATURES = pdfjsSharedUtil.UNSUPPORTED_FEATURES;
            exports2.createValidAbsoluteUrl = pdfjsSharedUtil.createValidAbsoluteUrl;
            exports2.createObjectURL = pdfjsSharedUtil.createObjectURL;
            exports2.removeNullCharacters = pdfjsSharedUtil.removeNullCharacters;
            exports2.shadow = pdfjsSharedUtil.shadow;
            exports2.Util = pdfjsSharedUtil.Util;
            exports2.RenderingCancelledException = pdfjsDisplayDisplayUtils.RenderingCancelledException;
            exports2.getFilenameFromUrl = pdfjsDisplayDisplayUtils.getFilenameFromUrl;
            exports2.LinkTarget = pdfjsDisplayDisplayUtils.LinkTarget;
            exports2.addLinkAttributes = pdfjsDisplayDisplayUtils.addLinkAttributes;
            exports2.loadScript = pdfjsDisplayDisplayUtils.loadScript;
            exports2.PDFDateString = pdfjsDisplayDisplayUtils.PDFDateString;
            exports2.GlobalWorkerOptions = pdfjsDisplayWorkerOptions.GlobalWorkerOptions;
            exports2.apiCompatibilityParams = pdfjsDisplayAPICompatibility.apiCompatibilityParams;
          },
          1750: function() {
            "use strict";
            ;
          },
          2918: function(__unused_webpack_module2, exports2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.isNodeJS = void 0;
            const isNodeJS = typeof process === "object" && process + "" === "[object process]" && !process.versions["nw"] && !process.versions["electron"];
            exports2.isNodeJS = isNodeJS;
          },
          9725: function(__unused_webpack_module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.MessageHandler = void 0;
            var _util2 = __webpack_require__2(7484);
            const CallbackKind = {
              UNKNOWN: 0,
              DATA: 1,
              ERROR: 2
            };
            const StreamKind = {
              UNKNOWN: 0,
              CANCEL: 1,
              CANCEL_COMPLETE: 2,
              CLOSE: 3,
              ENQUEUE: 4,
              ERROR: 5,
              PULL: 6,
              PULL_COMPLETE: 7,
              START_COMPLETE: 8
            };
            function wrapReason(reason) {
              if (typeof reason !== "object" || reason === null) {
                return reason;
              }
              switch (reason.name) {
                case "AbortException":
                  return new _util2.AbortException(reason.message);
                case "MissingPDFException":
                  return new _util2.MissingPDFException(reason.message);
                case "UnexpectedResponseException":
                  return new _util2.UnexpectedResponseException(reason.message, reason.status);
                case "UnknownErrorException":
                  return new _util2.UnknownErrorException(reason.message, reason.details);
                default:
                  return new _util2.UnknownErrorException(reason.message, reason.toString());
              }
            }
            class MessageHandler {
              constructor(sourceName, targetName, comObj) {
                this.sourceName = sourceName;
                this.targetName = targetName;
                this.comObj = comObj;
                this.callbackId = 1;
                this.streamId = 1;
                this.postMessageTransfers = true;
                this.streamSinks = /* @__PURE__ */ Object.create(null);
                this.streamControllers = /* @__PURE__ */ Object.create(null);
                this.callbackCapabilities = /* @__PURE__ */ Object.create(null);
                this.actionHandler = /* @__PURE__ */ Object.create(null);
                this._onComObjOnMessage = (event) => {
                  const data = event.data;
                  if (data.targetName !== this.sourceName) {
                    return;
                  }
                  if (data.stream) {
                    this._processStreamMessage(data);
                    return;
                  }
                  if (data.callback) {
                    const callbackId = data.callbackId;
                    const capability = this.callbackCapabilities[callbackId];
                    if (!capability) {
                      throw new Error(`Cannot resolve callback ${callbackId}`);
                    }
                    delete this.callbackCapabilities[callbackId];
                    if (data.callback === CallbackKind.DATA) {
                      capability.resolve(data.data);
                    } else if (data.callback === CallbackKind.ERROR) {
                      capability.reject(wrapReason(data.reason));
                    } else {
                      throw new Error("Unexpected callback case");
                    }
                    return;
                  }
                  const action = this.actionHandler[data.action];
                  if (!action) {
                    throw new Error(`Unknown action from worker: ${data.action}`);
                  }
                  if (data.callbackId) {
                    const sourceName2 = this.sourceName;
                    const targetName2 = data.sourceName;
                    new Promise(function(resolve) {
                      resolve(action(data.data));
                    }).then(function(result) {
                      comObj.postMessage({
                        sourceName: sourceName2,
                        targetName: targetName2,
                        callback: CallbackKind.DATA,
                        callbackId: data.callbackId,
                        data: result
                      });
                    }, function(reason) {
                      comObj.postMessage({
                        sourceName: sourceName2,
                        targetName: targetName2,
                        callback: CallbackKind.ERROR,
                        callbackId: data.callbackId,
                        reason: wrapReason(reason)
                      });
                    });
                    return;
                  }
                  if (data.streamId) {
                    this._createStreamSink(data);
                    return;
                  }
                  action(data.data);
                };
                comObj.addEventListener("message", this._onComObjOnMessage);
              }
              on(actionName, handler) {
                const ah = this.actionHandler;
                if (ah[actionName]) {
                  throw new Error(`There is already an actionName called "${actionName}"`);
                }
                ah[actionName] = handler;
              }
              send(actionName, data, transfers) {
                this._postMessage({
                  sourceName: this.sourceName,
                  targetName: this.targetName,
                  action: actionName,
                  data
                }, transfers);
              }
              sendWithPromise(actionName, data, transfers) {
                const callbackId = this.callbackId++;
                const capability = (0, _util2.createPromiseCapability)();
                this.callbackCapabilities[callbackId] = capability;
                try {
                  this._postMessage({
                    sourceName: this.sourceName,
                    targetName: this.targetName,
                    action: actionName,
                    callbackId,
                    data
                  }, transfers);
                } catch (ex) {
                  capability.reject(ex);
                }
                return capability.promise;
              }
              sendWithStream(actionName, data, queueingStrategy, transfers) {
                const streamId = this.streamId++;
                const sourceName = this.sourceName;
                const targetName = this.targetName;
                const comObj = this.comObj;
                return new ReadableStream({
                  start: (controller) => {
                    const startCapability = (0, _util2.createPromiseCapability)();
                    this.streamControllers[streamId] = {
                      controller,
                      startCall: startCapability,
                      pullCall: null,
                      cancelCall: null,
                      isClosed: false
                    };
                    this._postMessage({
                      sourceName,
                      targetName,
                      action: actionName,
                      streamId,
                      data,
                      desiredSize: controller.desiredSize
                    }, transfers);
                    return startCapability.promise;
                  },
                  pull: (controller) => {
                    const pullCapability = (0, _util2.createPromiseCapability)();
                    this.streamControllers[streamId].pullCall = pullCapability;
                    comObj.postMessage({
                      sourceName,
                      targetName,
                      stream: StreamKind.PULL,
                      streamId,
                      desiredSize: controller.desiredSize
                    });
                    return pullCapability.promise;
                  },
                  cancel: (reason) => {
                    (0, _util2.assert)(reason instanceof Error, "cancel must have a valid reason");
                    const cancelCapability = (0, _util2.createPromiseCapability)();
                    this.streamControllers[streamId].cancelCall = cancelCapability;
                    this.streamControllers[streamId].isClosed = true;
                    comObj.postMessage({
                      sourceName,
                      targetName,
                      stream: StreamKind.CANCEL,
                      streamId,
                      reason: wrapReason(reason)
                    });
                    return cancelCapability.promise;
                  }
                }, queueingStrategy);
              }
              _createStreamSink(data) {
                const self2 = this;
                const action = this.actionHandler[data.action];
                const streamId = data.streamId;
                const sourceName = this.sourceName;
                const targetName = data.sourceName;
                const comObj = this.comObj;
                const streamSink = {
                  enqueue(chunk, size = 1, transfers) {
                    if (this.isCancelled) {
                      return;
                    }
                    const lastDesiredSize = this.desiredSize;
                    this.desiredSize -= size;
                    if (lastDesiredSize > 0 && this.desiredSize <= 0) {
                      this.sinkCapability = (0, _util2.createPromiseCapability)();
                      this.ready = this.sinkCapability.promise;
                    }
                    self2._postMessage({
                      sourceName,
                      targetName,
                      stream: StreamKind.ENQUEUE,
                      streamId,
                      chunk
                    }, transfers);
                  },
                  close() {
                    if (this.isCancelled) {
                      return;
                    }
                    this.isCancelled = true;
                    comObj.postMessage({
                      sourceName,
                      targetName,
                      stream: StreamKind.CLOSE,
                      streamId
                    });
                    delete self2.streamSinks[streamId];
                  },
                  error(reason) {
                    (0, _util2.assert)(reason instanceof Error, "error must have a valid reason");
                    if (this.isCancelled) {
                      return;
                    }
                    this.isCancelled = true;
                    comObj.postMessage({
                      sourceName,
                      targetName,
                      stream: StreamKind.ERROR,
                      streamId,
                      reason: wrapReason(reason)
                    });
                  },
                  sinkCapability: (0, _util2.createPromiseCapability)(),
                  onPull: null,
                  onCancel: null,
                  isCancelled: false,
                  desiredSize: data.desiredSize,
                  ready: null
                };
                streamSink.sinkCapability.resolve();
                streamSink.ready = streamSink.sinkCapability.promise;
                this.streamSinks[streamId] = streamSink;
                new Promise(function(resolve) {
                  resolve(action(data.data, streamSink));
                }).then(function() {
                  comObj.postMessage({
                    sourceName,
                    targetName,
                    stream: StreamKind.START_COMPLETE,
                    streamId,
                    success: true
                  });
                }, function(reason) {
                  comObj.postMessage({
                    sourceName,
                    targetName,
                    stream: StreamKind.START_COMPLETE,
                    streamId,
                    reason: wrapReason(reason)
                  });
                });
              }
              _processStreamMessage(data) {
                const streamId = data.streamId;
                const sourceName = this.sourceName;
                const targetName = data.sourceName;
                const comObj = this.comObj;
                switch (data.stream) {
                  case StreamKind.START_COMPLETE:
                    if (data.success) {
                      this.streamControllers[streamId].startCall.resolve();
                    } else {
                      this.streamControllers[streamId].startCall.reject(wrapReason(data.reason));
                    }
                    break;
                  case StreamKind.PULL_COMPLETE:
                    if (data.success) {
                      this.streamControllers[streamId].pullCall.resolve();
                    } else {
                      this.streamControllers[streamId].pullCall.reject(wrapReason(data.reason));
                    }
                    break;
                  case StreamKind.PULL:
                    if (!this.streamSinks[streamId]) {
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.PULL_COMPLETE,
                        streamId,
                        success: true
                      });
                      break;
                    }
                    if (this.streamSinks[streamId].desiredSize <= 0 && data.desiredSize > 0) {
                      this.streamSinks[streamId].sinkCapability.resolve();
                    }
                    this.streamSinks[streamId].desiredSize = data.desiredSize;
                    const {
                      onPull
                    } = this.streamSinks[data.streamId];
                    new Promise(function(resolve) {
                      resolve(onPull && onPull());
                    }).then(function() {
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.PULL_COMPLETE,
                        streamId,
                        success: true
                      });
                    }, function(reason) {
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.PULL_COMPLETE,
                        streamId,
                        reason: wrapReason(reason)
                      });
                    });
                    break;
                  case StreamKind.ENQUEUE:
                    (0, _util2.assert)(this.streamControllers[streamId], "enqueue should have stream controller");
                    if (this.streamControllers[streamId].isClosed) {
                      break;
                    }
                    this.streamControllers[streamId].controller.enqueue(data.chunk);
                    break;
                  case StreamKind.CLOSE:
                    (0, _util2.assert)(this.streamControllers[streamId], "close should have stream controller");
                    if (this.streamControllers[streamId].isClosed) {
                      break;
                    }
                    this.streamControllers[streamId].isClosed = true;
                    this.streamControllers[streamId].controller.close();
                    this._deleteStreamController(streamId);
                    break;
                  case StreamKind.ERROR:
                    (0, _util2.assert)(this.streamControllers[streamId], "error should have stream controller");
                    this.streamControllers[streamId].controller.error(wrapReason(data.reason));
                    this._deleteStreamController(streamId);
                    break;
                  case StreamKind.CANCEL_COMPLETE:
                    if (data.success) {
                      this.streamControllers[streamId].cancelCall.resolve();
                    } else {
                      this.streamControllers[streamId].cancelCall.reject(wrapReason(data.reason));
                    }
                    this._deleteStreamController(streamId);
                    break;
                  case StreamKind.CANCEL:
                    if (!this.streamSinks[streamId]) {
                      break;
                    }
                    const {
                      onCancel
                    } = this.streamSinks[data.streamId];
                    new Promise(function(resolve) {
                      resolve(onCancel && onCancel(wrapReason(data.reason)));
                    }).then(function() {
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.CANCEL_COMPLETE,
                        streamId,
                        success: true
                      });
                    }, function(reason) {
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.CANCEL_COMPLETE,
                        streamId,
                        reason: wrapReason(reason)
                      });
                    });
                    this.streamSinks[streamId].sinkCapability.reject(wrapReason(data.reason));
                    this.streamSinks[streamId].isCancelled = true;
                    delete this.streamSinks[streamId];
                    break;
                  default:
                    throw new Error("Unexpected stream case");
                }
              }
              async _deleteStreamController(streamId) {
                await Promise.allSettled([this.streamControllers[streamId].startCall, this.streamControllers[streamId].pullCall, this.streamControllers[streamId].cancelCall].map(function(capability) {
                  return capability && capability.promise;
                }));
                delete this.streamControllers[streamId];
              }
              _postMessage(message, transfers) {
                if (transfers && this.postMessageTransfers) {
                  this.comObj.postMessage(message, transfers);
                } else {
                  this.comObj.postMessage(message);
                }
              }
              destroy() {
                this.comObj.removeEventListener("message", this._onComObjOnMessage);
              }
            }
            exports2.MessageHandler = MessageHandler;
          },
          7484: function(__unused_webpack_module2, exports2, __webpack_require__2) {
            "use strict";
            __webpack_require__2(7658);
            __webpack_require__2(3408);
            __webpack_require__2(4590);
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.arrayByteLength = arrayByteLength;
            exports2.arraysToBytes = arraysToBytes;
            exports2.assert = assert;
            exports2.bytesToString = bytesToString;
            exports2.createPromiseCapability = createPromiseCapability;
            exports2.getVerbosityLevel = getVerbosityLevel;
            exports2.info = info;
            exports2.isArrayBuffer = isArrayBuffer;
            exports2.isArrayEqual = isArrayEqual;
            exports2.isBool = isBool;
            exports2.isEmptyObj = isEmptyObj;
            exports2.isNum = isNum;
            exports2.isString = isString;
            exports2.isSameOrigin = isSameOrigin;
            exports2.createValidAbsoluteUrl = createValidAbsoluteUrl;
            exports2.removeNullCharacters = removeNullCharacters;
            exports2.setVerbosityLevel = setVerbosityLevel;
            exports2.shadow = shadow;
            exports2.string32 = string32;
            exports2.stringToBytes = stringToBytes;
            exports2.stringToPDFString = stringToPDFString;
            exports2.stringToUTF8String = stringToUTF8String;
            exports2.utf8StringToString = utf8StringToString;
            exports2.warn = warn;
            exports2.unreachable = unreachable;
            exports2.IsEvalSupportedCached = exports2.IsLittleEndianCached = exports2.createObjectURL = exports2.FormatError = exports2.Util = exports2.UnknownErrorException = exports2.UnexpectedResponseException = exports2.TextRenderingMode = exports2.StreamType = exports2.PermissionFlag = exports2.PasswordResponses = exports2.PasswordException = exports2.NativeImageDecoding = exports2.MissingPDFException = exports2.InvalidPDFException = exports2.AbortException = exports2.CMapCompressionType = exports2.ImageKind = exports2.FontType = exports2.AnnotationType = exports2.AnnotationStateModelType = exports2.AnnotationReviewState = exports2.AnnotationReplyType = exports2.AnnotationMarkedState = exports2.AnnotationFlag = exports2.AnnotationFieldFlag = exports2.AnnotationBorderStyleType = exports2.UNSUPPORTED_FEATURES = exports2.VerbosityLevel = exports2.OPS = exports2.IDENTITY_MATRIX = exports2.FONT_IDENTITY_MATRIX = exports2.BaseException = void 0;
            __webpack_require__2(1750);
            const IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
            exports2.IDENTITY_MATRIX = IDENTITY_MATRIX;
            const FONT_IDENTITY_MATRIX = [1e-3, 0, 0, 1e-3, 0, 0];
            exports2.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;
            const NativeImageDecoding = {
              NONE: "none",
              DECODE: "decode",
              DISPLAY: "display"
            };
            exports2.NativeImageDecoding = NativeImageDecoding;
            const PermissionFlag = {
              PRINT: 4,
              MODIFY_CONTENTS: 8,
              COPY: 16,
              MODIFY_ANNOTATIONS: 32,
              FILL_INTERACTIVE_FORMS: 256,
              COPY_FOR_ACCESSIBILITY: 512,
              ASSEMBLE: 1024,
              PRINT_HIGH_QUALITY: 2048
            };
            exports2.PermissionFlag = PermissionFlag;
            const TextRenderingMode = {
              FILL: 0,
              STROKE: 1,
              FILL_STROKE: 2,
              INVISIBLE: 3,
              FILL_ADD_TO_PATH: 4,
              STROKE_ADD_TO_PATH: 5,
              FILL_STROKE_ADD_TO_PATH: 6,
              ADD_TO_PATH: 7,
              FILL_STROKE_MASK: 3,
              ADD_TO_PATH_FLAG: 4
            };
            exports2.TextRenderingMode = TextRenderingMode;
            const ImageKind = {
              GRAYSCALE_1BPP: 1,
              RGB_24BPP: 2,
              RGBA_32BPP: 3
            };
            exports2.ImageKind = ImageKind;
            const AnnotationType = {
              TEXT: 1,
              LINK: 2,
              FREETEXT: 3,
              LINE: 4,
              SQUARE: 5,
              CIRCLE: 6,
              POLYGON: 7,
              POLYLINE: 8,
              HIGHLIGHT: 9,
              UNDERLINE: 10,
              SQUIGGLY: 11,
              STRIKEOUT: 12,
              STAMP: 13,
              CARET: 14,
              INK: 15,
              POPUP: 16,
              FILEATTACHMENT: 17,
              SOUND: 18,
              MOVIE: 19,
              WIDGET: 20,
              SCREEN: 21,
              PRINTERMARK: 22,
              TRAPNET: 23,
              WATERMARK: 24,
              THREED: 25,
              REDACT: 26
            };
            exports2.AnnotationType = AnnotationType;
            const AnnotationStateModelType = {
              MARKED: "Marked",
              REVIEW: "Review"
            };
            exports2.AnnotationStateModelType = AnnotationStateModelType;
            const AnnotationMarkedState = {
              MARKED: "Marked",
              UNMARKED: "Unmarked"
            };
            exports2.AnnotationMarkedState = AnnotationMarkedState;
            const AnnotationReviewState = {
              ACCEPTED: "Accepted",
              REJECTED: "Rejected",
              CANCELLED: "Cancelled",
              COMPLETED: "Completed",
              NONE: "None"
            };
            exports2.AnnotationReviewState = AnnotationReviewState;
            const AnnotationReplyType = {
              GROUP: "Group",
              REPLY: "R"
            };
            exports2.AnnotationReplyType = AnnotationReplyType;
            const AnnotationFlag = {
              INVISIBLE: 1,
              HIDDEN: 2,
              PRINT: 4,
              NOZOOM: 8,
              NOROTATE: 16,
              NOVIEW: 32,
              READONLY: 64,
              LOCKED: 128,
              TOGGLENOVIEW: 256,
              LOCKEDCONTENTS: 512
            };
            exports2.AnnotationFlag = AnnotationFlag;
            const AnnotationFieldFlag = {
              READONLY: 1,
              REQUIRED: 2,
              NOEXPORT: 4,
              MULTILINE: 4096,
              PASSWORD: 8192,
              NOTOGGLETOOFF: 16384,
              RADIO: 32768,
              PUSHBUTTON: 65536,
              COMBO: 131072,
              EDIT: 262144,
              SORT: 524288,
              FILESELECT: 1048576,
              MULTISELECT: 2097152,
              DONOTSPELLCHECK: 4194304,
              DONOTSCROLL: 8388608,
              COMB: 16777216,
              RICHTEXT: 33554432,
              RADIOSINUNISON: 33554432,
              COMMITONSELCHANGE: 67108864
            };
            exports2.AnnotationFieldFlag = AnnotationFieldFlag;
            const AnnotationBorderStyleType = {
              SOLID: 1,
              DASHED: 2,
              BEVELED: 3,
              INSET: 4,
              UNDERLINE: 5
            };
            exports2.AnnotationBorderStyleType = AnnotationBorderStyleType;
            const StreamType = {
              UNKNOWN: "UNKNOWN",
              FLATE: "FLATE",
              LZW: "LZW",
              DCT: "DCT",
              JPX: "JPX",
              JBIG: "JBIG",
              A85: "A85",
              AHX: "AHX",
              CCF: "CCF",
              RLX: "RLX"
            };
            exports2.StreamType = StreamType;
            const FontType = {
              UNKNOWN: "UNKNOWN",
              TYPE1: "TYPE1",
              TYPE1C: "TYPE1C",
              CIDFONTTYPE0: "CIDFONTTYPE0",
              CIDFONTTYPE0C: "CIDFONTTYPE0C",
              TRUETYPE: "TRUETYPE",
              CIDFONTTYPE2: "CIDFONTTYPE2",
              TYPE3: "TYPE3",
              OPENTYPE: "OPENTYPE",
              TYPE0: "TYPE0",
              MMTYPE1: "MMTYPE1"
            };
            exports2.FontType = FontType;
            const VerbosityLevel = {
              ERRORS: 0,
              WARNINGS: 1,
              INFOS: 5
            };
            exports2.VerbosityLevel = VerbosityLevel;
            const CMapCompressionType = {
              NONE: 0,
              BINARY: 1,
              STREAM: 2
            };
            exports2.CMapCompressionType = CMapCompressionType;
            const OPS = {
              dependency: 1,
              setLineWidth: 2,
              setLineCap: 3,
              setLineJoin: 4,
              setMiterLimit: 5,
              setDash: 6,
              setRenderingIntent: 7,
              setFlatness: 8,
              setGState: 9,
              save: 10,
              restore: 11,
              transform: 12,
              moveTo: 13,
              lineTo: 14,
              curveTo: 15,
              curveTo2: 16,
              curveTo3: 17,
              closePath: 18,
              rectangle: 19,
              stroke: 20,
              closeStroke: 21,
              fill: 22,
              eoFill: 23,
              fillStroke: 24,
              eoFillStroke: 25,
              closeFillStroke: 26,
              closeEOFillStroke: 27,
              endPath: 28,
              clip: 29,
              eoClip: 30,
              beginText: 31,
              endText: 32,
              setCharSpacing: 33,
              setWordSpacing: 34,
              setHScale: 35,
              setLeading: 36,
              setFont: 37,
              setTextRenderingMode: 38,
              setTextRise: 39,
              moveText: 40,
              setLeadingMoveText: 41,
              setTextMatrix: 42,
              nextLine: 43,
              showText: 44,
              showSpacedText: 45,
              nextLineShowText: 46,
              nextLineSetSpacingShowText: 47,
              setCharWidth: 48,
              setCharWidthAndBounds: 49,
              setStrokeColorSpace: 50,
              setFillColorSpace: 51,
              setStrokeColor: 52,
              setStrokeColorN: 53,
              setFillColor: 54,
              setFillColorN: 55,
              setStrokeGray: 56,
              setFillGray: 57,
              setStrokeRGBColor: 58,
              setFillRGBColor: 59,
              setStrokeCMYKColor: 60,
              setFillCMYKColor: 61,
              shadingFill: 62,
              beginInlineImage: 63,
              beginImageData: 64,
              endInlineImage: 65,
              paintXObject: 66,
              markPoint: 67,
              markPointProps: 68,
              beginMarkedContent: 69,
              beginMarkedContentProps: 70,
              endMarkedContent: 71,
              beginCompat: 72,
              endCompat: 73,
              paintFormXObjectBegin: 74,
              paintFormXObjectEnd: 75,
              beginGroup: 76,
              endGroup: 77,
              beginAnnotations: 78,
              endAnnotations: 79,
              beginAnnotation: 80,
              endAnnotation: 81,
              paintJpegXObject: 82,
              paintImageMaskXObject: 83,
              paintImageMaskXObjectGroup: 84,
              paintImageXObject: 85,
              paintInlineImageXObject: 86,
              paintInlineImageXObjectGroup: 87,
              paintImageXObjectRepeat: 88,
              paintImageMaskXObjectRepeat: 89,
              paintSolidColorImageMask: 90,
              constructPath: 91
            };
            exports2.OPS = OPS;
            const UNSUPPORTED_FEATURES = {
              unknown: "unknown",
              forms: "forms",
              javaScript: "javaScript",
              smask: "smask",
              shadingPattern: "shadingPattern",
              font: "font"
            };
            exports2.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES;
            const PasswordResponses = {
              NEED_PASSWORD: 1,
              INCORRECT_PASSWORD: 2
            };
            exports2.PasswordResponses = PasswordResponses;
            let verbosity = VerbosityLevel.WARNINGS;
            function setVerbosityLevel(level) {
              if (Number.isInteger(level)) {
                verbosity = level;
              }
            }
            function getVerbosityLevel() {
              return verbosity;
            }
            function info(msg) {
              if (verbosity >= VerbosityLevel.INFOS) {
                console.log(`Info: ${msg}`);
              }
            }
            function warn(msg) {
              if (verbosity >= VerbosityLevel.WARNINGS) {
                console.log(`Warning: ${msg}`);
              }
            }
            function unreachable(msg) {
              throw new Error(msg);
            }
            function assert(cond, msg) {
              if (!cond) {
                unreachable(msg);
              }
            }
            function isSameOrigin(baseUrl, otherUrl) {
              let base;
              try {
                base = new URL(baseUrl);
                if (!base.origin || base.origin === "null") {
                  return false;
                }
              } catch (e) {
                return false;
              }
              const other = new URL(otherUrl, base);
              return base.origin === other.origin;
            }
            function _isValidProtocol(url) {
              if (!url) {
                return false;
              }
              switch (url.protocol) {
                case "http:":
                case "https:":
                case "ftp:":
                case "mailto:":
                case "tel:":
                  return true;
                default:
                  return false;
              }
            }
            function createValidAbsoluteUrl(url, baseUrl) {
              if (!url) {
                return null;
              }
              try {
                const absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);
                if (_isValidProtocol(absoluteUrl)) {
                  return absoluteUrl;
                }
              } catch (ex) {
              }
              return null;
            }
            function shadow(obj, prop, value) {
              Object.defineProperty(obj, prop, {
                value,
                enumerable: true,
                configurable: true,
                writable: false
              });
              return value;
            }
            const BaseException = function BaseExceptionClosure() {
              function BaseException2(message) {
                if (this.constructor === BaseException2) {
                  unreachable("Cannot initialize BaseException.");
                }
                this.message = message;
                this.name = this.constructor.name;
              }
              BaseException2.prototype = new Error();
              BaseException2.constructor = BaseException2;
              return BaseException2;
            }();
            exports2.BaseException = BaseException;
            class PasswordException extends BaseException {
              constructor(msg, code) {
                super(msg);
                this.code = code;
              }
            }
            exports2.PasswordException = PasswordException;
            class UnknownErrorException extends BaseException {
              constructor(msg, details) {
                super(msg);
                this.details = details;
              }
            }
            exports2.UnknownErrorException = UnknownErrorException;
            class InvalidPDFException extends BaseException {
            }
            exports2.InvalidPDFException = InvalidPDFException;
            class MissingPDFException extends BaseException {
            }
            exports2.MissingPDFException = MissingPDFException;
            class UnexpectedResponseException extends BaseException {
              constructor(msg, status) {
                super(msg);
                this.status = status;
              }
            }
            exports2.UnexpectedResponseException = UnexpectedResponseException;
            class FormatError extends BaseException {
            }
            exports2.FormatError = FormatError;
            class AbortException extends BaseException {
            }
            exports2.AbortException = AbortException;
            const NullCharactersRegExp = /\x00/g;
            function removeNullCharacters(str) {
              if (typeof str !== "string") {
                warn("The argument for removeNullCharacters must be a string.");
                return str;
              }
              return str.replace(NullCharactersRegExp, "");
            }
            function bytesToString(bytes) {
              assert(bytes !== null && typeof bytes === "object" && bytes.length !== void 0, "Invalid argument for bytesToString");
              const length = bytes.length;
              const MAX_ARGUMENT_COUNT = 8192;
              if (length < MAX_ARGUMENT_COUNT) {
                return String.fromCharCode.apply(null, bytes);
              }
              const strBuf = [];
              for (let i = 0; i < length; i += MAX_ARGUMENT_COUNT) {
                const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);
                const chunk = bytes.subarray(i, chunkEnd);
                strBuf.push(String.fromCharCode.apply(null, chunk));
              }
              return strBuf.join("");
            }
            function stringToBytes(str) {
              assert(typeof str === "string", "Invalid argument for stringToBytes");
              const length = str.length;
              const bytes = new Uint8Array(length);
              for (let i = 0; i < length; ++i) {
                bytes[i] = str.charCodeAt(i) & 255;
              }
              return bytes;
            }
            function arrayByteLength(arr) {
              if (arr.length !== void 0) {
                return arr.length;
              }
              assert(arr.byteLength !== void 0);
              return arr.byteLength;
            }
            function arraysToBytes(arr) {
              const length = arr.length;
              if (length === 1 && arr[0] instanceof Uint8Array) {
                return arr[0];
              }
              let resultLength = 0;
              for (let i = 0; i < length; i++) {
                resultLength += arrayByteLength(arr[i]);
              }
              let pos = 0;
              const data = new Uint8Array(resultLength);
              for (let i = 0; i < length; i++) {
                let item = arr[i];
                if (!(item instanceof Uint8Array)) {
                  if (typeof item === "string") {
                    item = stringToBytes(item);
                  } else {
                    item = new Uint8Array(item);
                  }
                }
                const itemLength = item.byteLength;
                data.set(item, pos);
                pos += itemLength;
              }
              return data;
            }
            function string32(value) {
              return String.fromCharCode(value >> 24 & 255, value >> 16 & 255, value >> 8 & 255, value & 255);
            }
            function isLittleEndian() {
              const buffer8 = new Uint8Array(4);
              buffer8[0] = 1;
              const view32 = new Uint32Array(buffer8.buffer, 0, 1);
              return view32[0] === 1;
            }
            const IsLittleEndianCached = {
              get value() {
                return shadow(this, "value", isLittleEndian());
              }
            };
            exports2.IsLittleEndianCached = IsLittleEndianCached;
            function isEvalSupported() {
              try {
                new Function("");
                return true;
              } catch (e) {
                return false;
              }
            }
            const IsEvalSupportedCached = {
              get value() {
                return shadow(this, "value", isEvalSupported());
              }
            };
            exports2.IsEvalSupportedCached = IsEvalSupportedCached;
            const rgbBuf = ["rgb(", 0, ",", 0, ",", 0, ")"];
            class Util {
              static makeCssRgb(r, g, b) {
                rgbBuf[1] = r;
                rgbBuf[3] = g;
                rgbBuf[5] = b;
                return rgbBuf.join("");
              }
              static transform(m1, m2) {
                return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
              }
              static applyTransform(p, m) {
                const xt = p[0] * m[0] + p[1] * m[2] + m[4];
                const yt = p[0] * m[1] + p[1] * m[3] + m[5];
                return [xt, yt];
              }
              static applyInverseTransform(p, m) {
                const d = m[0] * m[3] - m[1] * m[2];
                const xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
                const yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
                return [xt, yt];
              }
              static getAxialAlignedBoundingBox(r, m) {
                const p1 = Util.applyTransform(r, m);
                const p2 = Util.applyTransform(r.slice(2, 4), m);
                const p3 = Util.applyTransform([r[0], r[3]], m);
                const p4 = Util.applyTransform([r[2], r[1]], m);
                return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];
              }
              static inverseTransform(m) {
                const d = m[0] * m[3] - m[1] * m[2];
                return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
              }
              static apply3dTransform(m, v) {
                return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]];
              }
              static singularValueDecompose2dScale(m) {
                const transpose = [m[0], m[2], m[1], m[3]];
                const a = m[0] * transpose[0] + m[1] * transpose[2];
                const b = m[0] * transpose[1] + m[1] * transpose[3];
                const c = m[2] * transpose[0] + m[3] * transpose[2];
                const d = m[2] * transpose[1] + m[3] * transpose[3];
                const first = (a + d) / 2;
                const second = Math.sqrt((a + d) * (a + d) - 4 * (a * d - c * b)) / 2;
                const sx = first + second || 1;
                const sy = first - second || 1;
                return [Math.sqrt(sx), Math.sqrt(sy)];
              }
              static normalizeRect(rect) {
                const r = rect.slice(0);
                if (rect[0] > rect[2]) {
                  r[0] = rect[2];
                  r[2] = rect[0];
                }
                if (rect[1] > rect[3]) {
                  r[1] = rect[3];
                  r[3] = rect[1];
                }
                return r;
              }
              static intersect(rect1, rect2) {
                function compare(a, b) {
                  return a - b;
                }
                const orderedX = [rect1[0], rect1[2], rect2[0], rect2[2]].sort(compare);
                const orderedY = [rect1[1], rect1[3], rect2[1], rect2[3]].sort(compare);
                const result = [];
                rect1 = Util.normalizeRect(rect1);
                rect2 = Util.normalizeRect(rect2);
                if (orderedX[0] === rect1[0] && orderedX[1] === rect2[0] || orderedX[0] === rect2[0] && orderedX[1] === rect1[0]) {
                  result[0] = orderedX[1];
                  result[2] = orderedX[2];
                } else {
                  return null;
                }
                if (orderedY[0] === rect1[1] && orderedY[1] === rect2[1] || orderedY[0] === rect2[1] && orderedY[1] === rect1[1]) {
                  result[1] = orderedY[1];
                  result[3] = orderedY[2];
                } else {
                  return null;
                }
                return result;
              }
            }
            exports2.Util = Util;
            const PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364];
            function stringToPDFString(str) {
              const length = str.length, strBuf = [];
              if (str[0] === "\xFE" && str[1] === "\xFF") {
                for (let i = 2; i < length; i += 2) {
                  strBuf.push(String.fromCharCode(str.charCodeAt(i) << 8 | str.charCodeAt(i + 1)));
                }
              } else if (str[0] === "\xFF" && str[1] === "\xFE") {
                for (let i = 2; i < length; i += 2) {
                  strBuf.push(String.fromCharCode(str.charCodeAt(i + 1) << 8 | str.charCodeAt(i)));
                }
              } else {
                for (let i = 0; i < length; ++i) {
                  const code = PDFStringTranslateTable[str.charCodeAt(i)];
                  strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));
                }
              }
              return strBuf.join("");
            }
            function stringToUTF8String(str) {
              return decodeURIComponent(escape(str));
            }
            function utf8StringToString(str) {
              return unescape(encodeURIComponent(str));
            }
            function isEmptyObj(obj) {
              for (const key in obj) {
                return false;
              }
              return true;
            }
            function isBool(v) {
              return typeof v === "boolean";
            }
            function isNum(v) {
              return typeof v === "number";
            }
            function isString(v) {
              return typeof v === "string";
            }
            function isArrayBuffer(v) {
              return typeof v === "object" && v !== null && v.byteLength !== void 0;
            }
            function isArrayEqual(arr1, arr2) {
              if (arr1.length !== arr2.length) {
                return false;
              }
              return arr1.every(function(element, index) {
                return element === arr2[index];
              });
            }
            function createPromiseCapability() {
              const capability = /* @__PURE__ */ Object.create(null);
              let isSettled = false;
              Object.defineProperty(capability, "settled", {
                get() {
                  return isSettled;
                }
              });
              capability.promise = new Promise(function(resolve, reject) {
                capability.resolve = function(data) {
                  isSettled = true;
                  resolve(data);
                };
                capability.reject = function(reason) {
                  isSettled = true;
                  reject(reason);
                };
              });
              return capability;
            }
            const createObjectURL = function createObjectURLClosure() {
              const digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
              return function createObjectURL2(data, contentType, forceDataSchema = false) {
                if (!forceDataSchema && URL.createObjectURL) {
                  const blob = new Blob([data], {
                    type: contentType
                  });
                  return URL.createObjectURL(blob);
                }
                let buffer = `data:${contentType};base64,`;
                for (let i = 0, ii = data.length; i < ii; i += 3) {
                  const b1 = data[i] & 255;
                  const b2 = data[i + 1] & 255;
                  const b3 = data[i + 2] & 255;
                  const d1 = b1 >> 2, d2 = (b1 & 3) << 4 | b2 >> 4;
                  const d3 = i + 1 < ii ? (b2 & 15) << 2 | b3 >> 6 : 64;
                  const d4 = i + 2 < ii ? b3 & 63 : 64;
                  buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];
                }
                return buffer;
              };
            }();
            exports2.createObjectURL = createObjectURL;
          },
          5346: function(__unused_webpack_module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.DefaultAnnotationLayerFactory = exports2.AnnotationLayerBuilder = void 0;
            var _pdf = __webpack_require__2(3941);
            var _ui_utils = __webpack_require__2(5570);
            var _pdf_link_service = __webpack_require__2(2388);
            class AnnotationLayerBuilder {
              constructor({
                pageDiv,
                pdfPage,
                linkService,
                downloadManager,
                imageResourcesPath = "",
                renderInteractiveForms = false,
                l10n = _ui_utils.NullL10n
              }) {
                this.pageDiv = pageDiv;
                this.pdfPage = pdfPage;
                this.linkService = linkService;
                this.downloadManager = downloadManager;
                this.imageResourcesPath = imageResourcesPath;
                this.renderInteractiveForms = renderInteractiveForms;
                this.l10n = l10n;
                this.div = null;
                this._cancelled = false;
              }
              render(viewport, intent = "display") {
                this.pdfPage.getAnnotations({
                  intent
                }).then((annotations) => {
                  if (this._cancelled) {
                    return;
                  }
                  const parameters = {
                    viewport: viewport.clone({
                      dontFlip: true
                    }),
                    div: this.div,
                    annotations,
                    page: this.pdfPage,
                    imageResourcesPath: this.imageResourcesPath,
                    renderInteractiveForms: this.renderInteractiveForms,
                    linkService: this.linkService,
                    downloadManager: this.downloadManager
                  };
                  if (this.div) {
                    _pdf.AnnotationLayer.update(parameters);
                  } else {
                    if (annotations.length === 0) {
                      return;
                    }
                    this.div = document.createElement("div");
                    this.div.className = "annotationLayer";
                    this.pageDiv.appendChild(this.div);
                    parameters.div = this.div;
                    _pdf.AnnotationLayer.render(parameters);
                    this.l10n.translate(this.div);
                  }
                });
              }
              cancel() {
                this._cancelled = true;
              }
              hide() {
                if (!this.div) {
                  return;
                }
                this.div.setAttribute("hidden", "true");
              }
            }
            exports2.AnnotationLayerBuilder = AnnotationLayerBuilder;
            class DefaultAnnotationLayerFactory {
              createAnnotationLayerBuilder(pageDiv, pdfPage, imageResourcesPath = "", renderInteractiveForms = false, l10n = _ui_utils.NullL10n) {
                return new AnnotationLayerBuilder({
                  pageDiv,
                  pdfPage,
                  imageResourcesPath,
                  renderInteractiveForms,
                  linkService: new _pdf_link_service.SimpleLinkService(),
                  l10n
                });
              }
            }
            exports2.DefaultAnnotationLayerFactory = DefaultAnnotationLayerFactory;
          },
          8375: function(__unused_webpack_module2, exports2, __webpack_require__2) {
            "use strict";
            __webpack_require__2(7658);
            __webpack_require__2(3408);
            __webpack_require__2(4590);
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.PDFPrintServiceFactory = exports2.DefaultExternalServices = exports2.PDFViewerApplication = void 0;
            var _ui_utils = __webpack_require__2(5570);
            var _app_options = __webpack_require__2(1958);
            var _pdf = __webpack_require__2(3941);
            var _pdf_cursor_tools = __webpack_require__2(6879);
            var _pdf_rendering_queue = __webpack_require__2(7807);
            var _pdf_sidebar = __webpack_require__2(8241);
            var _overlay_manager = __webpack_require__2(3421);
            var _password_prompt = __webpack_require__2(3755);
            var _pdf_attachment_viewer = __webpack_require__2(6506);
            var _pdf_document_properties = __webpack_require__2(5113);
            var _pdf_find_bar = __webpack_require__2(2105);
            var _pdf_find_controller = __webpack_require__2(5704);
            var _pdf_history = __webpack_require__2(2320);
            var _pdf_link_service = __webpack_require__2(2388);
            var _pdf_outline_viewer = __webpack_require__2(8753);
            var _pdf_presentation_mode = __webpack_require__2(1181);
            var _pdf_sidebar_resizer = __webpack_require__2(2355);
            var _pdf_thumbnail_viewer = __webpack_require__2(2096);
            var _pdf_viewer = __webpack_require__2(6157);
            var _secondary_toolbar = __webpack_require__2(4217);
            var _toolbar = __webpack_require__2(7637);
            var _view_history = __webpack_require__2(9361);
            const DEFAULT_SCALE_DELTA = 1.1;
            const DISABLE_AUTO_FETCH_LOADING_BAR_TIMEOUT = 5e3;
            const FORCE_PAGES_LOADED_TIMEOUT = 1e4;
            const WHEEL_ZOOM_DISABLED_TIMEOUT = 1e3;
            const ViewOnLoad = {
              UNKNOWN: -1,
              PREVIOUS: 0,
              INITIAL: 1
            };
            class DefaultExternalServices {
              constructor() {
                throw new Error("Cannot initialize DefaultExternalServices.");
              }
              static updateFindControlState(data) {
              }
              static updateFindMatchesCount(data) {
              }
              static initPassiveLoading(callbacks) {
              }
              static fallback(data, callback) {
              }
              static reportTelemetry(data) {
              }
              static createDownloadManager(options) {
                throw new Error("Not implemented: createDownloadManager");
              }
              static createPreferences() {
                throw new Error("Not implemented: createPreferences");
              }
              static createL10n(options) {
                throw new Error("Not implemented: createL10n");
              }
              static get supportsIntegratedFind() {
                return (0, _pdf.shadow)(this, "supportsIntegratedFind", false);
              }
              static get supportsDocumentFonts() {
                return (0, _pdf.shadow)(this, "supportsDocumentFonts", true);
              }
              static get supportedMouseWheelZoomModifierKeys() {
                return (0, _pdf.shadow)(this, "supportedMouseWheelZoomModifierKeys", {
                  ctrlKey: true,
                  metaKey: true
                });
              }
            }
            exports2.DefaultExternalServices = DefaultExternalServices;
            const PDFViewerApplication = {
              initialBookmark: document.location.hash.substring(1),
              _initializedCapability: (0, _pdf.createPromiseCapability)(),
              fellback: false,
              appConfig: null,
              pdfDocument: null,
              pdfLoadingTask: null,
              printService: null,
              pdfViewer: null,
              pdfThumbnailViewer: null,
              pdfRenderingQueue: null,
              pdfPresentationMode: null,
              pdfDocumentProperties: null,
              pdfLinkService: null,
              pdfHistory: null,
              pdfSidebar: null,
              pdfSidebarResizer: null,
              pdfOutlineViewer: null,
              pdfAttachmentViewer: null,
              pdfCursorTools: null,
              store: null,
              downloadManager: null,
              overlayManager: null,
              preferences: null,
              toolbar: null,
              secondaryToolbar: null,
              eventBus: null,
              l10n: null,
              isInitialViewSet: false,
              downloadComplete: false,
              isViewerEmbedded: window.parent !== window,
              url: "",
              baseUrl: "",
              externalServices: DefaultExternalServices,
              _boundEvents: {},
              contentDispositionFilename: null,
              async initialize(appConfig) {
                this.preferences = this.externalServices.createPreferences();
                this.appConfig = appConfig;
                await this._readPreferences();
                await this._parseHashParameters();
                await this._initializeL10n();
                if (this.isViewerEmbedded && _app_options.AppOptions.get("externalLinkTarget") === _pdf.LinkTarget.NONE) {
                  _app_options.AppOptions.set("externalLinkTarget", _pdf.LinkTarget.TOP);
                }
                await this._initializeViewerComponents();
                this.bindEvents();
                this.bindWindowEvents();
                const appContainer = appConfig.appContainer || document.documentElement;
                this.l10n.translate(appContainer).then(() => {
                  this.eventBus.dispatch("localized", {
                    source: this
                  });
                });
                this._initializedCapability.resolve();
              },
              async _readPreferences() {
                if (_app_options.AppOptions.get("disablePreferences") === true) {
                  return;
                }
                try {
                  const prefs = await this.preferences.getAll();
                  for (const name in prefs) {
                    _app_options.AppOptions.set(name, prefs[name]);
                  }
                } catch (reason) {
                  console.error(`_readPreferences: "${reason.message}".`);
                }
              },
              async _parseHashParameters() {
                if (!_app_options.AppOptions.get("pdfBugEnabled")) {
                  return void 0;
                }
                const hash = document.location.hash.substring(1);
                if (!hash) {
                  return void 0;
                }
                const hashParams = (0, _ui_utils.parseQueryString)(hash), waitOn = [];
                if ("disableworker" in hashParams && hashParams["disableworker"] === "true") {
                  waitOn.push(loadFakeWorker());
                }
                if ("disablerange" in hashParams) {
                  _app_options.AppOptions.set("disableRange", hashParams["disablerange"] === "true");
                }
                if ("disablestream" in hashParams) {
                  _app_options.AppOptions.set("disableStream", hashParams["disablestream"] === "true");
                }
                if ("disableautofetch" in hashParams) {
                  _app_options.AppOptions.set("disableAutoFetch", hashParams["disableautofetch"] === "true");
                }
                if ("disablefontface" in hashParams) {
                  _app_options.AppOptions.set("disableFontFace", hashParams["disablefontface"] === "true");
                }
                if ("disablehistory" in hashParams) {
                  _app_options.AppOptions.set("disableHistory", hashParams["disablehistory"] === "true");
                }
                if ("webgl" in hashParams) {
                  _app_options.AppOptions.set("enableWebGL", hashParams["webgl"] === "true");
                }
                if ("verbosity" in hashParams) {
                  _app_options.AppOptions.set("verbosity", hashParams["verbosity"] | 0);
                }
                if ("textlayer" in hashParams) {
                  switch (hashParams["textlayer"]) {
                    case "off":
                      _app_options.AppOptions.set("textLayerMode", _ui_utils.TextLayerMode.DISABLE);
                      break;
                    case "visible":
                    case "shadow":
                    case "hover":
                      const viewer = this.appConfig.viewerContainer;
                      viewer.classList.add("textLayer-" + hashParams["textlayer"]);
                      break;
                  }
                }
                if ("pdfbug" in hashParams) {
                  _app_options.AppOptions.set("pdfBug", true);
                  const enabled = hashParams["pdfbug"].split(",");
                  waitOn.push(loadAndEnablePDFBug(enabled));
                }
                if ("locale" in hashParams) {
                  _app_options.AppOptions.set("locale", hashParams["locale"]);
                }
                return Promise.all(waitOn).catch((reason) => {
                  console.error(`_parseHashParameters: "${reason.message}".`);
                });
              },
              async _initializeL10n() {
                this.l10n = this.externalServices.createL10n({
                  locale: _app_options.AppOptions.get("locale")
                });
                const dir = await this.l10n.getDirection();
                document.getElementsByTagName("html")[0].dir = dir;
              },
              async _initializeViewerComponents() {
                const appConfig = this.appConfig;
                this.overlayManager = new _overlay_manager.OverlayManager();
                const eventBus = appConfig.eventBus || new _ui_utils.EventBus({
                  dispatchToDOM: _app_options.AppOptions.get("eventBusDispatchToDOM")
                });
                this.eventBus = eventBus;
                const pdfRenderingQueue = new _pdf_rendering_queue.PDFRenderingQueue();
                pdfRenderingQueue.onIdle = this.cleanup.bind(this);
                this.pdfRenderingQueue = pdfRenderingQueue;
                const pdfLinkService = new _pdf_link_service.PDFLinkService({
                  eventBus,
                  externalLinkTarget: _app_options.AppOptions.get("externalLinkTarget"),
                  externalLinkRel: _app_options.AppOptions.get("externalLinkRel"),
                  ignoreDestinationZoom: _app_options.AppOptions.get("ignoreDestinationZoom")
                });
                this.pdfLinkService = pdfLinkService;
                const downloadManager = this.externalServices.createDownloadManager({
                  disableCreateObjectURL: _app_options.AppOptions.get("disableCreateObjectURL")
                });
                this.downloadManager = downloadManager;
                const findController = new _pdf_find_controller.PDFFindController({
                  linkService: pdfLinkService,
                  eventBus
                });
                this.findController = findController;
                const container = appConfig.mainContainer;
                const viewer = appConfig.viewerContainer;
                this.pdfViewer = new _pdf_viewer.PDFViewer({
                  container,
                  viewer,
                  eventBus,
                  renderingQueue: pdfRenderingQueue,
                  linkService: pdfLinkService,
                  downloadManager,
                  findController,
                  renderer: _app_options.AppOptions.get("renderer"),
                  enableWebGL: _app_options.AppOptions.get("enableWebGL"),
                  l10n: this.l10n,
                  textLayerMode: _app_options.AppOptions.get("textLayerMode"),
                  imageResourcesPath: _app_options.AppOptions.get("imageResourcesPath"),
                  renderInteractiveForms: _app_options.AppOptions.get("renderInteractiveForms"),
                  enablePrintAutoRotate: _app_options.AppOptions.get("enablePrintAutoRotate"),
                  useOnlyCssZoom: _app_options.AppOptions.get("useOnlyCssZoom"),
                  maxCanvasPixels: _app_options.AppOptions.get("maxCanvasPixels")
                });
                pdfRenderingQueue.setViewer(this.pdfViewer);
                pdfLinkService.setViewer(this.pdfViewer);
                this.pdfThumbnailViewer = new _pdf_thumbnail_viewer.PDFThumbnailViewer({
                  container: appConfig.sidebar.thumbnailView,
                  renderingQueue: pdfRenderingQueue,
                  linkService: pdfLinkService,
                  l10n: this.l10n
                });
                pdfRenderingQueue.setThumbnailViewer(this.pdfThumbnailViewer);
                this.pdfHistory = new _pdf_history.PDFHistory({
                  linkService: pdfLinkService,
                  eventBus
                });
                pdfLinkService.setHistory(this.pdfHistory);
                if (!this.supportsIntegratedFind) {
                  this.findBar = new _pdf_find_bar.PDFFindBar(appConfig.findBar, eventBus, this.l10n);
                }
                this.pdfDocumentProperties = new _pdf_document_properties.PDFDocumentProperties(appConfig.documentProperties, this.overlayManager, eventBus, this.l10n);
                this.pdfCursorTools = new _pdf_cursor_tools.PDFCursorTools({
                  container,
                  eventBus,
                  cursorToolOnLoad: _app_options.AppOptions.get("cursorToolOnLoad")
                });
                this.toolbar = new _toolbar.Toolbar(appConfig.toolbar, eventBus, this.l10n);
                this.secondaryToolbar = new _secondary_toolbar.SecondaryToolbar(appConfig.secondaryToolbar, container, eventBus);
                if (this.supportsFullscreen) {
                  this.pdfPresentationMode = new _pdf_presentation_mode.PDFPresentationMode({
                    container,
                    pdfViewer: this.pdfViewer,
                    eventBus,
                    contextMenuItems: appConfig.fullscreen
                  });
                }
                this.passwordPrompt = new _password_prompt.PasswordPrompt(appConfig.passwordOverlay, this.overlayManager, this.l10n);
                this.pdfOutlineViewer = new _pdf_outline_viewer.PDFOutlineViewer({
                  container: appConfig.sidebar.outlineView,
                  eventBus,
                  linkService: pdfLinkService
                });
                this.pdfAttachmentViewer = new _pdf_attachment_viewer.PDFAttachmentViewer({
                  container: appConfig.sidebar.attachmentsView,
                  eventBus,
                  downloadManager
                });
                this.pdfSidebar = new _pdf_sidebar.PDFSidebar({
                  elements: appConfig.sidebar,
                  pdfViewer: this.pdfViewer,
                  pdfThumbnailViewer: this.pdfThumbnailViewer,
                  eventBus,
                  l10n: this.l10n
                });
                this.pdfSidebar.onToggled = this.forceRendering.bind(this);
                this.pdfSidebarResizer = new _pdf_sidebar_resizer.PDFSidebarResizer(appConfig.sidebarResizer, eventBus, this.l10n);
              },
              run(config) {
                this.initialize(config).then(webViewerInitialized);
              },
              get initialized() {
                return this._initializedCapability.settled;
              },
              get initializedPromise() {
                return this._initializedCapability.promise;
              },
              zoomIn(ticks) {
                if (this.pdfViewer.isInPresentationMode) {
                  return;
                }
                let newScale = this.pdfViewer.currentScale;
                do {
                  newScale = (newScale * DEFAULT_SCALE_DELTA).toFixed(2);
                  newScale = Math.ceil(newScale * 10) / 10;
                  newScale = Math.min(_ui_utils.MAX_SCALE, newScale);
                } while (--ticks > 0 && newScale < _ui_utils.MAX_SCALE);
                this.pdfViewer.currentScaleValue = newScale;
              },
              zoomOut(ticks) {
                if (this.pdfViewer.isInPresentationMode) {
                  return;
                }
                let newScale = this.pdfViewer.currentScale;
                do {
                  newScale = (newScale / DEFAULT_SCALE_DELTA).toFixed(2);
                  newScale = Math.floor(newScale * 10) / 10;
                  newScale = Math.max(_ui_utils.MIN_SCALE, newScale);
                } while (--ticks > 0 && newScale > _ui_utils.MIN_SCALE);
                this.pdfViewer.currentScaleValue = newScale;
              },
              zoomReset() {
                if (this.pdfViewer.isInPresentationMode) {
                  return;
                }
                this.pdfViewer.currentScaleValue = _ui_utils.DEFAULT_SCALE_VALUE;
              },
              get pagesCount() {
                return this.pdfDocument ? this.pdfDocument.numPages : 0;
              },
              set page(val) {
                this.pdfViewer.currentPageNumber = val;
              },
              get page() {
                return this.pdfViewer.currentPageNumber;
              },
              get printing() {
                return !!this.printService;
              },
              get supportsPrinting() {
                return PDFPrintServiceFactory.instance.supportsPrinting;
              },
              get supportsFullscreen() {
                let support;
                const doc = document.documentElement;
                support = !!(doc.requestFullscreen || doc.mozRequestFullScreen || doc.webkitRequestFullScreen || doc.msRequestFullscreen);
                if (document.fullscreenEnabled === false || document.mozFullScreenEnabled === false || document.webkitFullscreenEnabled === false || document.msFullscreenEnabled === false) {
                  support = false;
                }
                return (0, _pdf.shadow)(this, "supportsFullscreen", support);
              },
              get supportsIntegratedFind() {
                return this.externalServices.supportsIntegratedFind;
              },
              get supportsDocumentFonts() {
                return this.externalServices.supportsDocumentFonts;
              },
              get loadingBar() {
                const bar = new _ui_utils.ProgressBar("#loadingBar");
                return (0, _pdf.shadow)(this, "loadingBar", bar);
              },
              get supportedMouseWheelZoomModifierKeys() {
                return this.externalServices.supportedMouseWheelZoomModifierKeys;
              },
              initPassiveLoading() {
                throw new Error("Not implemented: initPassiveLoading");
              },
              setTitleUsingUrl(url = "") {
                this.url = url;
                this.baseUrl = url.split("#")[0];
                let title = (0, _ui_utils.getPDFFileNameFromURL)(url, "");
                if (!title) {
                  try {
                    title = decodeURIComponent((0, _pdf.getFilenameFromUrl)(url)) || url;
                  } catch (ex) {
                    title = url;
                  }
                }
                this.setTitle(title);
              },
              setTitle(title) {
                if (this.isViewerEmbedded) {
                  return;
                }
                document.title = title;
              },
              async close() {
                const errorWrapper = this.appConfig.errorWrapper.container;
                errorWrapper.setAttribute("hidden", "true");
                if (!this.pdfLoadingTask) {
                  return void 0;
                }
                const promise = this.pdfLoadingTask.destroy();
                this.pdfLoadingTask = null;
                if (this.pdfDocument) {
                  this.pdfDocument = null;
                  this.pdfThumbnailViewer.setDocument(null);
                  this.pdfViewer.setDocument(null);
                  this.pdfLinkService.setDocument(null);
                  this.pdfDocumentProperties.setDocument(null);
                }
                this.store = null;
                this.isInitialViewSet = false;
                this.downloadComplete = false;
                this.url = "";
                this.baseUrl = "";
                this.contentDispositionFilename = null;
                this.pdfSidebar.reset();
                this.pdfOutlineViewer.reset();
                this.pdfAttachmentViewer.reset();
                if (this.pdfHistory) {
                  this.pdfHistory.reset();
                }
                if (this.findBar) {
                  this.findBar.reset();
                }
                this.toolbar.reset();
                this.secondaryToolbar.reset();
                if (typeof PDFBug !== "undefined") {
                  PDFBug.cleanup();
                }
                return promise;
              },
              async open(file, args) {
                if (this.pdfLoadingTask) {
                  await this.close();
                }
                const workerParameters = _app_options.AppOptions.getAll(_app_options.OptionKind.WORKER);
                for (const key in workerParameters) {
                  _pdf.GlobalWorkerOptions[key] = workerParameters[key];
                }
                const parameters = /* @__PURE__ */ Object.create(null);
                if (typeof file === "string") {
                  this.setTitleUsingUrl(file);
                  parameters.url = file;
                } else if (file && "byteLength" in file) {
                  parameters.data = file;
                } else if (file.url && file.originalUrl) {
                  this.setTitleUsingUrl(file.originalUrl);
                  parameters.url = file.url;
                }
                const apiParameters = _app_options.AppOptions.getAll(_app_options.OptionKind.API);
                for (const key in apiParameters) {
                  let value = apiParameters[key];
                  if (key === "docBaseUrl" && !value) {
                  }
                  parameters[key] = value;
                }
                if (args) {
                  for (const key in args) {
                    const value = args[key];
                    if (key === "length") {
                      this.pdfDocumentProperties.setFileSize(value);
                    }
                    parameters[key] = value;
                  }
                }
                const loadingTask = (0, _pdf.getDocument)(parameters);
                this.pdfLoadingTask = loadingTask;
                loadingTask.onPassword = (updateCallback, reason) => {
                  this.pdfLinkService.externalLinkEnabled = false;
                  this.passwordPrompt.setUpdateCallback(updateCallback, reason);
                  this.passwordPrompt.open();
                };
                loadingTask.onProgress = ({
                  loaded,
                  total
                }) => {
                  this.progress(loaded / total);
                };
                loadingTask.onUnsupportedFeature = this.fallback.bind(this);
                return loadingTask.promise.then((pdfDocument) => {
                  this.load(pdfDocument);
                }, (exception) => {
                  if (loadingTask !== this.pdfLoadingTask) {
                    return void 0;
                  }
                  const message = exception && exception.message;
                  let loadingErrorMessage;
                  if (exception instanceof _pdf.InvalidPDFException) {
                    loadingErrorMessage = this.l10n.get("invalid_file_error", null, "Invalid or corrupted PDF file.");
                  } else if (exception instanceof _pdf.MissingPDFException) {
                    loadingErrorMessage = this.l10n.get("missing_file_error", null, "Missing PDF file.");
                  } else if (exception instanceof _pdf.UnexpectedResponseException) {
                    loadingErrorMessage = this.l10n.get("unexpected_response_error", null, "Unexpected server response.");
                  } else {
                    loadingErrorMessage = this.l10n.get("loading_error", null, "An error occurred while loading the PDF.");
                  }
                  return loadingErrorMessage.then((msg) => {
                    this.error(msg, {
                      message
                    });
                    throw new Error(msg);
                  });
                });
              },
              download() {
                function downloadByUrl() {
                  downloadManager.downloadUrl(url, filename);
                }
                const url = this.baseUrl;
                const filename = this.contentDispositionFilename || (0, _ui_utils.getPDFFileNameFromURL)(this.url);
                const downloadManager = this.downloadManager;
                downloadManager.onerror = (err) => {
                  this.error(`PDF failed to download: ${err}`);
                };
                if (!this.pdfDocument || !this.downloadComplete) {
                  downloadByUrl();
                  return;
                }
                this.pdfDocument.getData().then(function(data) {
                  const blob = new Blob([data], {
                    type: "application/pdf"
                  });
                  downloadManager.download(blob, url, filename);
                }).catch(downloadByUrl);
              },
              fallback(featureId) {
                if (this.fellback) {
                  return;
                }
                this.fellback = true;
                this.externalServices.fallback({
                  featureId,
                  url: this.baseUrl
                }, function response(download) {
                  if (!download) {
                    return;
                  }
                  PDFViewerApplication.download();
                });
              },
              error(message, moreInfo) {
                const moreInfoText = [this.l10n.get("error_version_info", {
                  version: _pdf.version || "?",
                  build: _pdf.build || "?"
                }, "PDF.js v{{version}} (build: {{build}})")];
                if (moreInfo) {
                  moreInfoText.push(this.l10n.get("error_message", {
                    message: moreInfo.message
                  }, "Message: {{message}}"));
                  if (moreInfo.stack) {
                    moreInfoText.push(this.l10n.get("error_stack", {
                      stack: moreInfo.stack
                    }, "Stack: {{stack}}"));
                  } else {
                    if (moreInfo.filename) {
                      moreInfoText.push(this.l10n.get("error_file", {
                        file: moreInfo.filename
                      }, "File: {{file}}"));
                    }
                    if (moreInfo.lineNumber) {
                      moreInfoText.push(this.l10n.get("error_line", {
                        line: moreInfo.lineNumber
                      }, "Line: {{line}}"));
                    }
                  }
                }
                const errorWrapperConfig = this.appConfig.errorWrapper;
                const errorWrapper = errorWrapperConfig.container;
                errorWrapper.removeAttribute("hidden");
                const errorMessage = errorWrapperConfig.errorMessage;
                errorMessage.textContent = message;
                const closeButton = errorWrapperConfig.closeButton;
                closeButton.onclick = function() {
                  errorWrapper.setAttribute("hidden", "true");
                };
                const errorMoreInfo = errorWrapperConfig.errorMoreInfo;
                const moreInfoButton = errorWrapperConfig.moreInfoButton;
                const lessInfoButton = errorWrapperConfig.lessInfoButton;
                moreInfoButton.onclick = function() {
                  errorMoreInfo.removeAttribute("hidden");
                  moreInfoButton.setAttribute("hidden", "true");
                  lessInfoButton.removeAttribute("hidden");
                  errorMoreInfo.style.height = errorMoreInfo.scrollHeight + "px";
                };
                lessInfoButton.onclick = function() {
                  errorMoreInfo.setAttribute("hidden", "true");
                  moreInfoButton.removeAttribute("hidden");
                  lessInfoButton.setAttribute("hidden", "true");
                };
                moreInfoButton.oncontextmenu = _ui_utils.noContextMenuHandler;
                lessInfoButton.oncontextmenu = _ui_utils.noContextMenuHandler;
                closeButton.oncontextmenu = _ui_utils.noContextMenuHandler;
                moreInfoButton.removeAttribute("hidden");
                lessInfoButton.setAttribute("hidden", "true");
                Promise.all(moreInfoText).then((parts) => {
                  errorMoreInfo.value = parts.join("\n");
                });
              },
              progress(level) {
                if (this.downloadComplete) {
                  return;
                }
                const percent = Math.round(level * 100);
                if (percent > this.loadingBar.percent || isNaN(percent)) {
                  this.loadingBar.percent = percent;
                  const disableAutoFetch = this.pdfDocument ? this.pdfDocument.loadingParams["disableAutoFetch"] : _app_options.AppOptions.get("disableAutoFetch");
                  if (disableAutoFetch && percent) {
                    if (this.disableAutoFetchLoadingBarTimeout) {
                      clearTimeout(this.disableAutoFetchLoadingBarTimeout);
                      this.disableAutoFetchLoadingBarTimeout = null;
                    }
                    this.loadingBar.show();
                    this.disableAutoFetchLoadingBarTimeout = setTimeout(() => {
                      this.loadingBar.hide();
                      this.disableAutoFetchLoadingBarTimeout = null;
                    }, DISABLE_AUTO_FETCH_LOADING_BAR_TIMEOUT);
                  }
                }
              },
              load(pdfDocument) {
                this.pdfDocument = pdfDocument;
                pdfDocument.getDownloadInfo().then(() => {
                  this.downloadComplete = true;
                  this.loadingBar.hide();
                  firstPagePromise.then(() => {
                    this.eventBus.dispatch("documentloaded", {
                      source: this
                    });
                  });
                });
                const pageLayoutPromise = pdfDocument.getPageLayout().catch(function() {
                });
                const pageModePromise = pdfDocument.getPageMode().catch(function() {
                });
                const openActionPromise = pdfDocument.getOpenAction().catch(function() {
                });
                this.toolbar.setPagesCount(pdfDocument.numPages, false);
                this.secondaryToolbar.setPagesCount(pdfDocument.numPages);
                const store = this.store = new _view_history.ViewHistory(pdfDocument.fingerprint);
                let baseDocumentUrl;
                baseDocumentUrl = null;
                this.pdfLinkService.setDocument(pdfDocument, baseDocumentUrl);
                this.pdfDocumentProperties.setDocument(pdfDocument, this.url);
                const pdfViewer = this.pdfViewer;
                pdfViewer.setDocument(pdfDocument);
                const {
                  firstPagePromise,
                  onePageRendered,
                  pagesPromise
                } = pdfViewer;
                const pdfThumbnailViewer = this.pdfThumbnailViewer;
                pdfThumbnailViewer.setDocument(pdfDocument);
                firstPagePromise.then((pdfPage) => {
                  this.loadingBar.setWidth(this.appConfig.viewerContainer);
                  const storePromise = store.getMultiple({
                    page: null,
                    zoom: _ui_utils.DEFAULT_SCALE_VALUE,
                    scrollLeft: "0",
                    scrollTop: "0",
                    rotation: null,
                    sidebarView: _pdf_sidebar.SidebarView.UNKNOWN,
                    scrollMode: _ui_utils.ScrollMode.UNKNOWN,
                    spreadMode: _ui_utils.SpreadMode.UNKNOWN
                  }).catch(() => {
                  });
                  Promise.all([_ui_utils.animationStarted, storePromise, pageLayoutPromise, pageModePromise, openActionPromise]).then(async ([timeStamp, values = {}, pageLayout, pageMode, openAction]) => {
                    const viewOnLoad = _app_options.AppOptions.get("viewOnLoad");
                    this._initializePdfHistory({
                      fingerprint: pdfDocument.fingerprint,
                      viewOnLoad,
                      initialDest: openAction && openAction.dest
                    });
                    const initialBookmark = this.initialBookmark;
                    const zoom = _app_options.AppOptions.get("defaultZoomValue");
                    let hash = zoom ? `zoom=${zoom}` : null;
                    let rotation = null;
                    let sidebarView = _app_options.AppOptions.get("sidebarViewOnLoad");
                    let scrollMode = _app_options.AppOptions.get("scrollModeOnLoad");
                    let spreadMode = _app_options.AppOptions.get("spreadModeOnLoad");
                    if (values.page && viewOnLoad !== ViewOnLoad.INITIAL) {
                      hash = `page=${values.page}&zoom=${zoom || values.zoom},${values.scrollLeft},${values.scrollTop}`;
                      rotation = parseInt(values.rotation, 10);
                      if (sidebarView === _pdf_sidebar.SidebarView.UNKNOWN) {
                        sidebarView = values.sidebarView | 0;
                      }
                      if (scrollMode === _ui_utils.ScrollMode.UNKNOWN) {
                        scrollMode = values.scrollMode | 0;
                      }
                      if (spreadMode === _ui_utils.SpreadMode.UNKNOWN) {
                        spreadMode = values.spreadMode | 0;
                      }
                    }
                    if (pageMode && sidebarView === _pdf_sidebar.SidebarView.UNKNOWN) {
                      sidebarView = apiPageModeToSidebarView(pageMode);
                    }
                    if (pageLayout && spreadMode === _ui_utils.SpreadMode.UNKNOWN) {
                      spreadMode = apiPageLayoutToSpreadMode(pageLayout);
                    }
                    this.setInitialView(hash, {
                      rotation,
                      sidebarView,
                      scrollMode,
                      spreadMode
                    });
                    this.eventBus.dispatch("documentinit", {
                      source: this
                    });
                    if (!this.isViewerEmbedded) {
                      pdfViewer.focus();
                    }
                    await Promise.race([pagesPromise, new Promise((resolve) => {
                      setTimeout(resolve, FORCE_PAGES_LOADED_TIMEOUT);
                    })]);
                    if (!initialBookmark && !hash) {
                      return;
                    }
                    if (pdfViewer.hasEqualPageSizes) {
                      return;
                    }
                    this.initialBookmark = initialBookmark;
                    pdfViewer.currentScaleValue = pdfViewer.currentScaleValue;
                    this.setInitialView(hash);
                  }).catch(() => {
                    this.setInitialView();
                  }).then(function() {
                    pdfViewer.update();
                  });
                });
                pdfDocument.getPageLabels().then((labels) => {
                  if (!labels || _app_options.AppOptions.get("disablePageLabels")) {
                    return;
                  }
                  const numLabels = labels.length;
                  if (numLabels !== this.pagesCount) {
                    console.error("The number of Page Labels does not match the number of pages in the document.");
                    return;
                  }
                  let i = 0;
                  while (i < numLabels && labels[i] === (i + 1).toString()) {
                    i++;
                  }
                  if (i === numLabels) {
                    return;
                  }
                  pdfViewer.setPageLabels(labels);
                  pdfThumbnailViewer.setPageLabels(labels);
                  this.toolbar.setPagesCount(pdfDocument.numPages, true);
                  this.toolbar.setPageNumber(pdfViewer.currentPageNumber, pdfViewer.currentPageLabel);
                });
                pagesPromise.then(async () => {
                  const [openAction, javaScript] = await Promise.all([openActionPromise, pdfDocument.getJavaScript()]);
                  let triggerAutoPrint = false;
                  if (openAction && openAction.action === "Print") {
                    triggerAutoPrint = true;
                  }
                  if (javaScript) {
                    javaScript.some((js) => {
                      if (!js) {
                        return false;
                      }
                      console.warn("Warning: JavaScript is not supported");
                      this.fallback(_pdf.UNSUPPORTED_FEATURES.javaScript);
                      return true;
                    });
                    if (!triggerAutoPrint) {
                      for (const js of javaScript) {
                        if (js && _ui_utils.AutoPrintRegExp.test(js)) {
                          triggerAutoPrint = true;
                          break;
                        }
                      }
                    }
                  }
                  if (!this.supportsPrinting) {
                    return;
                  }
                  if (triggerAutoPrint) {
                    setTimeout(function() {
                      window.print();
                    });
                  }
                });
                onePageRendered.then(() => {
                  pdfDocument.getOutline().then((outline) => {
                    this.pdfOutlineViewer.render({
                      outline
                    });
                  });
                  pdfDocument.getAttachments().then((attachments) => {
                    this.pdfAttachmentViewer.render({
                      attachments
                    });
                  });
                });
                pdfDocument.getMetadata().then(({
                  info,
                  metadata,
                  contentDispositionFilename
                }) => {
                  this.documentInfo = info;
                  this.metadata = metadata;
                  this.contentDispositionFilename = contentDispositionFilename;
                  let pdfTitle;
                  const infoTitle = info && info["Title"];
                  if (infoTitle) {
                    pdfTitle = infoTitle;
                  }
                  const metadataTitle = metadata && metadata.get("dc:title");
                  if (metadataTitle) {
                    if (metadataTitle !== "Untitled" && !/[\uFFF0-\uFFFF]/g.test(metadataTitle)) {
                      pdfTitle = metadataTitle;
                    }
                  }
                  if (pdfTitle) {
                    this.setTitle(`${pdfTitle} - ${contentDispositionFilename || document.title}`);
                  } else if (contentDispositionFilename) {
                    this.setTitle(contentDispositionFilename);
                  }
                  if (info.IsAcroFormPresent) {
                    console.warn("Warning: AcroForm/XFA is not supported");
                    this.fallback(_pdf.UNSUPPORTED_FEATURES.forms);
                  }
                  let versionId = "other";
                  const KNOWN_VERSIONS = ["1.0", "1.1", "1.2", "1.3", "1.4", "1.5", "1.6", "1.7", "1.8", "1.9", "2.0", "2.1", "2.2", "2.3"];
                  if (KNOWN_VERSIONS.includes(info.PDFFormatVersion)) {
                    versionId = `v${info.PDFFormatVersion.replace(".", "_")}`;
                  }
                  let generatorId = "other";
                  const KNOWN_GENERATORS = ["acrobat distiller", "acrobat pdfwriter", "adobe livecycle", "adobe pdf library", "adobe photoshop", "ghostscript", "tcpdf", "cairo", "dvipdfm", "dvips", "pdftex", "pdfkit", "itext", "prince", "quarkxpress", "mac os x", "microsoft", "openoffice", "oracle", "luradocument", "pdf-xchange", "antenna house", "aspose.cells", "fpdf"];
                  if (info.Producer) {
                    const producer = info.Producer.toLowerCase();
                    KNOWN_GENERATORS.some(function(generator) {
                      if (!producer.includes(generator)) {
                        return false;
                      }
                      generatorId = generator.replace(/[ .\-]/g, "_");
                      return true;
                    });
                  }
                  let formType = null;
                  if (info.IsAcroFormPresent) {
                    formType = info.IsXFAPresent ? "xfa" : "acroform";
                  }
                  this.externalServices.reportTelemetry({
                    type: "documentInfo",
                    version: versionId,
                    generator: generatorId,
                    formType
                  });
                });
              },
              _initializePdfHistory({
                fingerprint,
                viewOnLoad,
                initialDest = null
              }) {
                if (_app_options.AppOptions.get("disableHistory") || this.isViewerEmbedded) {
                  return;
                }
                this.pdfHistory.initialize({
                  fingerprint,
                  resetHistory: viewOnLoad === ViewOnLoad.INITIAL,
                  updateUrl: _app_options.AppOptions.get("historyUpdateUrl")
                });
                if (this.pdfHistory.initialBookmark) {
                  this.initialBookmark = this.pdfHistory.initialBookmark;
                  this.initialRotation = this.pdfHistory.initialRotation;
                }
                if (initialDest && !this.initialBookmark && viewOnLoad === ViewOnLoad.UNKNOWN) {
                  this.initialBookmark = JSON.stringify(initialDest);
                  this.pdfHistory.push({
                    explicitDest: initialDest,
                    pageNumber: null
                  });
                }
              },
              setInitialView(storedHash, {
                rotation,
                sidebarView,
                scrollMode,
                spreadMode
              } = {}) {
                const setRotation = (angle) => {
                  if ((0, _ui_utils.isValidRotation)(angle)) {
                    this.pdfViewer.pagesRotation = angle;
                  }
                };
                const setViewerModes = (scroll, spread) => {
                  if ((0, _ui_utils.isValidScrollMode)(scroll)) {
                    this.pdfViewer.scrollMode = scroll;
                  }
                  if ((0, _ui_utils.isValidSpreadMode)(spread)) {
                    this.pdfViewer.spreadMode = spread;
                  }
                };
                this.isInitialViewSet = true;
                this.pdfSidebar.setInitialView(sidebarView);
                setViewerModes(scrollMode, spreadMode);
                if (this.initialBookmark) {
                  setRotation(this.initialRotation);
                  delete this.initialRotation;
                  this.pdfLinkService.setHash(this.initialBookmark);
                  this.initialBookmark = null;
                } else if (storedHash) {
                  setRotation(rotation);
                  this.pdfLinkService.setHash(storedHash);
                }
                this.toolbar.setPageNumber(this.pdfViewer.currentPageNumber, this.pdfViewer.currentPageLabel);
                this.secondaryToolbar.setPageNumber(this.pdfViewer.currentPageNumber);
                if (!this.pdfViewer.currentScaleValue) {
                  this.pdfViewer.currentScaleValue = _ui_utils.DEFAULT_SCALE_VALUE;
                }
              },
              cleanup() {
                if (!this.pdfDocument) {
                  return;
                }
                this.pdfViewer.cleanup();
                this.pdfThumbnailViewer.cleanup();
                if (this.pdfViewer.renderer !== _ui_utils.RendererType.SVG) {
                  this.pdfDocument.cleanup();
                }
              },
              forceRendering() {
                this.pdfRenderingQueue.printing = this.printing;
                this.pdfRenderingQueue.isThumbnailViewEnabled = this.pdfSidebar.isThumbnailViewVisible;
                this.pdfRenderingQueue.renderHighestPriority();
              },
              beforePrint() {
                if (this.printService) {
                  return;
                }
                if (!this.supportsPrinting) {
                  this.l10n.get("printing_not_supported", null, "Warning: Printing is not fully supported by this browser.").then((printMessage) => {
                    this.error(printMessage);
                  });
                  return;
                }
                if (!this.pdfViewer.pageViewsReady) {
                  this.l10n.get("printing_not_ready", null, "Warning: The PDF is not fully loaded for printing.").then((notReadyMessage) => {
                    window.alert(notReadyMessage);
                  });
                  return;
                }
                const pagesOverview = this.pdfViewer.getPagesOverview();
                const printContainer = this.appConfig.printContainer;
                const printService = PDFPrintServiceFactory.instance.createPrintService(this.pdfDocument, pagesOverview, printContainer, this.l10n);
                this.printService = printService;
                this.forceRendering();
                printService.layout();
                this.externalServices.reportTelemetry({
                  type: "print"
                });
              },
              afterPrint() {
                if (this.printService) {
                  this.printService.destroy();
                  this.printService = null;
                }
                this.forceRendering();
              },
              rotatePages(delta) {
                if (!this.pdfDocument) {
                  return;
                }
                const newRotation = (this.pdfViewer.pagesRotation + 360 + delta) % 360;
                this.pdfViewer.pagesRotation = newRotation;
              },
              requestPresentationMode() {
                if (!this.pdfPresentationMode) {
                  return;
                }
                this.pdfPresentationMode.request();
              },
              bindEvents() {
                const {
                  eventBus,
                  _boundEvents
                } = this;
                _boundEvents.beforePrint = this.beforePrint.bind(this);
                _boundEvents.afterPrint = this.afterPrint.bind(this);
                eventBus._on("resize", webViewerResize);
                eventBus._on("hashchange", webViewerHashchange);
                eventBus._on("beforeprint", _boundEvents.beforePrint);
                eventBus._on("afterprint", _boundEvents.afterPrint);
                eventBus._on("pagerendered", webViewerPageRendered);
                eventBus._on("updateviewarea", webViewerUpdateViewarea);
                eventBus._on("pagechanging", webViewerPageChanging);
                eventBus._on("scalechanging", webViewerScaleChanging);
                eventBus._on("rotationchanging", webViewerRotationChanging);
                eventBus._on("sidebarviewchanged", webViewerSidebarViewChanged);
                eventBus._on("pagemode", webViewerPageMode);
                eventBus._on("namedaction", webViewerNamedAction);
                eventBus._on("presentationmodechanged", webViewerPresentationModeChanged);
                eventBus._on("presentationmode", webViewerPresentationMode);
                eventBus._on("print", webViewerPrint);
                eventBus._on("download", webViewerDownload);
                eventBus._on("firstpage", webViewerFirstPage);
                eventBus._on("lastpage", webViewerLastPage);
                eventBus._on("nextpage", webViewerNextPage);
                eventBus._on("previouspage", webViewerPreviousPage);
                eventBus._on("zoomin", webViewerZoomIn);
                eventBus._on("zoomout", webViewerZoomOut);
                eventBus._on("zoomreset", webViewerZoomReset);
                eventBus._on("pagenumberchanged", webViewerPageNumberChanged);
                eventBus._on("scalechanged", webViewerScaleChanged);
                eventBus._on("rotatecw", webViewerRotateCw);
                eventBus._on("rotateccw", webViewerRotateCcw);
                eventBus._on("switchscrollmode", webViewerSwitchScrollMode);
                eventBus._on("scrollmodechanged", webViewerScrollModeChanged);
                eventBus._on("switchspreadmode", webViewerSwitchSpreadMode);
                eventBus._on("spreadmodechanged", webViewerSpreadModeChanged);
                eventBus._on("documentproperties", webViewerDocumentProperties);
                eventBus._on("find", webViewerFind);
                eventBus._on("findfromurlhash", webViewerFindFromUrlHash);
                eventBus._on("updatefindmatchescount", webViewerUpdateFindMatchesCount);
                eventBus._on("updatefindcontrolstate", webViewerUpdateFindControlState);
                eventBus._on("fileinputchange", webViewerFileInputChange);
                eventBus._on("openfile", webViewerOpenFile);
              },
              bindWindowEvents() {
                const {
                  eventBus,
                  _boundEvents
                } = this;
                _boundEvents.windowResize = () => {
                  eventBus.dispatch("resize", {
                    source: window
                  });
                };
                _boundEvents.windowHashChange = () => {
                  eventBus.dispatch("hashchange", {
                    source: window,
                    hash: document.location.hash.substring(1)
                  });
                };
                _boundEvents.windowBeforePrint = () => {
                  eventBus.dispatch("beforeprint", {
                    source: window
                  });
                };
                _boundEvents.windowAfterPrint = () => {
                  eventBus.dispatch("afterprint", {
                    source: window
                  });
                };
                window.addEventListener("visibilitychange", webViewerVisibilityChange);
                window.addEventListener("wheel", webViewerWheel, {
                  passive: false
                });
                window.addEventListener("click", webViewerClick);
                window.addEventListener("keydown", webViewerKeyDown);
                window.addEventListener("resize", _boundEvents.windowResize);
                window.addEventListener("hashchange", _boundEvents.windowHashChange);
                window.addEventListener("beforeprint", _boundEvents.windowBeforePrint);
                window.addEventListener("afterprint", _boundEvents.windowAfterPrint);
              },
              unbindEvents() {
                const {
                  eventBus,
                  _boundEvents
                } = this;
                eventBus._off("resize", webViewerResize);
                eventBus._off("hashchange", webViewerHashchange);
                eventBus._off("beforeprint", _boundEvents.beforePrint);
                eventBus._off("afterprint", _boundEvents.afterPrint);
                eventBus._off("pagerendered", webViewerPageRendered);
                eventBus._off("updateviewarea", webViewerUpdateViewarea);
                eventBus._off("pagechanging", webViewerPageChanging);
                eventBus._off("scalechanging", webViewerScaleChanging);
                eventBus._off("rotationchanging", webViewerRotationChanging);
                eventBus._off("sidebarviewchanged", webViewerSidebarViewChanged);
                eventBus._off("pagemode", webViewerPageMode);
                eventBus._off("namedaction", webViewerNamedAction);
                eventBus._off("presentationmodechanged", webViewerPresentationModeChanged);
                eventBus._off("presentationmode", webViewerPresentationMode);
                eventBus._off("print", webViewerPrint);
                eventBus._off("download", webViewerDownload);
                eventBus._off("firstpage", webViewerFirstPage);
                eventBus._off("lastpage", webViewerLastPage);
                eventBus._off("nextpage", webViewerNextPage);
                eventBus._off("previouspage", webViewerPreviousPage);
                eventBus._off("zoomin", webViewerZoomIn);
                eventBus._off("zoomout", webViewerZoomOut);
                eventBus._off("zoomreset", webViewerZoomReset);
                eventBus._off("pagenumberchanged", webViewerPageNumberChanged);
                eventBus._off("scalechanged", webViewerScaleChanged);
                eventBus._off("rotatecw", webViewerRotateCw);
                eventBus._off("rotateccw", webViewerRotateCcw);
                eventBus._off("switchscrollmode", webViewerSwitchScrollMode);
                eventBus._off("scrollmodechanged", webViewerScrollModeChanged);
                eventBus._off("switchspreadmode", webViewerSwitchSpreadMode);
                eventBus._off("spreadmodechanged", webViewerSpreadModeChanged);
                eventBus._off("documentproperties", webViewerDocumentProperties);
                eventBus._off("find", webViewerFind);
                eventBus._off("findfromurlhash", webViewerFindFromUrlHash);
                eventBus._off("updatefindmatchescount", webViewerUpdateFindMatchesCount);
                eventBus._off("updatefindcontrolstate", webViewerUpdateFindControlState);
                eventBus._off("fileinputchange", webViewerFileInputChange);
                eventBus._off("openfile", webViewerOpenFile);
                _boundEvents.beforePrint = null;
                _boundEvents.afterPrint = null;
              },
              unbindWindowEvents() {
                const {
                  _boundEvents
                } = this;
                window.removeEventListener("visibilitychange", webViewerVisibilityChange);
                window.removeEventListener("wheel", webViewerWheel);
                window.removeEventListener("click", webViewerClick);
                window.removeEventListener("keydown", webViewerKeyDown);
                window.removeEventListener("resize", _boundEvents.windowResize);
                window.removeEventListener("hashchange", _boundEvents.windowHashChange);
                window.removeEventListener("beforeprint", _boundEvents.windowBeforePrint);
                window.removeEventListener("afterprint", _boundEvents.windowAfterPrint);
                _boundEvents.windowResize = null;
                _boundEvents.windowHashChange = null;
                _boundEvents.windowBeforePrint = null;
                _boundEvents.windowAfterPrint = null;
              }
            };
            exports2.PDFViewerApplication = PDFViewerApplication;
            let validateFileURL;
            {
              const HOSTED_VIEWER_ORIGINS = ["null", "http://mozilla.github.io", "https://mozilla.github.io"];
              validateFileURL = function(file) {
                if (file === void 0) {
                  return;
                }
                try {
                  const viewerOrigin = new URL(window.location.href).origin || "null";
                  if (HOSTED_VIEWER_ORIGINS.includes(viewerOrigin)) {
                    return;
                  }
                  const {
                    origin,
                    protocol
                  } = new URL(file, window.location.href);
                  if (origin !== viewerOrigin && protocol !== "blob:") {
                    throw new Error("file origin does not match viewer's");
                  }
                } catch (ex) {
                  const message = ex && ex.message;
                  PDFViewerApplication.l10n.get("loading_error", null, "An error occurred while loading the PDF.").then((loadingErrorMessage) => {
                    PDFViewerApplication.error(loadingErrorMessage, {
                      message
                    });
                  });
                  throw ex;
                }
              };
            }
            async function loadFakeWorker() {
              if (!_pdf.GlobalWorkerOptions.workerSrc) {
                _pdf.GlobalWorkerOptions.workerSrc = _app_options.AppOptions.get("workerSrc");
              }
              return (0, _pdf.loadScript)(_pdf.PDFWorker.getWorkerSrc());
            }
            function loadAndEnablePDFBug(enabledTabs) {
              const appConfig = PDFViewerApplication.appConfig;
              return (0, _pdf.loadScript)(appConfig.debuggerScriptPath).then(function() {
                PDFBug.enable(enabledTabs);
                PDFBug.init({
                  OPS: _pdf.OPS
                }, appConfig.mainContainer);
              });
            }
            function webViewerInitialized() {
              const appConfig = PDFViewerApplication.appConfig;
              let file;
              const queryString = document.location.search.substring(1);
              const params = (0, _ui_utils.parseQueryString)(queryString);
              file = "file" in params ? params.file : _app_options.AppOptions.get("defaultUrl");
              validateFileURL(file);
              const fileInput = document.createElement("input");
              fileInput.id = appConfig.openFileInputName;
              fileInput.className = "fileInput";
              fileInput.setAttribute("type", "file");
              fileInput.oncontextmenu = _ui_utils.noContextMenuHandler;
              document.body.appendChild(fileInput);
              if (!window.File || !window.FileReader || !window.FileList || !window.Blob) {
                appConfig.toolbar.openFile.setAttribute("hidden", "true");
                appConfig.secondaryToolbar.openFileButton.setAttribute("hidden", "true");
              } else {
                fileInput.value = null;
              }
              fileInput.addEventListener("change", function(evt) {
                const files = evt.target.files;
                if (!files || files.length === 0) {
                  return;
                }
                PDFViewerApplication.eventBus.dispatch("fileinputchange", {
                  source: this,
                  fileInput: evt.target
                });
              });
              appConfig.mainContainer.addEventListener("dragover", function(evt) {
                evt.preventDefault();
                evt.dataTransfer.dropEffect = "move";
              });
              appConfig.mainContainer.addEventListener("drop", function(evt) {
                evt.preventDefault();
                const files = evt.dataTransfer.files;
                if (!files || files.length === 0) {
                  return;
                }
                PDFViewerApplication.eventBus.dispatch("fileinputchange", {
                  source: this,
                  fileInput: evt.dataTransfer
                });
              });
              if (!PDFViewerApplication.supportsDocumentFonts) {
                _app_options.AppOptions.set("disableFontFace", true);
                PDFViewerApplication.l10n.get("web_fonts_disabled", null, "Web fonts are disabled: unable to use embedded PDF fonts.").then((msg) => {
                  console.warn(msg);
                });
              }
              if (!PDFViewerApplication.supportsPrinting) {
                appConfig.toolbar.print.classList.add("hidden");
                appConfig.secondaryToolbar.printButton.classList.add("hidden");
              }
              if (!PDFViewerApplication.supportsFullscreen) {
                appConfig.toolbar.presentationModeButton.classList.add("hidden");
                appConfig.secondaryToolbar.presentationModeButton.classList.add("hidden");
              }
              if (PDFViewerApplication.supportsIntegratedFind) {
                appConfig.toolbar.viewFind.classList.add("hidden");
              }
              appConfig.mainContainer.addEventListener("transitionend", function(evt) {
                if (evt.target === this) {
                  PDFViewerApplication.eventBus.dispatch("resize", {
                    source: this
                  });
                }
              }, true);
              try {
                webViewerOpenFileViaURL(file);
              } catch (reason) {
                PDFViewerApplication.l10n.get("loading_error", null, "An error occurred while loading the PDF.").then((msg) => {
                  PDFViewerApplication.error(msg, reason);
                });
              }
            }
            let webViewerOpenFileViaURL;
            {
              webViewerOpenFileViaURL = function(file) {
                if (file && file.lastIndexOf("file:", 0) === 0) {
                  PDFViewerApplication.setTitleUsingUrl(file);
                  const xhr = new XMLHttpRequest();
                  xhr.onload = function() {
                    PDFViewerApplication.open(new Uint8Array(xhr.response));
                  };
                  xhr.open("GET", file);
                  xhr.responseType = "arraybuffer";
                  xhr.send();
                  return;
                }
                if (file) {
                  PDFViewerApplication.open(file);
                }
              };
            }
            function webViewerPageRendered(evt) {
              const pageNumber = evt.pageNumber;
              const pageIndex = pageNumber - 1;
              const pageView = PDFViewerApplication.pdfViewer.getPageView(pageIndex);
              if (pageNumber === PDFViewerApplication.page) {
                PDFViewerApplication.toolbar.updateLoadingIndicatorState(false);
              }
              if (!pageView) {
                return;
              }
              if (PDFViewerApplication.pdfSidebar.isThumbnailViewVisible) {
                const thumbnailView = PDFViewerApplication.pdfThumbnailViewer.getThumbnail(pageIndex);
                thumbnailView.setImage(pageView);
              }
              if (typeof Stats !== "undefined" && Stats.enabled && pageView.stats) {
                Stats.add(pageNumber, pageView.stats);
              }
              if (pageView.error) {
                PDFViewerApplication.l10n.get("rendering_error", null, "An error occurred while rendering the page.").then((msg) => {
                  PDFViewerApplication.error(msg, pageView.error);
                });
              }
              PDFViewerApplication.externalServices.reportTelemetry({
                type: "pageInfo",
                timestamp: evt.timestamp
              });
              PDFViewerApplication.pdfDocument.getStats().then(function(stats) {
                PDFViewerApplication.externalServices.reportTelemetry({
                  type: "documentStats",
                  stats
                });
              });
            }
            function webViewerPageMode({
              mode
            }) {
              let view;
              switch (mode) {
                case "thumbs":
                  view = _pdf_sidebar.SidebarView.THUMBS;
                  break;
                case "bookmarks":
                case "outline":
                  view = _pdf_sidebar.SidebarView.OUTLINE;
                  break;
                case "attachments":
                  view = _pdf_sidebar.SidebarView.ATTACHMENTS;
                  break;
                case "none":
                  view = _pdf_sidebar.SidebarView.NONE;
                  break;
                default:
                  console.error('Invalid "pagemode" hash parameter: ' + mode);
                  return;
              }
              PDFViewerApplication.pdfSidebar.switchView(view, true);
            }
            function webViewerNamedAction(evt) {
              const action = evt.action;
              switch (action) {
                case "GoToPage":
                  PDFViewerApplication.appConfig.toolbar.pageNumber.select();
                  break;
                case "Find":
                  if (!PDFViewerApplication.supportsIntegratedFind) {
                    PDFViewerApplication.findBar.toggle();
                  }
                  break;
              }
            }
            function webViewerPresentationModeChanged({
              active,
              switchInProgress
            }) {
              let state = _ui_utils.PresentationModeState.NORMAL;
              if (switchInProgress) {
                state = _ui_utils.PresentationModeState.CHANGING;
              } else if (active) {
                state = _ui_utils.PresentationModeState.FULLSCREEN;
              }
              PDFViewerApplication.pdfViewer.presentationModeState = state;
            }
            function webViewerSidebarViewChanged(evt) {
              PDFViewerApplication.pdfRenderingQueue.isThumbnailViewEnabled = PDFViewerApplication.pdfSidebar.isThumbnailViewVisible;
              const store = PDFViewerApplication.store;
              if (store && PDFViewerApplication.isInitialViewSet) {
                store.set("sidebarView", evt.view).catch(function() {
                });
              }
            }
            function webViewerUpdateViewarea(evt) {
              const location = evt.location, store = PDFViewerApplication.store;
              if (store && PDFViewerApplication.isInitialViewSet) {
                store.setMultiple({
                  page: location.pageNumber,
                  zoom: location.scale,
                  scrollLeft: location.left,
                  scrollTop: location.top,
                  rotation: location.rotation
                }).catch(function() {
                });
              }
              const href = PDFViewerApplication.pdfLinkService.getAnchorUrl(location.pdfOpenParams);
              PDFViewerApplication.appConfig.toolbar.viewBookmark.href = href;
              PDFViewerApplication.appConfig.secondaryToolbar.viewBookmarkButton.href = href;
              const currentPage = PDFViewerApplication.pdfViewer.getPageView(PDFViewerApplication.page - 1);
              const loading = currentPage.renderingState !== _pdf_rendering_queue.RenderingStates.FINISHED;
              PDFViewerApplication.toolbar.updateLoadingIndicatorState(loading);
            }
            function webViewerScrollModeChanged(evt) {
              const store = PDFViewerApplication.store;
              if (store && PDFViewerApplication.isInitialViewSet) {
                store.set("scrollMode", evt.mode).catch(function() {
                });
              }
            }
            function webViewerSpreadModeChanged(evt) {
              const store = PDFViewerApplication.store;
              if (store && PDFViewerApplication.isInitialViewSet) {
                store.set("spreadMode", evt.mode).catch(function() {
                });
              }
            }
            function webViewerResize() {
              const {
                pdfDocument,
                pdfViewer
              } = PDFViewerApplication;
              if (!pdfDocument) {
                return;
              }
              const currentScaleValue = pdfViewer.currentScaleValue;
              if (currentScaleValue === "auto" || currentScaleValue === "page-fit" || currentScaleValue === "page-width") {
                pdfViewer.currentScaleValue = currentScaleValue;
              }
              pdfViewer.update();
            }
            function webViewerHashchange(evt) {
              const hash = evt.hash;
              if (!hash) {
                return;
              }
              if (!PDFViewerApplication.isInitialViewSet) {
                PDFViewerApplication.initialBookmark = hash;
              } else if (!PDFViewerApplication.pdfHistory.popStateInProgress) {
                PDFViewerApplication.pdfLinkService.setHash(hash);
              }
            }
            let webViewerFileInputChange, webViewerOpenFile;
            {
              webViewerFileInputChange = function(evt) {
                if (PDFViewerApplication.pdfViewer && PDFViewerApplication.pdfViewer.isInPresentationMode) {
                  return;
                }
                const file = evt.fileInput.files[0];
                if (URL.createObjectURL && !_app_options.AppOptions.get("disableCreateObjectURL")) {
                  let url = URL.createObjectURL(file);
                  if (file.name) {
                    url = {
                      url,
                      originalUrl: file.name
                    };
                  }
                  PDFViewerApplication.open(url);
                } else {
                  PDFViewerApplication.setTitleUsingUrl(file.name);
                  const fileReader = new FileReader();
                  fileReader.onload = function webViewerChangeFileReaderOnload(event) {
                    const buffer = event.target.result;
                    PDFViewerApplication.open(new Uint8Array(buffer));
                  };
                  fileReader.readAsArrayBuffer(file);
                }
                const appConfig = PDFViewerApplication.appConfig;
                appConfig.toolbar.viewBookmark.setAttribute("hidden", "true");
                appConfig.secondaryToolbar.viewBookmarkButton.setAttribute("hidden", "true");
                appConfig.toolbar.download.setAttribute("hidden", "true");
                appConfig.secondaryToolbar.downloadButton.setAttribute("hidden", "true");
              };
              webViewerOpenFile = function(evt) {
                const openFileInputName = PDFViewerApplication.appConfig.openFileInputName;
                document.getElementById(openFileInputName).click();
              };
            }
            function webViewerPresentationMode() {
              PDFViewerApplication.requestPresentationMode();
            }
            function webViewerPrint() {
              window.print();
            }
            function webViewerDownload() {
              PDFViewerApplication.download();
            }
            function webViewerFirstPage() {
              if (PDFViewerApplication.pdfDocument) {
                PDFViewerApplication.page = 1;
              }
            }
            function webViewerLastPage() {
              if (PDFViewerApplication.pdfDocument) {
                PDFViewerApplication.page = PDFViewerApplication.pagesCount;
              }
            }
            function webViewerNextPage() {
              PDFViewerApplication.page++;
            }
            function webViewerPreviousPage() {
              PDFViewerApplication.page--;
            }
            function webViewerZoomIn() {
              PDFViewerApplication.zoomIn();
            }
            function webViewerZoomOut() {
              PDFViewerApplication.zoomOut();
            }
            function webViewerZoomReset() {
              PDFViewerApplication.zoomReset();
            }
            function webViewerPageNumberChanged(evt) {
              const pdfViewer = PDFViewerApplication.pdfViewer;
              if (evt.value !== "") {
                pdfViewer.currentPageLabel = evt.value;
              }
              if (evt.value !== pdfViewer.currentPageNumber.toString() && evt.value !== pdfViewer.currentPageLabel) {
                PDFViewerApplication.toolbar.setPageNumber(pdfViewer.currentPageNumber, pdfViewer.currentPageLabel);
              }
            }
            function webViewerScaleChanged(evt) {
              PDFViewerApplication.pdfViewer.currentScaleValue = evt.value;
            }
            function webViewerRotateCw() {
              PDFViewerApplication.rotatePages(90);
            }
            function webViewerRotateCcw() {
              PDFViewerApplication.rotatePages(-90);
            }
            function webViewerSwitchScrollMode(evt) {
              PDFViewerApplication.pdfViewer.scrollMode = evt.mode;
            }
            function webViewerSwitchSpreadMode(evt) {
              PDFViewerApplication.pdfViewer.spreadMode = evt.mode;
            }
            function webViewerDocumentProperties() {
              PDFViewerApplication.pdfDocumentProperties.open();
            }
            function webViewerFind(evt) {
              PDFViewerApplication.findController.executeCommand("find" + evt.type, {
                query: evt.query,
                phraseSearch: evt.phraseSearch,
                caseSensitive: evt.caseSensitive,
                entireWord: evt.entireWord,
                highlightAll: evt.highlightAll,
                findPrevious: evt.findPrevious
              });
            }
            function webViewerFindFromUrlHash(evt) {
              PDFViewerApplication.findController.executeCommand("find", {
                query: evt.query,
                phraseSearch: evt.phraseSearch,
                caseSensitive: false,
                entireWord: false,
                highlightAll: true,
                findPrevious: false
              });
            }
            function webViewerUpdateFindMatchesCount({
              matchesCount
            }) {
              if (PDFViewerApplication.supportsIntegratedFind) {
                PDFViewerApplication.externalServices.updateFindMatchesCount(matchesCount);
              } else {
                PDFViewerApplication.findBar.updateResultsCount(matchesCount);
              }
            }
            function webViewerUpdateFindControlState({
              state,
              previous,
              matchesCount
            }) {
              if (PDFViewerApplication.supportsIntegratedFind) {
                PDFViewerApplication.externalServices.updateFindControlState({
                  result: state,
                  findPrevious: previous,
                  matchesCount
                });
              } else {
                PDFViewerApplication.findBar.updateUIState(state, previous, matchesCount);
              }
            }
            function webViewerScaleChanging(evt) {
              PDFViewerApplication.toolbar.setPageScale(evt.presetValue, evt.scale);
              PDFViewerApplication.pdfViewer.update();
            }
            function webViewerRotationChanging(evt) {
              PDFViewerApplication.pdfThumbnailViewer.pagesRotation = evt.pagesRotation;
              PDFViewerApplication.forceRendering();
              PDFViewerApplication.pdfViewer.currentPageNumber = evt.pageNumber;
            }
            function webViewerPageChanging(evt) {
              const page = evt.pageNumber;
              PDFViewerApplication.toolbar.setPageNumber(page, evt.pageLabel || null);
              PDFViewerApplication.secondaryToolbar.setPageNumber(page);
              if (PDFViewerApplication.pdfSidebar.isThumbnailViewVisible) {
                PDFViewerApplication.pdfThumbnailViewer.scrollThumbnailIntoView(page);
              }
              if (typeof Stats !== "undefined" && Stats.enabled) {
                const pageView = PDFViewerApplication.pdfViewer.getPageView(page - 1);
                if (pageView && pageView.stats) {
                  Stats.add(page, pageView.stats);
                }
              }
            }
            function webViewerVisibilityChange(evt) {
              if (document.visibilityState === "visible") {
                setZoomDisabledTimeout();
              }
            }
            let zoomDisabledTimeout = null;
            function setZoomDisabledTimeout() {
              if (zoomDisabledTimeout) {
                clearTimeout(zoomDisabledTimeout);
              }
              zoomDisabledTimeout = setTimeout(function() {
                zoomDisabledTimeout = null;
              }, WHEEL_ZOOM_DISABLED_TIMEOUT);
            }
            function webViewerWheel(evt) {
              const {
                pdfViewer,
                supportedMouseWheelZoomModifierKeys
              } = PDFViewerApplication;
              if (pdfViewer.isInPresentationMode) {
                return;
              }
              if (evt.ctrlKey && supportedMouseWheelZoomModifierKeys.ctrlKey || evt.metaKey && supportedMouseWheelZoomModifierKeys.metaKey) {
                evt.preventDefault();
                if (zoomDisabledTimeout || document.visibilityState === "hidden") {
                  return;
                }
                const previousScale = pdfViewer.currentScale;
                const delta = (0, _ui_utils.normalizeWheelEventDelta)(evt);
                const MOUSE_WHEEL_DELTA_PER_PAGE_SCALE = 3;
                const ticks = delta * MOUSE_WHEEL_DELTA_PER_PAGE_SCALE;
                if (ticks < 0) {
                  PDFViewerApplication.zoomOut(-ticks);
                } else {
                  PDFViewerApplication.zoomIn(ticks);
                }
                const currentScale = pdfViewer.currentScale;
                if (previousScale !== currentScale) {
                  const scaleCorrectionFactor = currentScale / previousScale - 1;
                  const rect = pdfViewer.container.getBoundingClientRect();
                  const dx = evt.clientX - rect.left;
                  const dy = evt.clientY - rect.top;
                  pdfViewer.container.scrollLeft += dx * scaleCorrectionFactor;
                  pdfViewer.container.scrollTop += dy * scaleCorrectionFactor;
                }
              } else {
                setZoomDisabledTimeout();
              }
            }
            function webViewerClick(evt) {
              if (!PDFViewerApplication.secondaryToolbar.isOpen) {
                return;
              }
              const appConfig = PDFViewerApplication.appConfig;
              if (PDFViewerApplication.pdfViewer.containsElement(evt.target) || appConfig.toolbar.container.contains(evt.target) && evt.target !== appConfig.secondaryToolbar.toggleButton) {
                PDFViewerApplication.secondaryToolbar.close();
              }
            }
            function webViewerKeyDown(evt) {
              if (PDFViewerApplication.overlayManager.active) {
                return;
              }
              let handled = false, ensureViewerFocused = false;
              const cmd = (evt.ctrlKey ? 1 : 0) | (evt.altKey ? 2 : 0) | (evt.shiftKey ? 4 : 0) | (evt.metaKey ? 8 : 0);
              const pdfViewer = PDFViewerApplication.pdfViewer;
              const isViewerInPresentationMode = pdfViewer && pdfViewer.isInPresentationMode;
              if (cmd === 1 || cmd === 8 || cmd === 5 || cmd === 12) {
                switch (evt.keyCode) {
                  case 70:
                    if (!PDFViewerApplication.supportsIntegratedFind) {
                      PDFViewerApplication.findBar.open();
                      handled = true;
                    }
                    break;
                  case 71:
                    if (!PDFViewerApplication.supportsIntegratedFind) {
                      const findState = PDFViewerApplication.findController.state;
                      if (findState) {
                        PDFViewerApplication.findController.executeCommand("findagain", {
                          query: findState.query,
                          phraseSearch: findState.phraseSearch,
                          caseSensitive: findState.caseSensitive,
                          entireWord: findState.entireWord,
                          highlightAll: findState.highlightAll,
                          findPrevious: cmd === 5 || cmd === 12
                        });
                      }
                      handled = true;
                    }
                    break;
                  case 61:
                  case 107:
                  case 187:
                  case 171:
                    if (!isViewerInPresentationMode) {
                      PDFViewerApplication.zoomIn();
                    }
                    handled = true;
                    break;
                  case 173:
                  case 109:
                  case 189:
                    if (!isViewerInPresentationMode) {
                      PDFViewerApplication.zoomOut();
                    }
                    handled = true;
                    break;
                  case 48:
                  case 96:
                    if (!isViewerInPresentationMode) {
                      setTimeout(function() {
                        PDFViewerApplication.zoomReset();
                      });
                      handled = false;
                    }
                    break;
                  case 38:
                    if (isViewerInPresentationMode || PDFViewerApplication.page > 1) {
                      PDFViewerApplication.page = 1;
                      handled = true;
                      ensureViewerFocused = true;
                    }
                    break;
                  case 40:
                    if (isViewerInPresentationMode || PDFViewerApplication.page < PDFViewerApplication.pagesCount) {
                      PDFViewerApplication.page = PDFViewerApplication.pagesCount;
                      handled = true;
                      ensureViewerFocused = true;
                    }
                    break;
                }
              }
              if (cmd === 1 || cmd === 8) {
                switch (evt.keyCode) {
                  case 83:
                    PDFViewerApplication.download();
                    handled = true;
                    break;
                }
              }
              if (cmd === 3 || cmd === 10) {
                switch (evt.keyCode) {
                  case 80:
                    PDFViewerApplication.requestPresentationMode();
                    handled = true;
                    break;
                  case 71:
                    PDFViewerApplication.appConfig.toolbar.pageNumber.select();
                    handled = true;
                    break;
                }
              }
              if (handled) {
                if (ensureViewerFocused && !isViewerInPresentationMode) {
                  pdfViewer.focus();
                }
                evt.preventDefault();
                return;
              }
              const curElement = document.activeElement || document.querySelector(":focus");
              const curElementTagName = curElement && curElement.tagName.toUpperCase();
              if (curElementTagName === "INPUT" || curElementTagName === "TEXTAREA" || curElementTagName === "SELECT" || curElement && curElement.isContentEditable) {
                if (evt.keyCode !== 27) {
                  return;
                }
              }
              if (cmd === 0) {
                let turnPage = 0, turnOnlyIfPageFit = false;
                switch (evt.keyCode) {
                  case 38:
                  case 33:
                    if (pdfViewer.isVerticalScrollbarEnabled) {
                      turnOnlyIfPageFit = true;
                    }
                    turnPage = -1;
                    break;
                  case 8:
                    if (!isViewerInPresentationMode) {
                      turnOnlyIfPageFit = true;
                    }
                    turnPage = -1;
                    break;
                  case 37:
                    if (pdfViewer.isHorizontalScrollbarEnabled) {
                      turnOnlyIfPageFit = true;
                    }
                  case 75:
                  case 80:
                    turnPage = -1;
                    break;
                  case 27:
                    if (PDFViewerApplication.secondaryToolbar.isOpen) {
                      PDFViewerApplication.secondaryToolbar.close();
                      handled = true;
                    }
                    if (!PDFViewerApplication.supportsIntegratedFind && PDFViewerApplication.findBar.opened) {
                      PDFViewerApplication.findBar.close();
                      handled = true;
                    }
                    break;
                  case 40:
                  case 34:
                    if (pdfViewer.isVerticalScrollbarEnabled) {
                      turnOnlyIfPageFit = true;
                    }
                    turnPage = 1;
                    break;
                  case 13:
                  case 32:
                    if (!isViewerInPresentationMode) {
                      turnOnlyIfPageFit = true;
                    }
                    turnPage = 1;
                    break;
                  case 39:
                    if (pdfViewer.isHorizontalScrollbarEnabled) {
                      turnOnlyIfPageFit = true;
                    }
                  case 74:
                  case 78:
                    turnPage = 1;
                    break;
                  case 36:
                    if (isViewerInPresentationMode || PDFViewerApplication.page > 1) {
                      PDFViewerApplication.page = 1;
                      handled = true;
                      ensureViewerFocused = true;
                    }
                    break;
                  case 35:
                    if (isViewerInPresentationMode || PDFViewerApplication.page < PDFViewerApplication.pagesCount) {
                      PDFViewerApplication.page = PDFViewerApplication.pagesCount;
                      handled = true;
                      ensureViewerFocused = true;
                    }
                    break;
                  case 83:
                    PDFViewerApplication.pdfCursorTools.switchTool(_pdf_cursor_tools.CursorTool.SELECT);
                    break;
                  case 72:
                    PDFViewerApplication.pdfCursorTools.switchTool(_pdf_cursor_tools.CursorTool.HAND);
                    break;
                  case 82:
                    PDFViewerApplication.rotatePages(90);
                    break;
                  case 115:
                    PDFViewerApplication.pdfSidebar.toggle();
                    break;
                }
                if (turnPage !== 0 && (!turnOnlyIfPageFit || pdfViewer.currentScaleValue === "page-fit")) {
                  if (turnPage > 0) {
                    if (PDFViewerApplication.page < PDFViewerApplication.pagesCount) {
                      PDFViewerApplication.page++;
                    }
                  } else {
                    if (PDFViewerApplication.page > 1) {
                      PDFViewerApplication.page--;
                    }
                  }
                  handled = true;
                }
              }
              if (cmd === 4) {
                switch (evt.keyCode) {
                  case 13:
                  case 32:
                    if (!isViewerInPresentationMode && pdfViewer.currentScaleValue !== "page-fit") {
                      break;
                    }
                    if (PDFViewerApplication.page > 1) {
                      PDFViewerApplication.page--;
                    }
                    handled = true;
                    break;
                  case 82:
                    PDFViewerApplication.rotatePages(-90);
                    break;
                }
              }
              if (!handled && !isViewerInPresentationMode) {
                if (evt.keyCode >= 33 && evt.keyCode <= 40 || evt.keyCode === 32 && curElementTagName !== "BUTTON") {
                  ensureViewerFocused = true;
                }
              }
              if (ensureViewerFocused && !pdfViewer.containsElement(curElement)) {
                pdfViewer.focus();
              }
              if (handled) {
                evt.preventDefault();
              }
            }
            function apiPageLayoutToSpreadMode(layout) {
              switch (layout) {
                case "SinglePage":
                case "OneColumn":
                  return _ui_utils.SpreadMode.NONE;
                case "TwoColumnLeft":
                case "TwoPageLeft":
                  return _ui_utils.SpreadMode.ODD;
                case "TwoColumnRight":
                case "TwoPageRight":
                  return _ui_utils.SpreadMode.EVEN;
              }
              return _ui_utils.SpreadMode.NONE;
            }
            function apiPageModeToSidebarView(mode) {
              switch (mode) {
                case "UseNone":
                  return _pdf_sidebar.SidebarView.NONE;
                case "UseThumbs":
                  return _pdf_sidebar.SidebarView.THUMBS;
                case "UseOutlines":
                  return _pdf_sidebar.SidebarView.OUTLINE;
                case "UseAttachments":
                  return _pdf_sidebar.SidebarView.ATTACHMENTS;
                case "UseOC":
              }
              return _pdf_sidebar.SidebarView.NONE;
            }
            const PDFPrintServiceFactory = {
              instance: {
                supportsPrinting: false,
                createPrintService() {
                  throw new Error("Not implemented: createPrintService");
                }
              }
            };
            exports2.PDFPrintServiceFactory = PDFPrintServiceFactory;
          },
          1958: function(__unused_webpack_module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.OptionKind = exports2.AppOptions = void 0;
            var _pdf = __webpack_require__2(3941);
            var _viewer_compatibility = __webpack_require__2(55);
            const OptionKind = {
              VIEWER: 2,
              API: 4,
              WORKER: 8,
              PREFERENCE: 128
            };
            exports2.OptionKind = OptionKind;
            const defaultOptions = {
              cursorToolOnLoad: {
                value: 0,
                kind: OptionKind.VIEWER + OptionKind.PREFERENCE
              },
              defaultUrl: {
                value: "compressed.tracemonkey-pldi-09.pdf",
                kind: OptionKind.VIEWER
              },
              defaultZoomValue: {
                value: "",
                kind: OptionKind.VIEWER + OptionKind.PREFERENCE
              },
              disableHistory: {
                value: false,
                kind: OptionKind.VIEWER
              },
              disablePageLabels: {
                value: false,
                kind: OptionKind.VIEWER + OptionKind.PREFERENCE
              },
              enablePrintAutoRotate: {
                value: false,
                kind: OptionKind.VIEWER + OptionKind.PREFERENCE
              },
              enableWebGL: {
                value: false,
                kind: OptionKind.VIEWER + OptionKind.PREFERENCE
              },
              eventBusDispatchToDOM: {
                value: false,
                kind: OptionKind.VIEWER + OptionKind.PREFERENCE
              },
              externalLinkRel: {
                value: "noopener noreferrer nofollow",
                kind: OptionKind.VIEWER
              },
              externalLinkTarget: {
                value: 0,
                kind: OptionKind.VIEWER + OptionKind.PREFERENCE
              },
              historyUpdateUrl: {
                value: false,
                kind: OptionKind.VIEWER + OptionKind.PREFERENCE
              },
              ignoreDestinationZoom: {
                value: false,
                kind: OptionKind.VIEWER + OptionKind.PREFERENCE
              },
              imageResourcesPath: {
                value: "./images/",
                kind: OptionKind.VIEWER
              },
              maxCanvasPixels: {
                value: 16777216,
                compatibility: _viewer_compatibility.viewerCompatibilityParams.maxCanvasPixels,
                kind: OptionKind.VIEWER
              },
              pdfBugEnabled: {
                value: false,
                kind: OptionKind.VIEWER + OptionKind.PREFERENCE
              },
              renderer: {
                value: "canvas",
                kind: OptionKind.VIEWER + OptionKind.PREFERENCE
              },
              renderInteractiveForms: {
                value: false,
                kind: OptionKind.VIEWER + OptionKind.PREFERENCE
              },
              sidebarViewOnLoad: {
                value: -1,
                kind: OptionKind.VIEWER + OptionKind.PREFERENCE
              },
              scrollModeOnLoad: {
                value: -1,
                kind: OptionKind.VIEWER + OptionKind.PREFERENCE
              },
              spreadModeOnLoad: {
                value: -1,
                kind: OptionKind.VIEWER + OptionKind.PREFERENCE
              },
              textLayerMode: {
                value: 1,
                kind: OptionKind.VIEWER + OptionKind.PREFERENCE
              },
              useOnlyCssZoom: {
                value: false,
                kind: OptionKind.VIEWER + OptionKind.PREFERENCE
              },
              viewOnLoad: {
                value: 0,
                kind: OptionKind.VIEWER + OptionKind.PREFERENCE
              },
              cMapPacked: {
                value: true,
                kind: OptionKind.API
              },
              cMapUrl: {
                value: "../web/cmaps/",
                kind: OptionKind.API
              },
              disableAutoFetch: {
                value: false,
                kind: OptionKind.API + OptionKind.PREFERENCE
              },
              disableCreateObjectURL: {
                value: false,
                compatibility: _pdf.apiCompatibilityParams.disableCreateObjectURL,
                kind: OptionKind.API
              },
              disableFontFace: {
                value: false,
                kind: OptionKind.API + OptionKind.PREFERENCE
              },
              disableRange: {
                value: false,
                kind: OptionKind.API + OptionKind.PREFERENCE
              },
              disableStream: {
                value: false,
                kind: OptionKind.API + OptionKind.PREFERENCE
              },
              docBaseUrl: {
                value: "",
                kind: OptionKind.API
              },
              isEvalSupported: {
                value: true,
                kind: OptionKind.API
              },
              maxImageSize: {
                value: -1,
                kind: OptionKind.API
              },
              pdfBug: {
                value: false,
                kind: OptionKind.API
              },
              verbosity: {
                value: 1,
                kind: OptionKind.API
              },
              workerPort: {
                value: null,
                kind: OptionKind.WORKER
              },
              workerSrc: {
                value: "../build/pdf.worker.js",
                kind: OptionKind.WORKER
              }
            };
            ;
            const userOptions = /* @__PURE__ */ Object.create(null);
            class AppOptions {
              constructor() {
                throw new Error("Cannot initialize AppOptions.");
              }
              static get(name) {
                const userOption = userOptions[name];
                if (userOption !== void 0) {
                  return userOption;
                }
                const defaultOption = defaultOptions[name];
                if (defaultOption !== void 0) {
                  return defaultOption.compatibility || defaultOption.value;
                }
                return void 0;
              }
              static getAll(kind = null) {
                const options = /* @__PURE__ */ Object.create(null);
                for (const name in defaultOptions) {
                  const defaultOption = defaultOptions[name];
                  if (kind) {
                    if ((kind & defaultOption.kind) === 0) {
                      continue;
                    }
                    if (kind === OptionKind.PREFERENCE) {
                      const value = defaultOption.value, valueType = typeof value;
                      if (valueType === "boolean" || valueType === "string" || valueType === "number" && Number.isInteger(value)) {
                        options[name] = value;
                        continue;
                      }
                      throw new Error(`Invalid type for preference: ${name}`);
                    }
                  }
                  const userOption = userOptions[name];
                  options[name] = userOption !== void 0 ? userOption : defaultOption.compatibility || defaultOption.value;
                }
                return options;
              }
              static set(name, value) {
                userOptions[name] = value;
              }
              static remove(name) {
                delete userOptions[name];
              }
            }
            exports2.AppOptions = AppOptions;
          },
          5710: function(__unused_webpack_module2, exports2, __webpack_require__2) {
            "use strict";
            __webpack_require__2(7658);
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.BaseViewer = void 0;
            var _ui_utils = __webpack_require__2(5570);
            var _pdf_rendering_queue = __webpack_require__2(7807);
            var _annotation_layer_builder = __webpack_require__2(5346);
            var _pdf = __webpack_require__2(3941);
            var _pdf_page_view = __webpack_require__2(9016);
            var _pdf_link_service = __webpack_require__2(2388);
            var _text_layer_builder = __webpack_require__2(5645);
            const DEFAULT_CACHE_SIZE = 10;
            function PDFPageViewBuffer(size) {
              const data = [];
              this.push = function(view) {
                const i = data.indexOf(view);
                if (i >= 0) {
                  data.splice(i, 1);
                }
                data.push(view);
                if (data.length > size) {
                  data.shift().destroy();
                }
              };
              this.resize = function(newSize, pagesToKeep) {
                size = newSize;
                if (pagesToKeep) {
                  const pageIdsToKeep = /* @__PURE__ */ new Set();
                  for (let i = 0, iMax = pagesToKeep.length; i < iMax; ++i) {
                    pageIdsToKeep.add(pagesToKeep[i].id);
                  }
                  (0, _ui_utils.moveToEndOfArray)(data, function(page) {
                    return pageIdsToKeep.has(page.id);
                  });
                }
                while (data.length > size) {
                  data.shift().destroy();
                }
              };
            }
            function isSameScale(oldScale, newScale) {
              if (newScale === oldScale) {
                return true;
              }
              if (Math.abs(newScale - oldScale) < 1e-15) {
                return true;
              }
              return false;
            }
            class BaseViewer {
              constructor(options) {
                if (this.constructor === BaseViewer) {
                  throw new Error("Cannot initialize BaseViewer.");
                }
                this._name = this.constructor.name;
                this.container = options.container;
                this.viewer = options.viewer || options.container.firstElementChild;
                this.eventBus = options.eventBus || (0, _ui_utils.getGlobalEventBus)();
                this.linkService = options.linkService || new _pdf_link_service.SimpleLinkService();
                this.downloadManager = options.downloadManager || null;
                this.findController = options.findController || null;
                this.removePageBorders = options.removePageBorders || false;
                this.textLayerMode = Number.isInteger(options.textLayerMode) ? options.textLayerMode : _ui_utils.TextLayerMode.ENABLE;
                this.imageResourcesPath = options.imageResourcesPath || "";
                this.renderInteractiveForms = options.renderInteractiveForms || false;
                this.enablePrintAutoRotate = options.enablePrintAutoRotate || false;
                this.renderer = options.renderer || _ui_utils.RendererType.CANVAS;
                this.enableWebGL = options.enableWebGL || false;
                this.useOnlyCssZoom = options.useOnlyCssZoom || false;
                this.maxCanvasPixels = options.maxCanvasPixels;
                this.l10n = options.l10n || _ui_utils.NullL10n;
                this.defaultRenderingQueue = !options.renderingQueue;
                if (this.defaultRenderingQueue) {
                  this.renderingQueue = new _pdf_rendering_queue.PDFRenderingQueue();
                  this.renderingQueue.setViewer(this);
                } else {
                  this.renderingQueue = options.renderingQueue;
                }
                this.scroll = (0, _ui_utils.watchScroll)(this.container, this._scrollUpdate.bind(this));
                this.presentationModeState = _ui_utils.PresentationModeState.UNKNOWN;
                this._onBeforeDraw = this._onAfterDraw = null;
                this._resetView();
                if (this.removePageBorders) {
                  this.viewer.classList.add("removePageBorders");
                }
                Promise.resolve().then(() => {
                  this.eventBus.dispatch("baseviewerinit", {
                    source: this
                  });
                });
              }
              get pagesCount() {
                return this._pages.length;
              }
              getPageView(index) {
                return this._pages[index];
              }
              get pageViewsReady() {
                if (!this._pagesCapability.settled) {
                  return false;
                }
                return this._pages.every(function(pageView) {
                  return pageView && pageView.pdfPage;
                });
              }
              get currentPageNumber() {
                return this._currentPageNumber;
              }
              set currentPageNumber(val) {
                if (!Number.isInteger(val)) {
                  throw new Error("Invalid page number.");
                }
                if (!this.pdfDocument) {
                  return;
                }
                if (!this._setCurrentPageNumber(val, true)) {
                  console.error(`${this._name}.currentPageNumber: "${val}" is not a valid page.`);
                }
              }
              _setCurrentPageNumber(val, resetCurrentPageView = false) {
                if (this._currentPageNumber === val) {
                  if (resetCurrentPageView) {
                    this._resetCurrentPageView();
                  }
                  return true;
                }
                if (!(0 < val && val <= this.pagesCount)) {
                  return false;
                }
                this._currentPageNumber = val;
                this.eventBus.dispatch("pagechanging", {
                  source: this,
                  pageNumber: val,
                  pageLabel: this._pageLabels && this._pageLabels[val - 1]
                });
                if (resetCurrentPageView) {
                  this._resetCurrentPageView();
                }
                return true;
              }
              get currentPageLabel() {
                return this._pageLabels && this._pageLabels[this._currentPageNumber - 1];
              }
              set currentPageLabel(val) {
                if (!this.pdfDocument) {
                  return;
                }
                let page = val | 0;
                if (this._pageLabels) {
                  const i = this._pageLabels.indexOf(val);
                  if (i >= 0) {
                    page = i + 1;
                  }
                }
                if (!this._setCurrentPageNumber(page, true)) {
                  console.error(`${this._name}.currentPageLabel: "${val}" is not a valid page.`);
                }
              }
              get currentScale() {
                return this._currentScale !== _ui_utils.UNKNOWN_SCALE ? this._currentScale : _ui_utils.DEFAULT_SCALE;
              }
              set currentScale(val) {
                if (isNaN(val)) {
                  throw new Error("Invalid numeric scale.");
                }
                if (!this.pdfDocument) {
                  return;
                }
                this._setScale(val, false);
              }
              get currentScaleValue() {
                return this._currentScaleValue;
              }
              set currentScaleValue(val) {
                if (!this.pdfDocument) {
                  return;
                }
                this._setScale(val, false);
              }
              get pagesRotation() {
                return this._pagesRotation;
              }
              set pagesRotation(rotation) {
                if (!(0, _ui_utils.isValidRotation)(rotation)) {
                  throw new Error("Invalid pages rotation angle.");
                }
                if (!this.pdfDocument) {
                  return;
                }
                if (this._pagesRotation === rotation) {
                  return;
                }
                this._pagesRotation = rotation;
                const pageNumber = this._currentPageNumber;
                for (let i = 0, ii = this._pages.length; i < ii; i++) {
                  const pageView = this._pages[i];
                  pageView.update(pageView.scale, rotation);
                }
                if (this._currentScaleValue) {
                  this._setScale(this._currentScaleValue, true);
                }
                this.eventBus.dispatch("rotationchanging", {
                  source: this,
                  pagesRotation: rotation,
                  pageNumber
                });
                if (this.defaultRenderingQueue) {
                  this.update();
                }
              }
              get firstPagePromise() {
                return this.pdfDocument ? this._firstPageCapability.promise : null;
              }
              get onePageRendered() {
                return this.pdfDocument ? this._onePageRenderedCapability.promise : null;
              }
              get pagesPromise() {
                return this.pdfDocument ? this._pagesCapability.promise : null;
              }
              get _setDocumentViewerElement() {
                throw new Error("Not implemented: _setDocumentViewerElement");
              }
              setDocument(pdfDocument) {
                if (this.pdfDocument) {
                  this._cancelRendering();
                  this._resetView();
                  if (this.findController) {
                    this.findController.setDocument(null);
                  }
                }
                this.pdfDocument = pdfDocument;
                if (!pdfDocument) {
                  return;
                }
                const pagesCount = pdfDocument.numPages;
                const firstPagePromise = pdfDocument.getPage(1);
                this._pagesCapability.promise.then(() => {
                  this.eventBus.dispatch("pagesloaded", {
                    source: this,
                    pagesCount
                  });
                });
                this._onBeforeDraw = (evt) => {
                  const pageView = this._pages[evt.pageNumber - 1];
                  if (!pageView) {
                    return;
                  }
                  this._buffer.push(pageView);
                };
                this.eventBus._on("pagerender", this._onBeforeDraw);
                this._onAfterDraw = (evt) => {
                  if (evt.cssTransform || this._onePageRenderedCapability.settled) {
                    return;
                  }
                  this._onePageRenderedCapability.resolve();
                  this.eventBus._off("pagerendered", this._onAfterDraw);
                  this._onAfterDraw = null;
                };
                this.eventBus._on("pagerendered", this._onAfterDraw);
                firstPagePromise.then((firstPdfPage) => {
                  this._firstPageCapability.resolve(firstPdfPage);
                  const scale = this.currentScale;
                  const viewport = firstPdfPage.getViewport({
                    scale: scale * _ui_utils.CSS_UNITS
                  });
                  const textLayerFactory = this.textLayerMode !== _ui_utils.TextLayerMode.DISABLE ? this : null;
                  for (let pageNum = 1; pageNum <= pagesCount; ++pageNum) {
                    const pageView = new _pdf_page_view.PDFPageView({
                      container: this._setDocumentViewerElement,
                      eventBus: this.eventBus,
                      id: pageNum,
                      scale,
                      defaultViewport: viewport.clone(),
                      renderingQueue: this.renderingQueue,
                      textLayerFactory,
                      textLayerMode: this.textLayerMode,
                      annotationLayerFactory: this,
                      imageResourcesPath: this.imageResourcesPath,
                      renderInteractiveForms: this.renderInteractiveForms,
                      renderer: this.renderer,
                      enableWebGL: this.enableWebGL,
                      useOnlyCssZoom: this.useOnlyCssZoom,
                      maxCanvasPixels: this.maxCanvasPixels,
                      l10n: this.l10n
                    });
                    this._pages.push(pageView);
                  }
                  const firstPageView = this._pages[0];
                  if (firstPageView) {
                    firstPageView.setPdfPage(firstPdfPage);
                    this.linkService.cachePageRef(1, firstPdfPage.ref);
                  }
                  if (this._spreadMode !== _ui_utils.SpreadMode.NONE) {
                    this._updateSpreadMode();
                  }
                  this._onePageRenderedCapability.promise.then(() => {
                    if (this.findController) {
                      this.findController.setDocument(pdfDocument);
                    }
                    if (pdfDocument.loadingParams["disableAutoFetch"] || pagesCount > 7500) {
                      this._pagesCapability.resolve();
                      return;
                    }
                    let getPagesLeft = pagesCount - 1;
                    if (getPagesLeft <= 0) {
                      this._pagesCapability.resolve();
                      return;
                    }
                    for (let pageNum = 2; pageNum <= pagesCount; ++pageNum) {
                      pdfDocument.getPage(pageNum).then((pdfPage) => {
                        const pageView = this._pages[pageNum - 1];
                        if (!pageView.pdfPage) {
                          pageView.setPdfPage(pdfPage);
                        }
                        this.linkService.cachePageRef(pageNum, pdfPage.ref);
                        if (--getPagesLeft === 0) {
                          this._pagesCapability.resolve();
                        }
                      }, (reason) => {
                        console.error(`Unable to get page ${pageNum} to initialize viewer`, reason);
                        if (--getPagesLeft === 0) {
                          this._pagesCapability.resolve();
                        }
                      });
                    }
                  });
                  this.eventBus.dispatch("pagesinit", {
                    source: this
                  });
                  if (this.defaultRenderingQueue) {
                    this.update();
                  }
                }).catch((reason) => {
                  console.error("Unable to initialize viewer", reason);
                });
              }
              setPageLabels(labels) {
                if (!this.pdfDocument) {
                  return;
                }
                if (!labels) {
                  this._pageLabels = null;
                } else if (!(Array.isArray(labels) && this.pdfDocument.numPages === labels.length)) {
                  this._pageLabels = null;
                  console.error(`${this._name}.setPageLabels: Invalid page labels.`);
                } else {
                  this._pageLabels = labels;
                }
                for (let i = 0, ii = this._pages.length; i < ii; i++) {
                  const pageView = this._pages[i];
                  const label = this._pageLabels && this._pageLabels[i];
                  pageView.setPageLabel(label);
                }
              }
              _resetView() {
                this._pages = [];
                this._currentPageNumber = 1;
                this._currentScale = _ui_utils.UNKNOWN_SCALE;
                this._currentScaleValue = null;
                this._pageLabels = null;
                this._buffer = new PDFPageViewBuffer(DEFAULT_CACHE_SIZE);
                this._location = null;
                this._pagesRotation = 0;
                this._pagesRequests = /* @__PURE__ */ new WeakMap();
                this._firstPageCapability = (0, _pdf.createPromiseCapability)();
                this._onePageRenderedCapability = (0, _pdf.createPromiseCapability)();
                this._pagesCapability = (0, _pdf.createPromiseCapability)();
                this._scrollMode = _ui_utils.ScrollMode.VERTICAL;
                this._spreadMode = _ui_utils.SpreadMode.NONE;
                if (this._onBeforeDraw) {
                  this.eventBus._off("pagerender", this._onBeforeDraw);
                  this._onBeforeDraw = null;
                }
                if (this._onAfterDraw) {
                  this.eventBus._off("pagerendered", this._onAfterDraw);
                  this._onAfterDraw = null;
                }
                this.viewer.textContent = "";
                this._updateScrollMode();
              }
              _scrollUpdate() {
                if (this.pagesCount === 0) {
                  return;
                }
                this.update();
              }
              _scrollIntoView({
                pageDiv,
                pageSpot = null,
                pageNumber = null
              }) {
                (0, _ui_utils.scrollIntoView)(pageDiv, pageSpot);
              }
              _setScaleUpdatePages(newScale, newValue, noScroll = false, preset = false) {
                this._currentScaleValue = newValue.toString();
                if (isSameScale(this._currentScale, newScale)) {
                  if (preset) {
                    this.eventBus.dispatch("scalechanging", {
                      source: this,
                      scale: newScale,
                      presetValue: newValue
                    });
                  }
                  return;
                }
                for (let i = 0, ii = this._pages.length; i < ii; i++) {
                  this._pages[i].update(newScale);
                }
                this._currentScale = newScale;
                if (!noScroll) {
                  let page = this._currentPageNumber, dest;
                  if (this._location && !(this.isInPresentationMode || this.isChangingPresentationMode)) {
                    page = this._location.pageNumber;
                    dest = [null, {
                      name: "XYZ"
                    }, this._location.left, this._location.top, null];
                  }
                  this.scrollPageIntoView({
                    pageNumber: page,
                    destArray: dest,
                    allowNegativeOffset: true
                  });
                }
                this.eventBus.dispatch("scalechanging", {
                  source: this,
                  scale: newScale,
                  presetValue: preset ? newValue : void 0
                });
                if (this.defaultRenderingQueue) {
                  this.update();
                }
              }
              _setScale(value, noScroll = false) {
                let scale = parseFloat(value);
                if (scale > 0) {
                  this._setScaleUpdatePages(scale, value, noScroll, false);
                } else {
                  const currentPage = this._pages[this._currentPageNumber - 1];
                  if (!currentPage) {
                    return;
                  }
                  const noPadding = this.isInPresentationMode || this.removePageBorders;
                  let hPadding = noPadding ? 0 : _ui_utils.SCROLLBAR_PADDING;
                  let vPadding = noPadding ? 0 : _ui_utils.VERTICAL_PADDING;
                  if (!noPadding && this._isScrollModeHorizontal) {
                    [hPadding, vPadding] = [vPadding, hPadding];
                  }
                  const pageWidthScale = (this.container.clientWidth - hPadding) / currentPage.width * currentPage.scale;
                  const pageHeightScale = (this.container.clientHeight - vPadding) / currentPage.height * currentPage.scale;
                  switch (value) {
                    case "page-actual":
                      scale = 1;
                      break;
                    case "page-width":
                      scale = pageWidthScale;
                      break;
                    case "page-height":
                      scale = pageHeightScale;
                      break;
                    case "page-fit":
                      scale = Math.min(pageWidthScale, pageHeightScale);
                      break;
                    case "auto":
                      const horizontalScale = (0, _ui_utils.isPortraitOrientation)(currentPage) ? pageWidthScale : Math.min(pageHeightScale, pageWidthScale);
                      scale = Math.min(_ui_utils.MAX_AUTO_SCALE, horizontalScale);
                      break;
                    default:
                      console.error(`${this._name}._setScale: "${value}" is an unknown zoom value.`);
                      return;
                  }
                  this._setScaleUpdatePages(scale, value, noScroll, true);
                }
              }
              _resetCurrentPageView() {
                if (this.isInPresentationMode) {
                  this._setScale(this._currentScaleValue, true);
                }
                const pageView = this._pages[this._currentPageNumber - 1];
                this._scrollIntoView({
                  pageDiv: pageView.div
                });
              }
              scrollPageIntoView({
                pageNumber,
                destArray = null,
                allowNegativeOffset = false,
                ignoreDestinationZoom = false
              }) {
                if (!this.pdfDocument) {
                  return;
                }
                const pageView = Number.isInteger(pageNumber) && this._pages[pageNumber - 1];
                if (!pageView) {
                  console.error(`${this._name}.scrollPageIntoView: "${pageNumber}" is not a valid pageNumber parameter.`);
                  return;
                }
                if (this.isInPresentationMode || !destArray) {
                  this._setCurrentPageNumber(pageNumber, true);
                  return;
                }
                let x = 0, y = 0;
                let width = 0, height = 0, widthScale, heightScale;
                const changeOrientation = pageView.rotation % 180 !== 0;
                const pageWidth = (changeOrientation ? pageView.height : pageView.width) / pageView.scale / _ui_utils.CSS_UNITS;
                const pageHeight = (changeOrientation ? pageView.width : pageView.height) / pageView.scale / _ui_utils.CSS_UNITS;
                let scale = 0;
                switch (destArray[1].name) {
                  case "XYZ":
                    x = destArray[2];
                    y = destArray[3];
                    scale = destArray[4];
                    x = x !== null ? x : 0;
                    y = y !== null ? y : pageHeight;
                    break;
                  case "Fit":
                  case "FitB":
                    scale = "page-fit";
                    break;
                  case "FitH":
                  case "FitBH":
                    y = destArray[2];
                    scale = "page-width";
                    if (y === null && this._location) {
                      x = this._location.left;
                      y = this._location.top;
                    }
                    break;
                  case "FitV":
                  case "FitBV":
                    x = destArray[2];
                    width = pageWidth;
                    height = pageHeight;
                    scale = "page-height";
                    break;
                  case "FitR":
                    x = destArray[2];
                    y = destArray[3];
                    width = destArray[4] - x;
                    height = destArray[5] - y;
                    const hPadding = this.removePageBorders ? 0 : _ui_utils.SCROLLBAR_PADDING;
                    const vPadding = this.removePageBorders ? 0 : _ui_utils.VERTICAL_PADDING;
                    widthScale = (this.container.clientWidth - hPadding) / width / _ui_utils.CSS_UNITS;
                    heightScale = (this.container.clientHeight - vPadding) / height / _ui_utils.CSS_UNITS;
                    scale = Math.min(Math.abs(widthScale), Math.abs(heightScale));
                    break;
                  default:
                    console.error(`${this._name}.scrollPageIntoView: "${destArray[1].name}" is not a valid destination type.`);
                    return;
                }
                if (!ignoreDestinationZoom) {
                  if (scale && scale !== this._currentScale) {
                    this.currentScaleValue = scale;
                  } else if (this._currentScale === _ui_utils.UNKNOWN_SCALE) {
                    this.currentScaleValue = _ui_utils.DEFAULT_SCALE_VALUE;
                  }
                }
                if (scale === "page-fit" && !destArray[4]) {
                  this._scrollIntoView({
                    pageDiv: pageView.div,
                    pageNumber
                  });
                  return;
                }
                const boundingRect = [pageView.viewport.convertToViewportPoint(x, y), pageView.viewport.convertToViewportPoint(x + width, y + height)];
                let left = Math.min(boundingRect[0][0], boundingRect[1][0]);
                let top = Math.min(boundingRect[0][1], boundingRect[1][1]);
                if (!allowNegativeOffset) {
                  left = Math.max(left, 0);
                  top = Math.max(top, 0);
                }
                this._scrollIntoView({
                  pageDiv: pageView.div,
                  pageSpot: {
                    left,
                    top
                  },
                  pageNumber
                });
              }
              _updateLocation(firstPage) {
                const currentScale = this._currentScale;
                const currentScaleValue = this._currentScaleValue;
                const normalizedScaleValue = parseFloat(currentScaleValue) === currentScale ? Math.round(currentScale * 1e4) / 100 : currentScaleValue;
                const pageNumber = firstPage.id;
                let pdfOpenParams = "#page=" + pageNumber;
                pdfOpenParams += "&zoom=" + normalizedScaleValue;
                const currentPageView = this._pages[pageNumber - 1];
                const container = this.container;
                const topLeft = currentPageView.getPagePoint(container.scrollLeft - firstPage.x, container.scrollTop - firstPage.y);
                const intLeft = Math.round(topLeft[0]);
                const intTop = Math.round(topLeft[1]);
                pdfOpenParams += "," + intLeft + "," + intTop;
                this._location = {
                  pageNumber,
                  scale: normalizedScaleValue,
                  top: intTop,
                  left: intLeft,
                  rotation: this._pagesRotation,
                  pdfOpenParams
                };
              }
              _updateHelper(visiblePages) {
                throw new Error("Not implemented: _updateHelper");
              }
              update() {
                const visible = this._getVisiblePages();
                const visiblePages = visible.views, numVisiblePages = visiblePages.length;
                if (numVisiblePages === 0) {
                  return;
                }
                const newCacheSize = Math.max(DEFAULT_CACHE_SIZE, 2 * numVisiblePages + 1);
                this._buffer.resize(newCacheSize, visiblePages);
                this.renderingQueue.renderHighestPriority(visible);
                this._updateHelper(visiblePages);
                this._updateLocation(visible.first);
                this.eventBus.dispatch("updateviewarea", {
                  source: this,
                  location: this._location
                });
              }
              containsElement(element) {
                return this.container.contains(element);
              }
              focus() {
                this.container.focus();
              }
              get _isScrollModeHorizontal() {
                return this.isInPresentationMode ? false : this._scrollMode === _ui_utils.ScrollMode.HORIZONTAL;
              }
              get isInPresentationMode() {
                return this.presentationModeState === _ui_utils.PresentationModeState.FULLSCREEN;
              }
              get isChangingPresentationMode() {
                return this.presentationModeState === _ui_utils.PresentationModeState.CHANGING;
              }
              get isHorizontalScrollbarEnabled() {
                return this.isInPresentationMode ? false : this.container.scrollWidth > this.container.clientWidth;
              }
              get isVerticalScrollbarEnabled() {
                return this.isInPresentationMode ? false : this.container.scrollHeight > this.container.clientHeight;
              }
              _getCurrentVisiblePage() {
                if (!this.pagesCount) {
                  return {
                    views: []
                  };
                }
                const pageView = this._pages[this._currentPageNumber - 1];
                const element = pageView.div;
                const view = {
                  id: pageView.id,
                  x: element.offsetLeft + element.clientLeft,
                  y: element.offsetTop + element.clientTop,
                  view: pageView
                };
                return {
                  first: view,
                  last: view,
                  views: [view]
                };
              }
              _getVisiblePages() {
                return (0, _ui_utils.getVisibleElements)(this.container, this._pages, true, this._isScrollModeHorizontal);
              }
              isPageVisible(pageNumber) {
                if (!this.pdfDocument) {
                  return false;
                }
                if (pageNumber < 1 || pageNumber > this.pagesCount) {
                  console.error(`${this._name}.isPageVisible: "${pageNumber}" is out of bounds.`);
                  return false;
                }
                return this._getVisiblePages().views.some(function(view) {
                  return view.id === pageNumber;
                });
              }
              cleanup() {
                for (let i = 0, ii = this._pages.length; i < ii; i++) {
                  if (this._pages[i] && this._pages[i].renderingState !== _pdf_rendering_queue.RenderingStates.FINISHED) {
                    this._pages[i].reset();
                  }
                }
              }
              _cancelRendering() {
                for (let i = 0, ii = this._pages.length; i < ii; i++) {
                  if (this._pages[i]) {
                    this._pages[i].cancelRendering();
                  }
                }
              }
              _ensurePdfPageLoaded(pageView) {
                if (pageView.pdfPage) {
                  return Promise.resolve(pageView.pdfPage);
                }
                if (this._pagesRequests.has(pageView)) {
                  return this._pagesRequests.get(pageView);
                }
                const promise = this.pdfDocument.getPage(pageView.id).then((pdfPage) => {
                  if (!pageView.pdfPage) {
                    pageView.setPdfPage(pdfPage);
                  }
                  this._pagesRequests.delete(pageView);
                  return pdfPage;
                }).catch((reason) => {
                  console.error("Unable to get page for page view", reason);
                  this._pagesRequests.delete(pageView);
                });
                this._pagesRequests.set(pageView, promise);
                return promise;
              }
              forceRendering(currentlyVisiblePages) {
                const visiblePages = currentlyVisiblePages || this._getVisiblePages();
                const scrollAhead = this._isScrollModeHorizontal ? this.scroll.right : this.scroll.down;
                const pageView = this.renderingQueue.getHighestPriority(visiblePages, this._pages, scrollAhead);
                if (pageView) {
                  this._ensurePdfPageLoaded(pageView).then(() => {
                    this.renderingQueue.renderView(pageView);
                  });
                  return true;
                }
                return false;
              }
              createTextLayerBuilder(textLayerDiv, pageIndex, viewport, enhanceTextSelection = false, eventBus) {
                return new _text_layer_builder.TextLayerBuilder({
                  textLayerDiv,
                  eventBus,
                  pageIndex,
                  viewport,
                  findController: this.isInPresentationMode ? null : this.findController,
                  enhanceTextSelection: this.isInPresentationMode ? false : enhanceTextSelection
                });
              }
              createAnnotationLayerBuilder(pageDiv, pdfPage, imageResourcesPath = "", renderInteractiveForms = false, l10n = _ui_utils.NullL10n) {
                return new _annotation_layer_builder.AnnotationLayerBuilder({
                  pageDiv,
                  pdfPage,
                  imageResourcesPath,
                  renderInteractiveForms,
                  linkService: this.linkService,
                  downloadManager: this.downloadManager,
                  l10n
                });
              }
              get hasEqualPageSizes() {
                const firstPageView = this._pages[0];
                for (let i = 1, ii = this._pages.length; i < ii; ++i) {
                  const pageView = this._pages[i];
                  if (pageView.width !== firstPageView.width || pageView.height !== firstPageView.height) {
                    return false;
                  }
                }
                return true;
              }
              getPagesOverview() {
                const pagesOverview = this._pages.map(function(pageView) {
                  const viewport = pageView.pdfPage.getViewport({
                    scale: 1
                  });
                  return {
                    width: viewport.width,
                    height: viewport.height,
                    rotation: viewport.rotation
                  };
                });
                if (!this.enablePrintAutoRotate) {
                  return pagesOverview;
                }
                const isFirstPagePortrait = (0, _ui_utils.isPortraitOrientation)(pagesOverview[0]);
                return pagesOverview.map(function(size) {
                  if (isFirstPagePortrait === (0, _ui_utils.isPortraitOrientation)(size)) {
                    return size;
                  }
                  return {
                    width: size.height,
                    height: size.width,
                    rotation: (size.rotation + 90) % 360
                  };
                });
              }
              get scrollMode() {
                return this._scrollMode;
              }
              set scrollMode(mode) {
                if (this._scrollMode === mode) {
                  return;
                }
                if (!(0, _ui_utils.isValidScrollMode)(mode)) {
                  throw new Error(`Invalid scroll mode: ${mode}`);
                }
                this._scrollMode = mode;
                this.eventBus.dispatch("scrollmodechanged", {
                  source: this,
                  mode
                });
                this._updateScrollMode(this._currentPageNumber);
              }
              _updateScrollMode(pageNumber = null) {
                const scrollMode = this._scrollMode, viewer = this.viewer;
                viewer.classList.toggle("scrollHorizontal", scrollMode === _ui_utils.ScrollMode.HORIZONTAL);
                viewer.classList.toggle("scrollWrapped", scrollMode === _ui_utils.ScrollMode.WRAPPED);
                if (!this.pdfDocument || !pageNumber) {
                  return;
                }
                if (this._currentScaleValue && isNaN(this._currentScaleValue)) {
                  this._setScale(this._currentScaleValue, true);
                }
                this._setCurrentPageNumber(pageNumber, true);
                this.update();
              }
              get spreadMode() {
                return this._spreadMode;
              }
              set spreadMode(mode) {
                if (this._spreadMode === mode) {
                  return;
                }
                if (!(0, _ui_utils.isValidSpreadMode)(mode)) {
                  throw new Error(`Invalid spread mode: ${mode}`);
                }
                this._spreadMode = mode;
                this.eventBus.dispatch("spreadmodechanged", {
                  source: this,
                  mode
                });
                this._updateSpreadMode(this._currentPageNumber);
              }
              _updateSpreadMode(pageNumber = null) {
                if (!this.pdfDocument) {
                  return;
                }
                const viewer = this.viewer, pages = this._pages;
                viewer.textContent = "";
                if (this._spreadMode === _ui_utils.SpreadMode.NONE) {
                  for (let i = 0, iMax = pages.length; i < iMax; ++i) {
                    viewer.appendChild(pages[i].div);
                  }
                } else {
                  const parity = this._spreadMode - 1;
                  let spread = null;
                  for (let i = 0, iMax = pages.length; i < iMax; ++i) {
                    if (spread === null) {
                      spread = document.createElement("div");
                      spread.className = "spread";
                      viewer.appendChild(spread);
                    } else if (i % 2 === parity) {
                      spread = spread.cloneNode(false);
                      viewer.appendChild(spread);
                    }
                    spread.appendChild(pages[i].div);
                  }
                }
                if (!pageNumber) {
                  return;
                }
                this._setCurrentPageNumber(pageNumber, true);
                this.update();
              }
            }
            exports2.BaseViewer = BaseViewer;
          },
          9057: function(__unused_webpack_module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.DownloadManager = void 0;
            var _pdf = __webpack_require__2(3941);
            ;
            const DISABLE_CREATE_OBJECT_URL = _pdf.apiCompatibilityParams.disableCreateObjectURL || false;
            function download(blobUrl, filename) {
              const a = document.createElement("a");
              if (!a.click) {
                throw new Error('DownloadManager: "a.click()" is not supported.');
              }
              a.href = blobUrl;
              a.target = "_parent";
              if ("download" in a) {
                a.download = filename;
              }
              (document.body || document.documentElement).appendChild(a);
              a.click();
              a.remove();
            }
            class DownloadManager {
              constructor({
                disableCreateObjectURL = DISABLE_CREATE_OBJECT_URL
              }) {
                this.disableCreateObjectURL = disableCreateObjectURL;
              }
              downloadUrl(url, filename) {
                if (!(0, _pdf.createValidAbsoluteUrl)(url, "http://example.com")) {
                  return;
                }
                download(url + "#pdfjs.action=download", filename);
              }
              downloadData(data, filename, contentType) {
                if (navigator.msSaveBlob) {
                  navigator.msSaveBlob(new Blob([data], {
                    type: contentType
                  }), filename);
                  return;
                }
                const blobUrl = (0, _pdf.createObjectURL)(data, contentType, this.disableCreateObjectURL);
                download(blobUrl, filename);
              }
              download(blob, url, filename) {
                if (navigator.msSaveBlob) {
                  if (!navigator.msSaveBlob(blob, filename)) {
                    this.downloadUrl(url, filename);
                  }
                  return;
                }
                if (this.disableCreateObjectURL) {
                  this.downloadUrl(url, filename);
                  return;
                }
                const blobUrl = URL.createObjectURL(blob);
                download(blobUrl, filename);
              }
            }
            exports2.DownloadManager = DownloadManager;
          },
          3224: function(__unused_webpack_module2, exports2, __webpack_require__2) {
            "use strict";
            var __webpack_unused_export__;
            __webpack_unused_export__ = {
              value: true
            };
            __webpack_unused_export__ = void 0;
            var _app = __webpack_require__2(8375);
            var _preferences = __webpack_require__2(3128);
            var _download_manager = __webpack_require__2(9057);
            var _genericl10n = __webpack_require__2(2881);
            ;
            const GenericCom = {};
            __webpack_unused_export__ = GenericCom;
            class GenericPreferences extends _preferences.BasePreferences {
              async _writeToStorage(prefObj) {
                localStorage.setItem("pdfjs.preferences", JSON.stringify(prefObj));
              }
              async _readFromStorage(prefObj) {
                return JSON.parse(localStorage.getItem("pdfjs.preferences"));
              }
            }
            class GenericExternalServices extends _app.DefaultExternalServices {
              static createDownloadManager(options) {
                return new _download_manager.DownloadManager(options);
              }
              static createPreferences() {
                return new GenericPreferences();
              }
              static createL10n({
                locale = "en-US"
              }) {
                return new _genericl10n.GenericL10n(locale);
              }
            }
            _app.PDFViewerApplication.externalServices = GenericExternalServices;
          },
          2881: function(__unused_webpack_module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.GenericL10n = void 0;
            __webpack_require__2(9490);
            const webL10n = document.webL10n;
            class GenericL10n {
              constructor(lang) {
                this._lang = lang;
                this._ready = new Promise((resolve, reject) => {
                  webL10n.setLanguage(lang, () => {
                    resolve(webL10n);
                  });
                });
              }
              async getLanguage() {
                const l10n = await this._ready;
                return l10n.getLanguage();
              }
              async getDirection() {
                const l10n = await this._ready;
                return l10n.getDirection();
              }
              async get(property, args, fallback) {
                const l10n = await this._ready;
                return l10n.get(property, args, fallback);
              }
              async translate(element) {
                const l10n = await this._ready;
                return l10n.translate(element);
              }
            }
            exports2.GenericL10n = GenericL10n;
          },
          1565: function(__unused_webpack_module2, exports2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.GrabToPan = GrabToPan;
            function GrabToPan(options) {
              this.element = options.element;
              this.document = options.element.ownerDocument;
              if (typeof options.ignoreTarget === "function") {
                this.ignoreTarget = options.ignoreTarget;
              }
              this.onActiveChanged = options.onActiveChanged;
              this.activate = this.activate.bind(this);
              this.deactivate = this.deactivate.bind(this);
              this.toggle = this.toggle.bind(this);
              this._onmousedown = this._onmousedown.bind(this);
              this._onmousemove = this._onmousemove.bind(this);
              this._endPan = this._endPan.bind(this);
              const overlay = this.overlay = document.createElement("div");
              overlay.className = "grab-to-pan-grabbing";
            }
            GrabToPan.prototype = {
              CSS_CLASS_GRAB: "grab-to-pan-grab",
              activate: function GrabToPan_activate() {
                if (!this.active) {
                  this.active = true;
                  this.element.addEventListener("mousedown", this._onmousedown, true);
                  this.element.classList.add(this.CSS_CLASS_GRAB);
                  if (this.onActiveChanged) {
                    this.onActiveChanged(true);
                  }
                }
              },
              deactivate: function GrabToPan_deactivate() {
                if (this.active) {
                  this.active = false;
                  this.element.removeEventListener("mousedown", this._onmousedown, true);
                  this._endPan();
                  this.element.classList.remove(this.CSS_CLASS_GRAB);
                  if (this.onActiveChanged) {
                    this.onActiveChanged(false);
                  }
                }
              },
              toggle: function GrabToPan_toggle() {
                if (this.active) {
                  this.deactivate();
                } else {
                  this.activate();
                }
              },
              ignoreTarget: function GrabToPan_ignoreTarget(node) {
                return node[matchesSelector]("a[href], a[href] *, input, textarea, button, button *, select, option");
              },
              _onmousedown: function GrabToPan__onmousedown(event) {
                if (event.button !== 0 || this.ignoreTarget(event.target)) {
                  return;
                }
                if (event.originalTarget) {
                  try {
                    event.originalTarget.tagName;
                  } catch (e) {
                    return;
                  }
                }
                this.scrollLeftStart = this.element.scrollLeft;
                this.scrollTopStart = this.element.scrollTop;
                this.clientXStart = event.clientX;
                this.clientYStart = event.clientY;
                this.document.addEventListener("mousemove", this._onmousemove, true);
                this.document.addEventListener("mouseup", this._endPan, true);
                this.element.addEventListener("scroll", this._endPan, true);
                event.preventDefault();
                event.stopPropagation();
                const focusedElement = document.activeElement;
                if (focusedElement && !focusedElement.contains(event.target)) {
                  focusedElement.blur();
                }
              },
              _onmousemove: function GrabToPan__onmousemove(event) {
                this.element.removeEventListener("scroll", this._endPan, true);
                if (isLeftMouseReleased(event)) {
                  this._endPan();
                  return;
                }
                const xDiff = event.clientX - this.clientXStart;
                const yDiff = event.clientY - this.clientYStart;
                const scrollTop = this.scrollTopStart - yDiff;
                const scrollLeft = this.scrollLeftStart - xDiff;
                if (this.element.scrollTo) {
                  this.element.scrollTo({
                    top: scrollTop,
                    left: scrollLeft,
                    behavior: "instant"
                  });
                } else {
                  this.element.scrollTop = scrollTop;
                  this.element.scrollLeft = scrollLeft;
                }
                if (!this.overlay.parentNode) {
                  document.body.appendChild(this.overlay);
                }
              },
              _endPan: function GrabToPan__endPan() {
                this.element.removeEventListener("scroll", this._endPan, true);
                this.document.removeEventListener("mousemove", this._onmousemove, true);
                this.document.removeEventListener("mouseup", this._endPan, true);
                this.overlay.remove();
              }
            };
            let matchesSelector;
            ["webkitM", "mozM", "msM", "oM", "m"].some(function(prefix) {
              let name = prefix + "atches";
              if (name in document.documentElement) {
                matchesSelector = name;
              }
              name += "Selector";
              if (name in document.documentElement) {
                matchesSelector = name;
              }
              return matchesSelector;
            });
            const isNotIEorIsIE10plus = !document.documentMode || document.documentMode > 9;
            const chrome = window.chrome;
            const isChrome15OrOpera15plus = chrome && (chrome.webstore || chrome.app);
            const isSafari6plus = /Apple/.test(navigator.vendor) && /Version\/([6-9]\d*|[1-5]\d+)/.test(navigator.userAgent);
            function isLeftMouseReleased(event) {
              if ("buttons" in event && isNotIEorIsIE10plus) {
                return !(event.buttons & 1);
              }
              if (isChrome15OrOpera15plus || isSafari6plus) {
                return event.which === 0;
              }
              return false;
            }
          },
          3421: function(__unused_webpack_module2, exports2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.OverlayManager = void 0;
            class OverlayManager {
              constructor() {
                this._overlays = {};
                this._active = null;
                this._keyDownBound = this._keyDown.bind(this);
              }
              get active() {
                return this._active;
              }
              async register(name, element, callerCloseMethod = null, canForceClose = false) {
                let container;
                if (!name || !element || !(container = element.parentNode)) {
                  throw new Error("Not enough parameters.");
                } else if (this._overlays[name]) {
                  throw new Error("The overlay is already registered.");
                }
                this._overlays[name] = {
                  element,
                  container,
                  callerCloseMethod,
                  canForceClose
                };
              }
              async unregister(name) {
                if (!this._overlays[name]) {
                  throw new Error("The overlay does not exist.");
                } else if (this._active === name) {
                  throw new Error("The overlay cannot be removed while it is active.");
                }
                delete this._overlays[name];
              }
              async open(name) {
                if (!this._overlays[name]) {
                  throw new Error("The overlay does not exist.");
                } else if (this._active) {
                  if (this._overlays[name].canForceClose) {
                    this._closeThroughCaller();
                  } else if (this._active === name) {
                    throw new Error("The overlay is already active.");
                  } else {
                    throw new Error("Another overlay is currently active.");
                  }
                }
                this._active = name;
                this._overlays[this._active].element.classList.remove("hidden");
                this._overlays[this._active].container.classList.remove("hidden");
                window.addEventListener("keydown", this._keyDownBound);
              }
              async close(name) {
                if (!this._overlays[name]) {
                  throw new Error("The overlay does not exist.");
                } else if (!this._active) {
                  throw new Error("The overlay is currently not active.");
                } else if (this._active !== name) {
                  throw new Error("Another overlay is currently active.");
                }
                this._overlays[this._active].container.classList.add("hidden");
                this._overlays[this._active].element.classList.add("hidden");
                this._active = null;
                window.removeEventListener("keydown", this._keyDownBound);
              }
              _keyDown(evt) {
                if (this._active && evt.keyCode === 27) {
                  this._closeThroughCaller();
                  evt.preventDefault();
                }
              }
              _closeThroughCaller() {
                if (this._overlays[this._active].callerCloseMethod) {
                  this._overlays[this._active].callerCloseMethod();
                }
                if (this._active) {
                  this.close(this._active);
                }
              }
            }
            exports2.OverlayManager = OverlayManager;
          },
          3755: function(__unused_webpack_module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.PasswordPrompt = void 0;
            var _ui_utils = __webpack_require__2(5570);
            var _pdf = __webpack_require__2(3941);
            class PasswordPrompt {
              constructor(options, overlayManager, l10n = _ui_utils.NullL10n) {
                this.overlayName = options.overlayName;
                this.container = options.container;
                this.label = options.label;
                this.input = options.input;
                this.submitButton = options.submitButton;
                this.cancelButton = options.cancelButton;
                this.overlayManager = overlayManager;
                this.l10n = l10n;
                this.updateCallback = null;
                this.reason = null;
                this.submitButton.addEventListener("click", this.verify.bind(this));
                this.cancelButton.addEventListener("click", this.close.bind(this));
                this.input.addEventListener("keydown", (e) => {
                  if (e.keyCode === 13) {
                    this.verify();
                  }
                });
                this.overlayManager.register(this.overlayName, this.container, this.close.bind(this), true);
              }
              open() {
                this.overlayManager.open(this.overlayName).then(() => {
                  this.input.focus();
                  let promptString;
                  if (this.reason === _pdf.PasswordResponses.INCORRECT_PASSWORD) {
                    promptString = this.l10n.get("password_invalid", null, "Invalid password. Please try again.");
                  } else {
                    promptString = this.l10n.get("password_label", null, "Enter the password to open this PDF file.");
                  }
                  promptString.then((msg) => {
                    this.label.textContent = msg;
                  });
                });
              }
              close() {
                this.overlayManager.close(this.overlayName).then(() => {
                  this.input.value = "";
                });
              }
              verify() {
                const password = this.input.value;
                if (password && password.length > 0) {
                  this.close();
                  this.updateCallback(password);
                }
              }
              setUpdateCallback(updateCallback, reason) {
                this.updateCallback = updateCallback;
                this.reason = reason;
              }
            }
            exports2.PasswordPrompt = PasswordPrompt;
          },
          6506: function(__unused_webpack_module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.PDFAttachmentViewer = void 0;
            var _pdf = __webpack_require__2(3941);
            class PDFAttachmentViewer {
              constructor({
                container,
                eventBus,
                downloadManager
              }) {
                this.container = container;
                this.eventBus = eventBus;
                this.downloadManager = downloadManager;
                this.reset();
                this.eventBus._on("fileattachmentannotation", this._appendAttachment.bind(this));
              }
              reset(keepRenderedCapability = false) {
                this.attachments = null;
                this.container.textContent = "";
                if (!keepRenderedCapability) {
                  this._renderedCapability = (0, _pdf.createPromiseCapability)();
                }
              }
              _dispatchEvent(attachmentsCount) {
                this._renderedCapability.resolve();
                this.eventBus.dispatch("attachmentsloaded", {
                  source: this,
                  attachmentsCount
                });
              }
              _bindPdfLink(button, content, filename) {
                if (this.downloadManager.disableCreateObjectURL) {
                  throw new Error('bindPdfLink: Unsupported "disableCreateObjectURL" value.');
                }
                let blobUrl;
                button.onclick = function() {
                  if (!blobUrl) {
                    blobUrl = (0, _pdf.createObjectURL)(content, "application/pdf");
                  }
                  let viewerUrl;
                  viewerUrl = "?file=" + encodeURIComponent(blobUrl + "#" + filename);
                  window.open(viewerUrl);
                  return false;
                };
              }
              _bindLink(button, content, filename) {
                button.onclick = () => {
                  this.downloadManager.downloadData(content, filename, "");
                  return false;
                };
              }
              render({
                attachments,
                keepRenderedCapability = false
              }) {
                let attachmentsCount = 0;
                if (this.attachments) {
                  this.reset(keepRenderedCapability === true);
                }
                this.attachments = attachments || null;
                if (!attachments) {
                  this._dispatchEvent(attachmentsCount);
                  return;
                }
                const names = Object.keys(attachments).sort(function(a, b) {
                  return a.toLowerCase().localeCompare(b.toLowerCase());
                });
                attachmentsCount = names.length;
                for (let i = 0; i < attachmentsCount; i++) {
                  const item = attachments[names[i]];
                  const filename = (0, _pdf.removeNullCharacters)((0, _pdf.getFilenameFromUrl)(item.filename));
                  const div = document.createElement("div");
                  div.className = "attachmentsItem";
                  const button = document.createElement("button");
                  button.textContent = filename;
                  if (/\.pdf$/i.test(filename) && !this.downloadManager.disableCreateObjectURL) {
                    this._bindPdfLink(button, item.content, filename);
                  } else {
                    this._bindLink(button, item.content, filename);
                  }
                  div.appendChild(button);
                  this.container.appendChild(div);
                }
                this._dispatchEvent(attachmentsCount);
              }
              _appendAttachment({
                id,
                filename,
                content
              }) {
                this._renderedCapability.promise.then(() => {
                  let attachments = this.attachments;
                  if (!attachments) {
                    attachments = /* @__PURE__ */ Object.create(null);
                  } else {
                    for (const name in attachments) {
                      if (id === name) {
                        return;
                      }
                    }
                  }
                  attachments[id] = {
                    filename,
                    content
                  };
                  this.render({
                    attachments,
                    keepRenderedCapability: true
                  });
                });
              }
            }
            exports2.PDFAttachmentViewer = PDFAttachmentViewer;
          },
          6879: function(__unused_webpack_module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.PDFCursorTools = exports2.CursorTool = void 0;
            var _grab_to_pan = __webpack_require__2(1565);
            const CursorTool = {
              SELECT: 0,
              HAND: 1,
              ZOOM: 2
            };
            exports2.CursorTool = CursorTool;
            class PDFCursorTools {
              constructor({
                container,
                eventBus,
                cursorToolOnLoad = CursorTool.SELECT
              }) {
                this.container = container;
                this.eventBus = eventBus;
                this.active = CursorTool.SELECT;
                this.activeBeforePresentationMode = null;
                this.handTool = new _grab_to_pan.GrabToPan({
                  element: this.container
                });
                this._addEventListeners();
                Promise.resolve().then(() => {
                  this.switchTool(cursorToolOnLoad);
                });
              }
              get activeTool() {
                return this.active;
              }
              switchTool(tool) {
                if (this.activeBeforePresentationMode !== null) {
                  return;
                }
                if (tool === this.active) {
                  return;
                }
                const disableActiveTool = () => {
                  switch (this.active) {
                    case CursorTool.SELECT:
                      break;
                    case CursorTool.HAND:
                      this.handTool.deactivate();
                      break;
                    case CursorTool.ZOOM:
                  }
                };
                switch (tool) {
                  case CursorTool.SELECT:
                    disableActiveTool();
                    break;
                  case CursorTool.HAND:
                    disableActiveTool();
                    this.handTool.activate();
                    break;
                  case CursorTool.ZOOM:
                  default:
                    console.error(`switchTool: "${tool}" is an unsupported value.`);
                    return;
                }
                this.active = tool;
                this._dispatchEvent();
              }
              _dispatchEvent() {
                this.eventBus.dispatch("cursortoolchanged", {
                  source: this,
                  tool: this.active
                });
              }
              _addEventListeners() {
                this.eventBus._on("switchcursortool", (evt) => {
                  this.switchTool(evt.tool);
                });
                this.eventBus._on("presentationmodechanged", (evt) => {
                  if (evt.switchInProgress) {
                    return;
                  }
                  let previouslyActive;
                  if (evt.active) {
                    previouslyActive = this.active;
                    this.switchTool(CursorTool.SELECT);
                    this.activeBeforePresentationMode = previouslyActive;
                  } else {
                    previouslyActive = this.activeBeforePresentationMode;
                    this.activeBeforePresentationMode = null;
                    this.switchTool(previouslyActive);
                  }
                });
              }
            }
            exports2.PDFCursorTools = PDFCursorTools;
          },
          5113: function(__unused_webpack_module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.PDFDocumentProperties = void 0;
            var _pdf = __webpack_require__2(3941);
            var _ui_utils = __webpack_require__2(5570);
            const DEFAULT_FIELD_CONTENT = "-";
            const NON_METRIC_LOCALES = ["en-us", "en-lr", "my"];
            const US_PAGE_NAMES = {
              "8.5x11": "Letter",
              "8.5x14": "Legal"
            };
            const METRIC_PAGE_NAMES = {
              "297x420": "A3",
              "210x297": "A4"
            };
            function getPageName(size, isPortrait, pageNames) {
              const width = isPortrait ? size.width : size.height;
              const height = isPortrait ? size.height : size.width;
              return pageNames[`${width}x${height}`];
            }
            class PDFDocumentProperties {
              constructor({
                overlayName,
                fields,
                container,
                closeButton
              }, overlayManager, eventBus, l10n = _ui_utils.NullL10n) {
                this.overlayName = overlayName;
                this.fields = fields;
                this.container = container;
                this.overlayManager = overlayManager;
                this.l10n = l10n;
                this._reset();
                if (closeButton) {
                  closeButton.addEventListener("click", this.close.bind(this));
                }
                this.overlayManager.register(this.overlayName, this.container, this.close.bind(this));
                if (eventBus) {
                  eventBus._on("pagechanging", (evt) => {
                    this._currentPageNumber = evt.pageNumber;
                  });
                  eventBus._on("rotationchanging", (evt) => {
                    this._pagesRotation = evt.pagesRotation;
                  });
                }
                this._isNonMetricLocale = true;
                l10n.getLanguage().then((locale) => {
                  this._isNonMetricLocale = NON_METRIC_LOCALES.includes(locale);
                });
              }
              open() {
                const freezeFieldData = (data) => {
                  Object.defineProperty(this, "fieldData", {
                    value: Object.freeze(data),
                    writable: false,
                    enumerable: true,
                    configurable: true
                  });
                };
                Promise.all([this.overlayManager.open(this.overlayName), this._dataAvailableCapability.promise]).then(() => {
                  const currentPageNumber = this._currentPageNumber;
                  const pagesRotation = this._pagesRotation;
                  if (this.fieldData && currentPageNumber === this.fieldData["_currentPageNumber"] && pagesRotation === this.fieldData["_pagesRotation"]) {
                    this._updateUI();
                    return;
                  }
                  this.pdfDocument.getMetadata().then(({
                    info,
                    metadata,
                    contentDispositionFilename
                  }) => {
                    return Promise.all([info, metadata, contentDispositionFilename || (0, _ui_utils.getPDFFileNameFromURL)(this.url || ""), this._parseFileSize(this.maybeFileSize), this._parseDate(info.CreationDate), this._parseDate(info.ModDate), this.pdfDocument.getPage(currentPageNumber).then((pdfPage) => {
                      return this._parsePageSize((0, _ui_utils.getPageSizeInches)(pdfPage), pagesRotation);
                    }), this._parseLinearization(info.IsLinearized)]);
                  }).then(([info, metadata, fileName, fileSize, creationDate, modDate, pageSize, isLinearized]) => {
                    freezeFieldData({
                      fileName,
                      fileSize,
                      title: info.Title,
                      author: info.Author,
                      subject: info.Subject,
                      keywords: info.Keywords,
                      creationDate,
                      modificationDate: modDate,
                      creator: info.Creator,
                      producer: info.Producer,
                      version: info.PDFFormatVersion,
                      pageCount: this.pdfDocument.numPages,
                      pageSize,
                      linearized: isLinearized,
                      _currentPageNumber: currentPageNumber,
                      _pagesRotation: pagesRotation
                    });
                    this._updateUI();
                    return this.pdfDocument.getDownloadInfo();
                  }).then(({
                    length
                  }) => {
                    this.maybeFileSize = length;
                    return this._parseFileSize(length);
                  }).then((fileSize) => {
                    if (fileSize === this.fieldData["fileSize"]) {
                      return;
                    }
                    const data = Object.assign(/* @__PURE__ */ Object.create(null), this.fieldData);
                    data["fileSize"] = fileSize;
                    freezeFieldData(data);
                    this._updateUI();
                  });
                });
              }
              close() {
                this.overlayManager.close(this.overlayName);
              }
              setDocument(pdfDocument, url = null) {
                if (this.pdfDocument) {
                  this._reset();
                  this._updateUI(true);
                }
                if (!pdfDocument) {
                  return;
                }
                this.pdfDocument = pdfDocument;
                this.url = url;
                this._dataAvailableCapability.resolve();
              }
              setFileSize(fileSize) {
                if (Number.isInteger(fileSize) && fileSize > 0) {
                  this.maybeFileSize = fileSize;
                }
              }
              _reset() {
                this.pdfDocument = null;
                this.url = null;
                this.maybeFileSize = 0;
                delete this.fieldData;
                this._dataAvailableCapability = (0, _pdf.createPromiseCapability)();
                this._currentPageNumber = 1;
                this._pagesRotation = 0;
              }
              _updateUI(reset = false) {
                if (reset || !this.fieldData) {
                  for (const id in this.fields) {
                    this.fields[id].textContent = DEFAULT_FIELD_CONTENT;
                  }
                  return;
                }
                if (this.overlayManager.active !== this.overlayName) {
                  return;
                }
                for (const id in this.fields) {
                  const content = this.fieldData[id];
                  this.fields[id].textContent = content || content === 0 ? content : DEFAULT_FIELD_CONTENT;
                }
              }
              async _parseFileSize(fileSize = 0) {
                const kb = fileSize / 1024;
                if (!kb) {
                  return void 0;
                } else if (kb < 1024) {
                  return this.l10n.get("document_properties_kb", {
                    size_kb: (+kb.toPrecision(3)).toLocaleString(),
                    size_b: fileSize.toLocaleString()
                  }, "{{size_kb}} KB ({{size_b}} bytes)");
                }
                return this.l10n.get("document_properties_mb", {
                  size_mb: (+(kb / 1024).toPrecision(3)).toLocaleString(),
                  size_b: fileSize.toLocaleString()
                }, "{{size_mb}} MB ({{size_b}} bytes)");
              }
              async _parsePageSize(pageSizeInches, pagesRotation) {
                if (!pageSizeInches) {
                  return void 0;
                }
                if (pagesRotation % 180 !== 0) {
                  pageSizeInches = {
                    width: pageSizeInches.height,
                    height: pageSizeInches.width
                  };
                }
                const isPortrait = (0, _ui_utils.isPortraitOrientation)(pageSizeInches);
                let sizeInches = {
                  width: Math.round(pageSizeInches.width * 100) / 100,
                  height: Math.round(pageSizeInches.height * 100) / 100
                };
                let sizeMillimeters = {
                  width: Math.round(pageSizeInches.width * 25.4 * 10) / 10,
                  height: Math.round(pageSizeInches.height * 25.4 * 10) / 10
                };
                let pageName = null;
                let rawName = getPageName(sizeInches, isPortrait, US_PAGE_NAMES) || getPageName(sizeMillimeters, isPortrait, METRIC_PAGE_NAMES);
                if (!rawName && !(Number.isInteger(sizeMillimeters.width) && Number.isInteger(sizeMillimeters.height))) {
                  const exactMillimeters = {
                    width: pageSizeInches.width * 25.4,
                    height: pageSizeInches.height * 25.4
                  };
                  const intMillimeters = {
                    width: Math.round(sizeMillimeters.width),
                    height: Math.round(sizeMillimeters.height)
                  };
                  if (Math.abs(exactMillimeters.width - intMillimeters.width) < 0.1 && Math.abs(exactMillimeters.height - intMillimeters.height) < 0.1) {
                    rawName = getPageName(intMillimeters, isPortrait, METRIC_PAGE_NAMES);
                    if (rawName) {
                      sizeInches = {
                        width: Math.round(intMillimeters.width / 25.4 * 100) / 100,
                        height: Math.round(intMillimeters.height / 25.4 * 100) / 100
                      };
                      sizeMillimeters = intMillimeters;
                    }
                  }
                }
                if (rawName) {
                  pageName = this.l10n.get("document_properties_page_size_name_" + rawName.toLowerCase(), null, rawName);
                }
                return Promise.all([this._isNonMetricLocale ? sizeInches : sizeMillimeters, this.l10n.get("document_properties_page_size_unit_" + (this._isNonMetricLocale ? "inches" : "millimeters"), null, this._isNonMetricLocale ? "in" : "mm"), pageName, this.l10n.get("document_properties_page_size_orientation_" + (isPortrait ? "portrait" : "landscape"), null, isPortrait ? "portrait" : "landscape")]).then(([{
                  width,
                  height
                }, unit, name, orientation]) => {
                  return this.l10n.get("document_properties_page_size_dimension_" + (name ? "name_" : "") + "string", {
                    width: width.toLocaleString(),
                    height: height.toLocaleString(),
                    unit,
                    name,
                    orientation
                  }, "{{width}} \xD7 {{height}} {{unit}} (" + (name ? "{{name}}, " : "") + "{{orientation}})");
                });
              }
              async _parseDate(inputDate) {
                const dateObject = _pdf.PDFDateString.toDateObject(inputDate);
                if (!dateObject) {
                  return void 0;
                }
                return this.l10n.get("document_properties_date_string", {
                  date: dateObject.toLocaleDateString(),
                  time: dateObject.toLocaleTimeString()
                }, "{{date}}, {{time}}");
              }
              _parseLinearization(isLinearized) {
                return this.l10n.get("document_properties_linearized_" + (isLinearized ? "yes" : "no"), null, isLinearized ? "Yes" : "No");
              }
            }
            exports2.PDFDocumentProperties = PDFDocumentProperties;
          },
          2105: function(__unused_webpack_module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.PDFFindBar = void 0;
            var _ui_utils = __webpack_require__2(5570);
            var _pdf_find_controller = __webpack_require__2(5704);
            const MATCHES_COUNT_LIMIT = 1e3;
            class PDFFindBar {
              constructor(options, eventBus, l10n = _ui_utils.NullL10n) {
                this.opened = false;
                this.bar = options.bar || null;
                this.toggleButton = options.toggleButton || null;
                this.findField = options.findField || null;
                this.highlightAll = options.highlightAllCheckbox || null;
                this.caseSensitive = options.caseSensitiveCheckbox || null;
                this.entireWord = options.entireWordCheckbox || null;
                this.findMsg = options.findMsg || null;
                this.findResultsCount = options.findResultsCount || null;
                this.findPreviousButton = options.findPreviousButton || null;
                this.findNextButton = options.findNextButton || null;
                this.eventBus = eventBus || (0, _ui_utils.getGlobalEventBus)();
                this.l10n = l10n;
                this.toggleButton.addEventListener("click", () => {
                  this.toggle();
                });
                this.findField.addEventListener("input", () => {
                  this.dispatchEvent("");
                });
                this.bar.addEventListener("keydown", (e) => {
                  switch (e.keyCode) {
                    case 13:
                      if (e.target === this.findField) {
                        this.dispatchEvent("again", e.shiftKey);
                      }
                      break;
                    case 27:
                      this.close();
                      break;
                  }
                });
                this.findPreviousButton.addEventListener("click", () => {
                  this.dispatchEvent("again", true);
                });
                this.findNextButton.addEventListener("click", () => {
                  this.dispatchEvent("again", false);
                });
                this.highlightAll.addEventListener("click", () => {
                  this.dispatchEvent("highlightallchange");
                });
                this.caseSensitive.addEventListener("click", () => {
                  this.dispatchEvent("casesensitivitychange");
                });
                this.entireWord.addEventListener("click", () => {
                  this.dispatchEvent("entirewordchange");
                });
                this.eventBus._on("resize", this._adjustWidth.bind(this));
              }
              reset() {
                this.updateUIState();
              }
              dispatchEvent(type, findPrev) {
                this.eventBus.dispatch("find", {
                  source: this,
                  type,
                  query: this.findField.value,
                  phraseSearch: true,
                  caseSensitive: this.caseSensitive.checked,
                  entireWord: this.entireWord.checked,
                  highlightAll: this.highlightAll.checked,
                  findPrevious: findPrev
                });
              }
              updateUIState(state, previous, matchesCount) {
                let notFound = false;
                let findMsg = "";
                let status = "";
                switch (state) {
                  case _pdf_find_controller.FindState.FOUND:
                    break;
                  case _pdf_find_controller.FindState.PENDING:
                    status = "pending";
                    break;
                  case _pdf_find_controller.FindState.NOT_FOUND:
                    findMsg = this.l10n.get("find_not_found", null, "Phrase not found");
                    notFound = true;
                    break;
                  case _pdf_find_controller.FindState.WRAPPED:
                    if (previous) {
                      findMsg = this.l10n.get("find_reached_top", null, "Reached top of document, continued from bottom");
                    } else {
                      findMsg = this.l10n.get("find_reached_bottom", null, "Reached end of document, continued from top");
                    }
                    break;
                }
                this.findField.classList.toggle("notFound", notFound);
                this.findField.setAttribute("data-status", status);
                Promise.resolve(findMsg).then((msg) => {
                  this.findMsg.textContent = msg;
                  this._adjustWidth();
                });
                this.updateResultsCount(matchesCount);
              }
              updateResultsCount({
                current = 0,
                total = 0
              } = {}) {
                if (!this.findResultsCount) {
                  return;
                }
                const limit = MATCHES_COUNT_LIMIT;
                let matchesCountMsg = "";
                if (total > 0) {
                  if (total > limit) {
                    matchesCountMsg = this.l10n.get("find_match_count_limit", {
                      limit
                    }, "More than {{limit}} match" + (limit !== 1 ? "es" : ""));
                  } else {
                    matchesCountMsg = this.l10n.get("find_match_count", {
                      current,
                      total
                    }, "{{current}} of {{total}} match" + (total !== 1 ? "es" : ""));
                  }
                }
                Promise.resolve(matchesCountMsg).then((msg) => {
                  this.findResultsCount.textContent = msg;
                  this.findResultsCount.classList.toggle("hidden", !total);
                  this._adjustWidth();
                });
              }
              open() {
                if (!this.opened) {
                  this.opened = true;
                  this.toggleButton.classList.add("toggled");
                  this.bar.classList.remove("hidden");
                }
                this.findField.select();
                this.findField.focus();
                this._adjustWidth();
              }
              close() {
                if (!this.opened) {
                  return;
                }
                this.opened = false;
                this.toggleButton.classList.remove("toggled");
                this.bar.classList.add("hidden");
                this.eventBus.dispatch("findbarclose", {
                  source: this
                });
              }
              toggle() {
                if (this.opened) {
                  this.close();
                } else {
                  this.open();
                }
              }
              _adjustWidth() {
                if (!this.opened) {
                  return;
                }
                this.bar.classList.remove("wrapContainers");
                const findbarHeight = this.bar.clientHeight;
                const inputContainerHeight = this.bar.firstElementChild.clientHeight;
                if (findbarHeight > inputContainerHeight) {
                  this.bar.classList.add("wrapContainers");
                }
              }
            }
            exports2.PDFFindBar = PDFFindBar;
          },
          5704: function(__unused_webpack_module2, exports2, __webpack_require__2) {
            "use strict";
            __webpack_require__2(7658);
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.PDFFindController = exports2.FindState = void 0;
            var _ui_utils = __webpack_require__2(5570);
            var _pdf = __webpack_require__2(3941);
            var _pdf_find_utils = __webpack_require__2(7954);
            const FindState = {
              FOUND: 0,
              NOT_FOUND: 1,
              WRAPPED: 2,
              PENDING: 3
            };
            exports2.FindState = FindState;
            const FIND_TIMEOUT = 250;
            const MATCH_SCROLL_OFFSET_TOP = -50;
            const MATCH_SCROLL_OFFSET_LEFT = -400;
            const CHARACTERS_TO_NORMALIZE = {
              "\u2018": "'",
              "\u2019": "'",
              "\u201A": "'",
              "\u201B": "'",
              "\u201C": '"',
              "\u201D": '"',
              "\u201E": '"',
              "\u201F": '"',
              "\xBC": "1/4",
              "\xBD": "1/2",
              "\xBE": "3/4"
            };
            let normalizationRegex = null;
            function normalize(text) {
              if (!normalizationRegex) {
                const replace = Object.keys(CHARACTERS_TO_NORMALIZE).join("");
                normalizationRegex = new RegExp(`[${replace}]`, "g");
              }
              return text.replace(normalizationRegex, function(ch) {
                return CHARACTERS_TO_NORMALIZE[ch];
              });
            }
            class PDFFindController {
              constructor({
                linkService,
                eventBus
              }) {
                this._linkService = linkService;
                this._eventBus = eventBus || (0, _ui_utils.getGlobalEventBus)();
                this._reset();
                eventBus._on("findbarclose", this._onFindBarClose.bind(this));
              }
              get highlightMatches() {
                return this._highlightMatches;
              }
              get pageMatches() {
                return this._pageMatches;
              }
              get pageMatchesLength() {
                return this._pageMatchesLength;
              }
              get selected() {
                return this._selected;
              }
              get state() {
                return this._state;
              }
              setDocument(pdfDocument) {
                if (this._pdfDocument) {
                  this._reset();
                }
                if (!pdfDocument) {
                  return;
                }
                this._pdfDocument = pdfDocument;
                this._firstPageCapability.resolve();
              }
              executeCommand(cmd, state) {
                if (!state) {
                  return;
                }
                const pdfDocument = this._pdfDocument;
                if (this._state === null || this._shouldDirtyMatch(cmd, state)) {
                  this._dirtyMatch = true;
                }
                this._state = state;
                if (cmd !== "findhighlightallchange") {
                  this._updateUIState(FindState.PENDING);
                }
                this._firstPageCapability.promise.then(() => {
                  if (!this._pdfDocument || pdfDocument && this._pdfDocument !== pdfDocument) {
                    return;
                  }
                  this._extractText();
                  const findbarClosed = !this._highlightMatches;
                  const pendingTimeout = !!this._findTimeout;
                  if (this._findTimeout) {
                    clearTimeout(this._findTimeout);
                    this._findTimeout = null;
                  }
                  if (cmd === "find") {
                    this._findTimeout = setTimeout(() => {
                      this._nextMatch();
                      this._findTimeout = null;
                    }, FIND_TIMEOUT);
                  } else if (this._dirtyMatch) {
                    this._nextMatch();
                  } else if (cmd === "findagain") {
                    this._nextMatch();
                    if (findbarClosed && this._state.highlightAll) {
                      this._updateAllPages();
                    }
                  } else if (cmd === "findhighlightallchange") {
                    if (pendingTimeout) {
                      this._nextMatch();
                    } else {
                      this._highlightMatches = true;
                    }
                    this._updateAllPages();
                  } else {
                    this._nextMatch();
                  }
                });
              }
              scrollMatchIntoView({
                element = null,
                pageIndex = -1,
                matchIndex = -1
              }) {
                if (!this._scrollMatches || !element) {
                  return;
                } else if (matchIndex === -1 || matchIndex !== this._selected.matchIdx) {
                  return;
                } else if (pageIndex === -1 || pageIndex !== this._selected.pageIdx) {
                  return;
                }
                this._scrollMatches = false;
                const spot = {
                  top: MATCH_SCROLL_OFFSET_TOP,
                  left: MATCH_SCROLL_OFFSET_LEFT
                };
                (0, _ui_utils.scrollIntoView)(element, spot, true);
              }
              _reset() {
                this._highlightMatches = false;
                this._scrollMatches = false;
                this._pdfDocument = null;
                this._pageMatches = [];
                this._pageMatchesLength = [];
                this._state = null;
                this._selected = {
                  pageIdx: -1,
                  matchIdx: -1
                };
                this._offset = {
                  pageIdx: null,
                  matchIdx: null,
                  wrapped: false
                };
                this._extractTextPromises = [];
                this._pageContents = [];
                this._matchesCountTotal = 0;
                this._pagesToSearch = null;
                this._pendingFindMatches = /* @__PURE__ */ Object.create(null);
                this._resumePageIdx = null;
                this._dirtyMatch = false;
                clearTimeout(this._findTimeout);
                this._findTimeout = null;
                this._firstPageCapability = (0, _pdf.createPromiseCapability)();
              }
              get _query() {
                if (this._state.query !== this._rawQuery) {
                  this._rawQuery = this._state.query;
                  this._normalizedQuery = normalize(this._state.query);
                }
                return this._normalizedQuery;
              }
              _shouldDirtyMatch(cmd, state) {
                if (state.query !== this._state.query) {
                  return true;
                }
                switch (cmd) {
                  case "findagain":
                    const pageNumber = this._selected.pageIdx + 1;
                    const linkService = this._linkService;
                    if (pageNumber >= 1 && pageNumber <= linkService.pagesCount && pageNumber !== linkService.page && !linkService.isPageVisible(pageNumber)) {
                      return true;
                    }
                    return false;
                  case "findhighlightallchange":
                    return false;
                }
                return true;
              }
              _prepareMatches(matchesWithLength, matches, matchesLength) {
                function isSubTerm(currentIndex) {
                  const currentElem = matchesWithLength[currentIndex];
                  const nextElem = matchesWithLength[currentIndex + 1];
                  if (currentIndex < matchesWithLength.length - 1 && currentElem.match === nextElem.match) {
                    currentElem.skipped = true;
                    return true;
                  }
                  for (let i = currentIndex - 1; i >= 0; i--) {
                    const prevElem = matchesWithLength[i];
                    if (prevElem.skipped) {
                      continue;
                    }
                    if (prevElem.match + prevElem.matchLength < currentElem.match) {
                      break;
                    }
                    if (prevElem.match + prevElem.matchLength >= currentElem.match + currentElem.matchLength) {
                      currentElem.skipped = true;
                      return true;
                    }
                  }
                  return false;
                }
                matchesWithLength.sort(function(a, b) {
                  return a.match === b.match ? a.matchLength - b.matchLength : a.match - b.match;
                });
                for (let i = 0, len = matchesWithLength.length; i < len; i++) {
                  if (isSubTerm(i)) {
                    continue;
                  }
                  matches.push(matchesWithLength[i].match);
                  matchesLength.push(matchesWithLength[i].matchLength);
                }
              }
              _isEntireWord(content, startIdx, length) {
                if (startIdx > 0) {
                  const first = content.charCodeAt(startIdx);
                  const limit = content.charCodeAt(startIdx - 1);
                  if ((0, _pdf_find_utils.getCharacterType)(first) === (0, _pdf_find_utils.getCharacterType)(limit)) {
                    return false;
                  }
                }
                const endIdx = startIdx + length - 1;
                if (endIdx < content.length - 1) {
                  const last = content.charCodeAt(endIdx);
                  const limit = content.charCodeAt(endIdx + 1);
                  if ((0, _pdf_find_utils.getCharacterType)(last) === (0, _pdf_find_utils.getCharacterType)(limit)) {
                    return false;
                  }
                }
                return true;
              }
              _calculatePhraseMatch(query, pageIndex, pageContent, entireWord) {
                const matches = [];
                const queryLen = query.length;
                let matchIdx = -queryLen;
                while (true) {
                  matchIdx = pageContent.indexOf(query, matchIdx + queryLen);
                  if (matchIdx === -1) {
                    break;
                  }
                  if (entireWord && !this._isEntireWord(pageContent, matchIdx, queryLen)) {
                    continue;
                  }
                  matches.push(matchIdx);
                }
                this._pageMatches[pageIndex] = matches;
              }
              _calculateWordMatch(query, pageIndex, pageContent, entireWord) {
                const matchesWithLength = [];
                const queryArray = query.match(/\S+/g);
                for (let i = 0, len = queryArray.length; i < len; i++) {
                  const subquery = queryArray[i];
                  const subqueryLen = subquery.length;
                  let matchIdx = -subqueryLen;
                  while (true) {
                    matchIdx = pageContent.indexOf(subquery, matchIdx + subqueryLen);
                    if (matchIdx === -1) {
                      break;
                    }
                    if (entireWord && !this._isEntireWord(pageContent, matchIdx, subqueryLen)) {
                      continue;
                    }
                    matchesWithLength.push({
                      match: matchIdx,
                      matchLength: subqueryLen,
                      skipped: false
                    });
                  }
                }
                this._pageMatchesLength[pageIndex] = [];
                this._pageMatches[pageIndex] = [];
                this._prepareMatches(matchesWithLength, this._pageMatches[pageIndex], this._pageMatchesLength[pageIndex]);
              }
              _calculateMatch(pageIndex) {
                let pageContent = this._pageContents[pageIndex];
                let query = this._query;
                const {
                  caseSensitive,
                  entireWord,
                  phraseSearch
                } = this._state;
                if (query.length === 0) {
                  return;
                }
                if (!caseSensitive) {
                  pageContent = pageContent.toLowerCase();
                  query = query.toLowerCase();
                }
                if (phraseSearch) {
                  this._calculatePhraseMatch(query, pageIndex, pageContent, entireWord);
                } else {
                  this._calculateWordMatch(query, pageIndex, pageContent, entireWord);
                }
                if (this._state.highlightAll) {
                  this._updatePage(pageIndex);
                }
                if (this._resumePageIdx === pageIndex) {
                  this._resumePageIdx = null;
                  this._nextPageMatch();
                }
                const pageMatchesCount = this._pageMatches[pageIndex].length;
                if (pageMatchesCount > 0) {
                  this._matchesCountTotal += pageMatchesCount;
                  this._updateUIResultsCount();
                }
              }
              _extractText() {
                if (this._extractTextPromises.length > 0) {
                  return;
                }
                let promise = Promise.resolve();
                for (let i = 0, ii = this._linkService.pagesCount; i < ii; i++) {
                  const extractTextCapability = (0, _pdf.createPromiseCapability)();
                  this._extractTextPromises[i] = extractTextCapability.promise;
                  promise = promise.then(() => {
                    return this._pdfDocument.getPage(i + 1).then((pdfPage) => {
                      return pdfPage.getTextContent({
                        normalizeWhitespace: true
                      });
                    }).then((textContent) => {
                      const textItems = textContent.items;
                      const strBuf = [];
                      for (let j = 0, jj = textItems.length; j < jj; j++) {
                        strBuf.push(textItems[j].str);
                      }
                      this._pageContents[i] = normalize(strBuf.join(""));
                      extractTextCapability.resolve(i);
                    }, (reason) => {
                      console.error(`Unable to get text content for page ${i + 1}`, reason);
                      this._pageContents[i] = "";
                      extractTextCapability.resolve(i);
                    });
                  });
                }
              }
              _updatePage(index) {
                if (this._scrollMatches && this._selected.pageIdx === index) {
                  this._linkService.page = index + 1;
                }
                this._eventBus.dispatch("updatetextlayermatches", {
                  source: this,
                  pageIndex: index
                });
              }
              _updateAllPages() {
                this._eventBus.dispatch("updatetextlayermatches", {
                  source: this,
                  pageIndex: -1
                });
              }
              _nextMatch() {
                const previous = this._state.findPrevious;
                const currentPageIndex = this._linkService.page - 1;
                const numPages = this._linkService.pagesCount;
                this._highlightMatches = true;
                if (this._dirtyMatch) {
                  this._dirtyMatch = false;
                  this._selected.pageIdx = this._selected.matchIdx = -1;
                  this._offset.pageIdx = currentPageIndex;
                  this._offset.matchIdx = null;
                  this._offset.wrapped = false;
                  this._resumePageIdx = null;
                  this._pageMatches.length = 0;
                  this._pageMatchesLength.length = 0;
                  this._matchesCountTotal = 0;
                  this._updateAllPages();
                  for (let i = 0; i < numPages; i++) {
                    if (this._pendingFindMatches[i] === true) {
                      continue;
                    }
                    this._pendingFindMatches[i] = true;
                    this._extractTextPromises[i].then((pageIdx) => {
                      delete this._pendingFindMatches[pageIdx];
                      this._calculateMatch(pageIdx);
                    });
                  }
                }
                if (this._query === "") {
                  this._updateUIState(FindState.FOUND);
                  return;
                }
                if (this._resumePageIdx) {
                  return;
                }
                const offset = this._offset;
                this._pagesToSearch = numPages;
                if (offset.matchIdx !== null) {
                  const numPageMatches = this._pageMatches[offset.pageIdx].length;
                  if (!previous && offset.matchIdx + 1 < numPageMatches || previous && offset.matchIdx > 0) {
                    offset.matchIdx = previous ? offset.matchIdx - 1 : offset.matchIdx + 1;
                    this._updateMatch(true);
                    return;
                  }
                  this._advanceOffsetPage(previous);
                }
                this._nextPageMatch();
              }
              _matchesReady(matches) {
                const offset = this._offset;
                const numMatches = matches.length;
                const previous = this._state.findPrevious;
                if (numMatches) {
                  offset.matchIdx = previous ? numMatches - 1 : 0;
                  this._updateMatch(true);
                  return true;
                }
                this._advanceOffsetPage(previous);
                if (offset.wrapped) {
                  offset.matchIdx = null;
                  if (this._pagesToSearch < 0) {
                    this._updateMatch(false);
                    return true;
                  }
                }
                return false;
              }
              _nextPageMatch() {
                if (this._resumePageIdx !== null) {
                  console.error("There can only be one pending page.");
                }
                let matches = null;
                do {
                  const pageIdx = this._offset.pageIdx;
                  matches = this._pageMatches[pageIdx];
                  if (!matches) {
                    this._resumePageIdx = pageIdx;
                    break;
                  }
                } while (!this._matchesReady(matches));
              }
              _advanceOffsetPage(previous) {
                const offset = this._offset;
                const numPages = this._linkService.pagesCount;
                offset.pageIdx = previous ? offset.pageIdx - 1 : offset.pageIdx + 1;
                offset.matchIdx = null;
                this._pagesToSearch--;
                if (offset.pageIdx >= numPages || offset.pageIdx < 0) {
                  offset.pageIdx = previous ? numPages - 1 : 0;
                  offset.wrapped = true;
                }
              }
              _updateMatch(found = false) {
                let state = FindState.NOT_FOUND;
                const wrapped = this._offset.wrapped;
                this._offset.wrapped = false;
                if (found) {
                  const previousPage = this._selected.pageIdx;
                  this._selected.pageIdx = this._offset.pageIdx;
                  this._selected.matchIdx = this._offset.matchIdx;
                  state = wrapped ? FindState.WRAPPED : FindState.FOUND;
                  if (previousPage !== -1 && previousPage !== this._selected.pageIdx) {
                    this._updatePage(previousPage);
                  }
                }
                this._updateUIState(state, this._state.findPrevious);
                if (this._selected.pageIdx !== -1) {
                  this._scrollMatches = true;
                  this._updatePage(this._selected.pageIdx);
                }
              }
              _onFindBarClose(evt) {
                const pdfDocument = this._pdfDocument;
                this._firstPageCapability.promise.then(() => {
                  if (!this._pdfDocument || pdfDocument && this._pdfDocument !== pdfDocument) {
                    return;
                  }
                  if (this._findTimeout) {
                    clearTimeout(this._findTimeout);
                    this._findTimeout = null;
                  }
                  if (this._resumePageIdx) {
                    this._resumePageIdx = null;
                    this._dirtyMatch = true;
                  }
                  this._updateUIState(FindState.FOUND);
                  this._highlightMatches = false;
                  this._updateAllPages();
                });
              }
              _requestMatchesCount() {
                const {
                  pageIdx,
                  matchIdx
                } = this._selected;
                let current = 0, total = this._matchesCountTotal;
                if (matchIdx !== -1) {
                  for (let i = 0; i < pageIdx; i++) {
                    current += this._pageMatches[i] && this._pageMatches[i].length || 0;
                  }
                  current += matchIdx + 1;
                }
                if (current < 1 || current > total) {
                  current = total = 0;
                }
                return {
                  current,
                  total
                };
              }
              _updateUIResultsCount() {
                this._eventBus.dispatch("updatefindmatchescount", {
                  source: this,
                  matchesCount: this._requestMatchesCount()
                });
              }
              _updateUIState(state, previous) {
                this._eventBus.dispatch("updatefindcontrolstate", {
                  source: this,
                  state,
                  previous,
                  matchesCount: this._requestMatchesCount()
                });
              }
            }
            exports2.PDFFindController = PDFFindController;
          },
          7954: function(__unused_webpack_module2, exports2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.getCharacterType = getCharacterType;
            exports2.CharacterType = void 0;
            const CharacterType = {
              SPACE: 0,
              ALPHA_LETTER: 1,
              PUNCT: 2,
              HAN_LETTER: 3,
              KATAKANA_LETTER: 4,
              HIRAGANA_LETTER: 5,
              HALFWIDTH_KATAKANA_LETTER: 6,
              THAI_LETTER: 7
            };
            exports2.CharacterType = CharacterType;
            function isAlphabeticalScript(charCode) {
              return charCode < 11904;
            }
            function isAscii(charCode) {
              return (charCode & 65408) === 0;
            }
            function isAsciiAlpha(charCode) {
              return charCode >= 97 && charCode <= 122 || charCode >= 65 && charCode <= 90;
            }
            function isAsciiDigit(charCode) {
              return charCode >= 48 && charCode <= 57;
            }
            function isAsciiSpace(charCode) {
              return charCode === 32 || charCode === 9 || charCode === 13 || charCode === 10;
            }
            function isHan(charCode) {
              return charCode >= 13312 && charCode <= 40959 || charCode >= 63744 && charCode <= 64255;
            }
            function isKatakana(charCode) {
              return charCode >= 12448 && charCode <= 12543;
            }
            function isHiragana(charCode) {
              return charCode >= 12352 && charCode <= 12447;
            }
            function isHalfwidthKatakana(charCode) {
              return charCode >= 65376 && charCode <= 65439;
            }
            function isThai(charCode) {
              return (charCode & 65408) === 3584;
            }
            function getCharacterType(charCode) {
              if (isAlphabeticalScript(charCode)) {
                if (isAscii(charCode)) {
                  if (isAsciiSpace(charCode)) {
                    return CharacterType.SPACE;
                  } else if (isAsciiAlpha(charCode) || isAsciiDigit(charCode) || charCode === 95) {
                    return CharacterType.ALPHA_LETTER;
                  }
                  return CharacterType.PUNCT;
                } else if (isThai(charCode)) {
                  return CharacterType.THAI_LETTER;
                } else if (charCode === 160) {
                  return CharacterType.SPACE;
                }
                return CharacterType.ALPHA_LETTER;
              }
              if (isHan(charCode)) {
                return CharacterType.HAN_LETTER;
              } else if (isKatakana(charCode)) {
                return CharacterType.KATAKANA_LETTER;
              } else if (isHiragana(charCode)) {
                return CharacterType.HIRAGANA_LETTER;
              } else if (isHalfwidthKatakana(charCode)) {
                return CharacterType.HALFWIDTH_KATAKANA_LETTER;
              }
              return CharacterType.ALPHA_LETTER;
            }
          },
          2320: function(__unused_webpack_module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.isDestHashesEqual = isDestHashesEqual;
            exports2.isDestArraysEqual = isDestArraysEqual;
            exports2.PDFHistory = void 0;
            var _ui_utils = __webpack_require__2(5570);
            const HASH_CHANGE_TIMEOUT = 1e3;
            const POSITION_UPDATED_THRESHOLD = 50;
            const UPDATE_VIEWAREA_TIMEOUT = 1e3;
            function getCurrentHash() {
              return document.location.hash;
            }
            class PDFHistory {
              constructor({
                linkService,
                eventBus
              }) {
                this.linkService = linkService;
                this.eventBus = eventBus || (0, _ui_utils.getGlobalEventBus)();
                this._initialized = false;
                this._fingerprint = "";
                this.reset();
                this._boundEvents = null;
                this._isViewerInPresentationMode = false;
                this.eventBus._on("presentationmodechanged", (evt) => {
                  this._isViewerInPresentationMode = evt.active || evt.switchInProgress;
                });
                this.eventBus._on("pagesinit", () => {
                  this._isPagesLoaded = false;
                  const onPagesLoaded = (evt) => {
                    this.eventBus._off("pagesloaded", onPagesLoaded);
                    this._isPagesLoaded = !!evt.pagesCount;
                  };
                  this.eventBus._on("pagesloaded", onPagesLoaded);
                });
              }
              initialize({
                fingerprint,
                resetHistory = false,
                updateUrl = false
              }) {
                if (!fingerprint || typeof fingerprint !== "string") {
                  console.error('PDFHistory.initialize: The "fingerprint" must be a non-empty string.');
                  return;
                }
                if (this._initialized) {
                  this.reset();
                }
                const reInitialized = this._fingerprint !== "" && this._fingerprint !== fingerprint;
                this._fingerprint = fingerprint;
                this._updateUrl = updateUrl === true;
                this._initialized = true;
                this._bindEvents();
                const state = window.history.state;
                this._popStateInProgress = false;
                this._blockHashChange = 0;
                this._currentHash = getCurrentHash();
                this._numPositionUpdates = 0;
                this._uid = this._maxUid = 0;
                this._destination = null;
                this._position = null;
                if (!this._isValidState(state, true) || resetHistory) {
                  const {
                    hash,
                    page,
                    rotation
                  } = this._parseCurrentHash();
                  if (!hash || reInitialized || resetHistory) {
                    this._pushOrReplaceState(null, true);
                    return;
                  }
                  this._pushOrReplaceState({
                    hash,
                    page,
                    rotation
                  }, true);
                  return;
                }
                const destination = state.destination;
                this._updateInternalState(destination, state.uid, true);
                if (this._uid > this._maxUid) {
                  this._maxUid = this._uid;
                }
                if (destination.rotation !== void 0) {
                  this._initialRotation = destination.rotation;
                }
                if (destination.dest) {
                  this._initialBookmark = JSON.stringify(destination.dest);
                  this._destination.page = null;
                } else if (destination.hash) {
                  this._initialBookmark = destination.hash;
                } else if (destination.page) {
                  this._initialBookmark = `page=${destination.page}`;
                }
              }
              reset() {
                if (this._initialized) {
                  this._pageHide();
                  this._initialized = false;
                  this._unbindEvents();
                }
                if (this._updateViewareaTimeout) {
                  clearTimeout(this._updateViewareaTimeout);
                  this._updateViewareaTimeout = null;
                }
                this._initialBookmark = null;
                this._initialRotation = null;
              }
              push({
                namedDest = null,
                explicitDest,
                pageNumber
              }) {
                if (!this._initialized) {
                  return;
                }
                if (namedDest && typeof namedDest !== "string") {
                  console.error(`PDFHistory.push: "${namedDest}" is not a valid namedDest parameter.`);
                  return;
                } else if (!Array.isArray(explicitDest)) {
                  console.error(`PDFHistory.push: "${explicitDest}" is not a valid explicitDest parameter.`);
                  return;
                } else if (!(Number.isInteger(pageNumber) && pageNumber > 0 && pageNumber <= this.linkService.pagesCount)) {
                  if (pageNumber !== null || this._destination) {
                    console.error(`PDFHistory.push: "${pageNumber}" is not a valid pageNumber parameter.`);
                    return;
                  }
                }
                const hash = namedDest || JSON.stringify(explicitDest);
                if (!hash) {
                  return;
                }
                let forceReplace = false;
                if (this._destination && (isDestHashesEqual(this._destination.hash, hash) || isDestArraysEqual(this._destination.dest, explicitDest))) {
                  if (this._destination.page) {
                    return;
                  }
                  forceReplace = true;
                }
                if (this._popStateInProgress && !forceReplace) {
                  return;
                }
                this._pushOrReplaceState({
                  dest: explicitDest,
                  hash,
                  page: pageNumber,
                  rotation: this.linkService.rotation
                }, forceReplace);
                if (!this._popStateInProgress) {
                  this._popStateInProgress = true;
                  Promise.resolve().then(() => {
                    this._popStateInProgress = false;
                  });
                }
              }
              pushCurrentPosition() {
                if (!this._initialized || this._popStateInProgress) {
                  return;
                }
                this._tryPushCurrentPosition();
              }
              back() {
                if (!this._initialized || this._popStateInProgress) {
                  return;
                }
                const state = window.history.state;
                if (this._isValidState(state) && state.uid > 0) {
                  window.history.back();
                }
              }
              forward() {
                if (!this._initialized || this._popStateInProgress) {
                  return;
                }
                const state = window.history.state;
                if (this._isValidState(state) && state.uid < this._maxUid) {
                  window.history.forward();
                }
              }
              get popStateInProgress() {
                return this._initialized && (this._popStateInProgress || this._blockHashChange > 0);
              }
              get initialBookmark() {
                return this._initialized ? this._initialBookmark : null;
              }
              get initialRotation() {
                return this._initialized ? this._initialRotation : null;
              }
              _pushOrReplaceState(destination, forceReplace = false) {
                const shouldReplace = forceReplace || !this._destination;
                const newState = {
                  fingerprint: this._fingerprint,
                  uid: shouldReplace ? this._uid : this._uid + 1,
                  destination
                };
                this._updateInternalState(destination, newState.uid);
                let newUrl;
                if (this._updateUrl && destination && destination.hash) {
                  const baseUrl = document.location.href.split("#")[0];
                  if (!baseUrl.startsWith("file://")) {
                    newUrl = `${baseUrl}#${destination.hash}`;
                  }
                }
                if (shouldReplace) {
                  window.history.replaceState(newState, "", newUrl);
                } else {
                  this._maxUid = this._uid;
                  window.history.pushState(newState, "", newUrl);
                }
              }
              _tryPushCurrentPosition(temporary = false) {
                if (!this._position) {
                  return;
                }
                let position = this._position;
                if (temporary) {
                  position = Object.assign(/* @__PURE__ */ Object.create(null), this._position);
                  position.temporary = true;
                }
                if (!this._destination) {
                  this._pushOrReplaceState(position);
                  return;
                }
                if (this._destination.temporary) {
                  this._pushOrReplaceState(position, true);
                  return;
                }
                if (this._destination.hash === position.hash) {
                  return;
                }
                if (!this._destination.page && (POSITION_UPDATED_THRESHOLD <= 0 || this._numPositionUpdates <= POSITION_UPDATED_THRESHOLD)) {
                  return;
                }
                let forceReplace = false;
                if (this._destination.page >= position.first && this._destination.page <= position.page) {
                  if (this._destination.dest || !this._destination.first) {
                    return;
                  }
                  forceReplace = true;
                }
                this._pushOrReplaceState(position, forceReplace);
              }
              _isValidState(state, checkReload = false) {
                if (!state) {
                  return false;
                }
                if (state.fingerprint !== this._fingerprint) {
                  if (checkReload) {
                    if (typeof state.fingerprint !== "string" || state.fingerprint.length !== this._fingerprint.length) {
                      return false;
                    }
                    const [perfEntry] = performance.getEntriesByType("navigation");
                    if (!perfEntry || perfEntry.type !== "reload") {
                      return false;
                    }
                  } else {
                    return false;
                  }
                }
                if (!Number.isInteger(state.uid) || state.uid < 0) {
                  return false;
                }
                if (state.destination === null || typeof state.destination !== "object") {
                  return false;
                }
                return true;
              }
              _updateInternalState(destination, uid, removeTemporary = false) {
                if (this._updateViewareaTimeout) {
                  clearTimeout(this._updateViewareaTimeout);
                  this._updateViewareaTimeout = null;
                }
                if (removeTemporary && destination && destination.temporary) {
                  delete destination.temporary;
                }
                this._destination = destination;
                this._uid = uid;
                this._numPositionUpdates = 0;
              }
              _parseCurrentHash() {
                const hash = unescape(getCurrentHash()).substring(1);
                let page = (0, _ui_utils.parseQueryString)(hash).page | 0;
                if (!(Number.isInteger(page) && page > 0 && page <= this.linkService.pagesCount)) {
                  page = null;
                }
                return {
                  hash,
                  page,
                  rotation: this.linkService.rotation
                };
              }
              _updateViewarea({
                location
              }) {
                if (this._updateViewareaTimeout) {
                  clearTimeout(this._updateViewareaTimeout);
                  this._updateViewareaTimeout = null;
                }
                this._position = {
                  hash: this._isViewerInPresentationMode ? `page=${location.pageNumber}` : location.pdfOpenParams.substring(1),
                  page: this.linkService.page,
                  first: location.pageNumber,
                  rotation: location.rotation
                };
                if (this._popStateInProgress) {
                  return;
                }
                if (POSITION_UPDATED_THRESHOLD > 0 && this._isPagesLoaded && this._destination && !this._destination.page) {
                  this._numPositionUpdates++;
                }
                if (UPDATE_VIEWAREA_TIMEOUT > 0) {
                  this._updateViewareaTimeout = setTimeout(() => {
                    if (!this._popStateInProgress) {
                      this._tryPushCurrentPosition(true);
                    }
                    this._updateViewareaTimeout = null;
                  }, UPDATE_VIEWAREA_TIMEOUT);
                }
              }
              _popState({
                state
              }) {
                const newHash = getCurrentHash(), hashChanged = this._currentHash !== newHash;
                this._currentHash = newHash;
                if (!state) {
                  this._uid++;
                  const {
                    hash,
                    page,
                    rotation
                  } = this._parseCurrentHash();
                  this._pushOrReplaceState({
                    hash,
                    page,
                    rotation
                  }, true);
                  return;
                }
                if (!this._isValidState(state)) {
                  return;
                }
                this._popStateInProgress = true;
                if (hashChanged) {
                  this._blockHashChange++;
                  (0, _ui_utils.waitOnEventOrTimeout)({
                    target: window,
                    name: "hashchange",
                    delay: HASH_CHANGE_TIMEOUT
                  }).then(() => {
                    this._blockHashChange--;
                  });
                }
                const destination = state.destination;
                this._updateInternalState(destination, state.uid, true);
                if (this._uid > this._maxUid) {
                  this._maxUid = this._uid;
                }
                if ((0, _ui_utils.isValidRotation)(destination.rotation)) {
                  this.linkService.rotation = destination.rotation;
                }
                if (destination.dest) {
                  this.linkService.navigateTo(destination.dest);
                } else if (destination.hash) {
                  this.linkService.setHash(destination.hash);
                } else if (destination.page) {
                  this.linkService.page = destination.page;
                }
                Promise.resolve().then(() => {
                  this._popStateInProgress = false;
                });
              }
              _pageHide() {
                if (!this._destination || this._destination.temporary) {
                  this._tryPushCurrentPosition();
                }
              }
              _bindEvents() {
                if (this._boundEvents) {
                  return;
                }
                this._boundEvents = {
                  updateViewarea: this._updateViewarea.bind(this),
                  popState: this._popState.bind(this),
                  pageHide: this._pageHide.bind(this)
                };
                this.eventBus._on("updateviewarea", this._boundEvents.updateViewarea);
                window.addEventListener("popstate", this._boundEvents.popState);
                window.addEventListener("pagehide", this._boundEvents.pageHide);
              }
              _unbindEvents() {
                if (!this._boundEvents) {
                  return;
                }
                this.eventBus._off("updateviewarea", this._boundEvents.updateViewarea);
                window.removeEventListener("popstate", this._boundEvents.popState);
                window.removeEventListener("pagehide", this._boundEvents.pageHide);
                this._boundEvents = null;
              }
            }
            exports2.PDFHistory = PDFHistory;
            function isDestHashesEqual(destHash, pushHash) {
              if (typeof destHash !== "string" || typeof pushHash !== "string") {
                return false;
              }
              if (destHash === pushHash) {
                return true;
              }
              const {
                nameddest
              } = (0, _ui_utils.parseQueryString)(destHash);
              if (nameddest === pushHash) {
                return true;
              }
              return false;
            }
            function isDestArraysEqual(firstDest, secondDest) {
              function isEntryEqual(first, second) {
                if (typeof first !== typeof second) {
                  return false;
                }
                if (Array.isArray(first) || Array.isArray(second)) {
                  return false;
                }
                if (first !== null && typeof first === "object" && second !== null) {
                  if (Object.keys(first).length !== Object.keys(second).length) {
                    return false;
                  }
                  for (const key in first) {
                    if (!isEntryEqual(first[key], second[key])) {
                      return false;
                    }
                  }
                  return true;
                }
                return first === second || Number.isNaN(first) && Number.isNaN(second);
              }
              if (!(Array.isArray(firstDest) && Array.isArray(secondDest))) {
                return false;
              }
              if (firstDest.length !== secondDest.length) {
                return false;
              }
              for (let i = 0, ii = firstDest.length; i < ii; i++) {
                if (!isEntryEqual(firstDest[i], secondDest[i])) {
                  return false;
                }
              }
              return true;
            }
          },
          2388: function(__unused_webpack_module2, exports2, __webpack_require__2) {
            "use strict";
            __webpack_require__2(7658);
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.SimpleLinkService = exports2.PDFLinkService = void 0;
            var _ui_utils = __webpack_require__2(5570);
            class PDFLinkService {
              constructor({
                eventBus,
                externalLinkTarget = null,
                externalLinkRel = null,
                externalLinkEnabled = true,
                ignoreDestinationZoom = false
              } = {}) {
                this.eventBus = eventBus || (0, _ui_utils.getGlobalEventBus)();
                this.externalLinkTarget = externalLinkTarget;
                this.externalLinkRel = externalLinkRel;
                this.externalLinkEnabled = externalLinkEnabled;
                this._ignoreDestinationZoom = ignoreDestinationZoom;
                this.baseUrl = null;
                this.pdfDocument = null;
                this.pdfViewer = null;
                this.pdfHistory = null;
                this._pagesRefCache = null;
              }
              setDocument(pdfDocument, baseUrl = null) {
                this.baseUrl = baseUrl;
                this.pdfDocument = pdfDocument;
                this._pagesRefCache = /* @__PURE__ */ Object.create(null);
              }
              setViewer(pdfViewer) {
                this.pdfViewer = pdfViewer;
              }
              setHistory(pdfHistory) {
                this.pdfHistory = pdfHistory;
              }
              get pagesCount() {
                return this.pdfDocument ? this.pdfDocument.numPages : 0;
              }
              get page() {
                return this.pdfViewer.currentPageNumber;
              }
              set page(value) {
                this.pdfViewer.currentPageNumber = value;
              }
              get rotation() {
                return this.pdfViewer.pagesRotation;
              }
              set rotation(value) {
                this.pdfViewer.pagesRotation = value;
              }
              navigateTo(dest) {
                const goToDestination = ({
                  namedDest,
                  explicitDest
                }) => {
                  const destRef = explicitDest[0];
                  let pageNumber;
                  if (destRef instanceof Object) {
                    pageNumber = this._cachedPageNumber(destRef);
                    if (pageNumber === null) {
                      this.pdfDocument.getPageIndex(destRef).then((pageIndex) => {
                        this.cachePageRef(pageIndex + 1, destRef);
                        goToDestination({
                          namedDest,
                          explicitDest
                        });
                      }).catch(() => {
                        console.error(`PDFLinkService.navigateTo: "${destRef}" is not a valid page reference, for dest="${dest}".`);
                      });
                      return;
                    }
                  } else if (Number.isInteger(destRef)) {
                    pageNumber = destRef + 1;
                  } else {
                    console.error(`PDFLinkService.navigateTo: "${destRef}" is not a valid destination reference, for dest="${dest}".`);
                    return;
                  }
                  if (!pageNumber || pageNumber < 1 || pageNumber > this.pagesCount) {
                    console.error(`PDFLinkService.navigateTo: "${pageNumber}" is not a valid page number, for dest="${dest}".`);
                    return;
                  }
                  if (this.pdfHistory) {
                    this.pdfHistory.pushCurrentPosition();
                    this.pdfHistory.push({
                      namedDest,
                      explicitDest,
                      pageNumber
                    });
                  }
                  this.pdfViewer.scrollPageIntoView({
                    pageNumber,
                    destArray: explicitDest,
                    ignoreDestinationZoom: this._ignoreDestinationZoom
                  });
                };
                new Promise((resolve, reject) => {
                  if (typeof dest === "string") {
                    this.pdfDocument.getDestination(dest).then((destArray) => {
                      resolve({
                        namedDest: dest,
                        explicitDest: destArray
                      });
                    });
                    return;
                  }
                  resolve({
                    namedDest: "",
                    explicitDest: dest
                  });
                }).then((data) => {
                  if (!Array.isArray(data.explicitDest)) {
                    console.error(`PDFLinkService.navigateTo: "${data.explicitDest}" is not a valid destination array, for dest="${dest}".`);
                    return;
                  }
                  goToDestination(data);
                });
              }
              getDestinationHash(dest) {
                if (typeof dest === "string") {
                  return this.getAnchorUrl("#" + escape(dest));
                }
                if (Array.isArray(dest)) {
                  const str = JSON.stringify(dest);
                  return this.getAnchorUrl("#" + escape(str));
                }
                return this.getAnchorUrl("");
              }
              getAnchorUrl(anchor) {
                return (this.baseUrl || "") + anchor;
              }
              setHash(hash) {
                let pageNumber, dest;
                if (hash.includes("=")) {
                  const params = (0, _ui_utils.parseQueryString)(hash);
                  if ("search" in params) {
                    this.eventBus.dispatch("findfromurlhash", {
                      source: this,
                      query: params["search"].replace(/"/g, ""),
                      phraseSearch: params["phrase"] === "true"
                    });
                  }
                  if ("nameddest" in params) {
                    this.navigateTo(params.nameddest);
                    return;
                  }
                  if ("page" in params) {
                    pageNumber = params.page | 0 || 1;
                  }
                  if ("zoom" in params) {
                    const zoomArgs = params.zoom.split(",");
                    const zoomArg = zoomArgs[0];
                    const zoomArgNumber = parseFloat(zoomArg);
                    if (!zoomArg.includes("Fit")) {
                      dest = [null, {
                        name: "XYZ"
                      }, zoomArgs.length > 1 ? zoomArgs[1] | 0 : null, zoomArgs.length > 2 ? zoomArgs[2] | 0 : null, zoomArgNumber ? zoomArgNumber / 100 : zoomArg];
                    } else {
                      if (zoomArg === "Fit" || zoomArg === "FitB") {
                        dest = [null, {
                          name: zoomArg
                        }];
                      } else if (zoomArg === "FitH" || zoomArg === "FitBH" || zoomArg === "FitV" || zoomArg === "FitBV") {
                        dest = [null, {
                          name: zoomArg
                        }, zoomArgs.length > 1 ? zoomArgs[1] | 0 : null];
                      } else if (zoomArg === "FitR") {
                        if (zoomArgs.length !== 5) {
                          console.error('PDFLinkService.setHash: Not enough parameters for "FitR".');
                        } else {
                          dest = [null, {
                            name: zoomArg
                          }, zoomArgs[1] | 0, zoomArgs[2] | 0, zoomArgs[3] | 0, zoomArgs[4] | 0];
                        }
                      } else {
                        console.error(`PDFLinkService.setHash: "${zoomArg}" is not a valid zoom value.`);
                      }
                    }
                  }
                  if (dest) {
                    this.pdfViewer.scrollPageIntoView({
                      pageNumber: pageNumber || this.page,
                      destArray: dest,
                      allowNegativeOffset: true
                    });
                  } else if (pageNumber) {
                    this.page = pageNumber;
                  }
                  if ("pagemode" in params) {
                    this.eventBus.dispatch("pagemode", {
                      source: this,
                      mode: params.pagemode
                    });
                  }
                } else {
                  dest = unescape(hash);
                  try {
                    dest = JSON.parse(dest);
                    if (!Array.isArray(dest)) {
                      dest = dest.toString();
                    }
                  } catch (ex) {
                  }
                  if (typeof dest === "string" || isValidExplicitDestination(dest)) {
                    this.navigateTo(dest);
                    return;
                  }
                  console.error(`PDFLinkService.setHash: "${unescape(hash)}" is not a valid destination.`);
                }
              }
              executeNamedAction(action) {
                switch (action) {
                  case "GoBack":
                    if (this.pdfHistory) {
                      this.pdfHistory.back();
                    }
                    break;
                  case "GoForward":
                    if (this.pdfHistory) {
                      this.pdfHistory.forward();
                    }
                    break;
                  case "NextPage":
                    if (this.page < this.pagesCount) {
                      this.page++;
                    }
                    break;
                  case "PrevPage":
                    if (this.page > 1) {
                      this.page--;
                    }
                    break;
                  case "LastPage":
                    this.page = this.pagesCount;
                    break;
                  case "FirstPage":
                    this.page = 1;
                    break;
                  default:
                    break;
                }
                this.eventBus.dispatch("namedaction", {
                  source: this,
                  action
                });
              }
              cachePageRef(pageNum, pageRef) {
                if (!pageRef) {
                  return;
                }
                const refStr = pageRef.gen === 0 ? `${pageRef.num}R` : `${pageRef.num}R${pageRef.gen}`;
                this._pagesRefCache[refStr] = pageNum;
              }
              _cachedPageNumber(pageRef) {
                const refStr = pageRef.gen === 0 ? `${pageRef.num}R` : `${pageRef.num}R${pageRef.gen}`;
                return this._pagesRefCache && this._pagesRefCache[refStr] || null;
              }
              isPageVisible(pageNumber) {
                return this.pdfViewer.isPageVisible(pageNumber);
              }
            }
            exports2.PDFLinkService = PDFLinkService;
            function isValidExplicitDestination(dest) {
              if (!Array.isArray(dest)) {
                return false;
              }
              const destLength = dest.length;
              if (destLength < 2) {
                return false;
              }
              const page = dest[0];
              if (!(typeof page === "object" && Number.isInteger(page.num) && Number.isInteger(page.gen)) && !(Number.isInteger(page) && page >= 0)) {
                return false;
              }
              const zoom = dest[1];
              if (!(typeof zoom === "object" && typeof zoom.name === "string")) {
                return false;
              }
              let allowNull = true;
              switch (zoom.name) {
                case "XYZ":
                  if (destLength !== 5) {
                    return false;
                  }
                  break;
                case "Fit":
                case "FitB":
                  return destLength === 2;
                case "FitH":
                case "FitBH":
                case "FitV":
                case "FitBV":
                  if (destLength !== 3) {
                    return false;
                  }
                  break;
                case "FitR":
                  if (destLength !== 6) {
                    return false;
                  }
                  allowNull = false;
                  break;
                default:
                  return false;
              }
              for (let i = 2; i < destLength; i++) {
                const param = dest[i];
                if (!(typeof param === "number" || allowNull && param === null)) {
                  return false;
                }
              }
              return true;
            }
            class SimpleLinkService {
              constructor() {
                this.externalLinkTarget = null;
                this.externalLinkRel = null;
                this.externalLinkEnabled = true;
                this._ignoreDestinationZoom = false;
              }
              get pagesCount() {
                return 0;
              }
              get page() {
                return 0;
              }
              set page(value) {
              }
              get rotation() {
                return 0;
              }
              set rotation(value) {
              }
              navigateTo(dest) {
              }
              getDestinationHash(dest) {
                return "#";
              }
              getAnchorUrl(hash) {
                return "#";
              }
              setHash(hash) {
              }
              executeNamedAction(action) {
              }
              cachePageRef(pageNum, pageRef) {
              }
              isPageVisible(pageNumber) {
                return true;
              }
            }
            exports2.SimpleLinkService = SimpleLinkService;
          },
          8753: function(__unused_webpack_module2, exports2, __webpack_require__2) {
            "use strict";
            __webpack_require__2(7658);
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.PDFOutlineViewer = void 0;
            var _pdf = __webpack_require__2(3941);
            const DEFAULT_TITLE = "\u2013";
            class PDFOutlineViewer {
              constructor({
                container,
                linkService,
                eventBus
              }) {
                this.container = container;
                this.linkService = linkService;
                this.eventBus = eventBus;
                this.reset();
                eventBus._on("toggleoutlinetree", this.toggleOutlineTree.bind(this));
              }
              reset() {
                this.outline = null;
                this.lastToggleIsShow = true;
                this.container.textContent = "";
                this.container.classList.remove("outlineWithDeepNesting");
              }
              _dispatchEvent(outlineCount) {
                this.eventBus.dispatch("outlineloaded", {
                  source: this,
                  outlineCount
                });
              }
              _bindLink(element, {
                url,
                newWindow,
                dest
              }) {
                const {
                  linkService
                } = this;
                if (url) {
                  (0, _pdf.addLinkAttributes)(element, {
                    url,
                    target: newWindow ? _pdf.LinkTarget.BLANK : linkService.externalLinkTarget,
                    rel: linkService.externalLinkRel,
                    enabled: linkService.externalLinkEnabled
                  });
                  return;
                }
                element.href = linkService.getDestinationHash(dest);
                element.onclick = () => {
                  if (dest) {
                    linkService.navigateTo(dest);
                  }
                  return false;
                };
              }
              _setStyles(element, {
                bold,
                italic
              }) {
                if (bold) {
                  element.style.fontWeight = "bold";
                }
                if (italic) {
                  element.style.fontStyle = "italic";
                }
              }
              _addToggleButton(div, {
                count,
                items
              }) {
                const toggler = document.createElement("div");
                toggler.className = "outlineItemToggler";
                if (count < 0 && Math.abs(count) === items.length) {
                  toggler.classList.add("outlineItemsHidden");
                }
                toggler.onclick = (evt) => {
                  evt.stopPropagation();
                  toggler.classList.toggle("outlineItemsHidden");
                  if (evt.shiftKey) {
                    const shouldShowAll = !toggler.classList.contains("outlineItemsHidden");
                    this._toggleOutlineItem(div, shouldShowAll);
                  }
                };
                div.insertBefore(toggler, div.firstChild);
              }
              _toggleOutlineItem(root, show = false) {
                this.lastToggleIsShow = show;
                for (const toggler of root.querySelectorAll(".outlineItemToggler")) {
                  toggler.classList.toggle("outlineItemsHidden", !show);
                }
              }
              toggleOutlineTree() {
                if (!this.outline) {
                  return;
                }
                this._toggleOutlineItem(this.container, !this.lastToggleIsShow);
              }
              render({
                outline
              }) {
                let outlineCount = 0;
                if (this.outline) {
                  this.reset();
                }
                this.outline = outline || null;
                if (!outline) {
                  this._dispatchEvent(outlineCount);
                  return;
                }
                const fragment = document.createDocumentFragment();
                const queue = [{
                  parent: fragment,
                  items: this.outline
                }];
                let hasAnyNesting = false;
                while (queue.length > 0) {
                  const levelData = queue.shift();
                  for (const item of levelData.items) {
                    const div = document.createElement("div");
                    div.className = "outlineItem";
                    const element = document.createElement("a");
                    this._bindLink(element, item);
                    this._setStyles(element, item);
                    element.textContent = (0, _pdf.removeNullCharacters)(item.title) || DEFAULT_TITLE;
                    div.appendChild(element);
                    if (item.items.length > 0) {
                      hasAnyNesting = true;
                      this._addToggleButton(div, item);
                      const itemsDiv = document.createElement("div");
                      itemsDiv.className = "outlineItems";
                      div.appendChild(itemsDiv);
                      queue.push({
                        parent: itemsDiv,
                        items: item.items
                      });
                    }
                    levelData.parent.appendChild(div);
                    outlineCount++;
                  }
                }
                if (hasAnyNesting) {
                  this.container.classList.add("outlineWithDeepNesting");
                  this.lastToggleIsShow = fragment.querySelectorAll(".outlineItemsHidden").length === 0;
                }
                this.container.appendChild(fragment);
                this._dispatchEvent(outlineCount);
              }
            }
            exports2.PDFOutlineViewer = PDFOutlineViewer;
          },
          9016: function(__unused_webpack_module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.PDFPageView = void 0;
            var _ui_utils = __webpack_require__2(5570);
            var _pdf = __webpack_require__2(3941);
            var _pdf_rendering_queue = __webpack_require__2(7807);
            var _viewer_compatibility = __webpack_require__2(55);
            const MAX_CANVAS_PIXELS = _viewer_compatibility.viewerCompatibilityParams.maxCanvasPixels || 16777216;
            class PDFPageView {
              constructor(options) {
                const container = options.container;
                const defaultViewport = options.defaultViewport;
                this.id = options.id;
                this.renderingId = "page" + this.id;
                this.pdfPage = null;
                this.pageLabel = null;
                this.rotation = 0;
                this.scale = options.scale || _ui_utils.DEFAULT_SCALE;
                this.viewport = defaultViewport;
                this.pdfPageRotate = defaultViewport.rotation;
                this.hasRestrictedScaling = false;
                this.textLayerMode = Number.isInteger(options.textLayerMode) ? options.textLayerMode : _ui_utils.TextLayerMode.ENABLE;
                this.imageResourcesPath = options.imageResourcesPath || "";
                this.renderInteractiveForms = options.renderInteractiveForms || false;
                this.useOnlyCssZoom = options.useOnlyCssZoom || false;
                this.maxCanvasPixels = options.maxCanvasPixels || MAX_CANVAS_PIXELS;
                this.eventBus = options.eventBus || (0, _ui_utils.getGlobalEventBus)();
                this.renderingQueue = options.renderingQueue;
                this.textLayerFactory = options.textLayerFactory;
                this.annotationLayerFactory = options.annotationLayerFactory;
                this.renderer = options.renderer || _ui_utils.RendererType.CANVAS;
                this.enableWebGL = options.enableWebGL || false;
                this.l10n = options.l10n || _ui_utils.NullL10n;
                this.paintTask = null;
                this.paintedViewportMap = /* @__PURE__ */ new WeakMap();
                this.renderingState = _pdf_rendering_queue.RenderingStates.INITIAL;
                this.resume = null;
                this.error = null;
                this.annotationLayer = null;
                this.textLayer = null;
                this.zoomLayer = null;
                const div = document.createElement("div");
                div.className = "page";
                div.style.width = Math.floor(this.viewport.width) + "px";
                div.style.height = Math.floor(this.viewport.height) + "px";
                div.setAttribute("data-page-number", this.id);
                this.div = div;
                container.appendChild(div);
              }
              setPdfPage(pdfPage) {
                this.pdfPage = pdfPage;
                this.pdfPageRotate = pdfPage.rotate;
                const totalRotation = (this.rotation + this.pdfPageRotate) % 360;
                this.viewport = pdfPage.getViewport({
                  scale: this.scale * _ui_utils.CSS_UNITS,
                  rotation: totalRotation
                });
                this.stats = pdfPage.stats;
                this.reset();
              }
              destroy() {
                this.reset();
                if (this.pdfPage) {
                  this.pdfPage.cleanup();
                }
              }
              _resetZoomLayer(removeFromDOM = false) {
                if (!this.zoomLayer) {
                  return;
                }
                const zoomLayerCanvas = this.zoomLayer.firstChild;
                this.paintedViewportMap.delete(zoomLayerCanvas);
                zoomLayerCanvas.width = 0;
                zoomLayerCanvas.height = 0;
                if (removeFromDOM) {
                  this.zoomLayer.remove();
                }
                this.zoomLayer = null;
              }
              reset(keepZoomLayer = false, keepAnnotations = false) {
                this.cancelRendering(keepAnnotations);
                this.renderingState = _pdf_rendering_queue.RenderingStates.INITIAL;
                const div = this.div;
                div.style.width = Math.floor(this.viewport.width) + "px";
                div.style.height = Math.floor(this.viewport.height) + "px";
                const childNodes = div.childNodes;
                const currentZoomLayerNode = keepZoomLayer && this.zoomLayer || null;
                const currentAnnotationNode = keepAnnotations && this.annotationLayer && this.annotationLayer.div || null;
                for (let i = childNodes.length - 1; i >= 0; i--) {
                  const node = childNodes[i];
                  if (currentZoomLayerNode === node || currentAnnotationNode === node) {
                    continue;
                  }
                  div.removeChild(node);
                }
                div.removeAttribute("data-loaded");
                if (currentAnnotationNode) {
                  this.annotationLayer.hide();
                } else if (this.annotationLayer) {
                  this.annotationLayer.cancel();
                  this.annotationLayer = null;
                }
                if (!currentZoomLayerNode) {
                  if (this.canvas) {
                    this.paintedViewportMap.delete(this.canvas);
                    this.canvas.width = 0;
                    this.canvas.height = 0;
                    delete this.canvas;
                  }
                  this._resetZoomLayer();
                }
                if (this.svg) {
                  this.paintedViewportMap.delete(this.svg);
                  delete this.svg;
                }
                this.loadingIconDiv = document.createElement("div");
                this.loadingIconDiv.className = "loadingIcon";
                div.appendChild(this.loadingIconDiv);
              }
              update(scale, rotation) {
                this.scale = scale || this.scale;
                if (typeof rotation !== "undefined") {
                  this.rotation = rotation;
                }
                const totalRotation = (this.rotation + this.pdfPageRotate) % 360;
                this.viewport = this.viewport.clone({
                  scale: this.scale * _ui_utils.CSS_UNITS,
                  rotation: totalRotation
                });
                if (this.svg) {
                  this.cssTransform(this.svg, true);
                  this.eventBus.dispatch("pagerendered", {
                    source: this,
                    pageNumber: this.id,
                    cssTransform: true,
                    timestamp: performance.now()
                  });
                  return;
                }
                let isScalingRestricted = false;
                if (this.canvas && this.maxCanvasPixels > 0) {
                  const outputScale = this.outputScale;
                  if ((Math.floor(this.viewport.width) * outputScale.sx | 0) * (Math.floor(this.viewport.height) * outputScale.sy | 0) > this.maxCanvasPixels) {
                    isScalingRestricted = true;
                  }
                }
                if (this.canvas) {
                  if (this.useOnlyCssZoom || this.hasRestrictedScaling && isScalingRestricted) {
                    this.cssTransform(this.canvas, true);
                    this.eventBus.dispatch("pagerendered", {
                      source: this,
                      pageNumber: this.id,
                      cssTransform: true,
                      timestamp: performance.now()
                    });
                    return;
                  }
                  if (!this.zoomLayer && !this.canvas.hasAttribute("hidden")) {
                    this.zoomLayer = this.canvas.parentNode;
                    this.zoomLayer.style.position = "absolute";
                  }
                }
                if (this.zoomLayer) {
                  this.cssTransform(this.zoomLayer.firstChild);
                }
                this.reset(true, true);
              }
              cancelRendering(keepAnnotations = false) {
                if (this.paintTask) {
                  this.paintTask.cancel();
                  this.paintTask = null;
                }
                this.resume = null;
                if (this.textLayer) {
                  this.textLayer.cancel();
                  this.textLayer = null;
                }
                if (!keepAnnotations && this.annotationLayer) {
                  this.annotationLayer.cancel();
                  this.annotationLayer = null;
                }
              }
              cssTransform(target, redrawAnnotations = false) {
                const width = this.viewport.width;
                const height = this.viewport.height;
                const div = this.div;
                target.style.width = target.parentNode.style.width = div.style.width = Math.floor(width) + "px";
                target.style.height = target.parentNode.style.height = div.style.height = Math.floor(height) + "px";
                const relativeRotation = this.viewport.rotation - this.paintedViewportMap.get(target).rotation;
                const absRotation = Math.abs(relativeRotation);
                let scaleX = 1, scaleY = 1;
                if (absRotation === 90 || absRotation === 270) {
                  scaleX = height / width;
                  scaleY = width / height;
                }
                const cssTransform = "rotate(" + relativeRotation + "deg) scale(" + scaleX + "," + scaleY + ")";
                target.style.transform = cssTransform;
                if (this.textLayer) {
                  const textLayerViewport = this.textLayer.viewport;
                  const textRelativeRotation = this.viewport.rotation - textLayerViewport.rotation;
                  const textAbsRotation = Math.abs(textRelativeRotation);
                  let scale = width / textLayerViewport.width;
                  if (textAbsRotation === 90 || textAbsRotation === 270) {
                    scale = width / textLayerViewport.height;
                  }
                  const textLayerDiv = this.textLayer.textLayerDiv;
                  let transX, transY;
                  switch (textAbsRotation) {
                    case 0:
                      transX = transY = 0;
                      break;
                    case 90:
                      transX = 0;
                      transY = "-" + textLayerDiv.style.height;
                      break;
                    case 180:
                      transX = "-" + textLayerDiv.style.width;
                      transY = "-" + textLayerDiv.style.height;
                      break;
                    case 270:
                      transX = "-" + textLayerDiv.style.width;
                      transY = 0;
                      break;
                    default:
                      console.error("Bad rotation value.");
                      break;
                  }
                  textLayerDiv.style.transform = "rotate(" + textAbsRotation + "deg) scale(" + scale + ", " + scale + ") translate(" + transX + ", " + transY + ")";
                  textLayerDiv.style.transformOrigin = "0% 0%";
                }
                if (redrawAnnotations && this.annotationLayer) {
                  this.annotationLayer.render(this.viewport, "display");
                }
              }
              get width() {
                return this.viewport.width;
              }
              get height() {
                return this.viewport.height;
              }
              getPagePoint(x, y) {
                return this.viewport.convertToPdfPoint(x, y);
              }
              draw() {
                if (this.renderingState !== _pdf_rendering_queue.RenderingStates.INITIAL) {
                  console.error("Must be in new state before drawing");
                  this.reset();
                }
                const {
                  div,
                  pdfPage
                } = this;
                if (!pdfPage) {
                  this.renderingState = _pdf_rendering_queue.RenderingStates.FINISHED;
                  if (this.loadingIconDiv) {
                    div.removeChild(this.loadingIconDiv);
                    delete this.loadingIconDiv;
                  }
                  return Promise.reject(new Error("pdfPage is not loaded"));
                }
                this.renderingState = _pdf_rendering_queue.RenderingStates.RUNNING;
                const canvasWrapper = document.createElement("div");
                canvasWrapper.style.width = div.style.width;
                canvasWrapper.style.height = div.style.height;
                canvasWrapper.classList.add("canvasWrapper");
                if (this.annotationLayer && this.annotationLayer.div) {
                  div.insertBefore(canvasWrapper, this.annotationLayer.div);
                } else {
                  div.appendChild(canvasWrapper);
                }
                let textLayer = null;
                if (this.textLayerMode !== _ui_utils.TextLayerMode.DISABLE && this.textLayerFactory) {
                  const textLayerDiv = document.createElement("div");
                  textLayerDiv.className = "textLayer";
                  textLayerDiv.style.width = canvasWrapper.style.width;
                  textLayerDiv.style.height = canvasWrapper.style.height;
                  if (this.annotationLayer && this.annotationLayer.div) {
                    div.insertBefore(textLayerDiv, this.annotationLayer.div);
                  } else {
                    div.appendChild(textLayerDiv);
                  }
                  textLayer = this.textLayerFactory.createTextLayerBuilder(textLayerDiv, this.id - 1, this.viewport, this.textLayerMode === _ui_utils.TextLayerMode.ENABLE_ENHANCE, this.eventBus);
                }
                this.textLayer = textLayer;
                let renderContinueCallback = null;
                if (this.renderingQueue) {
                  renderContinueCallback = (cont) => {
                    if (!this.renderingQueue.isHighestPriority(this)) {
                      this.renderingState = _pdf_rendering_queue.RenderingStates.PAUSED;
                      this.resume = () => {
                        this.renderingState = _pdf_rendering_queue.RenderingStates.RUNNING;
                        cont();
                      };
                      return;
                    }
                    cont();
                  };
                }
                const finishPaintTask = async (error) => {
                  if (paintTask === this.paintTask) {
                    this.paintTask = null;
                  }
                  if (error instanceof _pdf.RenderingCancelledException) {
                    this.error = null;
                    return;
                  }
                  this.renderingState = _pdf_rendering_queue.RenderingStates.FINISHED;
                  if (this.loadingIconDiv) {
                    div.removeChild(this.loadingIconDiv);
                    delete this.loadingIconDiv;
                  }
                  this._resetZoomLayer(true);
                  this.error = error;
                  this.stats = pdfPage.stats;
                  this.eventBus.dispatch("pagerendered", {
                    source: this,
                    pageNumber: this.id,
                    cssTransform: false,
                    timestamp: performance.now()
                  });
                  if (error) {
                    throw error;
                  }
                };
                const paintTask = this.renderer === _ui_utils.RendererType.SVG ? this.paintOnSvg(canvasWrapper) : this.paintOnCanvas(canvasWrapper);
                paintTask.onRenderContinue = renderContinueCallback;
                this.paintTask = paintTask;
                const resultPromise = paintTask.promise.then(function() {
                  return finishPaintTask(null).then(function() {
                    if (textLayer) {
                      const readableStream = pdfPage.streamTextContent({
                        normalizeWhitespace: true
                      });
                      textLayer.setTextContentStream(readableStream);
                      textLayer.render();
                    }
                  });
                }, function(reason) {
                  return finishPaintTask(reason);
                });
                if (this.annotationLayerFactory) {
                  if (!this.annotationLayer) {
                    this.annotationLayer = this.annotationLayerFactory.createAnnotationLayerBuilder(div, pdfPage, this.imageResourcesPath, this.renderInteractiveForms, this.l10n);
                  }
                  this.annotationLayer.render(this.viewport, "display");
                }
                div.setAttribute("data-loaded", true);
                this.eventBus.dispatch("pagerender", {
                  source: this,
                  pageNumber: this.id
                });
                return resultPromise;
              }
              paintOnCanvas(canvasWrapper) {
                const renderCapability = (0, _pdf.createPromiseCapability)();
                const result = {
                  promise: renderCapability.promise,
                  onRenderContinue(cont) {
                    cont();
                  },
                  cancel() {
                    renderTask.cancel();
                  }
                };
                const viewport = this.viewport;
                const canvas = document.createElement("canvas");
                this.l10n.get("page_canvas", {
                  page: this.id
                }, "Page {{page}}").then((msg) => {
                  canvas.setAttribute("aria-label", msg);
                });
                canvas.setAttribute("hidden", "hidden");
                let isCanvasHidden = true;
                const showCanvas = function() {
                  if (isCanvasHidden) {
                    canvas.removeAttribute("hidden");
                    isCanvasHidden = false;
                  }
                };
                canvasWrapper.appendChild(canvas);
                this.canvas = canvas;
                canvas.mozOpaque = true;
                const ctx = canvas.getContext("2d", {
                  alpha: false
                });
                const outputScale = (0, _ui_utils.getOutputScale)(ctx);
                this.outputScale = outputScale;
                if (this.useOnlyCssZoom) {
                  const actualSizeViewport = viewport.clone({
                    scale: _ui_utils.CSS_UNITS
                  });
                  outputScale.sx *= actualSizeViewport.width / viewport.width;
                  outputScale.sy *= actualSizeViewport.height / viewport.height;
                  outputScale.scaled = true;
                }
                if (this.maxCanvasPixels > 0) {
                  const pixelsInViewport = viewport.width * viewport.height;
                  const maxScale = Math.sqrt(this.maxCanvasPixels / pixelsInViewport);
                  if (outputScale.sx > maxScale || outputScale.sy > maxScale) {
                    outputScale.sx = maxScale;
                    outputScale.sy = maxScale;
                    outputScale.scaled = true;
                    this.hasRestrictedScaling = true;
                  } else {
                    this.hasRestrictedScaling = false;
                  }
                }
                const sfx = (0, _ui_utils.approximateFraction)(outputScale.sx);
                const sfy = (0, _ui_utils.approximateFraction)(outputScale.sy);
                canvas.width = (0, _ui_utils.roundToDivide)(viewport.width * outputScale.sx, sfx[0]);
                canvas.height = (0, _ui_utils.roundToDivide)(viewport.height * outputScale.sy, sfy[0]);
                canvas.style.width = (0, _ui_utils.roundToDivide)(viewport.width, sfx[1]) + "px";
                canvas.style.height = (0, _ui_utils.roundToDivide)(viewport.height, sfy[1]) + "px";
                this.paintedViewportMap.set(canvas, viewport);
                const transform = !outputScale.scaled ? null : [outputScale.sx, 0, 0, outputScale.sy, 0, 0];
                const renderContext = {
                  canvasContext: ctx,
                  transform,
                  viewport: this.viewport,
                  enableWebGL: this.enableWebGL,
                  renderInteractiveForms: this.renderInteractiveForms
                };
                const renderTask = this.pdfPage.render(renderContext);
                renderTask.onContinue = function(cont) {
                  showCanvas();
                  if (result.onRenderContinue) {
                    result.onRenderContinue(cont);
                  } else {
                    cont();
                  }
                };
                renderTask.promise.then(function() {
                  showCanvas();
                  renderCapability.resolve(void 0);
                }, function(error) {
                  showCanvas();
                  renderCapability.reject(error);
                });
                return result;
              }
              paintOnSvg(wrapper) {
                let cancelled = false;
                const ensureNotCancelled = () => {
                  if (cancelled) {
                    throw new _pdf.RenderingCancelledException(`Rendering cancelled, page ${this.id}`, "svg");
                  }
                };
                const pdfPage = this.pdfPage;
                const actualSizeViewport = this.viewport.clone({
                  scale: _ui_utils.CSS_UNITS
                });
                const promise = pdfPage.getOperatorList().then((opList) => {
                  ensureNotCancelled();
                  const svgGfx = new _pdf.SVGGraphics(pdfPage.commonObjs, pdfPage.objs);
                  return svgGfx.getSVG(opList, actualSizeViewport).then((svg) => {
                    ensureNotCancelled();
                    this.svg = svg;
                    this.paintedViewportMap.set(svg, actualSizeViewport);
                    svg.style.width = wrapper.style.width;
                    svg.style.height = wrapper.style.height;
                    this.renderingState = _pdf_rendering_queue.RenderingStates.FINISHED;
                    wrapper.appendChild(svg);
                  });
                });
                return {
                  promise,
                  onRenderContinue(cont) {
                    cont();
                  },
                  cancel() {
                    cancelled = true;
                  }
                };
              }
              setPageLabel(label) {
                this.pageLabel = typeof label === "string" ? label : null;
                if (this.pageLabel !== null) {
                  this.div.setAttribute("data-page-label", this.pageLabel);
                } else {
                  this.div.removeAttribute("data-page-label");
                }
              }
            }
            exports2.PDFPageView = PDFPageView;
          },
          1181: function(__unused_webpack_module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.PDFPresentationMode = void 0;
            var _ui_utils = __webpack_require__2(5570);
            const DELAY_BEFORE_RESETTING_SWITCH_IN_PROGRESS = 1500;
            const DELAY_BEFORE_HIDING_CONTROLS = 3e3;
            const ACTIVE_SELECTOR = "pdfPresentationMode";
            const CONTROLS_SELECTOR = "pdfPresentationModeControls";
            const MOUSE_SCROLL_COOLDOWN_TIME = 50;
            const PAGE_SWITCH_THRESHOLD = 0.1;
            const SWIPE_MIN_DISTANCE_THRESHOLD = 50;
            const SWIPE_ANGLE_THRESHOLD = Math.PI / 6;
            class PDFPresentationMode {
              constructor({
                container,
                pdfViewer,
                eventBus,
                contextMenuItems = null
              }) {
                this.container = container;
                this.pdfViewer = pdfViewer;
                this.eventBus = eventBus;
                this.active = false;
                this.args = null;
                this.contextMenuOpen = false;
                this.mouseScrollTimeStamp = 0;
                this.mouseScrollDelta = 0;
                this.touchSwipeState = null;
                if (contextMenuItems) {
                  contextMenuItems.contextFirstPage.addEventListener("click", () => {
                    this.contextMenuOpen = false;
                    this.eventBus.dispatch("firstpage", {
                      source: this
                    });
                  });
                  contextMenuItems.contextLastPage.addEventListener("click", () => {
                    this.contextMenuOpen = false;
                    this.eventBus.dispatch("lastpage", {
                      source: this
                    });
                  });
                  contextMenuItems.contextPageRotateCw.addEventListener("click", () => {
                    this.contextMenuOpen = false;
                    this.eventBus.dispatch("rotatecw", {
                      source: this
                    });
                  });
                  contextMenuItems.contextPageRotateCcw.addEventListener("click", () => {
                    this.contextMenuOpen = false;
                    this.eventBus.dispatch("rotateccw", {
                      source: this
                    });
                  });
                }
              }
              request() {
                if (this.switchInProgress || this.active || !this.pdfViewer.pagesCount) {
                  return false;
                }
                this._addFullscreenChangeListeners();
                this._setSwitchInProgress();
                this._notifyStateChange();
                if (this.container.requestFullscreen) {
                  this.container.requestFullscreen();
                } else if (this.container.mozRequestFullScreen) {
                  this.container.mozRequestFullScreen();
                } else if (this.container.webkitRequestFullscreen) {
                  this.container.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
                } else if (this.container.msRequestFullscreen) {
                  this.container.msRequestFullscreen();
                } else {
                  return false;
                }
                this.args = {
                  page: this.pdfViewer.currentPageNumber,
                  previousScale: this.pdfViewer.currentScaleValue
                };
                return true;
              }
              _mouseWheel(evt) {
                if (!this.active) {
                  return;
                }
                evt.preventDefault();
                const delta = (0, _ui_utils.normalizeWheelEventDelta)(evt);
                const currentTime = new Date().getTime();
                const storedTime = this.mouseScrollTimeStamp;
                if (currentTime > storedTime && currentTime - storedTime < MOUSE_SCROLL_COOLDOWN_TIME) {
                  return;
                }
                if (this.mouseScrollDelta > 0 && delta < 0 || this.mouseScrollDelta < 0 && delta > 0) {
                  this._resetMouseScrollState();
                }
                this.mouseScrollDelta += delta;
                if (Math.abs(this.mouseScrollDelta) >= PAGE_SWITCH_THRESHOLD) {
                  const totalDelta = this.mouseScrollDelta;
                  this._resetMouseScrollState();
                  const success = totalDelta > 0 ? this._goToPreviousPage() : this._goToNextPage();
                  if (success) {
                    this.mouseScrollTimeStamp = currentTime;
                  }
                }
              }
              get isFullscreen() {
                return !!(document.fullscreenElement || document.mozFullScreen || document.webkitIsFullScreen || document.msFullscreenElement);
              }
              _goToPreviousPage() {
                const page = this.pdfViewer.currentPageNumber;
                if (page <= 1) {
                  return false;
                }
                this.pdfViewer.currentPageNumber = page - 1;
                return true;
              }
              _goToNextPage() {
                const page = this.pdfViewer.currentPageNumber;
                if (page >= this.pdfViewer.pagesCount) {
                  return false;
                }
                this.pdfViewer.currentPageNumber = page + 1;
                return true;
              }
              _notifyStateChange() {
                this.eventBus.dispatch("presentationmodechanged", {
                  source: this,
                  active: this.active,
                  switchInProgress: !!this.switchInProgress
                });
              }
              _setSwitchInProgress() {
                if (this.switchInProgress) {
                  clearTimeout(this.switchInProgress);
                }
                this.switchInProgress = setTimeout(() => {
                  this._removeFullscreenChangeListeners();
                  delete this.switchInProgress;
                  this._notifyStateChange();
                }, DELAY_BEFORE_RESETTING_SWITCH_IN_PROGRESS);
              }
              _resetSwitchInProgress() {
                if (this.switchInProgress) {
                  clearTimeout(this.switchInProgress);
                  delete this.switchInProgress;
                }
              }
              _enter() {
                this.active = true;
                this._resetSwitchInProgress();
                this._notifyStateChange();
                this.container.classList.add(ACTIVE_SELECTOR);
                setTimeout(() => {
                  this.pdfViewer.currentPageNumber = this.args.page;
                  this.pdfViewer.currentScaleValue = "page-fit";
                }, 0);
                this._addWindowListeners();
                this._showControls();
                this.contextMenuOpen = false;
                this.container.setAttribute("contextmenu", "viewerContextMenu");
                window.getSelection().removeAllRanges();
              }
              _exit() {
                const page = this.pdfViewer.currentPageNumber;
                this.container.classList.remove(ACTIVE_SELECTOR);
                setTimeout(() => {
                  this.active = false;
                  this._removeFullscreenChangeListeners();
                  this._notifyStateChange();
                  this.pdfViewer.currentScaleValue = this.args.previousScale;
                  this.pdfViewer.currentPageNumber = page;
                  this.args = null;
                }, 0);
                this._removeWindowListeners();
                this._hideControls();
                this._resetMouseScrollState();
                this.container.removeAttribute("contextmenu");
                this.contextMenuOpen = false;
              }
              _mouseDown(evt) {
                if (this.contextMenuOpen) {
                  this.contextMenuOpen = false;
                  evt.preventDefault();
                  return;
                }
                if (evt.button === 0) {
                  const isInternalLink = evt.target.href && evt.target.classList.contains("internalLink");
                  if (!isInternalLink) {
                    evt.preventDefault();
                    if (evt.shiftKey) {
                      this._goToPreviousPage();
                    } else {
                      this._goToNextPage();
                    }
                  }
                }
              }
              _contextMenu() {
                this.contextMenuOpen = true;
              }
              _showControls() {
                if (this.controlsTimeout) {
                  clearTimeout(this.controlsTimeout);
                } else {
                  this.container.classList.add(CONTROLS_SELECTOR);
                }
                this.controlsTimeout = setTimeout(() => {
                  this.container.classList.remove(CONTROLS_SELECTOR);
                  delete this.controlsTimeout;
                }, DELAY_BEFORE_HIDING_CONTROLS);
              }
              _hideControls() {
                if (!this.controlsTimeout) {
                  return;
                }
                clearTimeout(this.controlsTimeout);
                this.container.classList.remove(CONTROLS_SELECTOR);
                delete this.controlsTimeout;
              }
              _resetMouseScrollState() {
                this.mouseScrollTimeStamp = 0;
                this.mouseScrollDelta = 0;
              }
              _touchSwipe(evt) {
                if (!this.active) {
                  return;
                }
                if (evt.touches.length > 1) {
                  this.touchSwipeState = null;
                  return;
                }
                switch (evt.type) {
                  case "touchstart":
                    this.touchSwipeState = {
                      startX: evt.touches[0].pageX,
                      startY: evt.touches[0].pageY,
                      endX: evt.touches[0].pageX,
                      endY: evt.touches[0].pageY
                    };
                    break;
                  case "touchmove":
                    if (this.touchSwipeState === null) {
                      return;
                    }
                    this.touchSwipeState.endX = evt.touches[0].pageX;
                    this.touchSwipeState.endY = evt.touches[0].pageY;
                    evt.preventDefault();
                    break;
                  case "touchend":
                    if (this.touchSwipeState === null) {
                      return;
                    }
                    let delta = 0;
                    const dx = this.touchSwipeState.endX - this.touchSwipeState.startX;
                    const dy = this.touchSwipeState.endY - this.touchSwipeState.startY;
                    const absAngle = Math.abs(Math.atan2(dy, dx));
                    if (Math.abs(dx) > SWIPE_MIN_DISTANCE_THRESHOLD && (absAngle <= SWIPE_ANGLE_THRESHOLD || absAngle >= Math.PI - SWIPE_ANGLE_THRESHOLD)) {
                      delta = dx;
                    } else if (Math.abs(dy) > SWIPE_MIN_DISTANCE_THRESHOLD && Math.abs(absAngle - Math.PI / 2) <= SWIPE_ANGLE_THRESHOLD) {
                      delta = dy;
                    }
                    if (delta > 0) {
                      this._goToPreviousPage();
                    } else if (delta < 0) {
                      this._goToNextPage();
                    }
                    break;
                }
              }
              _addWindowListeners() {
                this.showControlsBind = this._showControls.bind(this);
                this.mouseDownBind = this._mouseDown.bind(this);
                this.mouseWheelBind = this._mouseWheel.bind(this);
                this.resetMouseScrollStateBind = this._resetMouseScrollState.bind(this);
                this.contextMenuBind = this._contextMenu.bind(this);
                this.touchSwipeBind = this._touchSwipe.bind(this);
                window.addEventListener("mousemove", this.showControlsBind);
                window.addEventListener("mousedown", this.mouseDownBind);
                window.addEventListener("wheel", this.mouseWheelBind);
                window.addEventListener("keydown", this.resetMouseScrollStateBind);
                window.addEventListener("contextmenu", this.contextMenuBind);
                window.addEventListener("touchstart", this.touchSwipeBind);
                window.addEventListener("touchmove", this.touchSwipeBind);
                window.addEventListener("touchend", this.touchSwipeBind);
              }
              _removeWindowListeners() {
                window.removeEventListener("mousemove", this.showControlsBind);
                window.removeEventListener("mousedown", this.mouseDownBind);
                window.removeEventListener("wheel", this.mouseWheelBind);
                window.removeEventListener("keydown", this.resetMouseScrollStateBind);
                window.removeEventListener("contextmenu", this.contextMenuBind);
                window.removeEventListener("touchstart", this.touchSwipeBind);
                window.removeEventListener("touchmove", this.touchSwipeBind);
                window.removeEventListener("touchend", this.touchSwipeBind);
                delete this.showControlsBind;
                delete this.mouseDownBind;
                delete this.mouseWheelBind;
                delete this.resetMouseScrollStateBind;
                delete this.contextMenuBind;
                delete this.touchSwipeBind;
              }
              _fullscreenChange() {
                if (this.isFullscreen) {
                  this._enter();
                } else {
                  this._exit();
                }
              }
              _addFullscreenChangeListeners() {
                this.fullscreenChangeBind = this._fullscreenChange.bind(this);
                window.addEventListener("fullscreenchange", this.fullscreenChangeBind);
                window.addEventListener("mozfullscreenchange", this.fullscreenChangeBind);
                window.addEventListener("webkitfullscreenchange", this.fullscreenChangeBind);
                window.addEventListener("MSFullscreenChange", this.fullscreenChangeBind);
              }
              _removeFullscreenChangeListeners() {
                window.removeEventListener("fullscreenchange", this.fullscreenChangeBind);
                window.removeEventListener("mozfullscreenchange", this.fullscreenChangeBind);
                window.removeEventListener("webkitfullscreenchange", this.fullscreenChangeBind);
                window.removeEventListener("MSFullscreenChange", this.fullscreenChangeBind);
                delete this.fullscreenChangeBind;
              }
            }
            exports2.PDFPresentationMode = PDFPresentationMode;
          },
          3819: function(__unused_webpack_module2, exports2, __webpack_require__2) {
            "use strict";
            var __webpack_unused_export__;
            window.__nativePrint__ = window.print.bind(window);
            __webpack_unused_export__ = {
              value: true
            };
            __webpack_unused_export__ = PDFPrintService;
            var _ui_utils = __webpack_require__2(5570);
            var _app = __webpack_require__2(8375);
            var _app_options = __webpack_require__2(1958);
            let activeService = null;
            let overlayManager = null;
            function renderPage(activeServiceOnEntry, pdfDocument, pageNumber, size) {
              const scratchCanvas = activeService.scratchCanvas;
              const PRINT_RESOLUTION = _app_options.AppOptions.get("printResolution") || 150;
              const PRINT_UNITS = PRINT_RESOLUTION / 72;
              scratchCanvas.width = Math.floor(size.width * PRINT_UNITS);
              scratchCanvas.height = Math.floor(size.height * PRINT_UNITS);
              const width = Math.floor(size.width * _ui_utils.CSS_UNITS) + "px";
              const height = Math.floor(size.height * _ui_utils.CSS_UNITS) + "px";
              const ctx = scratchCanvas.getContext("2d");
              ctx.save();
              ctx.fillStyle = "rgb(255, 255, 255)";
              ctx.fillRect(0, 0, scratchCanvas.width, scratchCanvas.height);
              ctx.restore();
              return pdfDocument.getPage(pageNumber).then(function(pdfPage) {
                const renderContext = {
                  canvasContext: ctx,
                  transform: [PRINT_UNITS, 0, 0, PRINT_UNITS, 0, 0],
                  viewport: pdfPage.getViewport({
                    scale: 1,
                    rotation: size.rotation
                  }),
                  intent: "print"
                };
                return pdfPage.render(renderContext).promise;
              }).then(function() {
                return {
                  width,
                  height
                };
              });
            }
            function PDFPrintService(pdfDocument, pagesOverview, printContainer, l10n) {
              this.pdfDocument = pdfDocument;
              this.pagesOverview = pagesOverview;
              this.printContainer = printContainer;
              this.l10n = l10n || _ui_utils.NullL10n;
              this.disableCreateObjectURL = pdfDocument.loadingParams["disableCreateObjectURL"];
              this.currentPage = -1;
              this.scratchCanvas = document.createElement("canvas");
            }
            PDFPrintService.prototype = {
              layout() {
                this.throwIfInactive();
                const body = document.querySelector("body");
                body.setAttribute("data-pdfjsprinting", true);
                const hasEqualPageSizes = this.pagesOverview.every(function(size) {
                  return size.width === this.pagesOverview[0].width && size.height === this.pagesOverview[0].height;
                }, this);
                if (!hasEqualPageSizes) {
                  console.warn("Not all pages have the same size. The printed result may be incorrect!");
                }
                this.pageStyleSheet = document.createElement("style");
                const pageSize = this.pagesOverview[0];
                this.pageStyleSheet.textContent = "@supports ((size:A4) and (size:1pt 1pt)) {@page { size: " + pageSize.width + "pt " + pageSize.height + "pt;}}";
                body.appendChild(this.pageStyleSheet);
              },
              destroy() {
                if (activeService !== this) {
                  return;
                }
                this.printContainer.textContent = "";
                const body = document.querySelector("body");
                body.removeAttribute("data-pdfjsprinting");
                if (this.pageStyleSheet) {
                  this.pageStyleSheet.remove();
                  this.pageStyleSheet = null;
                }
                this.scratchCanvas.width = this.scratchCanvas.height = 0;
                this.scratchCanvas = null;
                activeService = null;
                ensureOverlay().then(function() {
                  if (overlayManager.active !== "printServiceOverlay") {
                    return;
                  }
                  overlayManager.close("printServiceOverlay");
                });
              },
              renderPages() {
                const pageCount = this.pagesOverview.length;
                const renderNextPage = (resolve, reject) => {
                  this.throwIfInactive();
                  if (++this.currentPage >= pageCount) {
                    renderProgress(pageCount, pageCount, this.l10n);
                    resolve();
                    return;
                  }
                  const index = this.currentPage;
                  renderProgress(index, pageCount, this.l10n);
                  renderPage(this, this.pdfDocument, index + 1, this.pagesOverview[index]).then(this.useRenderedPage.bind(this)).then(function() {
                    renderNextPage(resolve, reject);
                  }, reject);
                };
                return new Promise(renderNextPage);
              },
              useRenderedPage(printItem) {
                this.throwIfInactive();
                const img = document.createElement("img");
                img.style.width = printItem.width;
                img.style.height = printItem.height;
                const scratchCanvas = this.scratchCanvas;
                if ("toBlob" in scratchCanvas && !this.disableCreateObjectURL) {
                  scratchCanvas.toBlob(function(blob) {
                    img.src = URL.createObjectURL(blob);
                  });
                } else {
                  img.src = scratchCanvas.toDataURL();
                }
                const wrapper = document.createElement("div");
                wrapper.appendChild(img);
                this.printContainer.appendChild(wrapper);
                return new Promise(function(resolve, reject) {
                  img.onload = resolve;
                  img.onerror = reject;
                });
              },
              performPrint() {
                this.throwIfInactive();
                return new Promise((resolve) => {
                  setTimeout(() => {
                    if (!this.active) {
                      resolve();
                      return;
                    }
                    print.call(window);
                    setTimeout(resolve, 20);
                  }, 0);
                });
              },
              get active() {
                return this === activeService;
              },
              throwIfInactive() {
                if (!this.active) {
                  throw new Error("This print request was cancelled or completed.");
                }
              }
            };
            const print = window.print;
            window.print = function() {
              if (activeService) {
                console.warn("Ignored window.print() because of a pending print job.");
                return;
              }
              ensureOverlay().then(function() {
                if (activeService) {
                  overlayManager.open("printServiceOverlay");
                }
              });
              try {
                dispatchEvent("beforeprint");
              } finally {
                if (!activeService) {
                  console.error("Expected print service to be initialized.");
                  ensureOverlay().then(function() {
                    if (overlayManager.active === "printServiceOverlay") {
                      overlayManager.close("printServiceOverlay");
                    }
                  });
                  return;
                }
                const activeServiceOnEntry = activeService;
                activeService.renderPages().then(function() {
                  return activeServiceOnEntry.performPrint();
                }).catch(function() {
                }).then(function() {
                  if (activeServiceOnEntry.active) {
                    abort();
                  }
                });
              }
            };
            function dispatchEvent(eventType) {
              const event = document.createEvent("CustomEvent");
              event.initCustomEvent(eventType, false, false, "custom");
              window.dispatchEvent(event);
            }
            function abort() {
              if (activeService) {
                activeService.destroy();
                dispatchEvent("afterprint");
              }
            }
            function renderProgress(index, total, l10n) {
              const progressContainer = document.getElementById("printServiceOverlay");
              const progress = Math.round(100 * index / total);
              const progressBar = progressContainer.querySelector("progress");
              const progressPerc = progressContainer.querySelector(".relative-progress");
              progressBar.value = progress;
              l10n.get("print_progress_percent", {
                progress
              }, progress + "%").then((msg) => {
                progressPerc.textContent = msg;
              });
            }
            window.addEventListener("keydown", function(event) {
              if (event.keyCode === 80 && (event.ctrlKey || event.metaKey) && !event.altKey && (!event.shiftKey || window.chrome || window.opera)) {
                window.print();
                event.preventDefault();
                if (event.stopImmediatePropagation) {
                  event.stopImmediatePropagation();
                } else {
                  event.stopPropagation();
                }
              }
            }, true);
            if ("onbeforeprint" in window) {
              const stopPropagationIfNeeded = function(event) {
                if (event.detail !== "custom" && event.stopImmediatePropagation) {
                  event.stopImmediatePropagation();
                }
              };
              window.addEventListener("beforeprint", stopPropagationIfNeeded);
              window.addEventListener("afterprint", stopPropagationIfNeeded);
            }
            let overlayPromise;
            function ensureOverlay() {
              if (!overlayPromise) {
                overlayManager = _app.PDFViewerApplication.overlayManager;
                if (!overlayManager) {
                  throw new Error("The overlay manager has not yet been initialized.");
                }
                overlayPromise = overlayManager.register("printServiceOverlay", document.getElementById("printServiceOverlay"), abort, true);
                document.getElementById("printCancel").onclick = abort;
              }
              return overlayPromise;
            }
            _app.PDFPrintServiceFactory.instance = {
              supportsPrinting: true,
              createPrintService(pdfDocument, pagesOverview, printContainer, l10n) {
                if (activeService) {
                  throw new Error("The print service is created and active.");
                }
                activeService = new PDFPrintService(pdfDocument, pagesOverview, printContainer, l10n);
                return activeService;
              }
            };
          },
          7807: function(__unused_webpack_module2, exports2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.PDFRenderingQueue = exports2.RenderingStates = void 0;
            const CLEANUP_TIMEOUT = 3e4;
            const RenderingStates = {
              INITIAL: 0,
              RUNNING: 1,
              PAUSED: 2,
              FINISHED: 3
            };
            exports2.RenderingStates = RenderingStates;
            class PDFRenderingQueue {
              constructor() {
                this.pdfViewer = null;
                this.pdfThumbnailViewer = null;
                this.onIdle = null;
                this.highestPriorityPage = null;
                this.idleTimeout = null;
                this.printing = false;
                this.isThumbnailViewEnabled = false;
              }
              setViewer(pdfViewer) {
                this.pdfViewer = pdfViewer;
              }
              setThumbnailViewer(pdfThumbnailViewer) {
                this.pdfThumbnailViewer = pdfThumbnailViewer;
              }
              isHighestPriority(view) {
                return this.highestPriorityPage === view.renderingId;
              }
              renderHighestPriority(currentlyVisiblePages) {
                if (this.idleTimeout) {
                  clearTimeout(this.idleTimeout);
                  this.idleTimeout = null;
                }
                if (this.pdfViewer.forceRendering(currentlyVisiblePages)) {
                  return;
                }
                if (this.pdfThumbnailViewer && this.isThumbnailViewEnabled) {
                  if (this.pdfThumbnailViewer.forceRendering()) {
                    return;
                  }
                }
                if (this.printing) {
                  return;
                }
                if (this.onIdle) {
                  this.idleTimeout = setTimeout(this.onIdle.bind(this), CLEANUP_TIMEOUT);
                }
              }
              getHighestPriority(visible, views, scrolledDown) {
                const visibleViews = visible.views;
                const numVisible = visibleViews.length;
                if (numVisible === 0) {
                  return null;
                }
                for (let i = 0; i < numVisible; ++i) {
                  const view = visibleViews[i].view;
                  if (!this.isViewFinished(view)) {
                    return view;
                  }
                }
                if (scrolledDown) {
                  const nextPageIndex = visible.last.id;
                  if (views[nextPageIndex] && !this.isViewFinished(views[nextPageIndex])) {
                    return views[nextPageIndex];
                  }
                } else {
                  const previousPageIndex = visible.first.id - 2;
                  if (views[previousPageIndex] && !this.isViewFinished(views[previousPageIndex])) {
                    return views[previousPageIndex];
                  }
                }
                return null;
              }
              isViewFinished(view) {
                return view.renderingState === RenderingStates.FINISHED;
              }
              renderView(view) {
                switch (view.renderingState) {
                  case RenderingStates.FINISHED:
                    return false;
                  case RenderingStates.PAUSED:
                    this.highestPriorityPage = view.renderingId;
                    view.resume();
                    break;
                  case RenderingStates.RUNNING:
                    this.highestPriorityPage = view.renderingId;
                    break;
                  case RenderingStates.INITIAL:
                    this.highestPriorityPage = view.renderingId;
                    view.draw().finally(() => {
                      this.renderHighestPriority();
                    }).catch((reason) => {
                      console.error(`renderView: "${reason}"`);
                    });
                    break;
                }
                return true;
              }
            }
            exports2.PDFRenderingQueue = PDFRenderingQueue;
          },
          8241: function(__unused_webpack_module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.PDFSidebar = exports2.SidebarView = void 0;
            var _ui_utils = __webpack_require__2(5570);
            var _pdf_rendering_queue = __webpack_require__2(7807);
            const UI_NOTIFICATION_CLASS = "pdfSidebarNotification";
            const SidebarView = {
              UNKNOWN: -1,
              NONE: 0,
              THUMBS: 1,
              OUTLINE: 2,
              ATTACHMENTS: 3,
              LAYERS: 4
            };
            exports2.SidebarView = SidebarView;
            class PDFSidebar {
              constructor({
                elements,
                pdfViewer,
                pdfThumbnailViewer,
                eventBus,
                l10n = _ui_utils.NullL10n,
                disableNotification = false
              }) {
                this.isOpen = false;
                this.active = SidebarView.THUMBS;
                this.isInitialViewSet = false;
                this.onToggled = null;
                this.pdfViewer = pdfViewer;
                this.pdfThumbnailViewer = pdfThumbnailViewer;
                this.outerContainer = elements.outerContainer;
                this.viewerContainer = elements.viewerContainer;
                this.toggleButton = elements.toggleButton;
                this.thumbnailButton = elements.thumbnailButton;
                this.outlineButton = elements.outlineButton;
                this.attachmentsButton = elements.attachmentsButton;
                this.thumbnailView = elements.thumbnailView;
                this.outlineView = elements.outlineView;
                this.attachmentsView = elements.attachmentsView;
                this.eventBus = eventBus;
                this.l10n = l10n;
                this._disableNotification = disableNotification;
                this._addEventListeners();
              }
              reset() {
                this.isInitialViewSet = false;
                this._hideUINotification(null);
                this.switchView(SidebarView.THUMBS);
                this.outlineButton.disabled = false;
                this.attachmentsButton.disabled = false;
              }
              get visibleView() {
                return this.isOpen ? this.active : SidebarView.NONE;
              }
              get isThumbnailViewVisible() {
                return this.isOpen && this.active === SidebarView.THUMBS;
              }
              get isOutlineViewVisible() {
                return this.isOpen && this.active === SidebarView.OUTLINE;
              }
              get isAttachmentsViewVisible() {
                return this.isOpen && this.active === SidebarView.ATTACHMENTS;
              }
              setInitialView(view = SidebarView.NONE) {
                if (this.isInitialViewSet) {
                  return;
                }
                this.isInitialViewSet = true;
                if (view === SidebarView.NONE || view === SidebarView.UNKNOWN) {
                  this._dispatchEvent();
                  return;
                }
                if (!this._switchView(view, true)) {
                  this._dispatchEvent();
                }
              }
              switchView(view, forceOpen = false) {
                this._switchView(view, forceOpen);
              }
              _switchView(view, forceOpen = false) {
                const isViewChanged = view !== this.active;
                let shouldForceRendering = false;
                switch (view) {
                  case SidebarView.NONE:
                    if (this.isOpen) {
                      this.close();
                      return true;
                    }
                    return false;
                  case SidebarView.THUMBS:
                    if (this.isOpen && isViewChanged) {
                      shouldForceRendering = true;
                    }
                    break;
                  case SidebarView.OUTLINE:
                    if (this.outlineButton.disabled) {
                      return false;
                    }
                    break;
                  case SidebarView.ATTACHMENTS:
                    if (this.attachmentsButton.disabled) {
                      return false;
                    }
                    break;
                  default:
                    console.error(`PDFSidebar._switchView: "${view}" is not a valid view.`);
                    return false;
                }
                this.active = view;
                this.thumbnailButton.classList.toggle("toggled", view === SidebarView.THUMBS);
                this.outlineButton.classList.toggle("toggled", view === SidebarView.OUTLINE);
                this.attachmentsButton.classList.toggle("toggled", view === SidebarView.ATTACHMENTS);
                this.thumbnailView.classList.toggle("hidden", view !== SidebarView.THUMBS);
                this.outlineView.classList.toggle("hidden", view !== SidebarView.OUTLINE);
                this.attachmentsView.classList.toggle("hidden", view !== SidebarView.ATTACHMENTS);
                if (forceOpen && !this.isOpen) {
                  this.open();
                  return true;
                }
                if (shouldForceRendering) {
                  this._updateThumbnailViewer();
                  this._forceRendering();
                }
                if (isViewChanged) {
                  this._dispatchEvent();
                }
                this._hideUINotification(this.active);
                return isViewChanged;
              }
              open() {
                if (this.isOpen) {
                  return;
                }
                this.isOpen = true;
                this.toggleButton.classList.add("toggled");
                this.outerContainer.classList.add("sidebarMoving", "sidebarOpen");
                if (this.active === SidebarView.THUMBS) {
                  this._updateThumbnailViewer();
                }
                this._forceRendering();
                this._dispatchEvent();
                this._hideUINotification(this.active);
              }
              close() {
                if (!this.isOpen) {
                  return;
                }
                this.isOpen = false;
                this.toggleButton.classList.remove("toggled");
                this.outerContainer.classList.add("sidebarMoving");
                this.outerContainer.classList.remove("sidebarOpen");
                this._forceRendering();
                this._dispatchEvent();
              }
              toggle() {
                if (this.isOpen) {
                  this.close();
                } else {
                  this.open();
                }
              }
              _dispatchEvent() {
                this.eventBus.dispatch("sidebarviewchanged", {
                  source: this,
                  view: this.visibleView
                });
              }
              _forceRendering() {
                if (this.onToggled) {
                  this.onToggled();
                } else {
                  this.pdfViewer.forceRendering();
                  this.pdfThumbnailViewer.forceRendering();
                }
              }
              _updateThumbnailViewer() {
                const {
                  pdfViewer,
                  pdfThumbnailViewer
                } = this;
                const pagesCount = pdfViewer.pagesCount;
                for (let pageIndex = 0; pageIndex < pagesCount; pageIndex++) {
                  const pageView = pdfViewer.getPageView(pageIndex);
                  if (pageView && pageView.renderingState === _pdf_rendering_queue.RenderingStates.FINISHED) {
                    const thumbnailView = pdfThumbnailViewer.getThumbnail(pageIndex);
                    thumbnailView.setImage(pageView);
                  }
                }
                pdfThumbnailViewer.scrollThumbnailIntoView(pdfViewer.currentPageNumber);
              }
              _showUINotification(view) {
                if (this._disableNotification) {
                  return;
                }
                this.l10n.get("toggle_sidebar_notification.title", null, "Toggle Sidebar (document contains outline/attachments)").then((msg) => {
                  this.toggleButton.title = msg;
                });
                if (!this.isOpen) {
                  this.toggleButton.classList.add(UI_NOTIFICATION_CLASS);
                } else if (view === this.active) {
                  return;
                }
                switch (view) {
                  case SidebarView.OUTLINE:
                    this.outlineButton.classList.add(UI_NOTIFICATION_CLASS);
                    break;
                  case SidebarView.ATTACHMENTS:
                    this.attachmentsButton.classList.add(UI_NOTIFICATION_CLASS);
                    break;
                }
              }
              _hideUINotification(view) {
                if (this._disableNotification) {
                  return;
                }
                const removeNotification = (sidebarView) => {
                  switch (sidebarView) {
                    case SidebarView.OUTLINE:
                      this.outlineButton.classList.remove(UI_NOTIFICATION_CLASS);
                      break;
                    case SidebarView.ATTACHMENTS:
                      this.attachmentsButton.classList.remove(UI_NOTIFICATION_CLASS);
                      break;
                  }
                };
                if (!this.isOpen && view !== null) {
                  return;
                }
                this.toggleButton.classList.remove(UI_NOTIFICATION_CLASS);
                if (view !== null) {
                  removeNotification(view);
                  return;
                }
                for (view in SidebarView) {
                  removeNotification(SidebarView[view]);
                }
                this.l10n.get("toggle_sidebar.title", null, "Toggle Sidebar").then((msg) => {
                  this.toggleButton.title = msg;
                });
              }
              _addEventListeners() {
                this.viewerContainer.addEventListener("transitionend", (evt) => {
                  if (evt.target === this.viewerContainer) {
                    this.outerContainer.classList.remove("sidebarMoving");
                  }
                });
                this.toggleButton.addEventListener("click", () => {
                  this.toggle();
                });
                this.thumbnailButton.addEventListener("click", () => {
                  this.switchView(SidebarView.THUMBS);
                });
                this.outlineButton.addEventListener("click", () => {
                  this.switchView(SidebarView.OUTLINE);
                });
                this.outlineButton.addEventListener("dblclick", () => {
                  this.eventBus.dispatch("toggleoutlinetree", {
                    source: this
                  });
                });
                this.attachmentsButton.addEventListener("click", () => {
                  this.switchView(SidebarView.ATTACHMENTS);
                });
                this.eventBus._on("outlineloaded", (evt) => {
                  const outlineCount = evt.outlineCount;
                  this.outlineButton.disabled = !outlineCount;
                  if (outlineCount) {
                    this._showUINotification(SidebarView.OUTLINE);
                  } else if (this.active === SidebarView.OUTLINE) {
                    this.switchView(SidebarView.THUMBS);
                  }
                });
                this.eventBus._on("attachmentsloaded", (evt) => {
                  if (evt.attachmentsCount) {
                    this.attachmentsButton.disabled = false;
                    this._showUINotification(SidebarView.ATTACHMENTS);
                    return;
                  }
                  Promise.resolve().then(() => {
                    if (this.attachmentsView.hasChildNodes()) {
                      return;
                    }
                    this.attachmentsButton.disabled = true;
                    if (this.active === SidebarView.ATTACHMENTS) {
                      this.switchView(SidebarView.THUMBS);
                    }
                  });
                });
                this.eventBus._on("presentationmodechanged", (evt) => {
                  if (!evt.active && !evt.switchInProgress && this.isThumbnailViewVisible) {
                    this._updateThumbnailViewer();
                  }
                });
              }
            }
            exports2.PDFSidebar = PDFSidebar;
          },
          2355: function(__unused_webpack_module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.PDFSidebarResizer = void 0;
            var _ui_utils = __webpack_require__2(5570);
            const SIDEBAR_WIDTH_VAR = "--sidebar-width";
            const SIDEBAR_MIN_WIDTH = 200;
            const SIDEBAR_RESIZING_CLASS = "sidebarResizing";
            class PDFSidebarResizer {
              constructor(options, eventBus, l10n = _ui_utils.NullL10n) {
                this.enabled = false;
                this.isRTL = false;
                this.sidebarOpen = false;
                this.doc = document.documentElement;
                this._width = null;
                this._outerContainerWidth = null;
                this._boundEvents = /* @__PURE__ */ Object.create(null);
                this.outerContainer = options.outerContainer;
                this.resizer = options.resizer;
                this.eventBus = eventBus;
                this.l10n = l10n;
                if (typeof CSS === "undefined" || typeof CSS.supports !== "function" || !CSS.supports(SIDEBAR_WIDTH_VAR, `calc(-1 * ${SIDEBAR_MIN_WIDTH}px)`)) {
                  console.warn("PDFSidebarResizer: The browser does not support resizing of the sidebar.");
                  return;
                }
                this.enabled = true;
                this.resizer.classList.remove("hidden");
                this.l10n.getDirection().then((dir) => {
                  this.isRTL = dir === "rtl";
                });
                this._addEventListeners();
              }
              get outerContainerWidth() {
                if (!this._outerContainerWidth) {
                  this._outerContainerWidth = this.outerContainer.clientWidth;
                }
                return this._outerContainerWidth;
              }
              _updateWidth(width = 0) {
                if (!this.enabled) {
                  return false;
                }
                const newWidth = (0, _ui_utils.clamp)(width, SIDEBAR_MIN_WIDTH, Math.floor(this.outerContainerWidth / 2));
                if (newWidth === this._width) {
                  return false;
                }
                this._width = newWidth;
                this.doc.style.setProperty(SIDEBAR_WIDTH_VAR, `${newWidth}px`);
                return true;
              }
              _mouseMove(evt) {
                let width = evt.clientX;
                if (this.isRTL) {
                  width = this.outerContainerWidth - width;
                }
                this._updateWidth(width);
              }
              _mouseUp(evt) {
                this.outerContainer.classList.remove(SIDEBAR_RESIZING_CLASS);
                this.eventBus.dispatch("resize", {
                  source: this
                });
                const _boundEvents = this._boundEvents;
                window.removeEventListener("mousemove", _boundEvents.mouseMove);
                window.removeEventListener("mouseup", _boundEvents.mouseUp);
              }
              _addEventListeners() {
                if (!this.enabled) {
                  return;
                }
                const _boundEvents = this._boundEvents;
                _boundEvents.mouseMove = this._mouseMove.bind(this);
                _boundEvents.mouseUp = this._mouseUp.bind(this);
                this.resizer.addEventListener("mousedown", (evt) => {
                  if (evt.button !== 0) {
                    return;
                  }
                  this.outerContainer.classList.add(SIDEBAR_RESIZING_CLASS);
                  window.addEventListener("mousemove", _boundEvents.mouseMove);
                  window.addEventListener("mouseup", _boundEvents.mouseUp);
                });
                this.eventBus._on("sidebarviewchanged", (evt) => {
                  this.sidebarOpen = !!(evt && evt.view);
                });
                this.eventBus._on("resize", (evt) => {
                  if (!evt || evt.source !== window) {
                    return;
                  }
                  this._outerContainerWidth = null;
                  if (!this._width) {
                    return;
                  }
                  if (!this.sidebarOpen) {
                    this._updateWidth(this._width);
                    return;
                  }
                  this.outerContainer.classList.add(SIDEBAR_RESIZING_CLASS);
                  const updated = this._updateWidth(this._width);
                  Promise.resolve().then(() => {
                    this.outerContainer.classList.remove(SIDEBAR_RESIZING_CLASS);
                    if (updated) {
                      this.eventBus.dispatch("resize", {
                        source: this
                      });
                    }
                  });
                });
              }
            }
            exports2.PDFSidebarResizer = PDFSidebarResizer;
          },
          1501: function(__unused_webpack_module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.PDFSinglePageViewer = void 0;
            var _base_viewer = __webpack_require__2(5710);
            var _pdf = __webpack_require__2(3941);
            class PDFSinglePageViewer extends _base_viewer.BaseViewer {
              constructor(options) {
                super(options);
                this.eventBus._on("pagesinit", (evt) => {
                  this._ensurePageViewVisible();
                });
              }
              get _setDocumentViewerElement() {
                return (0, _pdf.shadow)(this, "_setDocumentViewerElement", this._shadowViewer);
              }
              _resetView() {
                super._resetView();
                this._previousPageNumber = 1;
                this._shadowViewer = document.createDocumentFragment();
                this._updateScrollDown = null;
              }
              _ensurePageViewVisible() {
                const pageView = this._pages[this._currentPageNumber - 1];
                const previousPageView = this._pages[this._previousPageNumber - 1];
                const viewerNodes = this.viewer.childNodes;
                switch (viewerNodes.length) {
                  case 0:
                    this.viewer.appendChild(pageView.div);
                    break;
                  case 1:
                    if (viewerNodes[0] !== previousPageView.div) {
                      throw new Error("_ensurePageViewVisible: Unexpected previously visible page.");
                    }
                    if (pageView === previousPageView) {
                      break;
                    }
                    this._shadowViewer.appendChild(previousPageView.div);
                    this.viewer.appendChild(pageView.div);
                    this.container.scrollTop = 0;
                    break;
                  default:
                    throw new Error("_ensurePageViewVisible: Only one page should be visible at a time.");
                }
                this._previousPageNumber = this._currentPageNumber;
              }
              _scrollUpdate() {
                if (this._updateScrollDown) {
                  this._updateScrollDown();
                }
                super._scrollUpdate();
              }
              _scrollIntoView({
                pageDiv,
                pageSpot = null,
                pageNumber = null
              }) {
                if (pageNumber) {
                  this._setCurrentPageNumber(pageNumber);
                }
                const scrolledDown = this._currentPageNumber >= this._previousPageNumber;
                this._ensurePageViewVisible();
                this.update();
                super._scrollIntoView({
                  pageDiv,
                  pageSpot,
                  pageNumber
                });
                this._updateScrollDown = () => {
                  this.scroll.down = scrolledDown;
                  this._updateScrollDown = null;
                };
              }
              _getVisiblePages() {
                return this._getCurrentVisiblePage();
              }
              _updateHelper(visiblePages) {
              }
              get _isScrollModeHorizontal() {
                return (0, _pdf.shadow)(this, "_isScrollModeHorizontal", false);
              }
              _updateScrollMode() {
              }
              _updateSpreadMode() {
              }
            }
            exports2.PDFSinglePageViewer = PDFSinglePageViewer;
          },
          2142: function(__unused_webpack_module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.PDFThumbnailView = void 0;
            var _pdf = __webpack_require__2(3941);
            var _ui_utils = __webpack_require__2(5570);
            var _pdf_rendering_queue = __webpack_require__2(7807);
            const MAX_NUM_SCALING_STEPS = 3;
            const THUMBNAIL_CANVAS_BORDER_WIDTH = 1;
            const THUMBNAIL_WIDTH = 98;
            const TempImageFactory = function TempImageFactoryClosure() {
              let tempCanvasCache = null;
              return {
                getCanvas(width, height) {
                  let tempCanvas = tempCanvasCache;
                  if (!tempCanvas) {
                    tempCanvas = document.createElement("canvas");
                    tempCanvasCache = tempCanvas;
                  }
                  tempCanvas.width = width;
                  tempCanvas.height = height;
                  tempCanvas.mozOpaque = true;
                  const ctx = tempCanvas.getContext("2d", {
                    alpha: false
                  });
                  ctx.save();
                  ctx.fillStyle = "rgb(255, 255, 255)";
                  ctx.fillRect(0, 0, width, height);
                  ctx.restore();
                  return tempCanvas;
                },
                destroyCanvas() {
                  const tempCanvas = tempCanvasCache;
                  if (tempCanvas) {
                    tempCanvas.width = 0;
                    tempCanvas.height = 0;
                  }
                  tempCanvasCache = null;
                }
              };
            }();
            class PDFThumbnailView {
              constructor({
                container,
                id,
                defaultViewport,
                linkService,
                renderingQueue,
                disableCanvasToImageConversion = false,
                l10n = _ui_utils.NullL10n
              }) {
                this.id = id;
                this.renderingId = "thumbnail" + id;
                this.pageLabel = null;
                this.pdfPage = null;
                this.rotation = 0;
                this.viewport = defaultViewport;
                this.pdfPageRotate = defaultViewport.rotation;
                this.linkService = linkService;
                this.renderingQueue = renderingQueue;
                this.renderTask = null;
                this.renderingState = _pdf_rendering_queue.RenderingStates.INITIAL;
                this.resume = null;
                this.disableCanvasToImageConversion = disableCanvasToImageConversion;
                this.pageWidth = this.viewport.width;
                this.pageHeight = this.viewport.height;
                this.pageRatio = this.pageWidth / this.pageHeight;
                this.canvasWidth = THUMBNAIL_WIDTH;
                this.canvasHeight = this.canvasWidth / this.pageRatio | 0;
                this.scale = this.canvasWidth / this.pageWidth;
                this.l10n = l10n;
                const anchor = document.createElement("a");
                anchor.href = linkService.getAnchorUrl("#page=" + id);
                this._thumbPageTitle.then((msg) => {
                  anchor.title = msg;
                });
                anchor.onclick = function() {
                  linkService.page = id;
                  return false;
                };
                this.anchor = anchor;
                const div = document.createElement("div");
                div.className = "thumbnail";
                div.setAttribute("data-page-number", this.id);
                this.div = div;
                const ring = document.createElement("div");
                ring.className = "thumbnailSelectionRing";
                const borderAdjustment = 2 * THUMBNAIL_CANVAS_BORDER_WIDTH;
                ring.style.width = this.canvasWidth + borderAdjustment + "px";
                ring.style.height = this.canvasHeight + borderAdjustment + "px";
                this.ring = ring;
                div.appendChild(ring);
                anchor.appendChild(div);
                container.appendChild(anchor);
              }
              setPdfPage(pdfPage) {
                this.pdfPage = pdfPage;
                this.pdfPageRotate = pdfPage.rotate;
                const totalRotation = (this.rotation + this.pdfPageRotate) % 360;
                this.viewport = pdfPage.getViewport({
                  scale: 1,
                  rotation: totalRotation
                });
                this.reset();
              }
              reset() {
                this.cancelRendering();
                this.renderingState = _pdf_rendering_queue.RenderingStates.INITIAL;
                this.pageWidth = this.viewport.width;
                this.pageHeight = this.viewport.height;
                this.pageRatio = this.pageWidth / this.pageHeight;
                this.canvasHeight = this.canvasWidth / this.pageRatio | 0;
                this.scale = this.canvasWidth / this.pageWidth;
                this.div.removeAttribute("data-loaded");
                const ring = this.ring;
                const childNodes = ring.childNodes;
                for (let i = childNodes.length - 1; i >= 0; i--) {
                  ring.removeChild(childNodes[i]);
                }
                const borderAdjustment = 2 * THUMBNAIL_CANVAS_BORDER_WIDTH;
                ring.style.width = this.canvasWidth + borderAdjustment + "px";
                ring.style.height = this.canvasHeight + borderAdjustment + "px";
                if (this.canvas) {
                  this.canvas.width = 0;
                  this.canvas.height = 0;
                  delete this.canvas;
                }
                if (this.image) {
                  this.image.removeAttribute("src");
                  delete this.image;
                }
              }
              update(rotation) {
                if (typeof rotation !== "undefined") {
                  this.rotation = rotation;
                }
                const totalRotation = (this.rotation + this.pdfPageRotate) % 360;
                this.viewport = this.viewport.clone({
                  scale: 1,
                  rotation: totalRotation
                });
                this.reset();
              }
              cancelRendering() {
                if (this.renderTask) {
                  this.renderTask.cancel();
                  this.renderTask = null;
                }
                this.resume = null;
              }
              _getPageDrawContext(noCtxScale = false) {
                const canvas = document.createElement("canvas");
                this.canvas = canvas;
                canvas.mozOpaque = true;
                const ctx = canvas.getContext("2d", {
                  alpha: false
                });
                const outputScale = (0, _ui_utils.getOutputScale)(ctx);
                canvas.width = this.canvasWidth * outputScale.sx | 0;
                canvas.height = this.canvasHeight * outputScale.sy | 0;
                canvas.style.width = this.canvasWidth + "px";
                canvas.style.height = this.canvasHeight + "px";
                if (!noCtxScale && outputScale.scaled) {
                  ctx.scale(outputScale.sx, outputScale.sy);
                }
                return ctx;
              }
              _convertCanvasToImage() {
                if (!this.canvas) {
                  return;
                }
                if (this.renderingState !== _pdf_rendering_queue.RenderingStates.FINISHED) {
                  return;
                }
                const className = "thumbnailImage";
                if (this.disableCanvasToImageConversion) {
                  this.canvas.className = className;
                  this._thumbPageCanvas.then((msg) => {
                    this.canvas.setAttribute("aria-label", msg);
                  });
                  this.div.setAttribute("data-loaded", true);
                  this.ring.appendChild(this.canvas);
                  return;
                }
                const image = document.createElement("img");
                image.className = className;
                this._thumbPageCanvas.then((msg) => {
                  image.setAttribute("aria-label", msg);
                });
                image.style.width = this.canvasWidth + "px";
                image.style.height = this.canvasHeight + "px";
                image.src = this.canvas.toDataURL();
                this.image = image;
                this.div.setAttribute("data-loaded", true);
                this.ring.appendChild(image);
                this.canvas.width = 0;
                this.canvas.height = 0;
                delete this.canvas;
              }
              draw() {
                if (this.renderingState !== _pdf_rendering_queue.RenderingStates.INITIAL) {
                  console.error("Must be in new state before drawing");
                  return Promise.resolve(void 0);
                }
                const {
                  pdfPage
                } = this;
                if (!pdfPage) {
                  this.renderingState = _pdf_rendering_queue.RenderingStates.FINISHED;
                  return Promise.reject(new Error("pdfPage is not loaded"));
                }
                this.renderingState = _pdf_rendering_queue.RenderingStates.RUNNING;
                const renderCapability = (0, _pdf.createPromiseCapability)();
                const finishRenderTask = (error) => {
                  if (renderTask === this.renderTask) {
                    this.renderTask = null;
                  }
                  if (error instanceof _pdf.RenderingCancelledException) {
                    renderCapability.resolve(void 0);
                    return;
                  }
                  this.renderingState = _pdf_rendering_queue.RenderingStates.FINISHED;
                  this._convertCanvasToImage();
                  if (!error) {
                    renderCapability.resolve(void 0);
                  } else {
                    renderCapability.reject(error);
                  }
                };
                const ctx = this._getPageDrawContext();
                const drawViewport = this.viewport.clone({
                  scale: this.scale
                });
                const renderContinueCallback = (cont) => {
                  if (!this.renderingQueue.isHighestPriority(this)) {
                    this.renderingState = _pdf_rendering_queue.RenderingStates.PAUSED;
                    this.resume = () => {
                      this.renderingState = _pdf_rendering_queue.RenderingStates.RUNNING;
                      cont();
                    };
                    return;
                  }
                  cont();
                };
                const renderContext = {
                  canvasContext: ctx,
                  viewport: drawViewport
                };
                const renderTask = this.renderTask = pdfPage.render(renderContext);
                renderTask.onContinue = renderContinueCallback;
                renderTask.promise.then(function() {
                  finishRenderTask(null);
                }, function(error) {
                  finishRenderTask(error);
                });
                return renderCapability.promise;
              }
              setImage(pageView) {
                if (this.renderingState !== _pdf_rendering_queue.RenderingStates.INITIAL) {
                  return;
                }
                const img = pageView.canvas;
                if (!img) {
                  return;
                }
                if (!this.pdfPage) {
                  this.setPdfPage(pageView.pdfPage);
                }
                this.renderingState = _pdf_rendering_queue.RenderingStates.FINISHED;
                const ctx = this._getPageDrawContext(true);
                const canvas = ctx.canvas;
                if (img.width <= 2 * canvas.width) {
                  ctx.drawImage(img, 0, 0, img.width, img.height, 0, 0, canvas.width, canvas.height);
                  this._convertCanvasToImage();
                  return;
                }
                let reducedWidth = canvas.width << MAX_NUM_SCALING_STEPS;
                let reducedHeight = canvas.height << MAX_NUM_SCALING_STEPS;
                const reducedImage = TempImageFactory.getCanvas(reducedWidth, reducedHeight);
                const reducedImageCtx = reducedImage.getContext("2d");
                while (reducedWidth > img.width || reducedHeight > img.height) {
                  reducedWidth >>= 1;
                  reducedHeight >>= 1;
                }
                reducedImageCtx.drawImage(img, 0, 0, img.width, img.height, 0, 0, reducedWidth, reducedHeight);
                while (reducedWidth > 2 * canvas.width) {
                  reducedImageCtx.drawImage(reducedImage, 0, 0, reducedWidth, reducedHeight, 0, 0, reducedWidth >> 1, reducedHeight >> 1);
                  reducedWidth >>= 1;
                  reducedHeight >>= 1;
                }
                ctx.drawImage(reducedImage, 0, 0, reducedWidth, reducedHeight, 0, 0, canvas.width, canvas.height);
                this._convertCanvasToImage();
              }
              get _thumbPageTitle() {
                return this.l10n.get("thumb_page_title", {
                  page: this.pageLabel !== null ? this.pageLabel : this.id
                }, "Page {{page}}");
              }
              get _thumbPageCanvas() {
                return this.l10n.get("thumb_page_canvas", {
                  page: this.pageLabel !== null ? this.pageLabel : this.id
                }, "Thumbnail of Page {{page}}");
              }
              setPageLabel(label) {
                this.pageLabel = typeof label === "string" ? label : null;
                this._thumbPageTitle.then((msg) => {
                  this.anchor.title = msg;
                });
                if (this.renderingState !== _pdf_rendering_queue.RenderingStates.FINISHED) {
                  return;
                }
                this._thumbPageCanvas.then((msg) => {
                  if (this.image) {
                    this.image.setAttribute("aria-label", msg);
                  } else if (this.disableCanvasToImageConversion && this.canvas) {
                    this.canvas.setAttribute("aria-label", msg);
                  }
                });
              }
              static cleanup() {
                TempImageFactory.destroyCanvas();
              }
            }
            exports2.PDFThumbnailView = PDFThumbnailView;
          },
          2096: function(__unused_webpack_module2, exports2, __webpack_require__2) {
            "use strict";
            __webpack_require__2(7658);
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.PDFThumbnailViewer = void 0;
            var _ui_utils = __webpack_require__2(5570);
            var _pdf_thumbnail_view = __webpack_require__2(2142);
            const THUMBNAIL_SCROLL_MARGIN = -19;
            const THUMBNAIL_SELECTED_CLASS = "selected";
            class PDFThumbnailViewer {
              constructor({
                container,
                linkService,
                renderingQueue,
                l10n = _ui_utils.NullL10n
              }) {
                this.container = container;
                this.linkService = linkService;
                this.renderingQueue = renderingQueue;
                this.l10n = l10n;
                this.scroll = (0, _ui_utils.watchScroll)(this.container, this._scrollUpdated.bind(this));
                this._resetView();
              }
              _scrollUpdated() {
                this.renderingQueue.renderHighestPriority();
              }
              getThumbnail(index) {
                return this._thumbnails[index];
              }
              _getVisibleThumbs() {
                return (0, _ui_utils.getVisibleElements)(this.container, this._thumbnails);
              }
              scrollThumbnailIntoView(pageNumber) {
                if (!this.pdfDocument) {
                  return;
                }
                const thumbnailView = this._thumbnails[pageNumber - 1];
                if (!thumbnailView) {
                  console.error('scrollThumbnailIntoView: Invalid "pageNumber" parameter.');
                  return;
                }
                if (pageNumber !== this._currentPageNumber) {
                  const prevThumbnailView = this._thumbnails[this._currentPageNumber - 1];
                  prevThumbnailView.div.classList.remove(THUMBNAIL_SELECTED_CLASS);
                  thumbnailView.div.classList.add(THUMBNAIL_SELECTED_CLASS);
                }
                const visibleThumbs = this._getVisibleThumbs();
                const numVisibleThumbs = visibleThumbs.views.length;
                if (numVisibleThumbs > 0) {
                  const first = visibleThumbs.first.id;
                  const last = numVisibleThumbs > 1 ? visibleThumbs.last.id : first;
                  let shouldScroll = false;
                  if (pageNumber <= first || pageNumber >= last) {
                    shouldScroll = true;
                  } else {
                    visibleThumbs.views.some(function(view) {
                      if (view.id !== pageNumber) {
                        return false;
                      }
                      shouldScroll = view.percent < 100;
                      return true;
                    });
                  }
                  if (shouldScroll) {
                    (0, _ui_utils.scrollIntoView)(thumbnailView.div, {
                      top: THUMBNAIL_SCROLL_MARGIN
                    });
                  }
                }
                this._currentPageNumber = pageNumber;
              }
              get pagesRotation() {
                return this._pagesRotation;
              }
              set pagesRotation(rotation) {
                if (!(0, _ui_utils.isValidRotation)(rotation)) {
                  throw new Error("Invalid thumbnails rotation angle.");
                }
                if (!this.pdfDocument) {
                  return;
                }
                if (this._pagesRotation === rotation) {
                  return;
                }
                this._pagesRotation = rotation;
                for (let i = 0, ii = this._thumbnails.length; i < ii; i++) {
                  this._thumbnails[i].update(rotation);
                }
              }
              cleanup() {
                _pdf_thumbnail_view.PDFThumbnailView.cleanup();
              }
              _resetView() {
                this._thumbnails = [];
                this._currentPageNumber = 1;
                this._pageLabels = null;
                this._pagesRotation = 0;
                this._pagesRequests = /* @__PURE__ */ new WeakMap();
                this.container.textContent = "";
              }
              setDocument(pdfDocument) {
                if (this.pdfDocument) {
                  this._cancelRendering();
                  this._resetView();
                }
                this.pdfDocument = pdfDocument;
                if (!pdfDocument) {
                  return;
                }
                pdfDocument.getPage(1).then((firstPdfPage) => {
                  const pagesCount = pdfDocument.numPages;
                  const viewport = firstPdfPage.getViewport({
                    scale: 1
                  });
                  for (let pageNum = 1; pageNum <= pagesCount; ++pageNum) {
                    const thumbnail = new _pdf_thumbnail_view.PDFThumbnailView({
                      container: this.container,
                      id: pageNum,
                      defaultViewport: viewport.clone(),
                      linkService: this.linkService,
                      renderingQueue: this.renderingQueue,
                      disableCanvasToImageConversion: false,
                      l10n: this.l10n
                    });
                    this._thumbnails.push(thumbnail);
                  }
                  const firstThumbnailView = this._thumbnails[0];
                  if (firstThumbnailView) {
                    firstThumbnailView.setPdfPage(firstPdfPage);
                  }
                  const thumbnailView = this._thumbnails[this._currentPageNumber - 1];
                  thumbnailView.div.classList.add(THUMBNAIL_SELECTED_CLASS);
                }).catch((reason) => {
                  console.error("Unable to initialize thumbnail viewer", reason);
                });
              }
              _cancelRendering() {
                for (let i = 0, ii = this._thumbnails.length; i < ii; i++) {
                  if (this._thumbnails[i]) {
                    this._thumbnails[i].cancelRendering();
                  }
                }
              }
              setPageLabels(labels) {
                if (!this.pdfDocument) {
                  return;
                }
                if (!labels) {
                  this._pageLabels = null;
                } else if (!(Array.isArray(labels) && this.pdfDocument.numPages === labels.length)) {
                  this._pageLabels = null;
                  console.error("PDFThumbnailViewer_setPageLabels: Invalid page labels.");
                } else {
                  this._pageLabels = labels;
                }
                for (let i = 0, ii = this._thumbnails.length; i < ii; i++) {
                  const label = this._pageLabels && this._pageLabels[i];
                  this._thumbnails[i].setPageLabel(label);
                }
              }
              _ensurePdfPageLoaded(thumbView) {
                if (thumbView.pdfPage) {
                  return Promise.resolve(thumbView.pdfPage);
                }
                if (this._pagesRequests.has(thumbView)) {
                  return this._pagesRequests.get(thumbView);
                }
                const promise = this.pdfDocument.getPage(thumbView.id).then((pdfPage) => {
                  if (!thumbView.pdfPage) {
                    thumbView.setPdfPage(pdfPage);
                  }
                  this._pagesRequests.delete(thumbView);
                  return pdfPage;
                }).catch((reason) => {
                  console.error("Unable to get page for thumb view", reason);
                  this._pagesRequests.delete(thumbView);
                });
                this._pagesRequests.set(thumbView, promise);
                return promise;
              }
              forceRendering() {
                const visibleThumbs = this._getVisibleThumbs();
                const thumbView = this.renderingQueue.getHighestPriority(visibleThumbs, this._thumbnails, this.scroll.down);
                if (thumbView) {
                  this._ensurePdfPageLoaded(thumbView).then(() => {
                    this.renderingQueue.renderView(thumbView);
                  });
                  return true;
                }
                return false;
              }
            }
            exports2.PDFThumbnailViewer = PDFThumbnailViewer;
          },
          6157: function(__unused_webpack_module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.PDFViewer = void 0;
            var _base_viewer = __webpack_require__2(5710);
            var _pdf = __webpack_require__2(3941);
            class PDFViewer extends _base_viewer.BaseViewer {
              get _setDocumentViewerElement() {
                return (0, _pdf.shadow)(this, "_setDocumentViewerElement", this.viewer);
              }
              _scrollIntoView({
                pageDiv,
                pageSpot = null,
                pageNumber = null
              }) {
                if (!pageSpot && !this.isInPresentationMode) {
                  const left = pageDiv.offsetLeft + pageDiv.clientLeft;
                  const right = left + pageDiv.clientWidth;
                  const {
                    scrollLeft,
                    clientWidth
                  } = this.container;
                  if (this._isScrollModeHorizontal || left < scrollLeft || right > scrollLeft + clientWidth) {
                    pageSpot = {
                      left: 0,
                      top: 0
                    };
                  }
                }
                super._scrollIntoView({
                  pageDiv,
                  pageSpot,
                  pageNumber
                });
              }
              _getVisiblePages() {
                if (this.isInPresentationMode) {
                  return this._getCurrentVisiblePage();
                }
                return super._getVisiblePages();
              }
              _updateHelper(visiblePages) {
                if (this.isInPresentationMode) {
                  return;
                }
                let currentId = this._currentPageNumber;
                let stillFullyVisible = false;
                for (const page of visiblePages) {
                  if (page.percent < 100) {
                    break;
                  }
                  if (page.id === currentId) {
                    stillFullyVisible = true;
                    break;
                  }
                }
                if (!stillFullyVisible) {
                  currentId = visiblePages[0].id;
                }
                this._setCurrentPageNumber(currentId);
              }
            }
            exports2.PDFViewer = PDFViewer;
          },
          3128: function(__unused_webpack_module2, exports2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.BasePreferences = void 0;
            let defaultPreferences = null;
            function getDefaultPreferences() {
              if (!defaultPreferences) {
                defaultPreferences = Promise.resolve({
                  "cursorToolOnLoad": 0,
                  "defaultZoomValue": "",
                  "disablePageLabels": false,
                  "enablePrintAutoRotate": false,
                  "enableWebGL": false,
                  "eventBusDispatchToDOM": false,
                  "externalLinkTarget": 0,
                  "historyUpdateUrl": false,
                  "ignoreDestinationZoom": false,
                  "pdfBugEnabled": false,
                  "renderer": "canvas",
                  "renderInteractiveForms": false,
                  "sidebarViewOnLoad": -1,
                  "scrollModeOnLoad": -1,
                  "spreadModeOnLoad": -1,
                  "textLayerMode": 1,
                  "useOnlyCssZoom": false,
                  "viewOnLoad": 0,
                  "disableAutoFetch": false,
                  "disableFontFace": false,
                  "disableRange": false,
                  "disableStream": false
                });
              }
              return defaultPreferences;
            }
            class BasePreferences {
              constructor() {
                if (this.constructor === BasePreferences) {
                  throw new Error("Cannot initialize BasePreferences.");
                }
                this.prefs = null;
                this._initializedPromise = getDefaultPreferences().then((defaults) => {
                  Object.defineProperty(this, "defaults", {
                    value: Object.freeze(defaults),
                    writable: false,
                    enumerable: true,
                    configurable: false
                  });
                  this.prefs = Object.assign(/* @__PURE__ */ Object.create(null), defaults);
                  return this._readFromStorage(defaults);
                }).then((prefs) => {
                  if (!prefs) {
                    return;
                  }
                  for (const name in prefs) {
                    const defaultValue = this.defaults[name], prefValue = prefs[name];
                    if (defaultValue === void 0 || typeof prefValue !== typeof defaultValue) {
                      continue;
                    }
                    this.prefs[name] = prefValue;
                  }
                });
              }
              async _writeToStorage(prefObj) {
                throw new Error("Not implemented: _writeToStorage");
              }
              async _readFromStorage(prefObj) {
                throw new Error("Not implemented: _readFromStorage");
              }
              async reset() {
                await this._initializedPromise;
                this.prefs = Object.assign(/* @__PURE__ */ Object.create(null), this.defaults);
                return this._writeToStorage(this.defaults);
              }
              async set(name, value) {
                await this._initializedPromise;
                const defaultValue = this.defaults[name];
                if (defaultValue === void 0) {
                  throw new Error(`Set preference: "${name}" is undefined.`);
                } else if (value === void 0) {
                  throw new Error("Set preference: no value is specified.");
                }
                const valueType = typeof value;
                const defaultType = typeof defaultValue;
                if (valueType !== defaultType) {
                  if (valueType === "number" && defaultType === "string") {
                    value = value.toString();
                  } else {
                    throw new Error(`Set preference: "${value}" is a ${valueType}, expected a ${defaultType}.`);
                  }
                } else {
                  if (valueType === "number" && !Number.isInteger(value)) {
                    throw new Error(`Set preference: "${value}" must be an integer.`);
                  }
                }
                this.prefs[name] = value;
                return this._writeToStorage(this.prefs);
              }
              async get(name) {
                await this._initializedPromise;
                const defaultValue = this.defaults[name];
                if (defaultValue === void 0) {
                  throw new Error(`Get preference: "${name}" is undefined.`);
                } else {
                  const prefValue = this.prefs[name];
                  if (prefValue !== void 0) {
                    return prefValue;
                  }
                }
                return defaultValue;
              }
              async getAll() {
                await this._initializedPromise;
                return Object.assign(/* @__PURE__ */ Object.create(null), this.defaults, this.prefs);
              }
            }
            exports2.BasePreferences = BasePreferences;
          },
          4217: function(__unused_webpack_module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.SecondaryToolbar = void 0;
            var _ui_utils = __webpack_require__2(5570);
            var _pdf_cursor_tools = __webpack_require__2(6879);
            var _pdf_single_page_viewer = __webpack_require__2(1501);
            class SecondaryToolbar {
              constructor(options, mainContainer, eventBus) {
                this.toolbar = options.toolbar;
                this.toggleButton = options.toggleButton;
                this.toolbarButtonContainer = options.toolbarButtonContainer;
                this.buttons = [{
                  element: options.presentationModeButton,
                  eventName: "presentationmode",
                  close: true
                }, {
                  element: options.openFileButton,
                  eventName: "openfile",
                  close: true
                }, {
                  element: options.printButton,
                  eventName: "print",
                  close: true
                }, {
                  element: options.downloadButton,
                  eventName: "download",
                  close: true
                }, {
                  element: options.viewBookmarkButton,
                  eventName: null,
                  close: true
                }, {
                  element: options.firstPageButton,
                  eventName: "firstpage",
                  close: true
                }, {
                  element: options.lastPageButton,
                  eventName: "lastpage",
                  close: true
                }, {
                  element: options.pageRotateCwButton,
                  eventName: "rotatecw",
                  close: false
                }, {
                  element: options.pageRotateCcwButton,
                  eventName: "rotateccw",
                  close: false
                }, {
                  element: options.cursorSelectToolButton,
                  eventName: "switchcursortool",
                  eventDetails: {
                    tool: _pdf_cursor_tools.CursorTool.SELECT
                  },
                  close: true
                }, {
                  element: options.cursorHandToolButton,
                  eventName: "switchcursortool",
                  eventDetails: {
                    tool: _pdf_cursor_tools.CursorTool.HAND
                  },
                  close: true
                }, {
                  element: options.scrollVerticalButton,
                  eventName: "switchscrollmode",
                  eventDetails: {
                    mode: _ui_utils.ScrollMode.VERTICAL
                  },
                  close: true
                }, {
                  element: options.scrollHorizontalButton,
                  eventName: "switchscrollmode",
                  eventDetails: {
                    mode: _ui_utils.ScrollMode.HORIZONTAL
                  },
                  close: true
                }, {
                  element: options.scrollWrappedButton,
                  eventName: "switchscrollmode",
                  eventDetails: {
                    mode: _ui_utils.ScrollMode.WRAPPED
                  },
                  close: true
                }, {
                  element: options.spreadNoneButton,
                  eventName: "switchspreadmode",
                  eventDetails: {
                    mode: _ui_utils.SpreadMode.NONE
                  },
                  close: true
                }, {
                  element: options.spreadOddButton,
                  eventName: "switchspreadmode",
                  eventDetails: {
                    mode: _ui_utils.SpreadMode.ODD
                  },
                  close: true
                }, {
                  element: options.spreadEvenButton,
                  eventName: "switchspreadmode",
                  eventDetails: {
                    mode: _ui_utils.SpreadMode.EVEN
                  },
                  close: true
                }, {
                  element: options.documentPropertiesButton,
                  eventName: "documentproperties",
                  close: true
                }];
                this.items = {
                  firstPage: options.firstPageButton,
                  lastPage: options.lastPageButton,
                  pageRotateCw: options.pageRotateCwButton,
                  pageRotateCcw: options.pageRotateCcwButton
                };
                this.mainContainer = mainContainer;
                this.eventBus = eventBus;
                this.opened = false;
                this.containerHeight = null;
                this.previousContainerHeight = null;
                this.reset();
                this._bindClickListeners();
                this._bindCursorToolsListener(options);
                this._bindScrollModeListener(options);
                this._bindSpreadModeListener(options);
                this.eventBus._on("resize", this._setMaxHeight.bind(this));
                this.eventBus._on("baseviewerinit", (evt) => {
                  if (evt.source instanceof _pdf_single_page_viewer.PDFSinglePageViewer) {
                    this.toolbarButtonContainer.classList.add("hiddenScrollModeButtons", "hiddenSpreadModeButtons");
                  } else {
                    this.toolbarButtonContainer.classList.remove("hiddenScrollModeButtons", "hiddenSpreadModeButtons");
                  }
                });
              }
              get isOpen() {
                return this.opened;
              }
              setPageNumber(pageNumber) {
                this.pageNumber = pageNumber;
                this._updateUIState();
              }
              setPagesCount(pagesCount) {
                this.pagesCount = pagesCount;
                this._updateUIState();
              }
              reset() {
                this.pageNumber = 0;
                this.pagesCount = 0;
                this._updateUIState();
                this.eventBus.dispatch("secondarytoolbarreset", {
                  source: this
                });
              }
              _updateUIState() {
                this.items.firstPage.disabled = this.pageNumber <= 1;
                this.items.lastPage.disabled = this.pageNumber >= this.pagesCount;
                this.items.pageRotateCw.disabled = this.pagesCount === 0;
                this.items.pageRotateCcw.disabled = this.pagesCount === 0;
              }
              _bindClickListeners() {
                this.toggleButton.addEventListener("click", this.toggle.bind(this));
                for (const {
                  element,
                  eventName,
                  close,
                  eventDetails
                } of this.buttons) {
                  element.addEventListener("click", (evt) => {
                    if (eventName !== null) {
                      const details = {
                        source: this
                      };
                      for (const property in eventDetails) {
                        details[property] = eventDetails[property];
                      }
                      this.eventBus.dispatch(eventName, details);
                    }
                    if (close) {
                      this.close();
                    }
                  });
                }
              }
              _bindCursorToolsListener(buttons) {
                this.eventBus._on("cursortoolchanged", function({
                  tool
                }) {
                  buttons.cursorSelectToolButton.classList.toggle("toggled", tool === _pdf_cursor_tools.CursorTool.SELECT);
                  buttons.cursorHandToolButton.classList.toggle("toggled", tool === _pdf_cursor_tools.CursorTool.HAND);
                });
              }
              _bindScrollModeListener(buttons) {
                function scrollModeChanged({
                  mode
                }) {
                  buttons.scrollVerticalButton.classList.toggle("toggled", mode === _ui_utils.ScrollMode.VERTICAL);
                  buttons.scrollHorizontalButton.classList.toggle("toggled", mode === _ui_utils.ScrollMode.HORIZONTAL);
                  buttons.scrollWrappedButton.classList.toggle("toggled", mode === _ui_utils.ScrollMode.WRAPPED);
                  const isScrollModeHorizontal = mode === _ui_utils.ScrollMode.HORIZONTAL;
                  buttons.spreadNoneButton.disabled = isScrollModeHorizontal;
                  buttons.spreadOddButton.disabled = isScrollModeHorizontal;
                  buttons.spreadEvenButton.disabled = isScrollModeHorizontal;
                }
                this.eventBus._on("scrollmodechanged", scrollModeChanged);
                this.eventBus._on("secondarytoolbarreset", (evt) => {
                  if (evt.source === this) {
                    scrollModeChanged({
                      mode: _ui_utils.ScrollMode.VERTICAL
                    });
                  }
                });
              }
              _bindSpreadModeListener(buttons) {
                function spreadModeChanged({
                  mode
                }) {
                  buttons.spreadNoneButton.classList.toggle("toggled", mode === _ui_utils.SpreadMode.NONE);
                  buttons.spreadOddButton.classList.toggle("toggled", mode === _ui_utils.SpreadMode.ODD);
                  buttons.spreadEvenButton.classList.toggle("toggled", mode === _ui_utils.SpreadMode.EVEN);
                }
                this.eventBus._on("spreadmodechanged", spreadModeChanged);
                this.eventBus._on("secondarytoolbarreset", (evt) => {
                  if (evt.source === this) {
                    spreadModeChanged({
                      mode: _ui_utils.SpreadMode.NONE
                    });
                  }
                });
              }
              open() {
                if (this.opened) {
                  return;
                }
                this.opened = true;
                this._setMaxHeight();
                this.toggleButton.classList.add("toggled");
                this.toolbar.classList.remove("hidden");
              }
              close() {
                if (!this.opened) {
                  return;
                }
                this.opened = false;
                this.toolbar.classList.add("hidden");
                this.toggleButton.classList.remove("toggled");
              }
              toggle() {
                if (this.opened) {
                  this.close();
                } else {
                  this.open();
                }
              }
              _setMaxHeight() {
                if (!this.opened) {
                  return;
                }
                this.containerHeight = this.mainContainer.clientHeight;
                if (this.containerHeight === this.previousContainerHeight) {
                  return;
                }
                this.toolbarButtonContainer.style.maxHeight = `${this.containerHeight - _ui_utils.SCROLLBAR_PADDING}px`;
                this.previousContainerHeight = this.containerHeight;
              }
            }
            exports2.SecondaryToolbar = SecondaryToolbar;
          },
          5645: function(__unused_webpack_module2, exports2, __webpack_require__2) {
            "use strict";
            __webpack_require__2(7658);
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.DefaultTextLayerFactory = exports2.TextLayerBuilder = void 0;
            var _ui_utils = __webpack_require__2(5570);
            var _pdf = __webpack_require__2(3941);
            const EXPAND_DIVS_TIMEOUT = 300;
            class TextLayerBuilder {
              constructor({
                textLayerDiv,
                eventBus,
                pageIndex,
                viewport,
                findController = null,
                enhanceTextSelection = false
              }) {
                this.textLayerDiv = textLayerDiv;
                this.eventBus = eventBus || (0, _ui_utils.getGlobalEventBus)();
                this.textContent = null;
                this.textContentItemsStr = [];
                this.textContentStream = null;
                this.renderingDone = false;
                this.pageIdx = pageIndex;
                this.pageNumber = this.pageIdx + 1;
                this.matches = [];
                this.viewport = viewport;
                this.textDivs = [];
                this.findController = findController;
                this.textLayerRenderTask = null;
                this.enhanceTextSelection = enhanceTextSelection;
                this._onUpdateTextLayerMatches = null;
                this._bindMouse();
              }
              _finishRendering() {
                this.renderingDone = true;
                if (!this.enhanceTextSelection) {
                  const endOfContent = document.createElement("div");
                  endOfContent.className = "endOfContent";
                  this.textLayerDiv.appendChild(endOfContent);
                }
                this.eventBus.dispatch("textlayerrendered", {
                  source: this,
                  pageNumber: this.pageNumber,
                  numTextDivs: this.textDivs.length
                });
              }
              render(timeout = 0) {
                if (!(this.textContent || this.textContentStream) || this.renderingDone) {
                  return;
                }
                this.cancel();
                this.textDivs = [];
                const textLayerFrag = document.createDocumentFragment();
                this.textLayerRenderTask = (0, _pdf.renderTextLayer)({
                  textContent: this.textContent,
                  textContentStream: this.textContentStream,
                  container: textLayerFrag,
                  viewport: this.viewport,
                  textDivs: this.textDivs,
                  textContentItemsStr: this.textContentItemsStr,
                  timeout,
                  enhanceTextSelection: this.enhanceTextSelection
                });
                this.textLayerRenderTask.promise.then(() => {
                  this.textLayerDiv.appendChild(textLayerFrag);
                  this._finishRendering();
                  this._updateMatches();
                }, function(reason) {
                });
                if (!this._onUpdateTextLayerMatches) {
                  this._onUpdateTextLayerMatches = (evt) => {
                    if (evt.pageIndex === this.pageIdx || evt.pageIndex === -1) {
                      this._updateMatches();
                    }
                  };
                  this.eventBus._on("updatetextlayermatches", this._onUpdateTextLayerMatches);
                }
              }
              cancel() {
                if (this.textLayerRenderTask) {
                  this.textLayerRenderTask.cancel();
                  this.textLayerRenderTask = null;
                }
                if (this._onUpdateTextLayerMatches) {
                  this.eventBus._off("updatetextlayermatches", this._onUpdateTextLayerMatches);
                  this._onUpdateTextLayerMatches = null;
                }
              }
              setTextContentStream(readableStream) {
                this.cancel();
                this.textContentStream = readableStream;
              }
              setTextContent(textContent) {
                this.cancel();
                this.textContent = textContent;
              }
              _convertMatches(matches, matchesLength) {
                if (!matches) {
                  return [];
                }
                const {
                  findController,
                  textContentItemsStr
                } = this;
                let i = 0, iIndex = 0;
                const end = textContentItemsStr.length - 1;
                const queryLen = findController.state.query.length;
                const result = [];
                for (let m = 0, mm = matches.length; m < mm; m++) {
                  let matchIdx = matches[m];
                  while (i !== end && matchIdx >= iIndex + textContentItemsStr[i].length) {
                    iIndex += textContentItemsStr[i].length;
                    i++;
                  }
                  if (i === textContentItemsStr.length) {
                    console.error("Could not find a matching mapping");
                  }
                  const match = {
                    begin: {
                      divIdx: i,
                      offset: matchIdx - iIndex
                    }
                  };
                  if (matchesLength) {
                    matchIdx += matchesLength[m];
                  } else {
                    matchIdx += queryLen;
                  }
                  while (i !== end && matchIdx > iIndex + textContentItemsStr[i].length) {
                    iIndex += textContentItemsStr[i].length;
                    i++;
                  }
                  match.end = {
                    divIdx: i,
                    offset: matchIdx - iIndex
                  };
                  result.push(match);
                }
                return result;
              }
              _renderMatches(matches) {
                if (matches.length === 0) {
                  return;
                }
                const {
                  findController,
                  pageIdx,
                  textContentItemsStr,
                  textDivs
                } = this;
                const isSelectedPage = pageIdx === findController.selected.pageIdx;
                const selectedMatchIdx = findController.selected.matchIdx;
                const highlightAll = findController.state.highlightAll;
                let prevEnd = null;
                const infinity = {
                  divIdx: -1,
                  offset: void 0
                };
                function beginText(begin, className) {
                  const divIdx = begin.divIdx;
                  textDivs[divIdx].textContent = "";
                  appendTextToDiv(divIdx, 0, begin.offset, className);
                }
                function appendTextToDiv(divIdx, fromOffset, toOffset, className) {
                  const div = textDivs[divIdx];
                  const content = textContentItemsStr[divIdx].substring(fromOffset, toOffset);
                  const node = document.createTextNode(content);
                  if (className) {
                    const span = document.createElement("span");
                    span.className = className;
                    span.appendChild(node);
                    div.appendChild(span);
                    return;
                  }
                  div.appendChild(node);
                }
                let i0 = selectedMatchIdx, i1 = i0 + 1;
                if (highlightAll) {
                  i0 = 0;
                  i1 = matches.length;
                } else if (!isSelectedPage) {
                  return;
                }
                for (let i = i0; i < i1; i++) {
                  const match = matches[i];
                  const begin = match.begin;
                  const end = match.end;
                  const isSelected = isSelectedPage && i === selectedMatchIdx;
                  const highlightSuffix = isSelected ? " selected" : "";
                  if (isSelected) {
                    findController.scrollMatchIntoView({
                      element: textDivs[begin.divIdx],
                      pageIndex: pageIdx,
                      matchIndex: selectedMatchIdx
                    });
                  }
                  if (!prevEnd || begin.divIdx !== prevEnd.divIdx) {
                    if (prevEnd !== null) {
                      appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset);
                    }
                    beginText(begin);
                  } else {
                    appendTextToDiv(prevEnd.divIdx, prevEnd.offset, begin.offset);
                  }
                  if (begin.divIdx === end.divIdx) {
                    appendTextToDiv(begin.divIdx, begin.offset, end.offset, "highlight" + highlightSuffix);
                  } else {
                    appendTextToDiv(begin.divIdx, begin.offset, infinity.offset, "highlight begin" + highlightSuffix);
                    for (let n0 = begin.divIdx + 1, n1 = end.divIdx; n0 < n1; n0++) {
                      textDivs[n0].className = "highlight middle" + highlightSuffix;
                    }
                    beginText(end, "highlight end" + highlightSuffix);
                  }
                  prevEnd = end;
                }
                if (prevEnd) {
                  appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset);
                }
              }
              _updateMatches() {
                if (!this.renderingDone) {
                  return;
                }
                const {
                  findController,
                  matches,
                  pageIdx,
                  textContentItemsStr,
                  textDivs
                } = this;
                let clearedUntilDivIdx = -1;
                for (let i = 0, ii = matches.length; i < ii; i++) {
                  const match = matches[i];
                  const begin = Math.max(clearedUntilDivIdx, match.begin.divIdx);
                  for (let n = begin, end = match.end.divIdx; n <= end; n++) {
                    const div = textDivs[n];
                    div.textContent = textContentItemsStr[n];
                    div.className = "";
                  }
                  clearedUntilDivIdx = match.end.divIdx + 1;
                }
                if (!findController || !findController.highlightMatches) {
                  return;
                }
                const pageMatches = findController.pageMatches[pageIdx] || null;
                const pageMatchesLength = findController.pageMatchesLength[pageIdx] || null;
                this.matches = this._convertMatches(pageMatches, pageMatchesLength);
                this._renderMatches(this.matches);
              }
              _bindMouse() {
                const div = this.textLayerDiv;
                let expandDivsTimer = null;
                div.addEventListener("mousedown", (evt) => {
                  if (this.enhanceTextSelection && this.textLayerRenderTask) {
                    this.textLayerRenderTask.expandTextDivs(true);
                    if (expandDivsTimer) {
                      clearTimeout(expandDivsTimer);
                      expandDivsTimer = null;
                    }
                    return;
                  }
                  const end = div.querySelector(".endOfContent");
                  if (!end) {
                    return;
                  }
                  let adjustTop = evt.target !== div;
                  adjustTop = adjustTop && window.getComputedStyle(end).getPropertyValue("-moz-user-select") !== "none";
                  if (adjustTop) {
                    const divBounds = div.getBoundingClientRect();
                    const r = Math.max(0, (evt.pageY - divBounds.top) / divBounds.height);
                    end.style.top = (r * 100).toFixed(2) + "%";
                  }
                  end.classList.add("active");
                });
                div.addEventListener("mouseup", () => {
                  if (this.enhanceTextSelection && this.textLayerRenderTask) {
                    expandDivsTimer = setTimeout(() => {
                      if (this.textLayerRenderTask) {
                        this.textLayerRenderTask.expandTextDivs(false);
                      }
                      expandDivsTimer = null;
                    }, EXPAND_DIVS_TIMEOUT);
                    return;
                  }
                  const end = div.querySelector(".endOfContent");
                  if (!end) {
                    return;
                  }
                  end.style.top = "";
                  end.classList.remove("active");
                });
              }
            }
            exports2.TextLayerBuilder = TextLayerBuilder;
            class DefaultTextLayerFactory {
              createTextLayerBuilder(textLayerDiv, pageIndex, viewport, enhanceTextSelection = false, eventBus) {
                return new TextLayerBuilder({
                  textLayerDiv,
                  pageIndex,
                  viewport,
                  enhanceTextSelection,
                  eventBus
                });
              }
            }
            exports2.DefaultTextLayerFactory = DefaultTextLayerFactory;
          },
          7637: function(__unused_webpack_module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.Toolbar = void 0;
            var _ui_utils = __webpack_require__2(5570);
            const PAGE_NUMBER_LOADING_INDICATOR = "visiblePageIsLoading";
            const SCALE_SELECT_CONTAINER_WIDTH = 140;
            const SCALE_SELECT_WIDTH = 162;
            class Toolbar {
              constructor(options, eventBus, l10n = _ui_utils.NullL10n) {
                this.toolbar = options.container;
                this.eventBus = eventBus;
                this.l10n = l10n;
                this.buttons = [{
                  element: options.previous,
                  eventName: "previouspage"
                }, {
                  element: options.next,
                  eventName: "nextpage"
                }, {
                  element: options.zoomIn,
                  eventName: "zoomin"
                }, {
                  element: options.zoomOut,
                  eventName: "zoomout"
                }, {
                  element: options.openFile,
                  eventName: "openfile"
                }, {
                  element: options.print,
                  eventName: "print"
                }, {
                  element: options.presentationModeButton,
                  eventName: "presentationmode"
                }, {
                  element: options.download,
                  eventName: "download"
                }, {
                  element: options.viewBookmark,
                  eventName: null
                }];
                this.items = {
                  numPages: options.numPages,
                  pageNumber: options.pageNumber,
                  scaleSelectContainer: options.scaleSelectContainer,
                  scaleSelect: options.scaleSelect,
                  customScaleOption: options.customScaleOption,
                  previous: options.previous,
                  next: options.next,
                  zoomIn: options.zoomIn,
                  zoomOut: options.zoomOut
                };
                this._wasLocalized = false;
                this.reset();
                this._bindListeners();
              }
              setPageNumber(pageNumber, pageLabel) {
                this.pageNumber = pageNumber;
                this.pageLabel = pageLabel;
                this._updateUIState(false);
              }
              setPagesCount(pagesCount, hasPageLabels) {
                this.pagesCount = pagesCount;
                this.hasPageLabels = hasPageLabels;
                this._updateUIState(true);
              }
              setPageScale(pageScaleValue, pageScale) {
                this.pageScaleValue = (pageScaleValue || pageScale).toString();
                this.pageScale = pageScale;
                this._updateUIState(false);
              }
              reset() {
                this.pageNumber = 0;
                this.pageLabel = null;
                this.hasPageLabels = false;
                this.pagesCount = 0;
                this.pageScaleValue = _ui_utils.DEFAULT_SCALE_VALUE;
                this.pageScale = _ui_utils.DEFAULT_SCALE;
                this._updateUIState(true);
                this.updateLoadingIndicatorState();
              }
              _bindListeners() {
                const {
                  pageNumber,
                  scaleSelect
                } = this.items;
                const self2 = this;
                for (const {
                  element,
                  eventName
                } of this.buttons) {
                  element.addEventListener("click", (evt) => {
                    if (eventName !== null) {
                      this.eventBus.dispatch(eventName, {
                        source: this
                      });
                    }
                  });
                }
                pageNumber.addEventListener("click", function() {
                  this.select();
                });
                pageNumber.addEventListener("change", function() {
                  self2.eventBus.dispatch("pagenumberchanged", {
                    source: self2,
                    value: this.value
                  });
                });
                scaleSelect.addEventListener("change", function() {
                  if (this.value === "custom") {
                    return;
                  }
                  self2.eventBus.dispatch("scalechanged", {
                    source: self2,
                    value: this.value
                  });
                });
                scaleSelect.oncontextmenu = _ui_utils.noContextMenuHandler;
                this.eventBus._on("localized", () => {
                  this._wasLocalized = true;
                  this._adjustScaleWidth();
                  this._updateUIState(true);
                });
              }
              _updateUIState(resetNumPages = false) {
                if (!this._wasLocalized) {
                  return;
                }
                const {
                  pageNumber,
                  pagesCount,
                  pageScaleValue,
                  pageScale,
                  items
                } = this;
                if (resetNumPages) {
                  if (this.hasPageLabels) {
                    items.pageNumber.type = "text";
                  } else {
                    items.pageNumber.type = "number";
                    this.l10n.get("of_pages", {
                      pagesCount
                    }, "of {{pagesCount}}").then((msg) => {
                      items.numPages.textContent = msg;
                    });
                  }
                  items.pageNumber.max = pagesCount;
                }
                if (this.hasPageLabels) {
                  items.pageNumber.value = this.pageLabel;
                  this.l10n.get("page_of_pages", {
                    pageNumber,
                    pagesCount
                  }, "({{pageNumber}} of {{pagesCount}})").then((msg) => {
                    items.numPages.textContent = msg;
                  });
                } else {
                  items.pageNumber.value = pageNumber;
                }
                items.previous.disabled = pageNumber <= 1;
                items.next.disabled = pageNumber >= pagesCount;
                items.zoomOut.disabled = pageScale <= _ui_utils.MIN_SCALE;
                items.zoomIn.disabled = pageScale >= _ui_utils.MAX_SCALE;
                const customScale = Math.round(pageScale * 1e4) / 100;
                this.l10n.get("page_scale_percent", {
                  scale: customScale
                }, "{{scale}}%").then((msg) => {
                  let predefinedValueFound = false;
                  for (const option of items.scaleSelect.options) {
                    if (option.value !== pageScaleValue) {
                      option.selected = false;
                      continue;
                    }
                    option.selected = true;
                    predefinedValueFound = true;
                  }
                  if (!predefinedValueFound) {
                    items.customScaleOption.textContent = msg;
                    items.customScaleOption.selected = true;
                  }
                });
              }
              updateLoadingIndicatorState(loading = false) {
                const pageNumberInput = this.items.pageNumber;
                pageNumberInput.classList.toggle(PAGE_NUMBER_LOADING_INDICATOR, loading);
              }
              async _adjustScaleWidth() {
                const {
                  items,
                  l10n
                } = this;
                const predefinedValuesPromise = Promise.all([l10n.get("page_scale_auto", null, "Automatic Zoom"), l10n.get("page_scale_actual", null, "Actual Size"), l10n.get("page_scale_fit", null, "Page Fit"), l10n.get("page_scale_width", null, "Page Width")]);
                let canvas = document.createElement("canvas");
                canvas.mozOpaque = true;
                let ctx = canvas.getContext("2d", {
                  alpha: false
                });
                await _ui_utils.animationStarted;
                const {
                  fontSize,
                  fontFamily
                } = getComputedStyle(items.scaleSelect);
                ctx.font = `${fontSize} ${fontFamily}`;
                let maxWidth = 0;
                for (const predefinedValue of await predefinedValuesPromise) {
                  const {
                    width
                  } = ctx.measureText(predefinedValue);
                  if (width > maxWidth) {
                    maxWidth = width;
                  }
                }
                const overflow = SCALE_SELECT_WIDTH - SCALE_SELECT_CONTAINER_WIDTH;
                maxWidth += 1.5 * overflow;
                if (maxWidth > SCALE_SELECT_CONTAINER_WIDTH) {
                  items.scaleSelect.style.width = `${maxWidth + overflow}px`;
                  items.scaleSelectContainer.style.width = `${maxWidth}px`;
                }
                canvas.width = 0;
                canvas.height = 0;
                canvas = ctx = null;
              }
            }
            exports2.Toolbar = Toolbar;
          },
          5570: function(__unused_webpack_module2, exports2, __webpack_require__2) {
            "use strict";
            __webpack_require__2(7658);
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.isValidRotation = isValidRotation;
            exports2.isValidScrollMode = isValidScrollMode;
            exports2.isValidSpreadMode = isValidSpreadMode;
            exports2.isPortraitOrientation = isPortraitOrientation;
            exports2.getGlobalEventBus = getGlobalEventBus;
            exports2.clamp = clamp;
            exports2.getPDFFileNameFromURL = getPDFFileNameFromURL;
            exports2.noContextMenuHandler = noContextMenuHandler;
            exports2.parseQueryString = parseQueryString;
            exports2.backtrackBeforeAllVisibleElements = backtrackBeforeAllVisibleElements;
            exports2.getVisibleElements = getVisibleElements;
            exports2.roundToDivide = roundToDivide;
            exports2.getPageSizeInches = getPageSizeInches;
            exports2.approximateFraction = approximateFraction;
            exports2.getOutputScale = getOutputScale;
            exports2.scrollIntoView = scrollIntoView;
            exports2.watchScroll = watchScroll;
            exports2.binarySearchFirstItem = binarySearchFirstItem;
            exports2.normalizeWheelEventDelta = normalizeWheelEventDelta;
            exports2.waitOnEventOrTimeout = waitOnEventOrTimeout;
            exports2.moveToEndOfArray = moveToEndOfArray;
            exports2.WaitOnType = exports2.animationStarted = exports2.ProgressBar = exports2.EventBus = exports2.NullL10n = exports2.SpreadMode = exports2.ScrollMode = exports2.TextLayerMode = exports2.RendererType = exports2.PresentationModeState = exports2.VERTICAL_PADDING = exports2.SCROLLBAR_PADDING = exports2.MAX_AUTO_SCALE = exports2.UNKNOWN_SCALE = exports2.MAX_SCALE = exports2.MIN_SCALE = exports2.DEFAULT_SCALE = exports2.DEFAULT_SCALE_VALUE = exports2.CSS_UNITS = exports2.AutoPrintRegExp = void 0;
            const CSS_UNITS = 96 / 72;
            exports2.CSS_UNITS = CSS_UNITS;
            const DEFAULT_SCALE_VALUE = "auto";
            exports2.DEFAULT_SCALE_VALUE = DEFAULT_SCALE_VALUE;
            const DEFAULT_SCALE = 1;
            exports2.DEFAULT_SCALE = DEFAULT_SCALE;
            const MIN_SCALE = 0.1;
            exports2.MIN_SCALE = MIN_SCALE;
            const MAX_SCALE = 10;
            exports2.MAX_SCALE = MAX_SCALE;
            const UNKNOWN_SCALE = 0;
            exports2.UNKNOWN_SCALE = UNKNOWN_SCALE;
            const MAX_AUTO_SCALE = 1.25;
            exports2.MAX_AUTO_SCALE = MAX_AUTO_SCALE;
            const SCROLLBAR_PADDING = 40;
            exports2.SCROLLBAR_PADDING = SCROLLBAR_PADDING;
            const VERTICAL_PADDING = 5;
            exports2.VERTICAL_PADDING = VERTICAL_PADDING;
            const PresentationModeState = {
              UNKNOWN: 0,
              NORMAL: 1,
              CHANGING: 2,
              FULLSCREEN: 3
            };
            exports2.PresentationModeState = PresentationModeState;
            const RendererType = {
              CANVAS: "canvas",
              SVG: "svg"
            };
            exports2.RendererType = RendererType;
            const TextLayerMode = {
              DISABLE: 0,
              ENABLE: 1,
              ENABLE_ENHANCE: 2
            };
            exports2.TextLayerMode = TextLayerMode;
            const ScrollMode = {
              UNKNOWN: -1,
              VERTICAL: 0,
              HORIZONTAL: 1,
              WRAPPED: 2
            };
            exports2.ScrollMode = ScrollMode;
            const SpreadMode = {
              UNKNOWN: -1,
              NONE: 0,
              ODD: 1,
              EVEN: 2
            };
            exports2.SpreadMode = SpreadMode;
            const AutoPrintRegExp = /\bprint\s*\(/;
            exports2.AutoPrintRegExp = AutoPrintRegExp;
            function formatL10nValue(text, args) {
              if (!args) {
                return text;
              }
              return text.replace(/\{\{\s*(\w+)\s*\}\}/g, (all, name) => {
                return name in args ? args[name] : "{{" + name + "}}";
              });
            }
            const NullL10n = {
              async getLanguage() {
                return "en-us";
              },
              async getDirection() {
                return "ltr";
              },
              async get(property, args, fallback) {
                return formatL10nValue(fallback, args);
              },
              async translate(element) {
              }
            };
            exports2.NullL10n = NullL10n;
            function getOutputScale(ctx) {
              const devicePixelRatio = window.devicePixelRatio || 1;
              const backingStoreRatio = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;
              const pixelRatio = devicePixelRatio / backingStoreRatio;
              return {
                sx: pixelRatio,
                sy: pixelRatio,
                scaled: pixelRatio !== 1
              };
            }
            function scrollIntoView(element, spot, skipOverflowHiddenElements = false) {
              let parent = element.offsetParent;
              if (!parent) {
                console.error("offsetParent is not set -- cannot scroll");
                return;
              }
              let offsetY = element.offsetTop + element.clientTop;
              let offsetX = element.offsetLeft + element.clientLeft;
              while (parent.clientHeight === parent.scrollHeight && parent.clientWidth === parent.scrollWidth || skipOverflowHiddenElements && getComputedStyle(parent).overflow === "hidden") {
                if (parent.dataset._scaleY) {
                  offsetY /= parent.dataset._scaleY;
                  offsetX /= parent.dataset._scaleX;
                }
                offsetY += parent.offsetTop;
                offsetX += parent.offsetLeft;
                parent = parent.offsetParent;
                if (!parent) {
                  return;
                }
              }
              if (spot) {
                if (spot.top !== void 0) {
                  offsetY += spot.top;
                }
                if (spot.left !== void 0) {
                  offsetX += spot.left;
                  parent.scrollLeft = offsetX;
                }
              }
              parent.scrollTop = offsetY;
            }
            function watchScroll(viewAreaElement, callback) {
              const debounceScroll = function(evt) {
                if (rAF) {
                  return;
                }
                rAF = window.requestAnimationFrame(function viewAreaElementScrolled() {
                  rAF = null;
                  const currentX = viewAreaElement.scrollLeft;
                  const lastX = state.lastX;
                  if (currentX !== lastX) {
                    state.right = currentX > lastX;
                  }
                  state.lastX = currentX;
                  const currentY = viewAreaElement.scrollTop;
                  const lastY = state.lastY;
                  if (currentY !== lastY) {
                    state.down = currentY > lastY;
                  }
                  state.lastY = currentY;
                  callback(state);
                });
              };
              const state = {
                right: true,
                down: true,
                lastX: viewAreaElement.scrollLeft,
                lastY: viewAreaElement.scrollTop,
                _eventHandler: debounceScroll
              };
              let rAF = null;
              viewAreaElement.addEventListener("scroll", debounceScroll, true);
              return state;
            }
            function parseQueryString(query) {
              const parts = query.split("&");
              const params = /* @__PURE__ */ Object.create(null);
              for (let i = 0, ii = parts.length; i < ii; ++i) {
                const param = parts[i].split("=");
                const key = param[0].toLowerCase();
                const value = param.length > 1 ? param[1] : null;
                params[decodeURIComponent(key)] = decodeURIComponent(value);
              }
              return params;
            }
            function binarySearchFirstItem(items, condition) {
              let minIndex = 0;
              let maxIndex = items.length - 1;
              if (items.length === 0 || !condition(items[maxIndex])) {
                return items.length;
              }
              if (condition(items[minIndex])) {
                return minIndex;
              }
              while (minIndex < maxIndex) {
                const currentIndex = minIndex + maxIndex >> 1;
                const currentItem = items[currentIndex];
                if (condition(currentItem)) {
                  maxIndex = currentIndex;
                } else {
                  minIndex = currentIndex + 1;
                }
              }
              return minIndex;
            }
            function approximateFraction(x) {
              if (Math.floor(x) === x) {
                return [x, 1];
              }
              const xinv = 1 / x;
              const limit = 8;
              if (xinv > limit) {
                return [1, limit];
              } else if (Math.floor(xinv) === xinv) {
                return [1, xinv];
              }
              const x_ = x > 1 ? xinv : x;
              let a = 0, b = 1, c = 1, d = 1;
              while (true) {
                const p = a + c, q = b + d;
                if (q > limit) {
                  break;
                }
                if (x_ <= p / q) {
                  c = p;
                  d = q;
                } else {
                  a = p;
                  b = q;
                }
              }
              let result;
              if (x_ - a / b < c / d - x_) {
                result = x_ === x ? [a, b] : [b, a];
              } else {
                result = x_ === x ? [c, d] : [d, c];
              }
              return result;
            }
            function roundToDivide(x, div) {
              const r = x % div;
              return r === 0 ? x : Math.round(x - r + div);
            }
            function getPageSizeInches({
              view,
              userUnit,
              rotate
            }) {
              const [x1, y1, x2, y2] = view;
              const changeOrientation = rotate % 180 !== 0;
              const width = (x2 - x1) / 72 * userUnit;
              const height = (y2 - y1) / 72 * userUnit;
              return {
                width: changeOrientation ? height : width,
                height: changeOrientation ? width : height
              };
            }
            function backtrackBeforeAllVisibleElements(index, views, top) {
              if (index < 2) {
                return index;
              }
              let elt = views[index].div;
              let pageTop = elt.offsetTop + elt.clientTop;
              if (pageTop >= top) {
                elt = views[index - 1].div;
                pageTop = elt.offsetTop + elt.clientTop;
              }
              for (let i = index - 2; i >= 0; --i) {
                elt = views[i].div;
                if (elt.offsetTop + elt.clientTop + elt.clientHeight <= pageTop) {
                  break;
                }
                index = i;
              }
              return index;
            }
            function getVisibleElements(scrollEl, views, sortByVisibility = false, horizontal = false) {
              const top = scrollEl.scrollTop, bottom = top + scrollEl.clientHeight;
              const left = scrollEl.scrollLeft, right = left + scrollEl.clientWidth;
              function isElementBottomAfterViewTop(view) {
                const element = view.div;
                const elementBottom = element.offsetTop + element.clientTop + element.clientHeight;
                return elementBottom > top;
              }
              function isElementRightAfterViewLeft(view) {
                const element = view.div;
                const elementRight = element.offsetLeft + element.clientLeft + element.clientWidth;
                return elementRight > left;
              }
              const visible = [], numViews = views.length;
              let firstVisibleElementInd = numViews === 0 ? 0 : binarySearchFirstItem(views, horizontal ? isElementRightAfterViewLeft : isElementBottomAfterViewTop);
              if (firstVisibleElementInd > 0 && firstVisibleElementInd < numViews && !horizontal) {
                firstVisibleElementInd = backtrackBeforeAllVisibleElements(firstVisibleElementInd, views, top);
              }
              let lastEdge = horizontal ? right : -1;
              for (let i = firstVisibleElementInd; i < numViews; i++) {
                const view = views[i], element = view.div;
                const currentWidth = element.offsetLeft + element.clientLeft;
                const currentHeight = element.offsetTop + element.clientTop;
                const viewWidth = element.clientWidth, viewHeight = element.clientHeight;
                const viewRight = currentWidth + viewWidth;
                const viewBottom = currentHeight + viewHeight;
                if (lastEdge === -1) {
                  if (viewBottom >= bottom) {
                    lastEdge = viewBottom;
                  }
                } else if ((horizontal ? currentWidth : currentHeight) > lastEdge) {
                  break;
                }
                if (viewBottom <= top || currentHeight >= bottom || viewRight <= left || currentWidth >= right) {
                  continue;
                }
                const hiddenHeight = Math.max(0, top - currentHeight) + Math.max(0, viewBottom - bottom);
                const hiddenWidth = Math.max(0, left - currentWidth) + Math.max(0, viewRight - right);
                const percent = (viewHeight - hiddenHeight) * (viewWidth - hiddenWidth) * 100 / viewHeight / viewWidth | 0;
                visible.push({
                  id: view.id,
                  x: currentWidth,
                  y: currentHeight,
                  view,
                  percent
                });
              }
              const first = visible[0], last = visible[visible.length - 1];
              if (sortByVisibility) {
                visible.sort(function(a, b) {
                  const pc = a.percent - b.percent;
                  if (Math.abs(pc) > 1e-3) {
                    return -pc;
                  }
                  return a.id - b.id;
                });
              }
              return {
                first,
                last,
                views: visible
              };
            }
            function noContextMenuHandler(evt) {
              evt.preventDefault();
            }
            function isDataSchema(url) {
              let i = 0;
              const ii = url.length;
              while (i < ii && url[i].trim() === "") {
                i++;
              }
              return url.substring(i, i + 5).toLowerCase() === "data:";
            }
            function getPDFFileNameFromURL(url, defaultFilename = "document.pdf") {
              if (typeof url !== "string") {
                return defaultFilename;
              }
              if (isDataSchema(url)) {
                console.warn('getPDFFileNameFromURL: ignoring "data:" URL for performance reasons.');
                return defaultFilename;
              }
              const reURI = /^(?:(?:[^:]+:)?\/\/[^\/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/;
              const reFilename = /[^\/?#=]+\.pdf\b(?!.*\.pdf\b)/i;
              const splitURI = reURI.exec(url);
              let suggestedFilename = reFilename.exec(splitURI[1]) || reFilename.exec(splitURI[2]) || reFilename.exec(splitURI[3]);
              if (suggestedFilename) {
                suggestedFilename = suggestedFilename[0];
                if (suggestedFilename.includes("%")) {
                  try {
                    suggestedFilename = reFilename.exec(decodeURIComponent(suggestedFilename))[0];
                  } catch (ex) {
                  }
                }
              }
              return suggestedFilename || defaultFilename;
            }
            function normalizeWheelEventDelta(evt) {
              let delta = Math.sqrt(evt.deltaX * evt.deltaX + evt.deltaY * evt.deltaY);
              const angle = Math.atan2(evt.deltaY, evt.deltaX);
              if (-0.25 * Math.PI < angle && angle < 0.75 * Math.PI) {
                delta = -delta;
              }
              const MOUSE_DOM_DELTA_PIXEL_MODE = 0;
              const MOUSE_DOM_DELTA_LINE_MODE = 1;
              const MOUSE_PIXELS_PER_LINE = 30;
              const MOUSE_LINES_PER_PAGE = 30;
              if (evt.deltaMode === MOUSE_DOM_DELTA_PIXEL_MODE) {
                delta /= MOUSE_PIXELS_PER_LINE * MOUSE_LINES_PER_PAGE;
              } else if (evt.deltaMode === MOUSE_DOM_DELTA_LINE_MODE) {
                delta /= MOUSE_LINES_PER_PAGE;
              }
              return delta;
            }
            function isValidRotation(angle) {
              return Number.isInteger(angle) && angle % 90 === 0;
            }
            function isValidScrollMode(mode) {
              return Number.isInteger(mode) && Object.values(ScrollMode).includes(mode) && mode !== ScrollMode.UNKNOWN;
            }
            function isValidSpreadMode(mode) {
              return Number.isInteger(mode) && Object.values(SpreadMode).includes(mode) && mode !== SpreadMode.UNKNOWN;
            }
            function isPortraitOrientation(size) {
              return size.width <= size.height;
            }
            const WaitOnType = {
              EVENT: "event",
              TIMEOUT: "timeout"
            };
            exports2.WaitOnType = WaitOnType;
            function waitOnEventOrTimeout({
              target,
              name,
              delay = 0
            }) {
              return new Promise(function(resolve, reject) {
                if (typeof target !== "object" || !(name && typeof name === "string") || !(Number.isInteger(delay) && delay >= 0)) {
                  throw new Error("waitOnEventOrTimeout - invalid parameters.");
                }
                function handler(type) {
                  if (target instanceof EventBus) {
                    target._off(name, eventHandler);
                  } else {
                    target.removeEventListener(name, eventHandler);
                  }
                  if (timeout) {
                    clearTimeout(timeout);
                  }
                  resolve(type);
                }
                const eventHandler = handler.bind(null, WaitOnType.EVENT);
                if (target instanceof EventBus) {
                  target._on(name, eventHandler);
                } else {
                  target.addEventListener(name, eventHandler);
                }
                const timeoutHandler = handler.bind(null, WaitOnType.TIMEOUT);
                const timeout = setTimeout(timeoutHandler, delay);
              });
            }
            const animationStarted = new Promise(function(resolve) {
              window.requestAnimationFrame(resolve);
            });
            exports2.animationStarted = animationStarted;
            function dispatchDOMEvent(eventName, args = null) {
              const details = /* @__PURE__ */ Object.create(null);
              if (args && args.length > 0) {
                const obj = args[0];
                for (const key in obj) {
                  const value = obj[key];
                  if (key === "source") {
                    if (value === window || value === document) {
                      return;
                    }
                    continue;
                  }
                  details[key] = value;
                }
              }
              const event = document.createEvent("CustomEvent");
              event.initCustomEvent(eventName, true, true, details);
              document.dispatchEvent(event);
            }
            class EventBus {
              constructor({
                dispatchToDOM = false
              } = {}) {
                this._listeners = /* @__PURE__ */ Object.create(null);
                this._dispatchToDOM = dispatchToDOM === true;
                if (dispatchToDOM) {
                  console.error("The `eventBusDispatchToDOM` option/preference is deprecated, add event listeners to the EventBus instance rather than the DOM.");
                }
              }
              on(eventName, listener) {
                this._on(eventName, listener, {
                  external: true
                });
              }
              off(eventName, listener) {
                this._off(eventName, listener, {
                  external: true
                });
              }
              dispatch(eventName) {
                const eventListeners = this._listeners[eventName];
                if (!eventListeners || eventListeners.length === 0) {
                  if (this._dispatchToDOM) {
                    const args2 = Array.prototype.slice.call(arguments, 1);
                    dispatchDOMEvent(eventName, args2);
                  }
                  return;
                }
                const args = Array.prototype.slice.call(arguments, 1);
                let externalListeners;
                eventListeners.slice(0).forEach(function({
                  listener,
                  external
                }) {
                  if (external) {
                    if (!externalListeners) {
                      externalListeners = [];
                    }
                    externalListeners.push(listener);
                    return;
                  }
                  listener.apply(null, args);
                });
                if (externalListeners) {
                  externalListeners.forEach(function(listener) {
                    listener.apply(null, args);
                  });
                  externalListeners = null;
                }
                if (this._dispatchToDOM) {
                  dispatchDOMEvent(eventName, args);
                }
              }
              _on(eventName, listener, options = null) {
                let eventListeners = this._listeners[eventName];
                if (!eventListeners) {
                  this._listeners[eventName] = eventListeners = [];
                }
                eventListeners.push({
                  listener,
                  external: (options && options.external) === true
                });
              }
              _off(eventName, listener, options = null) {
                const eventListeners = this._listeners[eventName];
                if (!eventListeners) {
                  return;
                }
                for (let i = 0, ii = eventListeners.length; i < ii; i++) {
                  if (eventListeners[i].listener === listener) {
                    eventListeners.splice(i, 1);
                    return;
                  }
                }
              }
            }
            exports2.EventBus = EventBus;
            let globalEventBus = null;
            function getGlobalEventBus(dispatchToDOM = false) {
              console.error("getGlobalEventBus is deprecated, use a manually created EventBus instance instead.");
              if (!globalEventBus) {
                globalEventBus = new EventBus({
                  dispatchToDOM
                });
              }
              return globalEventBus;
            }
            function clamp(v, min, max) {
              return Math.min(Math.max(v, min), max);
            }
            class ProgressBar {
              constructor(id, {
                height,
                width,
                units
              } = {}) {
                this.visible = true;
                this.div = document.querySelector(id + " .progress");
                this.bar = this.div.parentNode;
                this.height = height || 100;
                this.width = width || 100;
                this.units = units || "%";
                this.div.style.height = this.height + this.units;
                this.percent = 0;
              }
              _updateBar() {
                if (this._indeterminate) {
                  this.div.classList.add("indeterminate");
                  this.div.style.width = this.width + this.units;
                  return;
                }
                this.div.classList.remove("indeterminate");
                const progressSize = this.width * this._percent / 100;
                this.div.style.width = progressSize + this.units;
              }
              get percent() {
                return this._percent;
              }
              set percent(val) {
                this._indeterminate = isNaN(val);
                this._percent = clamp(val, 0, 100);
                this._updateBar();
              }
              setWidth(viewer) {
                if (!viewer) {
                  return;
                }
                const container = viewer.parentNode;
                const scrollbarWidth = container.offsetWidth - viewer.offsetWidth;
                if (scrollbarWidth > 0) {
                  this.bar.style.width = `calc(100% - ${scrollbarWidth}px)`;
                }
              }
              hide() {
                if (!this.visible) {
                  return;
                }
                this.visible = false;
                this.bar.classList.add("hidden");
                document.body.classList.remove("loadingInProgress");
              }
              show() {
                if (this.visible) {
                  return;
                }
                this.visible = true;
                document.body.classList.add("loadingInProgress");
                this.bar.classList.remove("hidden");
              }
            }
            exports2.ProgressBar = ProgressBar;
            function moveToEndOfArray(arr, condition) {
              const moved = [], len = arr.length;
              let write = 0;
              for (let read = 0; read < len; ++read) {
                if (condition(arr[read])) {
                  moved.push(arr[read]);
                } else {
                  arr[write] = arr[read];
                  ++write;
                }
              }
              for (let read = 0; write < len; ++read, ++write) {
                arr[write] = moved[read];
              }
            }
          },
          9361: function(__unused_webpack_module2, exports2, __webpack_require__2) {
            "use strict";
            __webpack_require__2(7658);
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.ViewHistory = void 0;
            const DEFAULT_VIEW_HISTORY_CACHE_SIZE = 20;
            class ViewHistory {
              constructor(fingerprint, cacheSize = DEFAULT_VIEW_HISTORY_CACHE_SIZE) {
                this.fingerprint = fingerprint;
                this.cacheSize = cacheSize;
                this._initializedPromise = this._readFromStorage().then((databaseStr) => {
                  const database = JSON.parse(databaseStr || "{}");
                  if (!("files" in database)) {
                    database.files = [];
                  } else {
                    while (database.files.length >= this.cacheSize) {
                      database.files.shift();
                    }
                  }
                  let index = -1;
                  for (let i = 0, length = database.files.length; i < length; i++) {
                    const branch = database.files[i];
                    if (branch.fingerprint === this.fingerprint) {
                      index = i;
                      break;
                    }
                  }
                  if (index === -1) {
                    index = database.files.push({
                      fingerprint: this.fingerprint
                    }) - 1;
                  }
                  this.file = database.files[index];
                  this.database = database;
                });
              }
              async _writeToStorage() {
                const databaseStr = JSON.stringify(this.database);
                localStorage.setItem("pdfjs.history", databaseStr);
              }
              async _readFromStorage() {
                return localStorage.getItem("pdfjs.history");
              }
              async set(name, val) {
                await this._initializedPromise;
                this.file[name] = val;
                return this._writeToStorage();
              }
              async setMultiple(properties) {
                await this._initializedPromise;
                for (const name in properties) {
                  this.file[name] = properties[name];
                }
                return this._writeToStorage();
              }
              async get(name, defaultValue) {
                await this._initializedPromise;
                const val = this.file[name];
                return val !== void 0 ? val : defaultValue;
              }
              async getMultiple(properties) {
                await this._initializedPromise;
                const values = /* @__PURE__ */ Object.create(null);
                for (const name in properties) {
                  const val = this.file[name];
                  values[name] = val !== void 0 ? val : properties[name];
                }
                return values;
              }
            }
            exports2.ViewHistory = ViewHistory;
          },
          55: function(__unused_webpack_module2, exports2) {
            "use strict";
            const compatibilityParams = /* @__PURE__ */ Object.create(null);
            {
              const userAgent = typeof navigator !== "undefined" && navigator.userAgent || "";
              const platform = typeof navigator !== "undefined" && navigator.platform || "";
              const maxTouchPoints = typeof navigator !== "undefined" && navigator.maxTouchPoints || 1;
              const isAndroid = /Android/.test(userAgent);
              const isIOS = /\b(iPad|iPhone|iPod)(?=;)/.test(userAgent) || platform === "MacIntel" && maxTouchPoints > 1;
              (function checkCanvasSizeLimitation() {
                if (isIOS || isAndroid) {
                  compatibilityParams.maxCanvasPixels = 5242880;
                }
              })();
            }
            exports2.viewerCompatibilityParams = Object.freeze(compatibilityParams);
          },
          3744: function(__unused_webpack_module2, exports2) {
            "use strict";
            var __webpack_unused_export__;
            __webpack_unused_export__ = { value: true };
            exports2.Z = (sfc, props) => {
              const target = sfc.__vccOpts || sfc;
              for (const [key, val] of props) {
                target[key] = val;
              }
              return target;
            };
          },
          7652: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var content = __webpack_require__2(1208);
            if (content.__esModule)
              content = content.default;
            if (typeof content === "string")
              content = [[module2.id, content, ""]];
            if (content.locals)
              module2.exports = content.locals;
            var add = __webpack_require__2(4402).Z;
            var update = add("1695550f", content, true, { "sourceMap": false, "shadowMode": false });
          },
          9878: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var content = __webpack_require__2(7503);
            if (content.__esModule)
              content = content.default;
            if (typeof content === "string")
              content = [[module2.id, content, ""]];
            if (content.locals)
              module2.exports = content.locals;
            var add = __webpack_require__2(4402).Z;
            var update = add("64af901a", content, true, { "sourceMap": false, "shadowMode": false });
          },
          3162: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            var content = __webpack_require__2(9401);
            if (content.__esModule)
              content = content.default;
            if (typeof content === "string")
              content = [[module2.id, content, ""]];
            if (content.locals)
              module2.exports = content.locals;
            var add = __webpack_require__2(4402).Z;
            var update = add("5079849c", content, true, { "sourceMap": false, "shadowMode": false });
          },
          4402: function(__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) {
            "use strict";
            __webpack_require__2.d(__webpack_exports__2, {
              "Z": function() {
                return addStylesClient;
              }
            });
            ;
            function listToStyles(parentId, list) {
              var styles = [];
              var newStyles = {};
              for (var i = 0; i < list.length; i++) {
                var item = list[i];
                var id = item[0];
                var css = item[1];
                var media = item[2];
                var sourceMap = item[3];
                var part = {
                  id: parentId + ":" + i,
                  css,
                  media,
                  sourceMap
                };
                if (!newStyles[id]) {
                  styles.push(newStyles[id] = { id, parts: [part] });
                } else {
                  newStyles[id].parts.push(part);
                }
              }
              return styles;
            }
            ;
            var hasDocument = typeof document !== "undefined";
            if (typeof DEBUG !== "undefined" && DEBUG) {
              if (!hasDocument) {
                throw new Error(
                  "vue-style-loader cannot be used in a non-browser environment. Use { target: 'node' } in your Webpack config to indicate a server-rendering environment."
                );
              }
            }
            var stylesInDom = {};
            var head = hasDocument && (document.head || document.getElementsByTagName("head")[0]);
            var singletonElement = null;
            var singletonCounter = 0;
            var isProduction = false;
            var noop = function() {
            };
            var options = null;
            var ssrIdKey = "data-vue-ssr-id";
            var isOldIE = typeof navigator !== "undefined" && /msie [6-9]\b/.test(navigator.userAgent.toLowerCase());
            function addStylesClient(parentId, list, _isProduction, _options) {
              isProduction = _isProduction;
              options = _options || {};
              var styles = listToStyles(parentId, list);
              addStylesToDom(styles);
              return function update(newList) {
                var mayRemove = [];
                for (var i = 0; i < styles.length; i++) {
                  var item = styles[i];
                  var domStyle = stylesInDom[item.id];
                  domStyle.refs--;
                  mayRemove.push(domStyle);
                }
                if (newList) {
                  styles = listToStyles(parentId, newList);
                  addStylesToDom(styles);
                } else {
                  styles = [];
                }
                for (var i = 0; i < mayRemove.length; i++) {
                  var domStyle = mayRemove[i];
                  if (domStyle.refs === 0) {
                    for (var j = 0; j < domStyle.parts.length; j++) {
                      domStyle.parts[j]();
                    }
                    delete stylesInDom[domStyle.id];
                  }
                }
              };
            }
            function addStylesToDom(styles) {
              for (var i = 0; i < styles.length; i++) {
                var item = styles[i];
                var domStyle = stylesInDom[item.id];
                if (domStyle) {
                  domStyle.refs++;
                  for (var j = 0; j < domStyle.parts.length; j++) {
                    domStyle.parts[j](item.parts[j]);
                  }
                  for (; j < item.parts.length; j++) {
                    domStyle.parts.push(addStyle(item.parts[j]));
                  }
                  if (domStyle.parts.length > item.parts.length) {
                    domStyle.parts.length = item.parts.length;
                  }
                } else {
                  var parts = [];
                  for (var j = 0; j < item.parts.length; j++) {
                    parts.push(addStyle(item.parts[j]));
                  }
                  stylesInDom[item.id] = { id: item.id, refs: 1, parts };
                }
              }
            }
            function createStyleElement() {
              var styleElement = document.createElement("style");
              styleElement.type = "text/css";
              head.appendChild(styleElement);
              return styleElement;
            }
            function addStyle(obj) {
              var update, remove;
              var styleElement = document.querySelector("style[" + ssrIdKey + '~="' + obj.id + '"]');
              if (styleElement) {
                if (isProduction) {
                  return noop;
                } else {
                  styleElement.parentNode.removeChild(styleElement);
                }
              }
              if (isOldIE) {
                var styleIndex = singletonCounter++;
                styleElement = singletonElement || (singletonElement = createStyleElement());
                update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
                remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
              } else {
                styleElement = createStyleElement();
                update = applyToTag.bind(null, styleElement);
                remove = function() {
                  styleElement.parentNode.removeChild(styleElement);
                };
              }
              update(obj);
              return function updateStyle(newObj) {
                if (newObj) {
                  if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
                    return;
                  }
                  update(obj = newObj);
                } else {
                  remove();
                }
              };
            }
            var replaceText = function() {
              var textStore = [];
              return function(index, replacement) {
                textStore[index] = replacement;
                return textStore.filter(Boolean).join("\n");
              };
            }();
            function applyToSingletonTag(styleElement, index, remove, obj) {
              var css = remove ? "" : obj.css;
              if (styleElement.styleSheet) {
                styleElement.styleSheet.cssText = replaceText(index, css);
              } else {
                var cssNode = document.createTextNode(css);
                var childNodes = styleElement.childNodes;
                if (childNodes[index])
                  styleElement.removeChild(childNodes[index]);
                if (childNodes.length) {
                  styleElement.insertBefore(cssNode, childNodes[index]);
                } else {
                  styleElement.appendChild(cssNode);
                }
              }
            }
            function applyToTag(styleElement, obj) {
              var css = obj.css;
              var media = obj.media;
              var sourceMap = obj.sourceMap;
              if (media) {
                styleElement.setAttribute("media", media);
              }
              if (options.ssrId) {
                styleElement.setAttribute(ssrIdKey, obj.id);
              }
              if (sourceMap) {
                css += "\n/*# sourceURL=" + sourceMap.sources[0] + " */";
                css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
              }
              if (styleElement.styleSheet) {
                styleElement.styleSheet.cssText = css;
              } else {
                while (styleElement.firstChild) {
                  styleElement.removeChild(styleElement.firstChild);
                }
                styleElement.appendChild(document.createTextNode(css));
              }
            }
          },
          5086: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            "use strict";
            module2.exports = __webpack_require__2.p + "c9aec9aee3dffd46.cur";
          },
          8225: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            "use strict";
            module2.exports = __webpack_require__2.p + "e24589a18381ee82.cur";
          },
          5803: function(module2, __unused_webpack_exports2, __webpack_require__2) {
            "use strict";
            module2.exports = __webpack_require__2.p + "img/loading-icon.2cb588dc.svg";
          },
          7557: function(module2) {
            "use strict";
            module2.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABMAAAATCAQAAADYWf5HAAAA6UlEQVR4Xl2Pi2rEMAwE16fm1f7/r14v7w4rI0IzLAF7hLxNevBSEMEF5+OilNCsRd8ZMyn+a4NmsOT8WJw1lFbSYgGFzF2bLFoLjTClWjKKGRWpDYAGXUnZ4uhbBUzF3Oe/GG/ue2fn4GgsyXhNgysV2JnrhKEMg4fEZcALmiKbNhBBRFpSyDOj1G4QOVly6O1FV54ZZq8OVygrciDt6JazRgi1ljTPH0gbrPmHPXAbCiDd4GawIjip1TPh9tt2sz24qaCjr/jAb/GBFTbq9KZ7Ke/Cqt8nayUikZKsWZK7Fe6bg5dOUt8fZHWG2BHc+6EAAAAASUVORK5CYII=";
          },
          312: function(module2) {
            "use strict";
            module2.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAQAAABKmM6bAAAAR0lEQVQI12NgYHgx6YUSAyp4cebFyRc1L0RQhUDw0IukF+yoQiC45YXvCyZUIRAsQhVa/8IRWeP+FzEvWJFtLH8hgGwjmrsAP6JHRnPnejIAAAAASUVORK5CYII=";
          },
          8989: function(module2) {
            "use strict";
            module2.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAASCAQAAAD8x0bcAAAAXElEQVR4AWMAgRd9L6QZCIEXZ14cfZH2gp2AIjDc8MIWryIYBFlMUBHMYryK8FiMkMZjMUIKj8UICWwWE1a08YUdxdb1v5BBczimJRQGJsISTICwhNKkArYEDwAAaN/49eXnGYUAAAAASUVORK5CYII=";
          },
          9953: function(module2) {
            "use strict";
            module2.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAQAAABKmM6bAAAARElEQVR4AWMgDrzofXEGBbYxvBB7cQhJYPcLAZC6MCQhN4hWphfzoQJ9CPNUX5wACux/IYpsSTZQyB/VXrYXFS8YIWwAuoI/FPk23zUAAAAASUVORK5CYII=";
          },
          3386: function(module2) {
            "use strict";
            module2.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAASCAQAAAD8x0bcAAAAc0lEQVR4AWOgM3gx4cUZAnACwwupF8fwKQHKSoPMSserKA1iIduLTbiUAGXYYO6yw6nIlrDzJ6D6URbT+UARKfSgyMDmZHRF7AjnI5yMqcwBRZEN4dDvwx1FciDnYzoZu/NT8Uc3x4vNLzZiOBnT+ZhOBgAIx/kNQRV40AAAAABJRU5ErkJggg==";
          },
          7203: function(module2) {
            "use strict";
            module2.exports = __WEBPACK_EXTERNAL_MODULE__7203__;
          },
          104: function() {
          },
          3880: function() {
          },
          6173: function() {
          },
          6913: function() {
          },
          6659: function() {
          },
          9365: function() {
          },
          9635: function() {
          },
          4579: function() {
          },
          9510: function() {
          },
          8498: function() {
          }
        };
        var __webpack_module_cache__ = {};
        function __webpack_require__(moduleId) {
          var cachedModule = __webpack_module_cache__[moduleId];
          if (cachedModule !== void 0) {
            return cachedModule.exports;
          }
          var module2 = __webpack_module_cache__[moduleId] = {
            id: moduleId,
            exports: {}
          };
          __webpack_modules__[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
          return module2.exports;
        }
        __webpack_require__.m = __webpack_modules__;
        !function() {
          __webpack_require__.n = function(module2) {
            var getter = module2 && module2.__esModule ? function() {
              return module2["default"];
            } : function() {
              return module2;
            };
            __webpack_require__.d(getter, { a: getter });
            return getter;
          };
        }();
        !function() {
          __webpack_require__.d = function(exports2, definition) {
            for (var key in definition) {
              if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports2, key)) {
                Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
              }
            }
          };
        }();
        !function() {
          __webpack_require__.g = function() {
            if (typeof globalThis === "object")
              return globalThis;
            try {
              return this || new Function("return this")();
            } catch (e) {
              if (typeof window === "object")
                return window;
            }
          }();
        }();
        !function() {
          __webpack_require__.o = function(obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop);
          };
        }();
        !function() {
          __webpack_require__.r = function(exports2) {
            if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
              Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
            }
            Object.defineProperty(exports2, "__esModule", { value: true });
          };
        }();
        !function() {
          __webpack_require__.p = "";
        }();
        !function() {
          __webpack_require__.b = document.baseURI || self.location.href;
          var installedChunks = {
            255: 0
          };
        }();
        var __webpack_exports__ = {};
        !function() {
          "use strict";
          __webpack_require__.d(__webpack_exports__, {
            "default": function() {
              return entry_lib;
            }
          });
          ;
          if (typeof window !== "undefined") {
            var currentScript = window.document.currentScript;
            if (false) {
              var getCurrentScript;
            }
            var src = currentScript && currentScript.src.match(/(.+\/)[^/]+\.js(\?.*)?$/);
            if (src) {
              __webpack_require__.p = src[1];
            }
          }
          var setPublicPath = null;
          var external_commonjs_vue_commonjs2_vue_root_Vue_ = __webpack_require__(7203);
          ;
          const _withScopeId = (n) => ((0, external_commonjs_vue_commonjs2_vue_root_Vue_.pushScopeId)("data-v-0d167ef6"), n = n(), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.popScopeId)(), n);
          const _hoisted_1 = {
            id: "outerContainer"
          };
          const _hoisted_2 = {
            id: "toolbarSidebar"
          };
          const _hoisted_3 = {
            class: "splitToolbarButton toggled"
          };
          const _hoisted_4 = {
            id: "viewThumbnail",
            class: "toolbarButton toggled vue-pdf-app-icon view-thumbnail",
            title: "Show Thumbnails",
            tabindex: "2",
            "data-l10n-id": "thumbs"
          };
          const _hoisted_5 = _withScopeId(() => (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
            "data-l10n-id": "thumbs_label"
          }, "Thumbnails", -1));
          const _hoisted_6 = [_hoisted_5];
          const _hoisted_7 = {
            id: "viewOutline",
            class: "toolbarButton vue-pdf-app-icon view-outline",
            title: "Show Document Outline (double-click to expand/collapse all items)",
            tabindex: "3",
            "data-l10n-id": "document_outline"
          };
          const _hoisted_8 = _withScopeId(() => (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
            "data-l10n-id": "document_outline_label"
          }, "Document Outline", -1));
          const _hoisted_9 = [_hoisted_8];
          const _hoisted_10 = {
            id: "viewAttachments",
            class: "toolbarButton vue-pdf-app-icon view-attachments",
            title: "Show Attachments",
            tabindex: "4",
            "data-l10n-id": "attachments"
          };
          const _hoisted_11 = _withScopeId(() => (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
            "data-l10n-id": "attachments_label"
          }, "Attachments", -1));
          const _hoisted_12 = [_hoisted_11];
          const _hoisted_13 = {
            id: "thumbnailView"
          };
          const _hoisted_14 = {
            id: "outlineView",
            class: "hidden"
          };
          const _hoisted_15 = {
            id: "attachmentsView",
            class: "hidden"
          };
          const _hoisted_16 = _withScopeId(() => (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", {
            id: "sidebarResizer",
            class: "hidden"
          }, null, -1));
          const _hoisted_17 = {
            id: "mainContainer"
          };
          const _hoisted_18 = {
            class: "findbar hidden doorHanger",
            id: "findbar"
          };
          const _hoisted_19 = (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createStaticVNode)('<div id="findbarInputContainer" data-v-0d167ef6><input id="findInput" class="toolbarField" title="Find" placeholder="Find in document\u2026" tabindex="91" data-l10n-id="find_input" data-v-0d167ef6><div class="splitToolbarButton" data-v-0d167ef6><button id="findPrevious" class="toolbarButton findPrevious vue-pdf-app-icon find-previous" title="Find the previous occurrence of the phrase" tabindex="92" data-l10n-id="find_previous" data-v-0d167ef6><span data-l10n-id="find_previous_label" data-v-0d167ef6>Previous</span></button><div class="splitToolbarButtonSeparator" data-v-0d167ef6></div><button id="findNext" class="toolbarButton findNext vue-pdf-app-icon find-next" title="Find the next occurrence of the phrase" tabindex="93" data-l10n-id="find_next" data-v-0d167ef6><span data-l10n-id="find_next_label" data-v-0d167ef6>Next</span></button></div></div><div id="findbarOptionsOneContainer" data-v-0d167ef6><input type="checkbox" id="findHighlightAll" class="toolbarField" tabindex="94" data-v-0d167ef6><label for="findHighlightAll" class="toolbarLabel" data-l10n-id="find_highlight" data-v-0d167ef6>Highlight all</label><input type="checkbox" id="findMatchCase" class="toolbarField" tabindex="95" data-v-0d167ef6><label for="findMatchCase" class="toolbarLabel" data-l10n-id="find_match_case_label" data-v-0d167ef6>Match case</label></div><div id="findbarOptionsTwoContainer" data-v-0d167ef6><input type="checkbox" id="findEntireWord" class="toolbarField" tabindex="96" data-v-0d167ef6><label for="findEntireWord" class="toolbarLabel" data-l10n-id="find_entire_word_label" data-v-0d167ef6>Whole words</label><span id="findResultsCount" class="toolbarLabel hidden" data-v-0d167ef6></span></div><div id="findbarMessageContainer" data-v-0d167ef6><span id="findMsg" class="toolbarLabel" data-v-0d167ef6></span></div>', 4);
          const _hoisted_23 = [_hoisted_19];
          const _hoisted_24 = {
            id: "secondaryToolbar",
            class: "secondaryToolbar hidden doorHangerRight"
          };
          const _hoisted_25 = {
            id: "secondaryToolbarButtonContainer"
          };
          const _hoisted_26 = {
            id: "secondaryPresentationMode",
            class: "secondaryToolbarButton presentationMode visibleLargeView vue-pdf-app-icon presentation-mode",
            title: "Switch to Presentation Mode",
            tabindex: "51",
            "data-l10n-id": "presentation_mode"
          };
          const _hoisted_27 = _withScopeId(() => (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
            "data-l10n-id": "presentation_mode_label"
          }, "Presentation Mode", -1));
          const _hoisted_28 = [_hoisted_27];
          const _hoisted_29 = _withScopeId(() => (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
            "data-l10n-id": "open_file_label"
          }, "Open", -1));
          const _hoisted_30 = [_hoisted_29];
          const _hoisted_31 = {
            id: "secondaryPrint",
            class: "secondaryToolbarButton print visibleMediumView vue-pdf-app-icon print-button",
            title: "Print",
            tabindex: "53",
            "data-l10n-id": "print"
          };
          const _hoisted_32 = _withScopeId(() => (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
            "data-l10n-id": "print_label"
          }, "Print", -1));
          const _hoisted_33 = [_hoisted_32];
          const _hoisted_34 = {
            id: "secondaryDownload",
            class: "secondaryToolbarButton download visibleMediumView vue-pdf-app-icon download-button",
            title: "Download",
            tabindex: "54",
            "data-l10n-id": "download"
          };
          const _hoisted_35 = _withScopeId(() => (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
            "data-l10n-id": "download_label"
          }, "Download", -1));
          const _hoisted_36 = [_hoisted_35];
          const _hoisted_37 = {
            href: "#",
            id: "secondaryViewBookmark",
            class: "secondaryToolbarButton bookmark visibleSmallView vue-pdf-app-icon bookmark-button",
            title: "Current view (copy or open in new window)",
            tabindex: "55",
            "data-l10n-id": "bookmark"
          };
          const _hoisted_38 = _withScopeId(() => (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
            "data-l10n-id": "bookmark_label"
          }, "Current View", -1));
          const _hoisted_39 = [_hoisted_38];
          const _hoisted_40 = {
            key: 0,
            class: "horizontalToolbarSeparator visibleLargeView"
          };
          const _hoisted_41 = {
            id: "firstPage",
            class: "secondaryToolbarButton firstPage vue-pdf-app-icon first-page",
            title: "Go to First Page",
            tabindex: "56",
            "data-l10n-id": "first_page"
          };
          const _hoisted_42 = _withScopeId(() => (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
            "data-l10n-id": "first_page_label"
          }, "Go to First Page", -1));
          const _hoisted_43 = [_hoisted_42];
          const _hoisted_44 = {
            id: "lastPage",
            class: "secondaryToolbarButton lastPage vue-pdf-app-icon last-page",
            title: "Go to Last Page",
            tabindex: "57",
            "data-l10n-id": "last_page"
          };
          const _hoisted_45 = _withScopeId(() => (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
            "data-l10n-id": "last_page_label"
          }, "Go to Last Page", -1));
          const _hoisted_46 = [_hoisted_45];
          const _hoisted_47 = {
            key: 1,
            class: "horizontalToolbarSeparator"
          };
          const _hoisted_48 = {
            id: "pageRotateCw",
            class: "secondaryToolbarButton rotateCw vue-pdf-app-icon rotate-clockwise",
            title: "Rotate Clockwise",
            tabindex: "58",
            "data-l10n-id": "page_rotate_cw"
          };
          const _hoisted_49 = _withScopeId(() => (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
            "data-l10n-id": "page_rotate_cw_label"
          }, "Rotate Clockwise", -1));
          const _hoisted_50 = [_hoisted_49];
          const _hoisted_51 = {
            id: "pageRotateCcw",
            class: "secondaryToolbarButton rotateCcw vue-pdf-app-icon rotate-counter-clockwise",
            title: "Rotate Counterclockwise",
            tabindex: "59",
            "data-l10n-id": "page_rotate_ccw"
          };
          const _hoisted_52 = _withScopeId(() => (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
            "data-l10n-id": "page_rotate_ccw_label"
          }, "Rotate Counterclockwise", -1));
          const _hoisted_53 = [_hoisted_52];
          const _hoisted_54 = {
            key: 2,
            class: "horizontalToolbarSeparator"
          };
          const _hoisted_55 = {
            id: "cursorSelectTool",
            class: "secondaryToolbarButton selectTool toggled vue-pdf-app-icon select-tool",
            title: "Enable Text Selection Tool",
            tabindex: "60",
            "data-l10n-id": "cursor_text_select_tool"
          };
          const _hoisted_56 = _withScopeId(() => (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
            "data-l10n-id": "cursor_text_select_tool_label"
          }, "Text Selection Tool", -1));
          const _hoisted_57 = [_hoisted_56];
          const _hoisted_58 = {
            id: "cursorHandTool",
            class: "secondaryToolbarButton handTool vue-pdf-app-icon hand-tool",
            title: "Enable Hand Tool",
            tabindex: "61",
            "data-l10n-id": "cursor_hand_tool"
          };
          const _hoisted_59 = _withScopeId(() => (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
            "data-l10n-id": "cursor_hand_tool_label"
          }, "Hand Tool", -1));
          const _hoisted_60 = [_hoisted_59];
          const _hoisted_61 = {
            key: 3,
            class: "horizontalToolbarSeparator"
          };
          const _hoisted_62 = {
            id: "scrollVertical",
            class: "secondaryToolbarButton scrollModeButtons scrollVertical toggled vue-pdf-app-icon scroll-vertical",
            title: "Use Vertical Scrolling",
            tabindex: "62",
            "data-l10n-id": "scroll_vertical"
          };
          const _hoisted_63 = _withScopeId(() => (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
            "data-l10n-id": "scroll_vertical_label"
          }, "Vertical Scrolling", -1));
          const _hoisted_64 = [_hoisted_63];
          const _hoisted_65 = {
            id: "scrollHorizontal",
            class: "secondaryToolbarButton scrollModeButtons scrollHorizontal vue-pdf-app-icon scroll-horizontal",
            title: "Use Horizontal Scrolling",
            tabindex: "63",
            "data-l10n-id": "scroll_horizontal"
          };
          const _hoisted_66 = _withScopeId(() => (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
            "data-l10n-id": "scroll_horizontal_label"
          }, "Horizontal Scrolling", -1));
          const _hoisted_67 = [_hoisted_66];
          const _hoisted_68 = {
            id: "scrollWrapped",
            class: "secondaryToolbarButton scrollModeButtons scrollWrapped vue-pdf-app-icon scroll-wrapped",
            title: "Use Wrapped Scrolling",
            tabindex: "64",
            "data-l10n-id": "scroll_wrapped"
          };
          const _hoisted_69 = _withScopeId(() => (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
            "data-l10n-id": "scroll_wrapped_label"
          }, "Wrapped Scrolling", -1));
          const _hoisted_70 = [_hoisted_69];
          const _hoisted_71 = {
            key: 4,
            class: "horizontalToolbarSeparator scrollModeButtons"
          };
          const _hoisted_72 = {
            id: "spreadNone",
            class: "secondaryToolbarButton spreadModeButtons spreadNone toggled vue-pdf-app-icon spread-none",
            title: "Do not join page spreads",
            tabindex: "65",
            "data-l10n-id": "spread_none"
          };
          const _hoisted_73 = _withScopeId(() => (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
            "data-l10n-id": "spread_none_label"
          }, "No Spreads", -1));
          const _hoisted_74 = [_hoisted_73];
          const _hoisted_75 = {
            id: "spreadOdd",
            class: "secondaryToolbarButton spreadModeButtons vue-pdf-app-icon spread-odd",
            title: "Join page spreads starting with odd-numbered pages",
            tabindex: "66",
            "data-l10n-id": "spread_odd"
          };
          const _hoisted_76 = _withScopeId(() => (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
            "data-l10n-id": "spread_odd_label"
          }, "Odd Spreads", -1));
          const _hoisted_77 = [_hoisted_76];
          const _hoisted_78 = {
            id: "spreadEven",
            class: "secondaryToolbarButton spreadModeButtons spreadEven vue-pdf-app-icon spread-even",
            title: "Join page spreads starting with even-numbered pages",
            tabindex: "67",
            "data-l10n-id": "spread_even"
          };
          const _hoisted_79 = _withScopeId(() => (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
            "data-l10n-id": "spread_even_label"
          }, "Even Spreads", -1));
          const _hoisted_80 = [_hoisted_79];
          const _hoisted_81 = {
            key: 5,
            class: "horizontalToolbarSeparator spreadModeButtons"
          };
          const _hoisted_82 = {
            id: "documentProperties",
            class: "secondaryToolbarButton documentProperties vue-pdf-app-icon document-properties",
            title: "Document Properties\u2026",
            tabindex: "68",
            "data-l10n-id": "document_properties"
          };
          const _hoisted_83 = _withScopeId(() => (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
            "data-l10n-id": "document_properties_label"
          }, "Document Properties\u2026", -1));
          const _hoisted_84 = [_hoisted_83];
          const _hoisted_85 = {
            class: "toolbar"
          };
          const _hoisted_86 = {
            id: "toolbarContainer"
          };
          const _hoisted_87 = {
            id: "toolbarViewer"
          };
          const _hoisted_88 = {
            id: "toolbarViewerLeft"
          };
          const _hoisted_89 = {
            id: "sidebarToggle",
            class: "toolbarButton vue-pdf-app-icon sidebar-toggle",
            title: "Toggle Sidebar",
            tabindex: "11",
            "data-l10n-id": "toggle_sidebar"
          };
          const _hoisted_90 = _withScopeId(() => (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
            "data-l10n-id": "toggle_sidebar_label"
          }, "Toggle Sidebar", -1));
          const _hoisted_91 = [_hoisted_90];
          const _hoisted_92 = {
            key: 0,
            class: "toolbarButtonSpacer"
          };
          const _hoisted_93 = {
            id: "viewFind",
            class: "toolbarButton vue-pdf-app-icon view-find",
            title: "Find in Document",
            tabindex: "12",
            "data-l10n-id": "findbar"
          };
          const _hoisted_94 = _withScopeId(() => (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
            "data-l10n-id": "findbar_label"
          }, "Find", -1));
          const _hoisted_95 = [_hoisted_94];
          const _hoisted_96 = {
            class: "splitToolbarButton hiddenSmallView"
          };
          const _hoisted_97 = {
            class: "toolbarButton pageUp vue-pdf-app-icon page-up",
            title: "Previous Page",
            id: "previous",
            tabindex: "13",
            "data-l10n-id": "previous"
          };
          const _hoisted_98 = _withScopeId(() => (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
            "data-l10n-id": "previous_label"
          }, "Previous", -1));
          const _hoisted_99 = [_hoisted_98];
          const _hoisted_100 = {
            key: 0,
            class: "splitToolbarButtonSeparator"
          };
          const _hoisted_101 = {
            class: "toolbarButton pageDown vue-pdf-app-icon page-down",
            title: "Next Page",
            id: "next",
            tabindex: "14",
            "data-l10n-id": "next"
          };
          const _hoisted_102 = _withScopeId(() => (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
            "data-l10n-id": "next_label"
          }, "Next", -1));
          const _hoisted_103 = [_hoisted_102];
          const _hoisted_104 = {
            type: "number",
            id: "pageNumber",
            class: "toolbarField pageNumber",
            title: "Page",
            value: "1",
            size: "4",
            min: "1",
            tabindex: "15",
            "data-l10n-id": "page",
            autocomplete: "off"
          };
          const _hoisted_105 = {
            id: "numPages",
            class: "toolbarLabel"
          };
          const _hoisted_106 = {
            id: "toolbarViewerRight"
          };
          const _hoisted_107 = {
            id: "presentationMode",
            class: "toolbarButton presentationMode hiddenLargeView vue-pdf-app-icon presentation-mode",
            title: "Switch to Presentation Mode",
            tabindex: "31",
            "data-l10n-id": "presentation_mode"
          };
          const _hoisted_108 = _withScopeId(() => (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
            "data-l10n-id": "presentation_mode_label"
          }, "Presentation Mode", -1));
          const _hoisted_109 = [_hoisted_108];
          const _hoisted_110 = _withScopeId(() => (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
            "data-l10n-id": "open_file_label"
          }, "Open", -1));
          const _hoisted_111 = [_hoisted_110];
          const _hoisted_112 = {
            id: "print",
            class: "toolbarButton print hiddenMediumView vue-pdf-app-icon print-button",
            title: "Print",
            tabindex: "33",
            "data-l10n-id": "print"
          };
          const _hoisted_113 = _withScopeId(() => (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
            "data-l10n-id": "print_label"
          }, "Print", -1));
          const _hoisted_114 = [_hoisted_113];
          const _hoisted_115 = {
            id: "download",
            class: "toolbarButton download hiddenMediumView vue-pdf-app-icon download-button",
            title: "Download",
            tabindex: "34",
            "data-l10n-id": "download"
          };
          const _hoisted_116 = _withScopeId(() => (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
            "data-l10n-id": "download_label"
          }, "Download", -1));
          const _hoisted_117 = [_hoisted_116];
          const _hoisted_118 = {
            href: "#",
            id: "viewBookmark",
            class: "toolbarButton bookmark hiddenSmallView vue-pdf-app-icon bookmark-button",
            title: "Current view (copy or open in new window)",
            tabindex: "35",
            "data-l10n-id": "bookmark"
          };
          const _hoisted_119 = _withScopeId(() => (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
            "data-l10n-id": "bookmark_label"
          }, "Current View", -1));
          const _hoisted_120 = [_hoisted_119];
          const _hoisted_121 = {
            key: 0,
            class: "verticalToolbarSeparator hiddenSmallView"
          };
          const _hoisted_122 = {
            id: "secondaryToolbarToggle",
            class: "toolbarButton vue-pdf-app-icon secondary-toolbar-toggle",
            title: "Tools",
            tabindex: "36",
            "data-l10n-id": "tools"
          };
          const _hoisted_123 = _withScopeId(() => (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
            "data-l10n-id": "tools_label"
          }, "Tools", -1));
          const _hoisted_124 = [_hoisted_123];
          const _hoisted_125 = {
            id: "toolbarViewerMiddle"
          };
          const _hoisted_126 = {
            class: "splitToolbarButton"
          };
          const _hoisted_127 = {
            id: "zoomOut",
            class: "toolbarButton zoomOut vue-pdf-app-icon zoom-out",
            title: "Zoom Out",
            tabindex: "21",
            "data-l10n-id": "zoom_out"
          };
          const _hoisted_128 = _withScopeId(() => (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
            "data-l10n-id": "zoom_out_label"
          }, "Zoom Out", -1));
          const _hoisted_129 = [_hoisted_128];
          const _hoisted_130 = {
            key: 0,
            class: "splitToolbarButtonSeparator"
          };
          const _hoisted_131 = {
            id: "zoomIn",
            class: "toolbarButton zoomIn vue-pdf-app-icon zoom-in",
            title: "Zoom In",
            tabindex: "22",
            "data-l10n-id": "zoom_in"
          };
          const _hoisted_132 = _withScopeId(() => (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", {
            "data-l10n-id": "zoom_in_label"
          }, "Zoom In", -1));
          const _hoisted_133 = [_hoisted_132];
          const _hoisted_134 = {
            id: "scaleSelectContainer",
            class: "dropdownToolbarButton vue-pdf-app-icon dropdown-toolbar-button"
          };
          const _hoisted_135 = {
            id: "scaleSelect",
            title: "Zoom",
            tabindex: "23",
            "data-l10n-id": "zoom"
          };
          const _hoisted_136 = (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createStaticVNode)('<option id="pageAutoOption" value="auto" selected data-l10n-id="page_scale_auto" data-v-0d167ef6> Automatic Zoom </option><option id="pageActualOption" value="page-actual" data-l10n-id="page_scale_actual" data-v-0d167ef6> Actual Size </option><option id="pageFitOption" value="page-fit" data-l10n-id="page_scale_fit" data-v-0d167ef6> Page Fit </option><option id="pageWidthOption" value="page-width" data-l10n-id="page_scale_width" data-v-0d167ef6> Page Width </option><option id="customScaleOption" value="custom" disabled hidden="true" data-v-0d167ef6></option>', 5);
          const _hoisted_141 = ["data-l10n-args"];
          const _hoisted_142 = ["data-l10n-args"];
          const _hoisted_143 = ["data-l10n-args"];
          const _hoisted_144 = ["data-l10n-args"];
          const _hoisted_145 = ["data-l10n-args"];
          const _hoisted_146 = ["data-l10n-args"];
          const _hoisted_147 = ["data-l10n-args"];
          const _hoisted_148 = ["data-l10n-args"];
          const _hoisted_149 = _withScopeId(() => (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", {
            id: "loadingBar"
          }, [(0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", {
            class: "progress"
          }, [(0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", {
            class: "glimmer"
          })])], -1));
          const _hoisted_150 = {
            type: "context",
            id: "viewerContextMenu"
          };
          const _hoisted_151 = _withScopeId(() => (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", {
            id: "contextFirstPage",
            label: "First Page",
            "data-l10n-id": "first_page"
          }, null, -1));
          const _hoisted_152 = _withScopeId(() => (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", {
            id: "contextLastPage",
            label: "Last Page",
            "data-l10n-id": "last_page"
          }, null, -1));
          const _hoisted_153 = _withScopeId(() => (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", {
            id: "contextPageRotateCw",
            label: "Rotate Clockwise",
            "data-l10n-id": "page_rotate_cw"
          }, null, -1));
          const _hoisted_154 = _withScopeId(() => (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", {
            id: "contextPageRotateCcw",
            label: "Rotate Counter-Clockwise",
            "data-l10n-id": "page_rotate_ccw"
          }, null, -1));
          const _hoisted_155 = [_hoisted_151, _hoisted_152, _hoisted_153, _hoisted_154];
          const _hoisted_156 = _withScopeId(() => (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", {
            id: "viewer",
            class: "pdfViewer"
          }, null, -1));
          const _hoisted_157 = [_hoisted_156];
          const _hoisted_158 = {
            id: "errorWrapper",
            hidden: "true"
          };
          const _hoisted_159 = (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createStaticVNode)('<div id="errorMessageLeft" data-v-0d167ef6><span id="errorMessage" data-v-0d167ef6></span><button id="errorShowMore" data-l10n-id="error_more_info" data-v-0d167ef6> More Information </button><button id="errorShowLess" data-l10n-id="error_less_info" hidden="true" data-v-0d167ef6> Less Information </button></div><div id="errorMessageRight" data-v-0d167ef6><button id="errorClose" data-l10n-id="error_close" data-v-0d167ef6>Close</button></div><div class="clearBoth" data-v-0d167ef6></div><textarea id="errorMoreInfo" hidden="true" readonly data-v-0d167ef6></textarea>', 4);
          const _hoisted_163 = [_hoisted_159];
          const _hoisted_164 = (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createStaticVNode)('<div id="overlayContainer" class="hidden" data-v-0d167ef6><div id="passwordOverlay" class="container hidden" data-v-0d167ef6><div class="dialog" data-v-0d167ef6><div class="row" data-v-0d167ef6><p id="passwordText" data-l10n-id="password_label" data-v-0d167ef6> Enter the password to open this PDF file: </p></div><div class="row" data-v-0d167ef6><input type="password" id="password" class="toolbarField" data-v-0d167ef6></div><div class="buttonRow" data-v-0d167ef6><button id="passwordCancel" class="overlayButton" data-v-0d167ef6><span data-l10n-id="password_cancel" data-v-0d167ef6>Cancel</span></button><button id="passwordSubmit" class="overlayButton" data-v-0d167ef6><span data-l10n-id="password_ok" data-v-0d167ef6>OK</span></button></div></div></div><div id="documentPropertiesOverlay" class="container hidden" data-v-0d167ef6><div class="dialog" data-v-0d167ef6><div class="row" data-v-0d167ef6><span data-l10n-id="document_properties_file_name" data-v-0d167ef6>File name:</span><p id="fileNameField" data-v-0d167ef6>-</p></div><div class="row" data-v-0d167ef6><span data-l10n-id="document_properties_file_size" data-v-0d167ef6>File size:</span><p id="fileSizeField" data-v-0d167ef6>-</p></div><div class="separator" data-v-0d167ef6></div><div class="row" data-v-0d167ef6><span data-l10n-id="document_properties_title" data-v-0d167ef6>Title:</span><p id="titleField" data-v-0d167ef6>-</p></div><div class="row" data-v-0d167ef6><span data-l10n-id="document_properties_author" data-v-0d167ef6>Author:</span><p id="authorField" data-v-0d167ef6>-</p></div><div class="row" data-v-0d167ef6><span data-l10n-id="document_properties_subject" data-v-0d167ef6>Subject:</span><p id="subjectField" data-v-0d167ef6>-</p></div><div class="row" data-v-0d167ef6><span data-l10n-id="document_properties_keywords" data-v-0d167ef6>Keywords:</span><p id="keywordsField" data-v-0d167ef6>-</p></div><div class="row" data-v-0d167ef6><span data-l10n-id="document_properties_creation_date" data-v-0d167ef6>Creation Date:</span><p id="creationDateField" data-v-0d167ef6>-</p></div><div class="row" data-v-0d167ef6><span data-l10n-id="document_properties_modification_date" data-v-0d167ef6>Modification Date:</span><p id="modificationDateField" data-v-0d167ef6>-</p></div><div class="row" data-v-0d167ef6><span data-l10n-id="document_properties_creator" data-v-0d167ef6>Creator:</span><p id="creatorField" data-v-0d167ef6>-</p></div><div class="separator" data-v-0d167ef6></div><div class="row" data-v-0d167ef6><span data-l10n-id="document_properties_producer" data-v-0d167ef6>PDF Producer:</span><p id="producerField" data-v-0d167ef6>-</p></div><div class="row" data-v-0d167ef6><span data-l10n-id="document_properties_version" data-v-0d167ef6>PDF Version:</span><p id="versionField" data-v-0d167ef6>-</p></div><div class="row" data-v-0d167ef6><span data-l10n-id="document_properties_page_count" data-v-0d167ef6>Page Count:</span><p id="pageCountField" data-v-0d167ef6>-</p></div><div class="row" data-v-0d167ef6><span data-l10n-id="document_properties_page_size" data-v-0d167ef6>Page Size:</span><p id="pageSizeField" data-v-0d167ef6>-</p></div><div class="separator" data-v-0d167ef6></div><div class="row" data-v-0d167ef6><span data-l10n-id="document_properties_linearized" data-v-0d167ef6>Fast Web View:</span><p id="linearizedField" data-v-0d167ef6>-</p></div><div class="buttonRow" data-v-0d167ef6><button id="documentPropertiesClose" class="overlayButton" data-v-0d167ef6><span data-l10n-id="document_properties_close" data-v-0d167ef6>Close</span></button></div></div></div><div id="printServiceOverlay" class="container hidden" data-v-0d167ef6><div class="dialog" data-v-0d167ef6><div class="row" data-v-0d167ef6><span data-l10n-id="print_progress_message" data-v-0d167ef6>Preparing document for printing\u2026</span></div><div class="row" data-v-0d167ef6><progress value="0" max="100" data-v-0d167ef6></progress><span data-l10n-id="print_progress_percent" data-l10n-args="{ &#39;progress&#39;: 0 }" class="relative-progress" data-v-0d167ef6>0%</span></div><div class="buttonRow" data-v-0d167ef6><button id="printCancel" class="overlayButton" data-v-0d167ef6><span data-l10n-id="print_progress_close" data-v-0d167ef6>Cancel</span></button></div></div></div></div>', 1);
          function render(_ctx, _cache, $props, $setup, $data, $options) {
            return (0, external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", {
              id: "vuePdfApp",
              class: (0, external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([[_ctx.localTheme], "pdf-app"])
            }, [((0, external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createBlock)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.resolveDynamicComponent)("script"), {
              type: "application/l10n"
            }, {
              default: (0, external_commonjs_vue_commonjs2_vue_root_Vue_.withCtx)(() => [(0, external_commonjs_vue_commonjs2_vue_root_Vue_.createTextVNode)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.toDisplayString)(_ctx.defaultLocale), 1)]),
              _: 1
            })), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", _hoisted_1, [(0, external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", {
              class: (0, external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([_ctx.isToolbarHidden]),
              id: "sidebarContainer"
            }, [(0, external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", _hoisted_2, [(0, external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "toolbar-sidebar-prepend", (0, external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeProps)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.guardReactiveProps)(_ctx.slotProps)), void 0, true), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", _hoisted_3, [(0, external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("button", _hoisted_4, _hoisted_6, 512), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.showElem("sidebar.viewThumbnail", "viewThumbnail")]]), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("button", _hoisted_7, _hoisted_9, 512), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.showElem("sidebar.viewOutline", "viewOutline")]]), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("button", _hoisted_10, _hoisted_12, 512), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.showElem("sidebar.viewAttachments", "viewAttachments")]])]), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "toolbar-sidebar-append", (0, external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeProps)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.guardReactiveProps)(_ctx.slotProps)), void 0, true)], 512), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, !_ctx.isSidebarToolbarHidden]]), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", {
              class: (0, external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)({
                "zero-top": _ctx.isSidebarToolbarHidden
              }),
              id: "sidebarContent"
            }, [(0, external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", _hoisted_13, null, 512), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.showElem("sidebar.viewThumbnail")]]), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", _hoisted_14, null, 512), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.showElem("sidebar.viewOutline")]]), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", _hoisted_15, null, 512), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.showElem("sidebar.viewAttachments")]])], 2), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.showElem("sidebar")]]), _hoisted_16], 2), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.showElem("sidebar")]]), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", _hoisted_17, [(0, external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", _hoisted_18, _hoisted_23, 512), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.showElem("toolbar.toolbarViewerLeft.findbar", "findbar")]]), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", _hoisted_24, [(0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", _hoisted_25, [(0, external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "secondary-toolbar-prepend", (0, external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeProps)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.guardReactiveProps)(_ctx.slotProps)), void 0, true), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("button", _hoisted_26, _hoisted_28, 512), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.showElem("secondaryToolbar.secondaryPresentationMode")]]), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("button", {
              onClickOnce: _cache[0] || (_cache[0] = (...args) => _ctx.bindOpenHandler && _ctx.bindOpenHandler(...args)),
              id: "secondaryOpenFile",
              class: "secondaryToolbarButton openFile visibleLargeView vue-pdf-app-icon open-file",
              title: "Open File",
              tabindex: "52",
              "data-l10n-id": "open_file"
            }, _hoisted_30, 544), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.showElem("secondaryToolbar.secondaryOpenFile")]]), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("button", _hoisted_31, _hoisted_33, 512), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.showElem("secondaryToolbar.secondaryPrint")]]), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("button", _hoisted_34, _hoisted_36, 512), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.showElem("secondaryToolbar.secondaryDownload")]]), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("a", _hoisted_37, _hoisted_39, 512), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.showElem("secondaryToolbar.secondaryViewBookmark")]]), _ctx.showElem("secondaryToolbar.secondaryPresentationMode") || _ctx.showElem("secondaryToolbar.secondaryOpenFile") || _ctx.showElem("secondaryToolbar.secondaryPrint") || _ctx.showElem("secondaryToolbar.secondaryDownload") || _ctx.showElem("secondaryToolbar.secondaryViewBookmark") ? ((0, external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", _hoisted_40)) : (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("", true), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("button", _hoisted_41, _hoisted_43, 512), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.showElem("secondaryToolbar.firstPage", "firstPage")]]), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("button", _hoisted_44, _hoisted_46, 512), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.showElem("secondaryToolbar.lastPage", "lastPage")]]), _ctx.showElem("secondaryToolbar.lastPage", "lastPage") || _ctx.showElem("secondaryToolbar.firstPage", "firstPage") ? ((0, external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", _hoisted_47)) : (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("", true), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("button", _hoisted_48, _hoisted_50, 512), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.showElem("secondaryToolbar.pageRotateCw", "pageRotateCw")]]), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("button", _hoisted_51, _hoisted_53, 512), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.showElem("secondaryToolbar.pageRotateCcw", "pageRotateCcw")]]), _ctx.showElem("secondaryToolbar.pageRotateCcw", "pageRotateCcw") || _ctx.showElem("secondaryToolbar.pageRotateCw", "pageRotateCw") ? ((0, external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", _hoisted_54)) : (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("", true), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("button", _hoisted_55, _hoisted_57, 512), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.showElem("secondaryToolbar.cursorSelectTool", "cursorSelectTool")]]), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("button", _hoisted_58, _hoisted_60, 512), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.showElem("secondaryToolbar.cursorHandTool", "cursorHandTool")]]), _ctx.showElem("secondaryToolbar.cursorHandTool", "cursorHandTool") || _ctx.showElem("secondaryToolbar.cursorSelectTool", "cursorSelectTool") ? ((0, external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", _hoisted_61)) : (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("", true), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("button", _hoisted_62, _hoisted_64, 512), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.showElem("secondaryToolbar.scrollVertical", "scrollVertical")]]), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("button", _hoisted_65, _hoisted_67, 512), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.showElem("secondaryToolbar.scrollHorizontal", "scrollHorizontal")]]), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("button", _hoisted_68, _hoisted_70, 512), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.showElem("secondaryToolbar.scrollWrapped", "scrollWrapped")]]), _ctx.showElem("secondaryToolbar.scrollWrapped", "scrollWrapped") || _ctx.showElem("secondaryToolbar.scrollHorizontal", "scrollHorizontal") || _ctx.showElem("secondaryToolbar.scrollVertical", "scrollVertical") ? ((0, external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", _hoisted_71)) : (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("", true), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("button", _hoisted_72, _hoisted_74, 512), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.showElem("secondaryToolbar.spreadNone", "spreadNone")]]), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("button", _hoisted_75, _hoisted_77, 512), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.showElem("secondaryToolbar.spreadOdd", "spreadOdd")]]), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("button", _hoisted_78, _hoisted_80, 512), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.showElem("secondaryToolbar.spreadEven", "spreadEven")]]), _ctx.showElem("secondaryToolbar.spreadEven", "spreadEven") || _ctx.showElem("secondaryToolbar.spreadOdd", "spreadOdd") || _ctx.showElem("secondaryToolbar.spreadNone", "spreadNone") ? ((0, external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", _hoisted_81)) : (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("", true), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("button", _hoisted_82, _hoisted_84, 512), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.showElem("secondaryToolbar.documentProperties", "documentProperties")]]), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "secondary-toolbar-append", (0, external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeProps)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.guardReactiveProps)(_ctx.slotProps)), void 0, true)])], 512), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.showElem("secondaryToolbar")]]), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", _hoisted_85, [(0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", _hoisted_86, [(0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", _hoisted_87, [(0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", _hoisted_88, [(0, external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "toolbar-left-prepend", (0, external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeProps)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.guardReactiveProps)(_ctx.slotProps)), void 0, true), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("button", _hoisted_89, _hoisted_91, 512), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.showElem("sidebar", "sidebarToggle")]]), _ctx.showElem("sidebar") ? ((0, external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", _hoisted_92)) : (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("", true), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("button", _hoisted_93, _hoisted_95, 512), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.showElem("toolbar.toolbarViewerLeft.findbar", "toggleFindbar")]]), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", _hoisted_96, [(0, external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("button", _hoisted_97, _hoisted_99, 512), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.showElem("toolbar.toolbarViewerLeft.previous", "previousPage")]]), _ctx.showElem("toolbar.toolbarViewerLeft.next", "nextPage") && _ctx.showElem("toolbar.toolbarViewerLeft.previous", "previousPage") ? ((0, external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", _hoisted_100)) : (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("", true), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("button", _hoisted_101, _hoisted_103, 512), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.showElem("toolbar.toolbarViewerLeft.next", "nextPage")]])]), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("input", _hoisted_104, null, 512), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.showElem("toolbar.toolbarViewerLeft.pageNumber", "pageNumber")]]), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", _hoisted_105, null, 512), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.showElem("toolbar.toolbarViewerLeft.pageNumber", "numPages")]]), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "toolbar-left-append", (0, external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeProps)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.guardReactiveProps)(_ctx.slotProps)), void 0, true)]), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", _hoisted_106, [(0, external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "toolbar-right-prepend", (0, external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeProps)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.guardReactiveProps)(_ctx.slotProps)), void 0, true), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("button", _hoisted_107, _hoisted_109, 512), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.showElem("toolbar.toolbarViewerRight.presentationMode", "presentationMode")]]), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("button", {
              onClickOnce: _cache[1] || (_cache[1] = (...args) => _ctx.bindOpenHandler && _ctx.bindOpenHandler(...args)),
              id: "openFile",
              class: "toolbarButton openFile hiddenLargeView vue-pdf-app-icon open-file",
              title: "Open File",
              tabindex: "32",
              "data-l10n-id": "open_file"
            }, _hoisted_111, 544), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.showElem("toolbar.toolbarViewerRight.openFile", "openFile")]]), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("button", _hoisted_112, _hoisted_114, 512), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.showElem("toolbar.toolbarViewerRight.print", "print")]]), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("button", _hoisted_115, _hoisted_117, 512), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.showElem("toolbar.toolbarViewerRight.download", "download")]]), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("a", _hoisted_118, _hoisted_120, 512), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.showElem("toolbar.toolbarViewerRight.viewBookmark", "viewBookmark")]]), _ctx.showElem("secondaryToolbar") ? ((0, external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", _hoisted_121)) : (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("", true), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("button", _hoisted_122, _hoisted_124, 512), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.showElem("secondaryToolbar")]]), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "toolbar-right-append", (0, external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeProps)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.guardReactiveProps)(_ctx.slotProps)), void 0, true)]), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", _hoisted_125, [(0, external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "toolbar-middle-prepend", (0, external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeProps)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.guardReactiveProps)(_ctx.slotProps)), void 0, true), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", _hoisted_126, [(0, external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("button", _hoisted_127, _hoisted_129, 512), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.showElem("toolbar.toolbarViewerMiddle.zoomOut", "zoomOut")]]), _ctx.showElem("toolbar.toolbarViewerMiddle.zoomIn", "zoomIn") && _ctx.showElem("toolbar.toolbarViewerMiddle.zoomOut", "zoomOut") ? ((0, external_commonjs_vue_commonjs2_vue_root_Vue_.openBlock)(), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementBlock)("div", _hoisted_130)) : (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)("", true), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("button", _hoisted_131, _hoisted_133, 512), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.showElem("toolbar.toolbarViewerMiddle.zoomIn", "zoomIn")]])]), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("span", _hoisted_134, [(0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("select", _hoisted_135, [_hoisted_136, (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("option", {
              "data-l10n-args": _ctx.getScale(50),
              value: "0.5",
              "data-l10n-id": "page_scale_percent"
            }, " 50% ", 8, _hoisted_141), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("option", {
              "data-l10n-args": _ctx.getScale(75),
              value: "0.75",
              "data-l10n-id": "page_scale_percent"
            }, " 75% ", 8, _hoisted_142), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("option", {
              "data-l10n-args": _ctx.getScale(100),
              value: "1",
              "data-l10n-id": "page_scale_percent"
            }, " 100% ", 8, _hoisted_143), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("option", {
              "data-l10n-args": _ctx.getScale(125),
              value: "1.25",
              "data-l10n-id": "page_scale_percent"
            }, " 125% ", 8, _hoisted_144), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("option", {
              "data-l10n-args": _ctx.getScale(150),
              value: "1.5",
              "data-l10n-id": "page_scale_percent"
            }, " 150% ", 8, _hoisted_145), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("option", {
              "data-l10n-args": _ctx.getScale(200),
              value: "2",
              "data-l10n-id": "page_scale_percent"
            }, " 200% ", 8, _hoisted_146), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("option", {
              "data-l10n-args": _ctx.getScale(300),
              value: "3",
              "data-l10n-id": "page_scale_percent"
            }, " 300% ", 8, _hoisted_147), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("option", {
              "data-l10n-args": _ctx.getScale(400),
              value: "4",
              "data-l10n-id": "page_scale_percent"
            }, " 400% ", 8, _hoisted_148)])], 512), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.showElem("toolbar.toolbarViewerMiddle.scaleSelectContainer")]]), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "toolbar-middle-append", (0, external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeProps)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.guardReactiveProps)(_ctx.slotProps)), void 0, true)])])])], 512), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.showElem("toolbar")]]), _hoisted_149, (0, external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("menu", _hoisted_150, _hoisted_155, 512), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, false]]), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "viewer-header", (0, external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeProps)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.guardReactiveProps)(_ctx.slotProps)), void 0, true), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "viewer-prepend", (0, external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeProps)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.guardReactiveProps)(_ctx.slotProps)), void 0, true), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", {
              id: "viewerContainer",
              class: (0, external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeClass)([_ctx.isToolbarHidden]),
              tabindex: "0"
            }, _hoisted_157, 2), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "viewer-append", (0, external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeProps)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.guardReactiveProps)(_ctx.slotProps)), void 0, true), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "viewer-footer", (0, external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeProps)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.guardReactiveProps)(_ctx.slotProps)), void 0, true), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.withDirectives)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.createElementVNode)("div", _hoisted_158, _hoisted_163, 512), [[external_commonjs_vue_commonjs2_vue_root_Vue_.vShow, _ctx.showElem("errorWrapper")]])]), _hoisted_164]), (0, external_commonjs_vue_commonjs2_vue_root_Vue_.renderSlot)(_ctx.$slots, "footer", (0, external_commonjs_vue_commonjs2_vue_root_Vue_.normalizeProps)((0, external_commonjs_vue_commonjs2_vue_root_Vue_.guardReactiveProps)(_ctx.slotProps)), void 0, true)], 2);
          }
          ;
          var pdf = __webpack_require__(919);
          var app = __webpack_require__(8375);
          var app_options = __webpack_require__(1958);
          var genericcom = __webpack_require__(3224);
          var pdf_print_service = __webpack_require__(3819);
          var pdf_worker_entry = __webpack_require__(1353);
          var sass = __webpack_require__(3162);
          ;
          const PDF_FILE_INPUT_ID = "pdfFileInput";
          ;
          const getEl = document.getElementById.bind(document);
          var pdf_config = (idConfig = {}) => ({
            appContainer: getEl("pdf"),
            mainContainer: getEl("viewerContainer"),
            viewerContainer: getEl("viewer"),
            eventBus: null,
            toolbar: {
              container: getEl("toolbarViewer"),
              numPages: getEl(idConfig.numPages || "numPages"),
              pageNumber: getEl(idConfig.pageNumber || "pageNumber"),
              scaleSelectContainer: getEl("scaleSelectContainer"),
              scaleSelect: getEl("scaleSelect"),
              customScaleOption: getEl("customScaleOption"),
              previous: getEl(idConfig.previousPage || "previous"),
              next: getEl(idConfig.nextPage || "next"),
              zoomIn: getEl(idConfig.zoomIn || "zoomIn"),
              zoomOut: getEl(idConfig.zoomOut || "zoomOut"),
              viewFind: getEl(idConfig.toggleFindbar || "viewFind"),
              openFile: getEl(idConfig.openFile || "openFile"),
              print: getEl(idConfig.print || "print"),
              presentationModeButton: getEl(idConfig.presentationMode || "presentationMode"),
              download: getEl(idConfig.download || "download"),
              viewBookmark: getEl(idConfig.viewBookmark || "viewBookmark")
            },
            secondaryToolbar: {
              toolbar: getEl("secondaryToolbar"),
              toggleButton: getEl("secondaryToolbarToggle"),
              toolbarButtonContainer: getEl("secondaryToolbarButtonContainer"),
              presentationModeButton: getEl("secondaryPresentationMode"),
              openFileButton: getEl("secondaryOpenFile"),
              printButton: getEl("secondaryPrint"),
              downloadButton: getEl("secondaryDownload"),
              viewBookmarkButton: getEl("secondaryViewBookmark"),
              firstPageButton: getEl(idConfig.firstPage || "firstPage"),
              lastPageButton: getEl(idConfig.lastPage || "lastPage"),
              pageRotateCwButton: getEl(idConfig.pageRotateCw || "pageRotateCw"),
              pageRotateCcwButton: getEl(idConfig.pageRotateCcw || "pageRotateCcw"),
              cursorSelectToolButton: getEl(idConfig.cursorSelectTool || "cursorSelectTool"),
              cursorHandToolButton: getEl(idConfig.cursorHandTool || "cursorHandTool"),
              scrollVerticalButton: getEl(idConfig.scrollVertical || "scrollVertical"),
              scrollHorizontalButton: getEl(idConfig.scrollHorizontal || "scrollHorizontal"),
              scrollWrappedButton: getEl(idConfig.scrollWrapped || "scrollWrapped"),
              spreadNoneButton: getEl(idConfig.spreadNone || "spreadNone"),
              spreadOddButton: getEl(idConfig.spreadOdd || "spreadOdd"),
              spreadEvenButton: getEl(idConfig.spreadEven || "spreadEven"),
              documentPropertiesButton: getEl(idConfig.documentProperties || "documentProperties")
            },
            fullscreen: {
              contextFirstPage: getEl("contextFirstPage"),
              contextLastPage: getEl("contextLastPage"),
              contextPageRotateCw: getEl("contextPageRotateCw"),
              contextPageRotateCcw: getEl("contextPageRotateCcw")
            },
            sidebar: {
              outerContainer: getEl("outerContainer"),
              viewerContainer: getEl("viewerContainer"),
              toggleButton: getEl(idConfig.sidebarToggle || "sidebarToggle"),
              thumbnailButton: getEl(idConfig.viewThumbnail || "viewThumbnail"),
              outlineButton: getEl(idConfig.viewOutline || "viewOutline"),
              attachmentsButton: getEl(idConfig.viewAttachments || "viewAttachments"),
              thumbnailView: getEl("thumbnailView"),
              outlineView: getEl("outlineView"),
              attachmentsView: getEl("attachmentsView")
            },
            sidebarResizer: {
              outerContainer: getEl("outerContainer"),
              resizer: getEl("sidebarResizer")
            },
            findBar: {
              bar: getEl(idConfig.findbar || "findbar"),
              toggleButton: getEl(idConfig.toggleFindbar || "viewFind"),
              findField: getEl(idConfig.findInput || "findInput"),
              highlightAllCheckbox: getEl(idConfig.findHighlightAll || "findHighlightAll"),
              caseSensitiveCheckbox: getEl(idConfig.findMatchCase || "findMatchCase"),
              entireWordCheckbox: getEl(idConfig.findEntireWord || "findEntireWord"),
              findMsg: getEl(idConfig.findMessage || "findMsg"),
              findResultsCount: getEl(idConfig.findResultsCount || "findResultsCount"),
              findPreviousButton: getEl(idConfig.findPrevious || "findPrevious"),
              findNextButton: getEl(idConfig.findNext || "findNext")
            },
            passwordOverlay: {
              overlayName: "passwordOverlay",
              container: getEl("passwordOverlay"),
              label: getEl("passwordText"),
              input: getEl("password"),
              submitButton: getEl("passwordSubmit"),
              cancelButton: getEl("passwordCancel")
            },
            documentProperties: {
              overlayName: "documentPropertiesOverlay",
              container: getEl("documentPropertiesOverlay"),
              closeButton: getEl("documentPropertiesClose"),
              fields: {
                fileName: getEl("fileNameField"),
                fileSize: getEl("fileSizeField"),
                title: getEl("titleField"),
                author: getEl("authorField"),
                subject: getEl("subjectField"),
                keywords: getEl("keywordsField"),
                creationDate: getEl("creationDateField"),
                modificationDate: getEl("modificationDateField"),
                creator: getEl("creatorField"),
                producer: getEl("producerField"),
                version: getEl("versionField"),
                pageCount: getEl("pageCountField"),
                pageSize: getEl("pageSizeField"),
                linearized: getEl("linearizedField")
              }
            },
            errorWrapper: {
              container: getEl("errorWrapper"),
              errorMessage: getEl("errorMessage"),
              closeButton: getEl("errorClose"),
              errorMoreInfo: getEl("errorMoreInfo"),
              moreInfoButton: getEl("errorShowMore"),
              lessInfoButton: getEl("errorShowLess")
            },
            printContainer: getEl("printContainer"),
            openFileInputName: PDF_FILE_INPUT_ID
          });
          ;
          var locale = {
            default_locale: "en",
            locales: {
              en: {
                annotation_date_string: {
                  textContent: "{{date}}, {{time}}"
                },
                attachments_label: {
                  textContent: "Attachments"
                },
                attachments: {
                  title: "Show Attachments"
                },
                bookmark_label: {
                  textContent: "Current View"
                },
                bookmark: {
                  title: "Current view (copy or open in new window)"
                },
                cursor_hand_tool_label: {
                  textContent: "Hand Tool"
                },
                cursor_hand_tool: {
                  title: "Enable Hand Tool"
                },
                cursor_text_select_tool_label: {
                  textContent: "Text Selection Tool"
                },
                cursor_text_select_tool: {
                  title: "Enable Text Selection Tool"
                },
                document_outline_label: {
                  textContent: "Document Outline"
                },
                document_outline: {
                  title: "Show Document Outline (double-click to expand/collapse all items)"
                },
                document_properties_author: {
                  textContent: "Author:"
                },
                document_properties_close: {
                  textContent: "Close"
                },
                document_properties_creation_date: {
                  textContent: "Creation Date:"
                },
                document_properties_creator: {
                  textContent: "Creator:"
                },
                document_properties_date_string: {
                  textContent: "{{date}}, {{time}}"
                },
                document_properties_file_name: {
                  textContent: "File name:"
                },
                document_properties_file_size: {
                  textContent: "File size:"
                },
                document_properties_kb: {
                  textContent: "{{size_kb}} KB ({{size_b}} bytes)"
                },
                document_properties_keywords: {
                  textContent: "Keywords:"
                },
                document_properties_label: {
                  textContent: "Document Properties\u2026"
                },
                document_properties_linearized_no: {
                  textContent: "No"
                },
                document_properties_linearized_yes: {
                  textContent: "Yes"
                },
                document_properties_linearized: {
                  textContent: "Fast Web View:"
                },
                document_properties_mb: {
                  textContent: "{{size_mb}} MB ({{size_b}} bytes)"
                },
                document_properties_modification_date: {
                  textContent: "Modification Date:"
                },
                document_properties_page_count: {
                  textContent: "Page Count:"
                },
                document_properties_page_size_dimension_name_string: {
                  textContent: "{{width}} \xD7 {{height}} {{unit}} ({{name}}, {{orientation}})"
                },
                document_properties_page_size_dimension_string: {
                  textContent: "{{width}} \xD7 {{height}} {{unit}} ({{orientation}})"
                },
                document_properties_page_size_name_a3: {
                  textContent: "A3"
                },
                document_properties_page_size_name_a4: {
                  textContent: "A4"
                },
                document_properties_page_size_name_legal: {
                  textContent: "Legal"
                },
                document_properties_page_size_name_letter: {
                  textContent: "Letter"
                },
                document_properties_page_size_orientation_landscape: {
                  textContent: "landscape"
                },
                document_properties_page_size_orientation_portrait: {
                  textContent: "portrait"
                },
                document_properties_page_size_unit_inches: {
                  textContent: "in"
                },
                document_properties_page_size_unit_millimeters: {
                  textContent: "mm"
                },
                document_properties_page_size: {
                  textContent: "Page Size:"
                },
                document_properties_producer: {
                  textContent: "PDF Producer:"
                },
                document_properties_subject: {
                  textContent: "Subject:"
                },
                document_properties_title: {
                  textContent: "Title:"
                },
                document_properties_version: {
                  textContent: "PDF Version:"
                },
                document_properties: {
                  title: "Document Properties\u2026"
                },
                download_label: {
                  textContent: "Download"
                },
                download: {
                  title: "Download"
                },
                error_close: {
                  textContent: "Close"
                },
                error_file: {
                  textContent: "File: {{file}}"
                },
                error_less_info: {
                  textContent: "Less Information"
                },
                error_line: {
                  textContent: "Line: {{line}}"
                },
                error_message: {
                  textContent: "Message: {{message}}"
                },
                error_more_info: {
                  textContent: "More Information"
                },
                error_stack: {
                  textContent: "Stack: {{stack}}"
                },
                error_version_info: {
                  textContent: "PDF.js v{{version}} (build: {{build}})"
                },
                find_entire_word_label: {
                  textContent: "Whole words"
                },
                find_highlight: {
                  textContent: "Highlight all"
                },
                find_input: {
                  placeholder: "Find in document\u2026",
                  title: "Find"
                },
                find_match_case_label: {
                  textContent: "Match case"
                },
                "find_match_count_limit[few]": {
                  textContent: "More than {{limit}} matches"
                },
                "find_match_count_limit[many]": {
                  textContent: "More than {{limit}} matches"
                },
                "find_match_count_limit[one]": {
                  textContent: "More than {{limit}} match"
                },
                "find_match_count_limit[other]": {
                  textContent: "More than {{limit}} matches"
                },
                "find_match_count_limit[two]": {
                  textContent: "More than {{limit}} matches"
                },
                "find_match_count_limit[zero]": {
                  textContent: "More than {{limit}} matches"
                },
                find_match_count_limit: {
                  textContent: "{[ plural(limit) ]}"
                },
                "find_match_count[few]": {
                  textContent: "{{current}} of {{total}} matches"
                },
                "find_match_count[many]": {
                  textContent: "{{current}} of {{total}} matches"
                },
                "find_match_count[one]": {
                  textContent: "{{current}} of {{total}} match"
                },
                "find_match_count[other]": {
                  textContent: "{{current}} of {{total}} matches"
                },
                "find_match_count[two]": {
                  textContent: "{{current}} of {{total}} matches"
                },
                find_match_count: {
                  textContent: "{[ plural(total) ]}"
                },
                find_next_label: {
                  textContent: "Next"
                },
                find_next: {
                  title: "Find the next occurrence of the phrase"
                },
                find_not_found: {
                  textContent: "Phrase not found"
                },
                find_previous_label: {
                  textContent: "Previous"
                },
                find_previous: {
                  title: "Find the previous occurrence of the phrase"
                },
                find_reached_bottom: {
                  textContent: "Reached end of document, continued from top"
                },
                find_reached_top: {
                  textContent: "Reached top of document, continued from bottom"
                },
                findbar_label: {
                  textContent: "Find"
                },
                findbar: {
                  title: "Find in Document"
                },
                first_page_label: {
                  textContent: "Go to First Page"
                },
                first_page: {
                  label: "Go to First Page",
                  title: "Go to First Page"
                },
                invalid_file_error: {
                  textContent: "Invalid or corrupted PDF file."
                },
                last_page_label: {
                  textContent: "Go to Last Page"
                },
                last_page: {
                  title: "Go to Last Page"
                },
                loading_error_indicator: {
                  textContent: "Error"
                },
                loading_error: {
                  textContent: "An error occurred while loading the PDF."
                },
                missing_file_error: {
                  textContent: "Missing PDF file."
                },
                next_label: {
                  textContent: "Next"
                },
                next: {
                  title: "Next Page"
                },
                of_pages: {
                  textContent: "of {{pagesCount}}"
                },
                open_file_label: {
                  textContent: "Open"
                },
                open_file: {
                  title: "Open File"
                },
                page_canvas: {
                  textContent: "Page {{page}}"
                },
                page_of_pages: {
                  textContent: "({{pageNumber}} of {{pagesCount}})"
                },
                page_rotate_ccw_label: {
                  textContent: "Rotate Counterclockwise"
                },
                page_rotate_ccw: {
                  label: "Rotate Counterclockwise",
                  title: "Rotate Counterclockwise"
                },
                page_rotate_cw_label: {
                  textContent: "Rotate Clockwise"
                },
                page_rotate_cw: {
                  label: "Rotate Clockwise",
                  title: "Rotate Clockwise"
                },
                page_scale_actual: {
                  textContent: "Actual Size"
                },
                page_scale_auto: {
                  textContent: "Automatic Zoom"
                },
                page_scale_fit: {
                  textContent: "Page Fit"
                },
                page_scale_percent: {
                  textContent: "{{scale}}%"
                },
                page_scale_width: {
                  textContent: "Page Width"
                },
                page: {
                  title: "Page"
                },
                password_cancel: {
                  textContent: "Cancel"
                },
                password_invalid: {
                  textContent: "Invalid password. Please try again."
                },
                password_label: {
                  textContent: "Enter the password to open this PDF file."
                },
                password_ok: {
                  textContent: "OK"
                },
                presentation_mode_label: {
                  textContent: "Presentation Mode"
                },
                presentation_mode: {
                  title: "Switch to Presentation Mode"
                },
                previous_label: {
                  textContent: "Previous"
                },
                previous: {
                  title: "Previous Page"
                },
                print_label: {
                  textContent: "Print"
                },
                print_progress_close: {
                  textContent: "Cancel"
                },
                print_progress_message: {
                  textContent: "Preparing document for printing\u2026"
                },
                print_progress_percent: {
                  textContent: "{{progress}}%"
                },
                print: {
                  title: "Print"
                },
                printing_not_ready: {
                  textContent: "Warning: The PDF is not fully loaded for printing."
                },
                printing_not_supported: {
                  textContent: "Warning: Printing is not fully supported by this browser."
                },
                rendering_error: {
                  textContent: "An error occurred while rendering the page."
                },
                scroll_horizontal_label: {
                  textContent: "Horizontal Scrolling"
                },
                scroll_horizontal: {
                  title: "Use Horizontal Scrolling"
                },
                scroll_vertical_label: {
                  textContent: "Vertical Scrolling"
                },
                scroll_vertical: {
                  title: "Use Vertical Scrolling"
                },
                scroll_wrapped_label: {
                  textContent: "Wrapped Scrolling"
                },
                scroll_wrapped: {
                  title: "Use Wrapped Scrolling"
                },
                spread_even_label: {
                  textContent: "Even Spreads"
                },
                spread_even: {
                  title: "Join page spreads starting with even-numbered pages"
                },
                spread_none_label: {
                  textContent: "No Spreads"
                },
                spread_none: {
                  title: "Do not join page spreads"
                },
                spread_odd_label: {
                  textContent: "Odd Spreads"
                },
                spread_odd: {
                  title: "Join page spreads starting with odd-numbered pages"
                },
                text_annotation_type: {
                  alt: "[{{type}} Annotation]"
                },
                thumb_page_canvas: {
                  textContent: "Thumbnail of Page {{page}}"
                },
                thumb_page_title: {
                  textContent: "Page {{page}}"
                },
                thumbs_label: {
                  textContent: "Thumbnails"
                },
                thumbs: {
                  title: "Show Thumbnails"
                },
                toggle_sidebar_label: {
                  textContent: "Toggle Sidebar"
                },
                toggle_sidebar_notification: {
                  title: "Toggle Sidebar (document contains outline/attachments)"
                },
                toggle_sidebar: {
                  title: "Toggle Sidebar"
                },
                tools_label: {
                  textContent: "Tools"
                },
                tools: {
                  title: "Tools"
                },
                unexpected_response_error: {
                  textContent: "Unexpected server response."
                },
                web_fonts_disabled: {
                  textContent: "Web fonts are disabled: unable to use embedded PDF fonts."
                },
                zoom_in_label: {
                  textContent: "Zoom In"
                },
                zoom_in: {
                  title: "Zoom In"
                },
                zoom_out_label: {
                  textContent: "Zoom Out"
                },
                zoom_out: {
                  title: "Zoom Out"
                },
                zoom: {
                  title: "Zoom"
                }
              }
            }
          };
          ;
          const toolbarConfig = {
            sidebar: {
              viewThumbnail: true,
              viewOutline: true,
              viewAttachments: true
            },
            secondaryToolbar: {
              secondaryPresentationMode: true,
              secondaryOpenFile: true,
              secondaryPrint: true,
              secondaryDownload: true,
              secondaryViewBookmark: true,
              firstPage: true,
              lastPage: true,
              pageRotateCw: true,
              pageRotateCcw: true,
              cursorSelectTool: true,
              cursorHandTool: true,
              scrollVertical: true,
              scrollHorizontal: true,
              scrollWrapped: true,
              spreadNone: true,
              spreadOdd: true,
              spreadEven: true,
              documentProperties: true
            },
            toolbar: {
              toolbarViewerLeft: {
                findbar: true,
                previous: true,
                next: true,
                pageNumber: true
              },
              toolbarViewerRight: {
                presentationMode: true,
                openFile: true,
                print: true,
                download: true,
                viewBookmark: true
              },
              toolbarViewerMiddle: {
                zoomOut: true,
                zoomIn: true,
                scaleSelectContainer: true
              }
            },
            errorWrapper: true
          };
          const getToolbarConfigValue = (config, path) => {
            const props = path.split(".");
            let currValue = config[props[0]];
            for (let i = 1; i < props.length; i++) {
              if (typeof currValue === "object") {
                currValue = currValue[props[i]];
              } else
                break;
            }
            return currValue;
          };
          ;
          if (app_options.AppOptions) {
            app_options.AppOptions.set("defaultUrl", null);
          }
          const themeCacheKey = "vue-pdf-app-theme";
          const errorHandler = console.error.bind(console);
          const pdfPrint = window.print.bind(window);
          window.print = window.__nativePrint__ || pdfPrint;
          var pdf_viewervue_type_script_lang_ts = (0, external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent)({
            props: {
              config: {
                default: () => toolbarConfig,
                type: Object
              },
              title: {
                type: Boolean,
                default: () => false
              },
              pdf: {
                type: [String, ArrayBuffer]
              },
              theme: String,
              fileName: String,
              idConfig: {
                type: Object
              },
              pageScale: [Number, String],
              pageNumber: Number
            },
            setup(props, ctx) {
              const defaultLocale = (0, external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(JSON.stringify(locale));
              const isOpenHandlerBinded = (0, external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(false);
              const isSidebarHidden = (0, external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(true);
              const isFindbarHidden = (0, external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(true);
              const cacheTheme = (0, external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(window.localStorage.getItem(themeCacheKey));
              const isSidebarToolbarHidden = (0, external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
                const idConfig = props.idConfig;
                const isCustomToolbar = (idConfig == null ? void 0 : idConfig.viewAttachments) && (idConfig == null ? void 0 : idConfig.viewOutline) && (idConfig == null ? void 0 : idConfig.viewThumbnail);
                return isCustomToolbar || !props.config.sidebar;
              });
              const isToolbarHidden = (0, external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
                if (props.config.toolbar === false)
                  return "zero-top";
                return "";
              });
              const localTheme = (0, external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
                if (props.theme)
                  return props.theme;
                if (cacheTheme.value)
                  return cacheTheme.value;
                const prefersTheme = window.getComputedStyle(document.documentElement).getPropertyValue("content").replace(/"/g, "");
                if (["light", "dark"].includes(prefersTheme))
                  return prefersTheme;
                return "dark";
              });
              const slotProps = (0, external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
                return {
                  toggleTheme,
                  isSidebarHidden: isSidebarHidden.value,
                  isFindbarHidden: isFindbarHidden.value
                };
              });
              const toggleButtonUnmount = (0, external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
              const findbarButtonUnmount = (0, external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
              const fileInputUnmount = (0, external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
              const printContainerUnmount = (0, external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
              (0, external_commonjs_vue_commonjs2_vue_root_Vue_.onBeforeUnmount)(() => {
                destroyPdf();
                if (toggleButtonUnmount.value) {
                  toggleButtonUnmount.value();
                }
                if (findbarButtonUnmount.value) {
                  findbarButtonUnmount.value();
                }
                if (fileInputUnmount.value) {
                  fileInputUnmount.value();
                }
                if (printContainerUnmount.value) {
                  printContainerUnmount.value();
                }
              });
              window.print = pdfPrint;
              app.PDFViewerApplication.isViewerEmbedded = !props.title;
              ctx.emit("after-created", app.PDFViewerApplication);
              (0, external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
                addPrintContainer();
                const config = pdf_config(props.idConfig);
                if (app.PDFViewerApplication) {
                  app.PDFViewerApplication.run(config);
                  app.PDFViewerApplication.initializedPromise.then(setDefaultPageScale).then(open).then(bindSidebarToggleEvents).then(bindFindbarToggleEvents).catch(errorHandler);
                }
              });
              function bindSidebarToggleEvents() {
                const config = pdf_config(props.idConfig);
                const toggleButton = config.sidebar.toggleButton;
                const handler = checkSidebarVisibility;
                toggleButton == null ? void 0 : toggleButton.addEventListener("click", handler);
                toggleButtonUnmount.value = () => {
                  toggleButton == null ? void 0 : toggleButton.removeEventListener("click", handler);
                };
              }
              function bindFindbarToggleEvents() {
                const config = pdf_config(props.idConfig);
                const toggleButton = config.findBar.toggleButton;
                const handler = checkFindbarVisibility;
                toggleButton == null ? void 0 : toggleButton.addEventListener("click", handler);
                findbarButtonUnmount.value = () => {
                  toggleButton == null ? void 0 : toggleButton.removeEventListener("click", handler);
                };
              }
              function bindOpenHandler() {
                if (isOpenHandlerBinded.value)
                  return;
                const fileInput = document.getElementById(PDF_FILE_INPUT_ID);
                const fileInputHandler = async () => {
                  var _a;
                  await ((_a = app.PDFViewerApplication.pdfLoadingTask) == null ? void 0 : _a.promise);
                  openDocument();
                };
                fileInput == null ? void 0 : fileInput.addEventListener("change", fileInputHandler);
                fileInputUnmount.value = () => {
                  fileInput == null ? void 0 : fileInput.removeEventListener("change", fileInputHandler);
                };
                isOpenHandlerBinded.value = true;
              }
              function open() {
                clearCacheTimeout();
                if (!app.PDFViewerApplication)
                  return;
                if (!props.pdf) {
                  app.PDFViewerApplication.close();
                } else {
                  app.PDFViewerApplication.open(props.pdf).then(() => {
                    var _a;
                    if (props.pageNumber) {
                      setTimeout(() => app.PDFViewerApplication.page = props.pageNumber);
                    }
                    return (_a = app.PDFViewerApplication.pdfDocument) == null ? void 0 : _a.getMetadata();
                  }).then((fileMetadata) => {
                    app.PDFViewerApplication.contentDispositionFilename = props.fileName || fileMetadata.contentDispositionFilename;
                    ctx.emit("pages-rendered", app.PDFViewerApplication);
                  }).catch(errorHandler);
                }
              }
              function checkSidebarVisibility() {
                var _a;
                const sidebar = (_a = app.PDFViewerApplication) == null ? void 0 : _a.pdfSidebar;
                isSidebarHidden.value = !(sidebar && sidebar.isOpen);
              }
              function checkFindbarVisibility() {
                var _a;
                const findbar = (_a = app.PDFViewerApplication) == null ? void 0 : _a.findBar;
                isFindbarHidden.value = !(findbar && findbar.opened);
              }
              async function openDocument() {
                var _a, _b;
                resetLoadingBar();
                ctx.emit("open", app.PDFViewerApplication);
                if ((_b = (_a = app.PDFViewerApplication) == null ? void 0 : _a.pdfViewer) == null ? void 0 : _b.pagesPromise) {
                  await app.PDFViewerApplication.pdfViewer.pagesPromise["catch"](errorHandler);
                  if (props.pageNumber) {
                    setTimeout(() => app.PDFViewerApplication.page = props.pageNumber);
                  }
                  checkSidebarVisibility();
                  checkFindbarVisibility();
                  ctx.emit("pages-rendered", app.PDFViewerApplication);
                }
              }
              function addPrintContainer() {
                const printElId = "printContainer";
                const el = document.createElement("div");
                el.id = printElId;
                document.body.appendChild(el);
                const styleEl = document.createElement("style");
                styleEl.type = "text/css";
                styleEl.innerHTML = `
        @media print {
          body > *:not(#printContainer) {
            display: none !important;
        }
      }`;
                document.head.appendChild(styleEl);
                printContainerUnmount.value = () => {
                  document.body.removeChild(el);
                  document.head.removeChild(styleEl);
                };
              }
              function destroyPdf() {
                var _a;
                clearCacheTimeout();
                app.PDFViewerApplication.unbindEvents();
                app.PDFViewerApplication.unbindWindowEvents();
                (_a = app.PDFViewerApplication.pdfDocument) == null ? void 0 : _a.destroy();
                const el = document.getElementById(PDF_FILE_INPUT_ID);
                el && el.remove();
                window.print = window.__nativePrint__ || window.print;
              }
              function toggleTheme() {
                const newTheme = localTheme.value === "dark" ? "light" : "dark";
                ctx.emit("update:theme", newTheme);
                cacheTheme.value = newTheme;
                window.localStorage.setItem(themeCacheKey, newTheme);
              }
              function clearCacheTimeout() {
                var _a;
                const cacheTimeoutId = (_a = app.PDFViewerApplication.pdfRenderingQueue) == null ? void 0 : _a.idleTimeout;
                clearTimeout(cacheTimeoutId);
              }
              function getScale(value) {
                return `{ "scale": ${value} }`;
              }
              function showElem(defaultToolbarPath, customToolbarElem) {
                if (customToolbarElem && props.idConfig) {
                  return !props.idConfig[customToolbarElem];
                }
                return !(getToolbarConfigValue(props.config, defaultToolbarPath) === false);
              }
              function setDefaultPageScale() {
                props.pageScale && app_options.AppOptions.set("defaultZoomValue", props.pageScale);
              }
              function resetLoadingBar() {
                app.PDFViewerApplication.loadingBar.show();
                app.PDFViewerApplication.loadingBar.percent = 0;
              }
              (0, external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.pdf, open);
              return {
                showElem,
                getScale,
                slotProps,
                isToolbarHidden,
                isSidebarToolbarHidden,
                localTheme,
                defaultLocale,
                bindOpenHandler
              };
            }
          });
          ;
          var pdf_viewervue_type_style_index_0_id_0d167ef6_lang_css = __webpack_require__(7652);
          ;
          var pdf_viewervue_type_style_index_1_id_0d167ef6_lang_scss_scoped_true = __webpack_require__(9878);
          ;
          var exportHelper = __webpack_require__(3744);
          ;
          ;
          const __exports__ = (0, exportHelper.Z)(pdf_viewervue_type_script_lang_ts, [["render", render], ["__scopeId", "data-v-0d167ef6"]]);
          var pdf_viewer = __exports__;
          ;
          var entry_lib = pdf_viewer;
        }();
        __webpack_exports__ = __webpack_exports__["default"];
        return __webpack_exports__;
      }();
    });
  }
});
export default require_vue3_pdf_app_umd();
//# sourceMappingURL=vue3-pdf-app.js.map
